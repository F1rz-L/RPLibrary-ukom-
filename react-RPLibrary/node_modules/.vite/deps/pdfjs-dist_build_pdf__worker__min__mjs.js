import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-5HFSU4IV.js";

// node_modules/pdfjs-dist/build/pdf.worker.min.mjs
var e = { d: (t2, i2) => {
  for (var a2 in i2)
    e.o(i2, a2) && !e.o(t2, a2) && Object.defineProperty(t2, a2, { enumerable: true, get: i2[a2] });
}, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2) };
var __webpack_exports__ = globalThis.pdfjsWorker = {};
e.d(__webpack_exports__, { WorkerMessageHandler: () => WorkerMessageHandler });
var t = !("object" != typeof process || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && "browser" !== process.type);
var i = [1, 0, 0, 1, 0, 0];
var a = [1e-3, 0, 0, 1e-3, 0, 0];
var s = 1.35;
var r = 0.35;
var n = 0.25925925925925924;
var g = 1;
var o = 2;
var c = 4;
var C = 8;
var h = 16;
var l = 64;
var Q = 128;
var E = 256;
var u = "pdfjs_internal_editor_";
var d = 3;
var f = 9;
var p = 13;
var m = 15;
var y = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 };
var w = 0;
var D = 4;
var b = 1;
var F = 2;
var S = 3;
var k = 1;
var R = 2;
var N = 3;
var G = 4;
var x = 5;
var U = 6;
var M = 7;
var L = 8;
var H = 9;
var J = 10;
var Y = 11;
var v = 12;
var K = 13;
var T = 14;
var q = 15;
var O = 16;
var W = 17;
var j = 20;
var X = "Group";
var Z = "R";
var V = 1;
var z = 2;
var _ = 4;
var $ = 16;
var AA = 32;
var eA = 128;
var tA = 512;
var iA = 1;
var aA = 2;
var sA = 4096;
var rA = 8192;
var nA = 32768;
var gA = 65536;
var oA = 131072;
var IA = 1048576;
var cA = 2097152;
var CA = 8388608;
var hA = 16777216;
var BA = 1;
var lA = 2;
var QA = 3;
var EA = 4;
var uA = 5;
var dA = { E: "Mouse Enter", X: "Mouse Exit", D: "Mouse Down", U: "Mouse Up", Fo: "Focus", Bl: "Blur", PO: "PageOpen", PC: "PageClose", PV: "PageVisible", PI: "PageInvisible", K: "Keystroke", F: "Format", V: "Validate", C: "Calculate" };
var fA = { WC: "WillClose", WS: "WillSave", DS: "DidSave", WP: "WillPrint", DP: "DidPrint" };
var pA = { O: "PageOpen", C: "PageClose" };
var mA = { ERRORS: 0, WARNINGS: 1, INFOS: 5 };
var yA = { NONE: 0, BINARY: 1 };
var wA = 1;
var DA = 2;
var bA = 3;
var FA = 4;
var SA = 5;
var kA = 6;
var RA = 7;
var NA = 8;
var GA = 9;
var xA = 10;
var UA = 11;
var MA = 12;
var LA = 13;
var HA = 14;
var JA = 15;
var YA = 16;
var vA = 17;
var KA = 18;
var TA = 19;
var qA = 20;
var OA = 21;
var PA = 22;
var WA = 23;
var jA = 24;
var XA = 25;
var ZA = 26;
var VA = 27;
var zA = 28;
var _A = 29;
var $A = 30;
var Ae = 31;
var ee = 32;
var te = 33;
var ie = 34;
var ae = 35;
var se = 36;
var re = 37;
var ne = 38;
var ge = 39;
var oe = 40;
var Ie = 41;
var ce = 42;
var Ce = 43;
var he = 44;
var Be = 45;
var le = 46;
var Qe = 47;
var Ee = 48;
var ue = 49;
var de = 50;
var fe = 51;
var pe = 52;
var me = 53;
var ye = 54;
var we = 55;
var De = 56;
var be = 57;
var Fe = 58;
var Se = 59;
var ke = 60;
var Re = 61;
var Ne = 62;
var Ge = 63;
var xe = 64;
var Ue = 65;
var Me = 66;
var Le = 67;
var He = 68;
var Je = 69;
var Ye = 70;
var ve = 71;
var Ke = 72;
var Te = 73;
var qe = 74;
var Oe = 75;
var Pe = 76;
var We = 77;
var je = 80;
var Xe = 81;
var Ze = 83;
var Ve = 84;
var ze = 85;
var _e = 86;
var $e = 87;
var At = 88;
var et = 89;
var tt = 90;
var it = 91;
var at = 92;
var st = 93;
var rt = 1;
var nt = 2;
var gt = mA.WARNINGS;
function getVerbosityLevel() {
  return gt;
}
function info(e2) {
  gt >= mA.INFOS && console.log(`Info: ${e2}`);
}
function warn(e2) {
  gt >= mA.WARNINGS && console.log(`Warning: ${e2}`);
}
function unreachable(e2) {
  throw new Error(e2);
}
function assert(e2, t2) {
  e2 || unreachable(t2);
}
function createValidAbsoluteUrl(e2, t2 = null, i2 = null) {
  if (!e2)
    return null;
  try {
    if (i2 && "string" == typeof e2) {
      if (i2.addDefaultProtocol && e2.startsWith("www.")) {
        const t3 = e2.match(/\./g);
        (t3 == null ? void 0 : t3.length) >= 2 && (e2 = `http://${e2}`);
      }
      if (i2.tryConvertEncoding)
        try {
          e2 = stringToUTF8String(e2);
        } catch {
        }
    }
    const a2 = t2 ? new URL(e2, t2) : new URL(e2);
    if (function _isValidProtocol(e3) {
      switch (e3 == null ? void 0 : e3.protocol) {
        case "http:":
        case "https:":
        case "ftp:":
        case "mailto:":
        case "tel:":
          return true;
        default:
          return false;
      }
    }(a2))
      return a2;
  } catch {
  }
  return null;
}
function shadow(e2, t2, i2, a2 = false) {
  Object.defineProperty(e2, t2, { value: i2, enumerable: !a2, configurable: true, writable: false });
  return i2;
}
var ot = function BaseExceptionClosure() {
  function BaseException(e2, t2) {
    this.constructor === BaseException && unreachable("Cannot initialize BaseException.");
    this.message = e2;
    this.name = t2;
  }
  BaseException.prototype = new Error();
  BaseException.constructor = BaseException;
  return BaseException;
}();
var PasswordException = class extends ot {
  constructor(e2, t2) {
    super(e2, "PasswordException");
    this.code = t2;
  }
};
var UnknownErrorException = class extends ot {
  constructor(e2, t2) {
    super(e2, "UnknownErrorException");
    this.details = t2;
  }
};
var InvalidPDFException = class extends ot {
  constructor(e2) {
    super(e2, "InvalidPDFException");
  }
};
var MissingPDFException = class extends ot {
  constructor(e2) {
    super(e2, "MissingPDFException");
  }
};
var UnexpectedResponseException = class extends ot {
  constructor(e2, t2) {
    super(e2, "UnexpectedResponseException");
    this.status = t2;
  }
};
var FormatError = class extends ot {
  constructor(e2) {
    super(e2, "FormatError");
  }
};
var AbortException = class extends ot {
  constructor(e2) {
    super(e2, "AbortException");
  }
};
function bytesToString(e2) {
  "object" == typeof e2 && void 0 !== (e2 == null ? void 0 : e2.length) || unreachable("Invalid argument for bytesToString");
  const t2 = e2.length, i2 = 8192;
  if (t2 < i2)
    return String.fromCharCode.apply(null, e2);
  const a2 = [];
  for (let s2 = 0; s2 < t2; s2 += i2) {
    const r2 = Math.min(s2 + i2, t2), n2 = e2.subarray(s2, r2);
    a2.push(String.fromCharCode.apply(null, n2));
  }
  return a2.join("");
}
function stringToBytes(e2) {
  "string" != typeof e2 && unreachable("Invalid argument for stringToBytes");
  const t2 = e2.length, i2 = new Uint8Array(t2);
  for (let a2 = 0; a2 < t2; ++a2)
    i2[a2] = 255 & e2.charCodeAt(a2);
  return i2;
}
function string32(e2) {
  return String.fromCharCode(e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2);
}
function objectSize(e2) {
  return Object.keys(e2).length;
}
var FeatureTest = class {
  static get isLittleEndian() {
    return shadow(this, "isLittleEndian", function isLittleEndian() {
      const e2 = new Uint8Array(4);
      e2[0] = 1;
      return 1 === new Uint32Array(e2.buffer, 0, 1)[0];
    }());
  }
  static get isEvalSupported() {
    return shadow(this, "isEvalSupported", function isEvalSupported() {
      try {
        new Function("");
        return true;
      } catch {
        return false;
      }
    }());
  }
  static get isOffscreenCanvasSupported() {
    return shadow(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
  }
  static get platform() {
    return "undefined" != typeof navigator && "string" == typeof (navigator == null ? void 0 : navigator.platform) ? shadow(this, "platform", { isMac: navigator.platform.includes("Mac") }) : shadow(this, "platform", { isMac: false });
  }
  static get isCSSRoundSupported() {
    var _a4, _b2;
    return shadow(this, "isCSSRoundSupported", (_b2 = (_a4 = globalThis.CSS) == null ? void 0 : _a4.supports) == null ? void 0 : _b2.call(_a4, "width: round(1.5px, 1px)"));
  }
};
var It = Array.from(Array(256).keys(), (e2) => e2.toString(16).padStart(2, "0"));
var _A2, A_fn, _e2, e_fn;
var Util = class {
  static makeHexColor(e2, t2, i2) {
    return `#${It[e2]}${It[t2]}${It[i2]}`;
  }
  static scaleMinMax(e2, t2) {
    let i2;
    if (e2[0]) {
      if (e2[0] < 0) {
        i2 = t2[0];
        t2[0] = t2[2];
        t2[2] = i2;
      }
      t2[0] *= e2[0];
      t2[2] *= e2[0];
      if (e2[3] < 0) {
        i2 = t2[1];
        t2[1] = t2[3];
        t2[3] = i2;
      }
      t2[1] *= e2[3];
      t2[3] *= e2[3];
    } else {
      i2 = t2[0];
      t2[0] = t2[1];
      t2[1] = i2;
      i2 = t2[2];
      t2[2] = t2[3];
      t2[3] = i2;
      if (e2[1] < 0) {
        i2 = t2[1];
        t2[1] = t2[3];
        t2[3] = i2;
      }
      t2[1] *= e2[1];
      t2[3] *= e2[1];
      if (e2[2] < 0) {
        i2 = t2[0];
        t2[0] = t2[2];
        t2[2] = i2;
      }
      t2[0] *= e2[2];
      t2[2] *= e2[2];
    }
    t2[0] += e2[4];
    t2[1] += e2[5];
    t2[2] += e2[4];
    t2[3] += e2[5];
  }
  static transform(e2, t2) {
    return [e2[0] * t2[0] + e2[2] * t2[1], e2[1] * t2[0] + e2[3] * t2[1], e2[0] * t2[2] + e2[2] * t2[3], e2[1] * t2[2] + e2[3] * t2[3], e2[0] * t2[4] + e2[2] * t2[5] + e2[4], e2[1] * t2[4] + e2[3] * t2[5] + e2[5]];
  }
  static applyTransform(e2, t2) {
    return [e2[0] * t2[0] + e2[1] * t2[2] + t2[4], e2[0] * t2[1] + e2[1] * t2[3] + t2[5]];
  }
  static applyInverseTransform(e2, t2) {
    const i2 = t2[0] * t2[3] - t2[1] * t2[2];
    return [(e2[0] * t2[3] - e2[1] * t2[2] + t2[2] * t2[5] - t2[4] * t2[3]) / i2, (-e2[0] * t2[1] + e2[1] * t2[0] + t2[4] * t2[1] - t2[5] * t2[0]) / i2];
  }
  static getAxialAlignedBoundingBox(e2, t2) {
    const i2 = this.applyTransform(e2, t2), a2 = this.applyTransform(e2.slice(2, 4), t2), s2 = this.applyTransform([e2[0], e2[3]], t2), r2 = this.applyTransform([e2[2], e2[1]], t2);
    return [Math.min(i2[0], a2[0], s2[0], r2[0]), Math.min(i2[1], a2[1], s2[1], r2[1]), Math.max(i2[0], a2[0], s2[0], r2[0]), Math.max(i2[1], a2[1], s2[1], r2[1])];
  }
  static inverseTransform(e2) {
    const t2 = e2[0] * e2[3] - e2[1] * e2[2];
    return [e2[3] / t2, -e2[1] / t2, -e2[2] / t2, e2[0] / t2, (e2[2] * e2[5] - e2[4] * e2[3]) / t2, (e2[4] * e2[1] - e2[5] * e2[0]) / t2];
  }
  static singularValueDecompose2dScale(e2) {
    const t2 = [e2[0], e2[2], e2[1], e2[3]], i2 = e2[0] * t2[0] + e2[1] * t2[2], a2 = e2[0] * t2[1] + e2[1] * t2[3], s2 = e2[2] * t2[0] + e2[3] * t2[2], r2 = e2[2] * t2[1] + e2[3] * t2[3], n2 = (i2 + r2) / 2, g2 = Math.sqrt((i2 + r2) ** 2 - 4 * (i2 * r2 - s2 * a2)) / 2, o2 = n2 + g2 || 1, c2 = n2 - g2 || 1;
    return [Math.sqrt(o2), Math.sqrt(c2)];
  }
  static normalizeRect(e2) {
    const t2 = e2.slice(0);
    if (e2[0] > e2[2]) {
      t2[0] = e2[2];
      t2[2] = e2[0];
    }
    if (e2[1] > e2[3]) {
      t2[1] = e2[3];
      t2[3] = e2[1];
    }
    return t2;
  }
  static intersect(e2, t2) {
    const i2 = Math.max(Math.min(e2[0], e2[2]), Math.min(t2[0], t2[2])), a2 = Math.min(Math.max(e2[0], e2[2]), Math.max(t2[0], t2[2]));
    if (i2 > a2)
      return null;
    const s2 = Math.max(Math.min(e2[1], e2[3]), Math.min(t2[1], t2[3])), r2 = Math.min(Math.max(e2[1], e2[3]), Math.max(t2[1], t2[3]));
    return s2 > r2 ? null : [i2, s2, a2, r2];
  }
  static bezierBoundingBox(e2, t2, i2, a2, s2, r2, n2, g2, o2) {
    if (o2) {
      o2[0] = Math.min(o2[0], e2, n2);
      o2[1] = Math.min(o2[1], t2, g2);
      o2[2] = Math.max(o2[2], e2, n2);
      o2[3] = Math.max(o2[3], t2, g2);
    } else
      o2 = [Math.min(e2, n2), Math.min(t2, g2), Math.max(e2, n2), Math.max(t2, g2)];
    __privateMethod(this, _e2, e_fn).call(this, e2, i2, s2, n2, t2, a2, r2, g2, 3 * (3 * (i2 - s2) - e2 + n2), 6 * (e2 - 2 * i2 + s2), 3 * (i2 - e2), o2);
    __privateMethod(this, _e2, e_fn).call(this, e2, i2, s2, n2, t2, a2, r2, g2, 3 * (3 * (a2 - r2) - t2 + g2), 6 * (t2 - 2 * a2 + r2), 3 * (a2 - t2), o2);
    return o2;
  }
};
_A2 = new WeakSet();
A_fn = function(e2, t2, i2, a2, s2, r2, n2, g2, o2, c2) {
  if (o2 <= 0 || o2 >= 1)
    return;
  const C2 = 1 - o2, h2 = o2 * o2, l2 = h2 * o2, Q2 = C2 * (C2 * (C2 * e2 + 3 * o2 * t2) + 3 * h2 * i2) + l2 * a2, E2 = C2 * (C2 * (C2 * s2 + 3 * o2 * r2) + 3 * h2 * n2) + l2 * g2;
  c2[0] = Math.min(c2[0], Q2);
  c2[1] = Math.min(c2[1], E2);
  c2[2] = Math.max(c2[2], Q2);
  c2[3] = Math.max(c2[3], E2);
};
_e2 = new WeakSet();
e_fn = function(e2, t2, i2, a2, s2, r2, n2, g2, o2, c2, C2, h2) {
  if (Math.abs(o2) < 1e-12) {
    Math.abs(c2) >= 1e-12 && __privateMethod(this, _A2, A_fn).call(this, e2, t2, i2, a2, s2, r2, n2, g2, -C2 / c2, h2);
    return;
  }
  const l2 = c2 ** 2 - 4 * C2 * o2;
  if (l2 < 0)
    return;
  const Q2 = Math.sqrt(l2), E2 = 2 * o2;
  __privateMethod(this, _A2, A_fn).call(this, e2, t2, i2, a2, s2, r2, n2, g2, (-c2 + Q2) / E2, h2);
  __privateMethod(this, _A2, A_fn).call(this, e2, t2, i2, a2, s2, r2, n2, g2, (-c2 - Q2) / E2, h2);
};
__privateAdd(Util, _A2);
__privateAdd(Util, _e2);
var ct = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
function stringToPDFString(e2) {
  if (e2[0] >= "ï") {
    let t3;
    if ("þ" === e2[0] && "ÿ" === e2[1]) {
      t3 = "utf-16be";
      e2.length % 2 == 1 && (e2 = e2.slice(0, -1));
    } else if ("ÿ" === e2[0] && "þ" === e2[1]) {
      t3 = "utf-16le";
      e2.length % 2 == 1 && (e2 = e2.slice(0, -1));
    } else
      "ï" === e2[0] && "»" === e2[1] && "¿" === e2[2] && (t3 = "utf-8");
    if (t3)
      try {
        const i2 = new TextDecoder(t3, { fatal: true }), a2 = stringToBytes(e2), s2 = i2.decode(a2);
        return s2.includes("\x1B") ? s2.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "") : s2;
      } catch (e3) {
        warn(`stringToPDFString: "${e3}".`);
      }
  }
  const t2 = [];
  for (let i2 = 0, a2 = e2.length; i2 < a2; i2++) {
    const s2 = e2.charCodeAt(i2);
    if (27 === s2) {
      for (; ++i2 < a2 && 27 !== e2.charCodeAt(i2); )
        ;
      continue;
    }
    const r2 = ct[s2];
    t2.push(r2 ? String.fromCharCode(r2) : e2.charAt(i2));
  }
  return t2.join("");
}
function stringToUTF8String(e2) {
  return decodeURIComponent(escape(e2));
}
function utf8StringToString(e2) {
  return unescape(encodeURIComponent(e2));
}
function isArrayEqual(e2, t2) {
  if (e2.length !== t2.length)
    return false;
  for (let i2 = 0, a2 = e2.length; i2 < a2; i2++)
    if (e2[i2] !== t2[i2])
      return false;
  return true;
}
function getModificationDate(e2 = /* @__PURE__ */ new Date()) {
  return [e2.getUTCFullYear().toString(), (e2.getUTCMonth() + 1).toString().padStart(2, "0"), e2.getUTCDate().toString().padStart(2, "0"), e2.getUTCHours().toString().padStart(2, "0"), e2.getUTCMinutes().toString().padStart(2, "0"), e2.getUTCSeconds().toString().padStart(2, "0")].join("");
}
var Ct = null;
var ht = null;
var Bt = 0;
var lt = 1;
var Qt = 2;
var Et = 3;
var ut = 4;
var dt = 5;
var ft = 6;
var pt = 7;
var mt = 8;
var yt = Symbol("CIRCULAR_REF");
var wt = Symbol("EOF");
var Dt = /* @__PURE__ */ Object.create(null);
var bt = /* @__PURE__ */ Object.create(null);
var Ft = /* @__PURE__ */ Object.create(null);
var Name = class _Name {
  constructor(e2) {
    this.name = e2;
  }
  static get(e2) {
    return bt[e2] || (bt[e2] = new _Name(e2));
  }
};
var Cmd = class _Cmd {
  constructor(e2) {
    this.cmd = e2;
  }
  static get(e2) {
    return Dt[e2] || (Dt[e2] = new _Cmd(e2));
  }
};
var St = function nonSerializableClosure() {
  return St;
};
var Dict = class _Dict {
  constructor(e2 = null) {
    this._map = /* @__PURE__ */ Object.create(null);
    this.xref = e2;
    this.objId = null;
    this.suppressEncryption = false;
    this.__nonSerializable__ = St;
  }
  assignXref(e2) {
    this.xref = e2;
  }
  get size() {
    return Object.keys(this._map).length;
  }
  get(e2, t2, i2) {
    let a2 = this._map[e2];
    if (void 0 === a2 && void 0 !== t2) {
      a2 = this._map[t2];
      void 0 === a2 && void 0 !== i2 && (a2 = this._map[i2]);
    }
    return a2 instanceof Ref && this.xref ? this.xref.fetch(a2, this.suppressEncryption) : a2;
  }
  async getAsync(e2, t2, i2) {
    let a2 = this._map[e2];
    if (void 0 === a2 && void 0 !== t2) {
      a2 = this._map[t2];
      void 0 === a2 && void 0 !== i2 && (a2 = this._map[i2]);
    }
    return a2 instanceof Ref && this.xref ? this.xref.fetchAsync(a2, this.suppressEncryption) : a2;
  }
  getArray(e2, t2, i2) {
    let a2 = this._map[e2];
    if (void 0 === a2 && void 0 !== t2) {
      a2 = this._map[t2];
      void 0 === a2 && void 0 !== i2 && (a2 = this._map[i2]);
    }
    a2 instanceof Ref && this.xref && (a2 = this.xref.fetch(a2, this.suppressEncryption));
    if (Array.isArray(a2)) {
      a2 = a2.slice();
      for (let e3 = 0, t3 = a2.length; e3 < t3; e3++)
        a2[e3] instanceof Ref && this.xref && (a2[e3] = this.xref.fetch(a2[e3], this.suppressEncryption));
    }
    return a2;
  }
  getRaw(e2) {
    return this._map[e2];
  }
  getKeys() {
    return Object.keys(this._map);
  }
  getRawValues() {
    return Object.values(this._map);
  }
  set(e2, t2) {
    this._map[e2] = t2;
  }
  has(e2) {
    return void 0 !== this._map[e2];
  }
  forEach(e2) {
    for (const t2 in this._map)
      e2(t2, this.get(t2));
  }
  static get empty() {
    const e2 = new _Dict(null);
    e2.set = (e3, t2) => {
      unreachable("Should not call `set` on the empty dictionary.");
    };
    return shadow(this, "empty", e2);
  }
  static merge({ xref: e2, dictArray: t2, mergeSubDicts: i2 = false }) {
    const a2 = new _Dict(e2), s2 = /* @__PURE__ */ new Map();
    for (const e3 of t2)
      if (e3 instanceof _Dict)
        for (const [t3, a3] of Object.entries(e3._map)) {
          let e4 = s2.get(t3);
          if (void 0 === e4) {
            e4 = [];
            s2.set(t3, e4);
          } else if (!(i2 && a3 instanceof _Dict))
            continue;
          e4.push(a3);
        }
    for (const [t3, i3] of s2) {
      if (1 === i3.length || !(i3[0] instanceof _Dict)) {
        a2._map[t3] = i3[0];
        continue;
      }
      const s3 = new _Dict(e2);
      for (const e3 of i3)
        for (const [t4, i4] of Object.entries(e3._map))
          void 0 === s3._map[t4] && (s3._map[t4] = i4);
      s3.size > 0 && (a2._map[t3] = s3);
    }
    s2.clear();
    return a2.size > 0 ? a2 : _Dict.empty;
  }
  clone() {
    const e2 = new _Dict(this.xref);
    for (const t2 of this.getKeys())
      e2.set(t2, this.getRaw(t2));
    return e2;
  }
  delete(e2) {
    delete this._map[e2];
  }
};
var Ref = class _Ref {
  constructor(e2, t2) {
    this.num = e2;
    this.gen = t2;
  }
  toString() {
    return 0 === this.gen ? `${this.num}R` : `${this.num}R${this.gen}`;
  }
  static fromString(e2) {
    const t2 = Ft[e2];
    if (t2)
      return t2;
    const i2 = /^(\d+)R(\d*)$/.exec(e2);
    return i2 && "0" !== i2[1] ? Ft[e2] = new _Ref(parseInt(i2[1]), i2[2] ? parseInt(i2[2]) : 0) : null;
  }
  static get(e2, t2) {
    const i2 = 0 === t2 ? `${e2}R` : `${e2}R${t2}`;
    return Ft[i2] || (Ft[i2] = new _Ref(e2, t2));
  }
};
var RefSet = class {
  constructor(e2 = null) {
    this._set = new Set(e2 == null ? void 0 : e2._set);
  }
  has(e2) {
    return this._set.has(e2.toString());
  }
  put(e2) {
    this._set.add(e2.toString());
  }
  remove(e2) {
    this._set.delete(e2.toString());
  }
  [Symbol.iterator]() {
    return this._set.values();
  }
  clear() {
    this._set.clear();
  }
};
var RefSetCache = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._map.size;
  }
  get(e2) {
    return this._map.get(e2.toString());
  }
  has(e2) {
    return this._map.has(e2.toString());
  }
  put(e2, t2) {
    this._map.set(e2.toString(), t2);
  }
  putAlias(e2, t2) {
    this._map.set(e2.toString(), this.get(t2));
  }
  [Symbol.iterator]() {
    return this._map.values();
  }
  clear() {
    this._map.clear();
  }
  *items() {
    for (const [e2, t2] of this._map)
      yield [Ref.fromString(e2), t2];
  }
};
function isName(e2, t2) {
  return e2 instanceof Name && (void 0 === t2 || e2.name === t2);
}
function isCmd(e2, t2) {
  return e2 instanceof Cmd && (void 0 === t2 || e2.cmd === t2);
}
function isDict(e2, t2) {
  return e2 instanceof Dict && (void 0 === t2 || isName(e2.get("Type"), t2));
}
function isRefsEqual(e2, t2) {
  return e2.num === t2.num && e2.gen === t2.gen;
}
var BaseStream = class _BaseStream {
  constructor() {
    this.constructor === _BaseStream && unreachable("Cannot initialize BaseStream.");
  }
  get length() {
    unreachable("Abstract getter `length` accessed");
  }
  get isEmpty() {
    unreachable("Abstract getter `isEmpty` accessed");
  }
  get isDataLoaded() {
    return shadow(this, "isDataLoaded", true);
  }
  getByte() {
    unreachable("Abstract method `getByte` called");
  }
  getBytes(e2) {
    unreachable("Abstract method `getBytes` called");
  }
  async getImageData(e2, t2) {
    return this.getBytes(e2, t2);
  }
  async asyncGetBytes() {
    unreachable("Abstract method `asyncGetBytes` called");
  }
  get isAsync() {
    return false;
  }
  get canAsyncDecodeImageFromBuffer() {
    return false;
  }
  peekByte() {
    const e2 = this.getByte();
    -1 !== e2 && this.pos--;
    return e2;
  }
  peekBytes(e2) {
    const t2 = this.getBytes(e2);
    this.pos -= t2.length;
    return t2;
  }
  getUint16() {
    const e2 = this.getByte(), t2 = this.getByte();
    return -1 === e2 || -1 === t2 ? -1 : (e2 << 8) + t2;
  }
  getInt32() {
    return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
  }
  getByteRange(e2, t2) {
    unreachable("Abstract method `getByteRange` called");
  }
  getString(e2) {
    return bytesToString(this.getBytes(e2));
  }
  skip(e2) {
    this.pos += e2 || 1;
  }
  reset() {
    unreachable("Abstract method `reset` called");
  }
  moveStart() {
    unreachable("Abstract method `moveStart` called");
  }
  makeSubStream(e2, t2, i2 = null) {
    unreachable("Abstract method `makeSubStream` called");
  }
  getBaseStreams() {
    return null;
  }
};
var kt = /^[1-9]\.\d$/;
function getLookupTableFactory(e2) {
  let t2;
  return function() {
    if (e2) {
      t2 = /* @__PURE__ */ Object.create(null);
      e2(t2);
      e2 = null;
    }
    return t2;
  };
}
var MissingDataException = class extends ot {
  constructor(e2, t2) {
    super(`Missing data [${e2}, ${t2})`, "MissingDataException");
    this.begin = e2;
    this.end = t2;
  }
};
var ParserEOFException = class extends ot {
  constructor(e2) {
    super(e2, "ParserEOFException");
  }
};
var XRefEntryException = class extends ot {
  constructor(e2) {
    super(e2, "XRefEntryException");
  }
};
var XRefParseException = class extends ot {
  constructor(e2) {
    super(e2, "XRefParseException");
  }
};
function arrayBuffersToBytes(e2) {
  const t2 = e2.length;
  if (0 === t2)
    return new Uint8Array(0);
  if (1 === t2)
    return new Uint8Array(e2[0]);
  let i2 = 0;
  for (let a3 = 0; a3 < t2; a3++)
    i2 += e2[a3].byteLength;
  const a2 = new Uint8Array(i2);
  let s2 = 0;
  for (let i3 = 0; i3 < t2; i3++) {
    const t3 = new Uint8Array(e2[i3]);
    a2.set(t3, s2);
    s2 += t3.byteLength;
  }
  return a2;
}
function getInheritableProperty({ dict: e2, key: t2, getArray: i2 = false, stopWhenFound: a2 = true }) {
  let s2;
  const r2 = new RefSet();
  for (; e2 instanceof Dict && (!e2.objId || !r2.has(e2.objId)); ) {
    e2.objId && r2.put(e2.objId);
    const n2 = i2 ? e2.getArray(t2) : e2.get(t2);
    if (void 0 !== n2) {
      if (a2)
        return n2;
      (s2 || (s2 = [])).push(n2);
    }
    e2 = e2.get("Parent");
  }
  return s2;
}
var Rt = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
function toRomanNumerals(e2, t2 = false) {
  assert(Number.isInteger(e2) && e2 > 0, "The number should be a positive integer.");
  const i2 = [];
  let a2;
  for (; e2 >= 1e3; ) {
    e2 -= 1e3;
    i2.push("M");
  }
  a2 = e2 / 100 | 0;
  e2 %= 100;
  i2.push(Rt[a2]);
  a2 = e2 / 10 | 0;
  e2 %= 10;
  i2.push(Rt[10 + a2]);
  i2.push(Rt[20 + e2]);
  const s2 = i2.join("");
  return t2 ? s2.toLowerCase() : s2;
}
function log2(e2) {
  return e2 <= 0 ? 0 : Math.ceil(Math.log2(e2));
}
function readInt8(e2, t2) {
  return e2[t2] << 24 >> 24;
}
function readUint16(e2, t2) {
  return e2[t2] << 8 | e2[t2 + 1];
}
function readUint32(e2, t2) {
  return (e2[t2] << 24 | e2[t2 + 1] << 16 | e2[t2 + 2] << 8 | e2[t2 + 3]) >>> 0;
}
function isWhiteSpace(e2) {
  return 32 === e2 || 9 === e2 || 13 === e2 || 10 === e2;
}
function isNumberArray(e2, t2) {
  return Array.isArray(e2) && (null === t2 || e2.length === t2) && e2.every((e3) => "number" == typeof e3);
}
function lookupMatrix(e2, t2) {
  return isNumberArray(e2, 6) ? e2 : t2;
}
function lookupRect(e2, t2) {
  return isNumberArray(e2, 4) ? e2 : t2;
}
function lookupNormalRect(e2, t2) {
  return isNumberArray(e2, 4) ? Util.normalizeRect(e2) : t2;
}
function parseXFAPath(e2) {
  const t2 = /(.+)\[(\d+)\]$/;
  return e2.split(".").map((e3) => {
    const i2 = e3.match(t2);
    return i2 ? { name: i2[1], pos: parseInt(i2[2], 10) } : { name: e3, pos: 0 };
  });
}
function escapePDFName(e2) {
  const t2 = [];
  let i2 = 0;
  for (let a2 = 0, s2 = e2.length; a2 < s2; a2++) {
    const s3 = e2.charCodeAt(a2);
    if (s3 < 33 || s3 > 126 || 35 === s3 || 40 === s3 || 41 === s3 || 60 === s3 || 62 === s3 || 91 === s3 || 93 === s3 || 123 === s3 || 125 === s3 || 47 === s3 || 37 === s3) {
      i2 < a2 && t2.push(e2.substring(i2, a2));
      t2.push(`#${s3.toString(16)}`);
      i2 = a2 + 1;
    }
  }
  if (0 === t2.length)
    return e2;
  i2 < e2.length && t2.push(e2.substring(i2, e2.length));
  return t2.join("");
}
function escapeString(e2) {
  return e2.replaceAll(/([()\\\n\r])/g, (e3) => "\n" === e3 ? "\\n" : "\r" === e3 ? "\\r" : `\\${e3}`);
}
function _collectJS(e2, t2, i2, a2) {
  if (!e2)
    return;
  let s2 = null;
  if (e2 instanceof Ref) {
    if (a2.has(e2))
      return;
    s2 = e2;
    a2.put(s2);
    e2 = t2.fetch(e2);
  }
  if (Array.isArray(e2))
    for (const s3 of e2)
      _collectJS(s3, t2, i2, a2);
  else if (e2 instanceof Dict) {
    if (isName(e2.get("S"), "JavaScript")) {
      const t3 = e2.get("JS");
      let a3;
      t3 instanceof BaseStream ? a3 = t3.getString() : "string" == typeof t3 && (a3 = t3);
      a3 && (a3 = stringToPDFString(a3).replaceAll("\0", ""));
      a3 && i2.push(a3);
    }
    _collectJS(e2.getRaw("Next"), t2, i2, a2);
  }
  s2 && a2.remove(s2);
}
function collectActions(e2, t2, i2) {
  const a2 = /* @__PURE__ */ Object.create(null), s2 = getInheritableProperty({ dict: t2, key: "AA", stopWhenFound: false });
  if (s2)
    for (let t3 = s2.length - 1; t3 >= 0; t3--) {
      const r2 = s2[t3];
      if (r2 instanceof Dict)
        for (const t4 of r2.getKeys()) {
          const s3 = i2[t4];
          if (!s3)
            continue;
          const n2 = [];
          _collectJS(r2.getRaw(t4), e2, n2, new RefSet());
          n2.length > 0 && (a2[s3] = n2);
        }
    }
  if (t2.has("A")) {
    const i3 = [];
    _collectJS(t2.get("A"), e2, i3, new RefSet());
    i3.length > 0 && (a2.Action = i3);
  }
  return objectSize(a2) > 0 ? a2 : null;
}
var Nt = { 60: "&lt;", 62: "&gt;", 38: "&amp;", 34: "&quot;", 39: "&apos;" };
function* codePointIter(e2) {
  for (let t2 = 0, i2 = e2.length; t2 < i2; t2++) {
    const i3 = e2.codePointAt(t2);
    i3 > 55295 && (i3 < 57344 || i3 > 65533) && t2++;
    yield i3;
  }
}
function encodeToXmlString(e2) {
  const t2 = [];
  let i2 = 0;
  for (let a2 = 0, s2 = e2.length; a2 < s2; a2++) {
    const s3 = e2.codePointAt(a2);
    if (32 <= s3 && s3 <= 126) {
      const r2 = Nt[s3];
      if (r2) {
        i2 < a2 && t2.push(e2.substring(i2, a2));
        t2.push(r2);
        i2 = a2 + 1;
      }
    } else {
      i2 < a2 && t2.push(e2.substring(i2, a2));
      t2.push(`&#x${s3.toString(16).toUpperCase()};`);
      s3 > 55295 && (s3 < 57344 || s3 > 65533) && a2++;
      i2 = a2 + 1;
    }
  }
  if (0 === t2.length)
    return e2;
  i2 < e2.length && t2.push(e2.substring(i2, e2.length));
  return t2.join("");
}
function validateFontName(e2, t2 = false) {
  const i2 = /^("|').*("|')$/.exec(e2);
  if (i2 && i2[1] === i2[2]) {
    if (new RegExp(`[^\\\\]${i2[1]}`).test(e2.slice(1, -1))) {
      t2 && warn(`FontFamily contains unescaped ${i2[1]}: ${e2}.`);
      return false;
    }
  } else
    for (const i3 of e2.split(/[ \t]+/))
      if (/^(\d|(-(\d|-)))/.test(i3) || !/^[\w-\\]+$/.test(i3)) {
        t2 && warn(`FontFamily contains invalid <custom-ident>: ${e2}.`);
        return false;
      }
  return true;
}
function validateCSSFont(e2) {
  const t2 = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), { fontFamily: i2, fontWeight: a2, italicAngle: s2 } = e2;
  if (!validateFontName(i2, true))
    return false;
  const r2 = a2 ? a2.toString() : "";
  e2.fontWeight = t2.has(r2) ? r2 : "400";
  const n2 = parseFloat(s2);
  e2.italicAngle = isNaN(n2) || n2 < -90 || n2 > 90 ? "14" : s2.toString();
  return true;
}
function recoverJsURL(e2) {
  const t2 = new RegExp("^\\s*(" + ["app.launchURL", "window.open", "xfa.host.gotoURL"].join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(e2);
  if (t2 == null ? void 0 : t2[2]) {
    const e3 = t2[2];
    let i2 = false;
    "true" === t2[3] && "app.launchURL" === t2[1] && (i2 = true);
    return { url: e3, newWindow: i2 };
  }
  return null;
}
function numberToString(e2) {
  if (Number.isInteger(e2))
    return e2.toString();
  const t2 = Math.round(100 * e2);
  return t2 % 100 == 0 ? (t2 / 100).toString() : t2 % 10 == 0 ? e2.toFixed(1) : e2.toFixed(2);
}
function getNewAnnotationsMap(e2) {
  if (!e2)
    return null;
  const t2 = /* @__PURE__ */ new Map();
  for (const [i2, a2] of e2) {
    if (!i2.startsWith(u))
      continue;
    let e3 = t2.get(a2.pageIndex);
    if (!e3) {
      e3 = [];
      t2.set(a2.pageIndex, e3);
    }
    e3.push(a2);
  }
  return t2.size > 0 ? t2 : null;
}
function stringToAsciiOrUTF16BE(e2) {
  return function isAscii(e3) {
    return /^[\x00-\x7F]*$/.test(e3);
  }(e2) ? e2 : stringToUTF16String(e2, true);
}
function stringToUTF16HexString(e2) {
  const t2 = [];
  for (let i2 = 0, a2 = e2.length; i2 < a2; i2++) {
    const a3 = e2.charCodeAt(i2);
    t2.push((a3 >> 8 & 255).toString(16).padStart(2, "0"), (255 & a3).toString(16).padStart(2, "0"));
  }
  return t2.join("");
}
function stringToUTF16String(e2, t2 = false) {
  const i2 = [];
  t2 && i2.push("þÿ");
  for (let t3 = 0, a2 = e2.length; t3 < a2; t3++) {
    const a3 = e2.charCodeAt(t3);
    i2.push(String.fromCharCode(a3 >> 8 & 255), String.fromCharCode(255 & a3));
  }
  return i2.join("");
}
function getRotationMatrix(e2, t2, i2) {
  switch (e2) {
    case 90:
      return [0, 1, -1, 0, t2, 0];
    case 180:
      return [-1, 0, 0, -1, t2, i2];
    case 270:
      return [0, -1, 1, 0, 0, i2];
    default:
      throw new Error("Invalid rotation");
  }
}
function getSizeInBytes(e2) {
  return Math.ceil(Math.ceil(Math.log2(1 + e2)) / 8);
}
var Stream = class _Stream extends BaseStream {
  constructor(e2, t2, i2, a2) {
    super();
    this.bytes = e2 instanceof Uint8Array ? e2 : new Uint8Array(e2);
    this.start = t2 || 0;
    this.pos = this.start;
    this.end = t2 + i2 || this.bytes.length;
    this.dict = a2;
  }
  get length() {
    return this.end - this.start;
  }
  get isEmpty() {
    return 0 === this.length;
  }
  getByte() {
    return this.pos >= this.end ? -1 : this.bytes[this.pos++];
  }
  getBytes(e2) {
    const t2 = this.bytes, i2 = this.pos, a2 = this.end;
    if (!e2)
      return t2.subarray(i2, a2);
    let s2 = i2 + e2;
    s2 > a2 && (s2 = a2);
    this.pos = s2;
    return t2.subarray(i2, s2);
  }
  getByteRange(e2, t2) {
    e2 < 0 && (e2 = 0);
    t2 > this.end && (t2 = this.end);
    return this.bytes.subarray(e2, t2);
  }
  reset() {
    this.pos = this.start;
  }
  moveStart() {
    this.start = this.pos;
  }
  makeSubStream(e2, t2, i2 = null) {
    return new _Stream(this.bytes.buffer, e2, t2, i2);
  }
};
var StringStream = class extends Stream {
  constructor(e2) {
    super(stringToBytes(e2));
  }
};
var NullStream = class extends Stream {
  constructor() {
    super(new Uint8Array(0));
  }
};
var ChunkedStream = class extends Stream {
  constructor(e2, t2, i2) {
    super(new Uint8Array(e2), 0, e2, null);
    this.chunkSize = t2;
    this._loadedChunks = /* @__PURE__ */ new Set();
    this.numChunks = Math.ceil(e2 / t2);
    this.manager = i2;
    this.progressiveDataLength = 0;
    this.lastSuccessfulEnsureByteChunk = -1;
  }
  getMissingChunks() {
    const e2 = [];
    for (let t2 = 0, i2 = this.numChunks; t2 < i2; ++t2)
      this._loadedChunks.has(t2) || e2.push(t2);
    return e2;
  }
  get numChunksLoaded() {
    return this._loadedChunks.size;
  }
  get isDataLoaded() {
    return this.numChunksLoaded === this.numChunks;
  }
  onReceiveData(e2, t2) {
    const i2 = this.chunkSize;
    if (e2 % i2 != 0)
      throw new Error(`Bad begin offset: ${e2}`);
    const a2 = e2 + t2.byteLength;
    if (a2 % i2 != 0 && a2 !== this.bytes.length)
      throw new Error(`Bad end offset: ${a2}`);
    this.bytes.set(new Uint8Array(t2), e2);
    const s2 = Math.floor(e2 / i2), r2 = Math.floor((a2 - 1) / i2) + 1;
    for (let e3 = s2; e3 < r2; ++e3)
      this._loadedChunks.add(e3);
  }
  onReceiveProgressiveData(e2) {
    let t2 = this.progressiveDataLength;
    const i2 = Math.floor(t2 / this.chunkSize);
    this.bytes.set(new Uint8Array(e2), t2);
    t2 += e2.byteLength;
    this.progressiveDataLength = t2;
    const a2 = t2 >= this.end ? this.numChunks : Math.floor(t2 / this.chunkSize);
    for (let e3 = i2; e3 < a2; ++e3)
      this._loadedChunks.add(e3);
  }
  ensureByte(e2) {
    if (e2 < this.progressiveDataLength)
      return;
    const t2 = Math.floor(e2 / this.chunkSize);
    if (!(t2 > this.numChunks) && t2 !== this.lastSuccessfulEnsureByteChunk) {
      if (!this._loadedChunks.has(t2))
        throw new MissingDataException(e2, e2 + 1);
      this.lastSuccessfulEnsureByteChunk = t2;
    }
  }
  ensureRange(e2, t2) {
    if (e2 >= t2)
      return;
    if (t2 <= this.progressiveDataLength)
      return;
    const i2 = Math.floor(e2 / this.chunkSize);
    if (i2 > this.numChunks)
      return;
    const a2 = Math.min(Math.floor((t2 - 1) / this.chunkSize) + 1, this.numChunks);
    for (let s2 = i2; s2 < a2; ++s2)
      if (!this._loadedChunks.has(s2))
        throw new MissingDataException(e2, t2);
  }
  nextEmptyChunk(e2) {
    const t2 = this.numChunks;
    for (let i2 = 0; i2 < t2; ++i2) {
      const a2 = (e2 + i2) % t2;
      if (!this._loadedChunks.has(a2))
        return a2;
    }
    return null;
  }
  hasChunk(e2) {
    return this._loadedChunks.has(e2);
  }
  getByte() {
    const e2 = this.pos;
    if (e2 >= this.end)
      return -1;
    e2 >= this.progressiveDataLength && this.ensureByte(e2);
    return this.bytes[this.pos++];
  }
  getBytes(e2) {
    const t2 = this.bytes, i2 = this.pos, a2 = this.end;
    if (!e2) {
      a2 > this.progressiveDataLength && this.ensureRange(i2, a2);
      return t2.subarray(i2, a2);
    }
    let s2 = i2 + e2;
    s2 > a2 && (s2 = a2);
    s2 > this.progressiveDataLength && this.ensureRange(i2, s2);
    this.pos = s2;
    return t2.subarray(i2, s2);
  }
  getByteRange(e2, t2) {
    e2 < 0 && (e2 = 0);
    t2 > this.end && (t2 = this.end);
    t2 > this.progressiveDataLength && this.ensureRange(e2, t2);
    return this.bytes.subarray(e2, t2);
  }
  makeSubStream(e2, t2, i2 = null) {
    t2 ? e2 + t2 > this.progressiveDataLength && this.ensureRange(e2, e2 + t2) : e2 >= this.progressiveDataLength && this.ensureByte(e2);
    function ChunkedStreamSubstream() {
    }
    ChunkedStreamSubstream.prototype = Object.create(this);
    ChunkedStreamSubstream.prototype.getMissingChunks = function() {
      const e3 = this.chunkSize, t3 = Math.floor(this.start / e3), i3 = Math.floor((this.end - 1) / e3) + 1, a3 = [];
      for (let e4 = t3; e4 < i3; ++e4)
        this._loadedChunks.has(e4) || a3.push(e4);
      return a3;
    };
    Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", { get() {
      return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length;
    }, configurable: true });
    const a2 = new ChunkedStreamSubstream();
    a2.pos = a2.start = e2;
    a2.end = e2 + t2 || this.end;
    a2.dict = i2;
    return a2;
  }
  getBaseStreams() {
    return [this];
  }
};
var ChunkedStreamManager = class {
  constructor(e2, t2) {
    this.length = t2.length;
    this.chunkSize = t2.rangeChunkSize;
    this.stream = new ChunkedStream(this.length, this.chunkSize, this);
    this.pdfNetworkStream = e2;
    this.disableAutoFetch = t2.disableAutoFetch;
    this.msgHandler = t2.msgHandler;
    this.currRequestId = 0;
    this._chunksNeededByRequest = /* @__PURE__ */ new Map();
    this._requestsByChunk = /* @__PURE__ */ new Map();
    this._promisesByRequest = /* @__PURE__ */ new Map();
    this.progressiveDataLength = 0;
    this.aborted = false;
    this._loadedStreamCapability = Promise.withResolvers();
  }
  sendRequest(e2, t2) {
    const i2 = this.pdfNetworkStream.getRangeReader(e2, t2);
    i2.isStreamingSupported || (i2.onProgress = this.onProgress.bind(this));
    let a2 = [], s2 = 0;
    return new Promise((e3, t3) => {
      const readChunk = ({ value: r2, done: n2 }) => {
        try {
          if (n2) {
            const t4 = arrayBuffersToBytes(a2);
            a2 = null;
            e3(t4);
            return;
          }
          s2 += r2.byteLength;
          i2.isStreamingSupported && this.onProgress({ loaded: s2 });
          a2.push(r2);
          i2.read().then(readChunk, t3);
        } catch (e4) {
          t3(e4);
        }
      };
      i2.read().then(readChunk, t3);
    }).then((t3) => {
      this.aborted || this.onReceiveData({ chunk: t3, begin: e2 });
    });
  }
  requestAllChunks(e2 = false) {
    if (!e2) {
      const e3 = this.stream.getMissingChunks();
      this._requestChunks(e3);
    }
    return this._loadedStreamCapability.promise;
  }
  _requestChunks(e2) {
    const t2 = this.currRequestId++, i2 = /* @__PURE__ */ new Set();
    this._chunksNeededByRequest.set(t2, i2);
    for (const t3 of e2)
      this.stream.hasChunk(t3) || i2.add(t3);
    if (0 === i2.size)
      return Promise.resolve();
    const a2 = Promise.withResolvers();
    this._promisesByRequest.set(t2, a2);
    const s2 = [];
    for (const e3 of i2) {
      let i3 = this._requestsByChunk.get(e3);
      if (!i3) {
        i3 = [];
        this._requestsByChunk.set(e3, i3);
        s2.push(e3);
      }
      i3.push(t2);
    }
    if (s2.length > 0) {
      const e3 = this.groupChunks(s2);
      for (const t3 of e3) {
        const e4 = t3.beginChunk * this.chunkSize, i3 = Math.min(t3.endChunk * this.chunkSize, this.length);
        this.sendRequest(e4, i3).catch(a2.reject);
      }
    }
    return a2.promise.catch((e3) => {
      if (!this.aborted)
        throw e3;
    });
  }
  getStream() {
    return this.stream;
  }
  requestRange(e2, t2) {
    t2 = Math.min(t2, this.length);
    const i2 = this.getBeginChunk(e2), a2 = this.getEndChunk(t2), s2 = [];
    for (let e3 = i2; e3 < a2; ++e3)
      s2.push(e3);
    return this._requestChunks(s2);
  }
  requestRanges(e2 = []) {
    const t2 = [];
    for (const i2 of e2) {
      const e3 = this.getBeginChunk(i2.begin), a2 = this.getEndChunk(i2.end);
      for (let i3 = e3; i3 < a2; ++i3)
        t2.includes(i3) || t2.push(i3);
    }
    t2.sort(function(e3, t3) {
      return e3 - t3;
    });
    return this._requestChunks(t2);
  }
  groupChunks(e2) {
    const t2 = [];
    let i2 = -1, a2 = -1;
    for (let s2 = 0, r2 = e2.length; s2 < r2; ++s2) {
      const r3 = e2[s2];
      i2 < 0 && (i2 = r3);
      if (a2 >= 0 && a2 + 1 !== r3) {
        t2.push({ beginChunk: i2, endChunk: a2 + 1 });
        i2 = r3;
      }
      s2 + 1 === e2.length && t2.push({ beginChunk: i2, endChunk: r3 + 1 });
      a2 = r3;
    }
    return t2;
  }
  onProgress(e2) {
    this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize + e2.loaded, total: this.length });
  }
  onReceiveData(e2) {
    const t2 = e2.chunk, i2 = void 0 === e2.begin, a2 = i2 ? this.progressiveDataLength : e2.begin, s2 = a2 + t2.byteLength, r2 = Math.floor(a2 / this.chunkSize), n2 = s2 < this.length ? Math.floor(s2 / this.chunkSize) : Math.ceil(s2 / this.chunkSize);
    if (i2) {
      this.stream.onReceiveProgressiveData(t2);
      this.progressiveDataLength = s2;
    } else
      this.stream.onReceiveData(a2, t2);
    this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
    const g2 = [];
    for (let e3 = r2; e3 < n2; ++e3) {
      const t3 = this._requestsByChunk.get(e3);
      if (t3) {
        this._requestsByChunk.delete(e3);
        for (const i3 of t3) {
          const t4 = this._chunksNeededByRequest.get(i3);
          t4.has(e3) && t4.delete(e3);
          t4.size > 0 || g2.push(i3);
        }
      }
    }
    if (!this.disableAutoFetch && 0 === this._requestsByChunk.size) {
      let e3;
      if (1 === this.stream.numChunksLoaded) {
        const t3 = this.stream.numChunks - 1;
        this.stream.hasChunk(t3) || (e3 = t3);
      } else
        e3 = this.stream.nextEmptyChunk(n2);
      Number.isInteger(e3) && this._requestChunks([e3]);
    }
    for (const e3 of g2) {
      const t3 = this._promisesByRequest.get(e3);
      this._promisesByRequest.delete(e3);
      t3.resolve();
    }
    this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize, total: this.length });
  }
  onError(e2) {
    this._loadedStreamCapability.reject(e2);
  }
  getBeginChunk(e2) {
    return Math.floor(e2 / this.chunkSize);
  }
  getEndChunk(e2) {
    return Math.floor((e2 - 1) / this.chunkSize) + 1;
  }
  abort(e2) {
    var _a4;
    this.aborted = true;
    (_a4 = this.pdfNetworkStream) == null ? void 0 : _a4.cancelAllRequests(e2);
    for (const t2 of this._promisesByRequest.values())
      t2.reject(e2);
  }
};
var ColorSpace = class _ColorSpace {
  constructor(e2, t2) {
    this.constructor === _ColorSpace && unreachable("Cannot initialize ColorSpace.");
    this.name = e2;
    this.numComps = t2;
  }
  getRgb(e2, t2) {
    const i2 = new Uint8ClampedArray(3);
    this.getRgbItem(e2, t2, i2, 0);
    return i2;
  }
  getRgbItem(e2, t2, i2, a2) {
    unreachable("Should not call ColorSpace.getRgbItem");
  }
  getRgbBuffer(e2, t2, i2, a2, s2, r2, n2) {
    unreachable("Should not call ColorSpace.getRgbBuffer");
  }
  getOutputLength(e2, t2) {
    unreachable("Should not call ColorSpace.getOutputLength");
  }
  isPassthrough(e2) {
    return false;
  }
  isDefaultDecode(e2, t2) {
    return _ColorSpace.isDefaultDecode(e2, this.numComps);
  }
  fillRgb(e2, t2, i2, a2, s2, r2, n2, g2, o2) {
    const c2 = t2 * i2;
    let C2 = null;
    const h2 = 1 << n2, l2 = i2 !== s2 || t2 !== a2;
    if (this.isPassthrough(n2))
      C2 = g2;
    else if (1 === this.numComps && c2 > h2 && "DeviceGray" !== this.name && "DeviceRGB" !== this.name) {
      const t3 = n2 <= 8 ? new Uint8Array(h2) : new Uint16Array(h2);
      for (let e3 = 0; e3 < h2; e3++)
        t3[e3] = e3;
      const i3 = new Uint8ClampedArray(3 * h2);
      this.getRgbBuffer(t3, 0, h2, i3, 0, n2, 0);
      if (l2) {
        C2 = new Uint8Array(3 * c2);
        let e3 = 0;
        for (let t4 = 0; t4 < c2; ++t4) {
          const a3 = 3 * g2[t4];
          C2[e3++] = i3[a3];
          C2[e3++] = i3[a3 + 1];
          C2[e3++] = i3[a3 + 2];
        }
      } else {
        let t4 = 0;
        for (let a3 = 0; a3 < c2; ++a3) {
          const s3 = 3 * g2[a3];
          e2[t4++] = i3[s3];
          e2[t4++] = i3[s3 + 1];
          e2[t4++] = i3[s3 + 2];
          t4 += o2;
        }
      }
    } else if (l2) {
      C2 = new Uint8ClampedArray(3 * c2);
      this.getRgbBuffer(g2, 0, c2, C2, 0, n2, 0);
    } else
      this.getRgbBuffer(g2, 0, a2 * r2, e2, 0, n2, o2);
    if (C2)
      if (l2)
        !function resizeRgbImage(e3, t3, i3, a3, s3, r3, n3) {
          n3 = 1 !== n3 ? 0 : n3;
          const g3 = i3 / s3, o3 = a3 / r3;
          let c3, C3 = 0;
          const h3 = new Uint16Array(s3), l3 = 3 * i3;
          for (let e4 = 0; e4 < s3; e4++)
            h3[e4] = 3 * Math.floor(e4 * g3);
          for (let i4 = 0; i4 < r3; i4++) {
            const a4 = Math.floor(i4 * o3) * l3;
            for (let i5 = 0; i5 < s3; i5++) {
              c3 = a4 + h3[i5];
              t3[C3++] = e3[c3++];
              t3[C3++] = e3[c3++];
              t3[C3++] = e3[c3++];
              C3 += n3;
            }
          }
        }(C2, e2, t2, i2, a2, s2, o2);
      else {
        let t3 = 0, i3 = 0;
        for (let s3 = 0, n3 = a2 * r2; s3 < n3; s3++) {
          e2[t3++] = C2[i3++];
          e2[t3++] = C2[i3++];
          e2[t3++] = C2[i3++];
          t3 += o2;
        }
      }
  }
  get usesZeroToOneRange() {
    return shadow(this, "usesZeroToOneRange", true);
  }
  static _cache(e2, t2, i2, a2) {
    if (!i2)
      throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
    if (!a2)
      throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
    let s2, r2;
    if (e2 instanceof Ref) {
      r2 = e2;
      e2 = t2.fetch(e2);
    }
    e2 instanceof Name && (s2 = e2.name);
    (s2 || r2) && i2.set(s2, r2, a2);
  }
  static getCached(e2, t2, i2) {
    if (!i2)
      throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
    if (e2 instanceof Ref) {
      const a2 = i2.getByRef(e2);
      if (a2)
        return a2;
      try {
        e2 = t2.fetch(e2);
      } catch (e3) {
        if (e3 instanceof MissingDataException)
          throw e3;
      }
    }
    if (e2 instanceof Name) {
      const t3 = i2.getByName(e2.name);
      if (t3)
        return t3;
    }
    return null;
  }
  static async parseAsync({ cs: e2, xref: t2, resources: i2 = null, pdfFunctionFactory: a2, localColorSpaceCache: s2 }) {
    const r2 = this._parse(e2, t2, i2, a2);
    this._cache(e2, t2, s2, r2);
    return r2;
  }
  static parse({ cs: e2, xref: t2, resources: i2 = null, pdfFunctionFactory: a2, localColorSpaceCache: s2 }) {
    const r2 = this.getCached(e2, t2, s2);
    if (r2)
      return r2;
    const n2 = this._parse(e2, t2, i2, a2);
    this._cache(e2, t2, s2, n2);
    return n2;
  }
  static _parse(e2, t2, i2 = null, a2) {
    if ((e2 = t2.fetchIfRef(e2)) instanceof Name)
      switch (e2.name) {
        case "G":
        case "DeviceGray":
          return this.singletons.gray;
        case "RGB":
        case "DeviceRGB":
          return this.singletons.rgb;
        case "DeviceRGBA":
          return this.singletons.rgba;
        case "CMYK":
        case "DeviceCMYK":
          return this.singletons.cmyk;
        case "Pattern":
          return new PatternCS(null);
        default:
          if (i2 instanceof Dict) {
            const s2 = i2.get("ColorSpace");
            if (s2 instanceof Dict) {
              const r2 = s2.get(e2.name);
              if (r2) {
                if (r2 instanceof Name)
                  return this._parse(r2, t2, i2, a2);
                e2 = r2;
                break;
              }
            }
          }
          warn(`Unrecognized ColorSpace: ${e2.name}`);
          return this.singletons.gray;
      }
    if (Array.isArray(e2)) {
      const s2 = t2.fetchIfRef(e2[0]).name;
      let r2, n2, g2, o2, c2, C2;
      switch (s2) {
        case "G":
        case "DeviceGray":
          return this.singletons.gray;
        case "RGB":
        case "DeviceRGB":
          return this.singletons.rgb;
        case "CMYK":
        case "DeviceCMYK":
          return this.singletons.cmyk;
        case "CalGray":
          r2 = t2.fetchIfRef(e2[1]);
          o2 = r2.getArray("WhitePoint");
          c2 = r2.getArray("BlackPoint");
          C2 = r2.get("Gamma");
          return new CalGrayCS(o2, c2, C2);
        case "CalRGB":
          r2 = t2.fetchIfRef(e2[1]);
          o2 = r2.getArray("WhitePoint");
          c2 = r2.getArray("BlackPoint");
          C2 = r2.getArray("Gamma");
          const h2 = r2.getArray("Matrix");
          return new CalRGBCS(o2, c2, C2, h2);
        case "ICCBased":
          const l2 = t2.fetchIfRef(e2[1]).dict;
          n2 = l2.get("N");
          const Q2 = l2.get("Alternate");
          if (Q2) {
            const e3 = this._parse(Q2, t2, i2, a2);
            if (e3.numComps === n2)
              return e3;
            warn("ICCBased color space: Ignoring incorrect /Alternate entry.");
          }
          if (1 === n2)
            return this.singletons.gray;
          if (3 === n2)
            return this.singletons.rgb;
          if (4 === n2)
            return this.singletons.cmyk;
          break;
        case "Pattern":
          g2 = e2[1] || null;
          g2 && (g2 = this._parse(g2, t2, i2, a2));
          return new PatternCS(g2);
        case "I":
        case "Indexed":
          g2 = this._parse(e2[1], t2, i2, a2);
          const E2 = t2.fetchIfRef(e2[2]) + 1, u2 = t2.fetchIfRef(e2[3]);
          return new IndexedCS(g2, E2, u2);
        case "Separation":
        case "DeviceN":
          const d2 = t2.fetchIfRef(e2[1]);
          n2 = Array.isArray(d2) ? d2.length : 1;
          g2 = this._parse(e2[2], t2, i2, a2);
          const f2 = a2.create(e2[3]);
          return new AlternateCS(n2, g2, f2);
        case "Lab":
          r2 = t2.fetchIfRef(e2[1]);
          o2 = r2.getArray("WhitePoint");
          c2 = r2.getArray("BlackPoint");
          const p2 = r2.getArray("Range");
          return new LabCS(o2, c2, p2);
        default:
          warn(`Unimplemented ColorSpace object: ${s2}`);
          return this.singletons.gray;
      }
    }
    warn(`Unrecognized ColorSpace object: ${e2}`);
    return this.singletons.gray;
  }
  static isDefaultDecode(e2, t2) {
    if (!Array.isArray(e2))
      return true;
    if (2 * t2 !== e2.length) {
      warn("The decode map is not the correct length");
      return true;
    }
    for (let t3 = 0, i2 = e2.length; t3 < i2; t3 += 2)
      if (0 !== e2[t3] || 1 !== e2[t3 + 1])
        return false;
    return true;
  }
  static get singletons() {
    return shadow(this, "singletons", { get gray() {
      return shadow(this, "gray", new DeviceGrayCS());
    }, get rgb() {
      return shadow(this, "rgb", new DeviceRgbCS());
    }, get rgba() {
      return shadow(this, "rgba", new DeviceRgbaCS());
    }, get cmyk() {
      return shadow(this, "cmyk", new DeviceCmykCS());
    } });
  }
};
var AlternateCS = class extends ColorSpace {
  constructor(e2, t2, i2) {
    super("Alternate", e2);
    this.base = t2;
    this.tintFn = i2;
    this.tmpBuf = new Float32Array(t2.numComps);
  }
  getRgbItem(e2, t2, i2, a2) {
    const s2 = this.tmpBuf;
    this.tintFn(e2, t2, s2, 0);
    this.base.getRgbItem(s2, 0, i2, a2);
  }
  getRgbBuffer(e2, t2, i2, a2, s2, r2, n2) {
    const g2 = this.tintFn, o2 = this.base, c2 = 1 / ((1 << r2) - 1), C2 = o2.numComps, h2 = o2.usesZeroToOneRange, l2 = (o2.isPassthrough(8) || !h2) && 0 === n2;
    let Q2 = l2 ? s2 : 0;
    const E2 = l2 ? a2 : new Uint8ClampedArray(C2 * i2), u2 = this.numComps, d2 = new Float32Array(u2), f2 = new Float32Array(C2);
    let p2, m2;
    for (p2 = 0; p2 < i2; p2++) {
      for (m2 = 0; m2 < u2; m2++)
        d2[m2] = e2[t2++] * c2;
      g2(d2, 0, f2, 0);
      if (h2)
        for (m2 = 0; m2 < C2; m2++)
          E2[Q2++] = 255 * f2[m2];
      else {
        o2.getRgbItem(f2, 0, E2, Q2);
        Q2 += C2;
      }
    }
    l2 || o2.getRgbBuffer(E2, 0, i2, a2, s2, 8, n2);
  }
  getOutputLength(e2, t2) {
    return this.base.getOutputLength(e2 * this.base.numComps / this.numComps, t2);
  }
};
var PatternCS = class extends ColorSpace {
  constructor(e2) {
    super("Pattern", null);
    this.base = e2;
  }
  isDefaultDecode(e2, t2) {
    unreachable("Should not call PatternCS.isDefaultDecode");
  }
};
var IndexedCS = class extends ColorSpace {
  constructor(e2, t2, i2) {
    super("Indexed", 1);
    this.base = e2;
    this.highVal = t2;
    const a2 = e2.numComps * t2;
    this.lookup = new Uint8Array(a2);
    if (i2 instanceof BaseStream) {
      const e3 = i2.getBytes(a2);
      this.lookup.set(e3);
    } else {
      if ("string" != typeof i2)
        throw new FormatError(`IndexedCS - unrecognized lookup table: ${i2}`);
      for (let e3 = 0; e3 < a2; ++e3)
        this.lookup[e3] = 255 & i2.charCodeAt(e3);
    }
  }
  getRgbItem(e2, t2, i2, a2) {
    const s2 = this.base.numComps, r2 = e2[t2] * s2;
    this.base.getRgbBuffer(this.lookup, r2, 1, i2, a2, 8, 0);
  }
  getRgbBuffer(e2, t2, i2, a2, s2, r2, n2) {
    const g2 = this.base, o2 = g2.numComps, c2 = g2.getOutputLength(o2, n2), C2 = this.lookup;
    for (let r3 = 0; r3 < i2; ++r3) {
      const i3 = e2[t2++] * o2;
      g2.getRgbBuffer(C2, i3, 1, a2, s2, 8, n2);
      s2 += c2;
    }
  }
  getOutputLength(e2, t2) {
    return this.base.getOutputLength(e2 * this.base.numComps, t2);
  }
  isDefaultDecode(e2, t2) {
    if (!Array.isArray(e2))
      return true;
    if (2 !== e2.length) {
      warn("Decode map length is not correct");
      return true;
    }
    if (!Number.isInteger(t2) || t2 < 1) {
      warn("Bits per component is not correct");
      return true;
    }
    return 0 === e2[0] && e2[1] === (1 << t2) - 1;
  }
};
var DeviceGrayCS = class extends ColorSpace {
  constructor() {
    super("DeviceGray", 1);
  }
  getRgbItem(e2, t2, i2, a2) {
    const s2 = 255 * e2[t2];
    i2[a2] = i2[a2 + 1] = i2[a2 + 2] = s2;
  }
  getRgbBuffer(e2, t2, i2, a2, s2, r2, n2) {
    const g2 = 255 / ((1 << r2) - 1);
    let o2 = t2, c2 = s2;
    for (let t3 = 0; t3 < i2; ++t3) {
      const t4 = g2 * e2[o2++];
      a2[c2++] = t4;
      a2[c2++] = t4;
      a2[c2++] = t4;
      c2 += n2;
    }
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2);
  }
};
var DeviceRgbCS = class extends ColorSpace {
  constructor() {
    super("DeviceRGB", 3);
  }
  getRgbItem(e2, t2, i2, a2) {
    i2[a2] = 255 * e2[t2];
    i2[a2 + 1] = 255 * e2[t2 + 1];
    i2[a2 + 2] = 255 * e2[t2 + 2];
  }
  getRgbBuffer(e2, t2, i2, a2, s2, r2, n2) {
    if (8 === r2 && 0 === n2) {
      a2.set(e2.subarray(t2, t2 + 3 * i2), s2);
      return;
    }
    const g2 = 255 / ((1 << r2) - 1);
    let o2 = t2, c2 = s2;
    for (let t3 = 0; t3 < i2; ++t3) {
      a2[c2++] = g2 * e2[o2++];
      a2[c2++] = g2 * e2[o2++];
      a2[c2++] = g2 * e2[o2++];
      c2 += n2;
    }
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2) / 3 | 0;
  }
  isPassthrough(e2) {
    return 8 === e2;
  }
};
var DeviceRgbaCS = class extends ColorSpace {
  constructor() {
    super("DeviceRGBA", 4);
  }
  getOutputLength(e2, t2) {
    return 4 * e2;
  }
  isPassthrough(e2) {
    return 8 === e2;
  }
};
var _t, t_fn;
var DeviceCmykCS = class extends ColorSpace {
  constructor() {
    super("DeviceCMYK", 4);
    __privateAdd(this, _t);
  }
  getRgbItem(e2, t2, i2, a2) {
    __privateMethod(this, _t, t_fn).call(this, e2, t2, 1, i2, a2);
  }
  getRgbBuffer(e2, t2, i2, a2, s2, r2, n2) {
    const g2 = 1 / ((1 << r2) - 1);
    for (let r3 = 0; r3 < i2; r3++) {
      __privateMethod(this, _t, t_fn).call(this, e2, t2, g2, a2, s2);
      t2 += 4;
      s2 += 3 + n2;
    }
  }
  getOutputLength(e2, t2) {
    return e2 / 4 * (3 + t2) | 0;
  }
};
_t = new WeakSet();
t_fn = function(e2, t2, i2, a2, s2) {
  const r2 = e2[t2] * i2, n2 = e2[t2 + 1] * i2, g2 = e2[t2 + 2] * i2, o2 = e2[t2 + 3] * i2;
  a2[s2] = 255 + r2 * (-4.387332384609988 * r2 + 54.48615194189176 * n2 + 18.82290502165302 * g2 + 212.25662451639585 * o2 - 285.2331026137004) + n2 * (1.7149763477362134 * n2 - 5.6096736904047315 * g2 + -17.873870861415444 * o2 - 5.497006427196366) + g2 * (-2.5217340131683033 * g2 - 21.248923337353073 * o2 + 17.5119270841813) + o2 * (-21.86122147463605 * o2 - 189.48180835922747);
  a2[s2 + 1] = 255 + r2 * (8.841041422036149 * r2 + 60.118027045597366 * n2 + 6.871425592049007 * g2 + 31.159100130055922 * o2 - 79.2970844816548) + n2 * (-15.310361306967817 * n2 + 17.575251261109482 * g2 + 131.35250912493976 * o2 - 190.9453302588951) + g2 * (4.444339102852739 * g2 + 9.8632861493405 * o2 - 24.86741582555878) + o2 * (-20.737325471181034 * o2 - 187.80453709719578);
  a2[s2 + 2] = 255 + r2 * (0.8842522430003296 * r2 + 8.078677503112928 * n2 + 30.89978309703729 * g2 - 0.23883238689178934 * o2 - 14.183576799673286) + n2 * (10.49593273432072 * n2 + 63.02378494754052 * g2 + 50.606957656360734 * o2 - 112.23884253719248) + g2 * (0.03296041114873217 * g2 + 115.60384449646641 * o2 - 193.58209356861505) + o2 * (-22.33816807309886 * o2 - 180.12613974708367);
};
var _t2, t_fn2;
var CalGrayCS = class extends ColorSpace {
  constructor(e2, t2, i2) {
    super("CalGray", 1);
    __privateAdd(this, _t2);
    if (!e2)
      throw new FormatError("WhitePoint missing - required for color space CalGray");
    [this.XW, this.YW, this.ZW] = e2;
    [this.XB, this.YB, this.ZB] = t2 || [0, 0, 0];
    this.G = i2 || 1;
    if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW)
      throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
      info(`Invalid BlackPoint for ${this.name}, falling back to default.`);
      this.XB = this.YB = this.ZB = 0;
    }
    0 === this.XB && 0 === this.YB && 0 === this.ZB || warn(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);
    if (this.G < 1) {
      info(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);
      this.G = 1;
    }
  }
  getRgbItem(e2, t2, i2, a2) {
    __privateMethod(this, _t2, t_fn2).call(this, e2, t2, i2, a2, 1);
  }
  getRgbBuffer(e2, t2, i2, a2, s2, r2, n2) {
    const g2 = 1 / ((1 << r2) - 1);
    for (let r3 = 0; r3 < i2; ++r3) {
      __privateMethod(this, _t2, t_fn2).call(this, e2, t2, a2, s2, g2);
      t2 += 1;
      s2 += 3 + n2;
    }
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2);
  }
};
_t2 = new WeakSet();
t_fn2 = function(e2, t2, i2, a2, s2) {
  const r2 = (e2[t2] * s2) ** this.G, n2 = this.YW * r2, g2 = Math.max(295.8 * n2 ** 0.3333333333333333 - 40.8, 0);
  i2[a2] = g2;
  i2[a2 + 1] = g2;
  i2[a2 + 2] = g2;
};
var _i, _a, _s, _r, _n, _g, _o, _I, _c, c_fn, _C, C_fn, _h, h_fn, _B, B_fn, _l, l_fn, _Q, Q_fn, _E, E_fn, _u, u_fn, _d, d_fn, _t3, t_fn3;
var _CalRGBCS = class _CalRGBCS extends ColorSpace {
  constructor(e2, t2, i2, a2) {
    super("CalRGB", 3);
    __privateAdd(this, _c);
    __privateAdd(this, _C);
    __privateAdd(this, _h);
    __privateAdd(this, _B);
    __privateAdd(this, _l);
    __privateAdd(this, _Q);
    __privateAdd(this, _E);
    __privateAdd(this, _u);
    __privateAdd(this, _d);
    __privateAdd(this, _t3);
    if (!e2)
      throw new FormatError("WhitePoint missing - required for color space CalRGB");
    const [s2, r2, n2] = this.whitePoint = e2, [g2, o2, c2] = this.blackPoint = t2 || new Float32Array(3);
    [this.GR, this.GG, this.GB] = i2 || new Float32Array([1, 1, 1]);
    [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = a2 || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    if (s2 < 0 || n2 < 0 || 1 !== r2)
      throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    if (g2 < 0 || o2 < 0 || c2 < 0) {
      info(`Invalid BlackPoint for ${this.name} [${g2}, ${o2}, ${c2}], falling back to default.`);
      this.blackPoint = new Float32Array(3);
    }
    if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
      info(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);
      this.GR = this.GG = this.GB = 1;
    }
  }
  getRgbItem(e2, t2, i2, a2) {
    __privateMethod(this, _t3, t_fn3).call(this, e2, t2, i2, a2, 1);
  }
  getRgbBuffer(e2, t2, i2, a2, s2, r2, n2) {
    const g2 = 1 / ((1 << r2) - 1);
    for (let r3 = 0; r3 < i2; ++r3) {
      __privateMethod(this, _t3, t_fn3).call(this, e2, t2, a2, s2, g2);
      t2 += 3;
      s2 += 3 + n2;
    }
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2) / 3 | 0;
  }
};
_i = new WeakMap();
_a = new WeakMap();
_s = new WeakMap();
_r = new WeakMap();
_n = new WeakMap();
_g = new WeakMap();
_o = new WeakMap();
_I = new WeakMap();
_c = new WeakSet();
c_fn = function(e2, t2, i2) {
  i2[0] = e2[0] * t2[0] + e2[1] * t2[1] + e2[2] * t2[2];
  i2[1] = e2[3] * t2[0] + e2[4] * t2[1] + e2[5] * t2[2];
  i2[2] = e2[6] * t2[0] + e2[7] * t2[1] + e2[8] * t2[2];
};
_C = new WeakSet();
C_fn = function(e2, t2, i2) {
  i2[0] = 1 * t2[0] / e2[0];
  i2[1] = 1 * t2[1] / e2[1];
  i2[2] = 1 * t2[2] / e2[2];
};
_h = new WeakSet();
h_fn = function(e2, t2, i2) {
  i2[0] = 0.95047 * t2[0] / e2[0];
  i2[1] = 1 * t2[1] / e2[1];
  i2[2] = 1.08883 * t2[2] / e2[2];
};
_B = new WeakSet();
B_fn = function(e2) {
  return e2 <= 31308e-7 ? __privateMethod(this, _l, l_fn).call(this, 0, 1, 12.92 * e2) : e2 >= 0.99554525 ? 1 : __privateMethod(this, _l, l_fn).call(this, 0, 1, 1.055 * e2 ** (1 / 2.4) - 0.055);
};
_l = new WeakSet();
l_fn = function(e2, t2, i2) {
  return Math.max(e2, Math.min(t2, i2));
};
_Q = new WeakSet();
Q_fn = function(e2) {
  return e2 < 0 ? -__privateMethod(this, _Q, Q_fn).call(this, -e2) : e2 > 8 ? ((e2 + 16) / 116) ** 3 : e2 * __privateGet(_CalRGBCS, _I);
};
_E = new WeakSet();
E_fn = function(e2, t2, i2) {
  if (0 === e2[0] && 0 === e2[1] && 0 === e2[2]) {
    i2[0] = t2[0];
    i2[1] = t2[1];
    i2[2] = t2[2];
    return;
  }
  const a2 = __privateMethod(this, _Q, Q_fn).call(this, 0), s2 = (1 - a2) / (1 - __privateMethod(this, _Q, Q_fn).call(this, e2[0])), r2 = 1 - s2, n2 = (1 - a2) / (1 - __privateMethod(this, _Q, Q_fn).call(this, e2[1])), g2 = 1 - n2, o2 = (1 - a2) / (1 - __privateMethod(this, _Q, Q_fn).call(this, e2[2])), c2 = 1 - o2;
  i2[0] = t2[0] * s2 + r2;
  i2[1] = t2[1] * n2 + g2;
  i2[2] = t2[2] * o2 + c2;
};
_u = new WeakSet();
u_fn = function(e2, t2, i2) {
  if (1 === e2[0] && 1 === e2[2]) {
    i2[0] = t2[0];
    i2[1] = t2[1];
    i2[2] = t2[2];
    return;
  }
  const a2 = i2;
  __privateMethod(this, _c, c_fn).call(this, __privateGet(_CalRGBCS, _i), t2, a2);
  const s2 = __privateGet(_CalRGBCS, _n);
  __privateMethod(this, _C, C_fn).call(this, e2, a2, s2);
  __privateMethod(this, _c, c_fn).call(this, __privateGet(_CalRGBCS, _a), s2, i2);
};
_d = new WeakSet();
d_fn = function(e2, t2, i2) {
  const a2 = i2;
  __privateMethod(this, _c, c_fn).call(this, __privateGet(_CalRGBCS, _i), t2, a2);
  const s2 = __privateGet(_CalRGBCS, _n);
  __privateMethod(this, _h, h_fn).call(this, e2, a2, s2);
  __privateMethod(this, _c, c_fn).call(this, __privateGet(_CalRGBCS, _a), s2, i2);
};
_t3 = new WeakSet();
t_fn3 = function(e2, t2, i2, a2, s2) {
  const r2 = __privateMethod(this, _l, l_fn).call(this, 0, 1, e2[t2] * s2), n2 = __privateMethod(this, _l, l_fn).call(this, 0, 1, e2[t2 + 1] * s2), g2 = __privateMethod(this, _l, l_fn).call(this, 0, 1, e2[t2 + 2] * s2), o2 = 1 === r2 ? 1 : r2 ** this.GR, c2 = 1 === n2 ? 1 : n2 ** this.GG, C2 = 1 === g2 ? 1 : g2 ** this.GB, h2 = this.MXA * o2 + this.MXB * c2 + this.MXC * C2, l2 = this.MYA * o2 + this.MYB * c2 + this.MYC * C2, Q2 = this.MZA * o2 + this.MZB * c2 + this.MZC * C2, E2 = __privateGet(_CalRGBCS, _g);
  E2[0] = h2;
  E2[1] = l2;
  E2[2] = Q2;
  const u2 = __privateGet(_CalRGBCS, _o);
  __privateMethod(this, _u, u_fn).call(this, this.whitePoint, E2, u2);
  const d2 = __privateGet(_CalRGBCS, _g);
  __privateMethod(this, _E, E_fn).call(this, this.blackPoint, u2, d2);
  const f2 = __privateGet(_CalRGBCS, _o);
  __privateMethod(this, _d, d_fn).call(this, __privateGet(_CalRGBCS, _r), d2, f2);
  const p2 = __privateGet(_CalRGBCS, _g);
  __privateMethod(this, _c, c_fn).call(this, __privateGet(_CalRGBCS, _s), f2, p2);
  i2[a2] = 255 * __privateMethod(this, _B, B_fn).call(this, p2[0]);
  i2[a2 + 1] = 255 * __privateMethod(this, _B, B_fn).call(this, p2[1]);
  i2[a2 + 2] = 255 * __privateMethod(this, _B, B_fn).call(this, p2[2]);
};
__privateAdd(_CalRGBCS, _i, new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]));
__privateAdd(_CalRGBCS, _a, new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]));
__privateAdd(_CalRGBCS, _s, new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]));
__privateAdd(_CalRGBCS, _r, new Float32Array([1, 1, 1]));
__privateAdd(_CalRGBCS, _n, new Float32Array(3));
__privateAdd(_CalRGBCS, _g, new Float32Array(3));
__privateAdd(_CalRGBCS, _o, new Float32Array(3));
__privateAdd(_CalRGBCS, _I, (24 / 116) ** 3 / 8);
var CalRGBCS = _CalRGBCS;
var _f, f_fn, _p, p_fn, _t4, t_fn4;
var LabCS = class extends ColorSpace {
  constructor(e2, t2, i2) {
    super("Lab", 3);
    __privateAdd(this, _f);
    __privateAdd(this, _p);
    __privateAdd(this, _t4);
    if (!e2)
      throw new FormatError("WhitePoint missing - required for color space Lab");
    [this.XW, this.YW, this.ZW] = e2;
    [this.amin, this.amax, this.bmin, this.bmax] = i2 || [-100, 100, -100, 100];
    [this.XB, this.YB, this.ZB] = t2 || [0, 0, 0];
    if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW)
      throw new FormatError("Invalid WhitePoint components, no fallback available");
    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
      info("Invalid BlackPoint, falling back to default");
      this.XB = this.YB = this.ZB = 0;
    }
    if (this.amin > this.amax || this.bmin > this.bmax) {
      info("Invalid Range, falling back to defaults");
      this.amin = -100;
      this.amax = 100;
      this.bmin = -100;
      this.bmax = 100;
    }
  }
  getRgbItem(e2, t2, i2, a2) {
    __privateMethod(this, _t4, t_fn4).call(this, e2, t2, false, i2, a2);
  }
  getRgbBuffer(e2, t2, i2, a2, s2, r2, n2) {
    const g2 = (1 << r2) - 1;
    for (let r3 = 0; r3 < i2; r3++) {
      __privateMethod(this, _t4, t_fn4).call(this, e2, t2, g2, a2, s2);
      t2 += 3;
      s2 += 3 + n2;
    }
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2) / 3 | 0;
  }
  isDefaultDecode(e2, t2) {
    return true;
  }
  get usesZeroToOneRange() {
    return shadow(this, "usesZeroToOneRange", false);
  }
};
_f = new WeakSet();
f_fn = function(e2) {
  return e2 >= 6 / 29 ? e2 ** 3 : 108 / 841 * (e2 - 4 / 29);
};
_p = new WeakSet();
p_fn = function(e2, t2, i2, a2) {
  return i2 + e2 * (a2 - i2) / t2;
};
_t4 = new WeakSet();
t_fn4 = function(e2, t2, i2, a2, s2) {
  let r2 = e2[t2], n2 = e2[t2 + 1], g2 = e2[t2 + 2];
  if (false !== i2) {
    r2 = __privateMethod(this, _p, p_fn).call(this, r2, i2, 0, 100);
    n2 = __privateMethod(this, _p, p_fn).call(this, n2, i2, this.amin, this.amax);
    g2 = __privateMethod(this, _p, p_fn).call(this, g2, i2, this.bmin, this.bmax);
  }
  n2 > this.amax ? n2 = this.amax : n2 < this.amin && (n2 = this.amin);
  g2 > this.bmax ? g2 = this.bmax : g2 < this.bmin && (g2 = this.bmin);
  const o2 = (r2 + 16) / 116, c2 = o2 + n2 / 500, C2 = o2 - g2 / 200, h2 = this.XW * __privateMethod(this, _f, f_fn).call(this, c2), l2 = this.YW * __privateMethod(this, _f, f_fn).call(this, o2), Q2 = this.ZW * __privateMethod(this, _f, f_fn).call(this, C2);
  let E2, u2, d2;
  if (this.ZW < 1) {
    E2 = 3.1339 * h2 + -1.617 * l2 + -0.4906 * Q2;
    u2 = -0.9785 * h2 + 1.916 * l2 + 0.0333 * Q2;
    d2 = 0.072 * h2 + -0.229 * l2 + 1.4057 * Q2;
  } else {
    E2 = 3.2406 * h2 + -1.5372 * l2 + -0.4986 * Q2;
    u2 = -0.9689 * h2 + 1.8758 * l2 + 0.0415 * Q2;
    d2 = 0.0557 * h2 + -0.204 * l2 + 1.057 * Q2;
  }
  a2[s2] = 255 * Math.sqrt(E2);
  a2[s2 + 1] = 255 * Math.sqrt(u2);
  a2[s2 + 2] = 255 * Math.sqrt(d2);
};
function hexToInt(e2, t2) {
  let i2 = 0;
  for (let a2 = 0; a2 <= t2; a2++)
    i2 = i2 << 8 | e2[a2];
  return i2 >>> 0;
}
function hexToStr(e2, t2) {
  return 1 === t2 ? String.fromCharCode(e2[0], e2[1]) : 3 === t2 ? String.fromCharCode(e2[0], e2[1], e2[2], e2[3]) : String.fromCharCode(...e2.subarray(0, t2 + 1));
}
function addHex(e2, t2, i2) {
  let a2 = 0;
  for (let s2 = i2; s2 >= 0; s2--) {
    a2 += e2[s2] + t2[s2];
    e2[s2] = 255 & a2;
    a2 >>= 8;
  }
}
function incHex(e2, t2) {
  let i2 = 1;
  for (let a2 = t2; a2 >= 0 && i2 > 0; a2--) {
    i2 += e2[a2];
    e2[a2] = 255 & i2;
    i2 >>= 8;
  }
}
var Gt = 16;
var BinaryCMapStream = class {
  constructor(e2) {
    this.buffer = e2;
    this.pos = 0;
    this.end = e2.length;
    this.tmpBuf = new Uint8Array(19);
  }
  readByte() {
    return this.pos >= this.end ? -1 : this.buffer[this.pos++];
  }
  readNumber() {
    let e2, t2 = 0;
    do {
      const i2 = this.readByte();
      if (i2 < 0)
        throw new FormatError("unexpected EOF in bcmap");
      e2 = !(128 & i2);
      t2 = t2 << 7 | 127 & i2;
    } while (!e2);
    return t2;
  }
  readSigned() {
    const e2 = this.readNumber();
    return 1 & e2 ? ~(e2 >>> 1) : e2 >>> 1;
  }
  readHex(e2, t2) {
    e2.set(this.buffer.subarray(this.pos, this.pos + t2 + 1));
    this.pos += t2 + 1;
  }
  readHexNumber(e2, t2) {
    let i2;
    const a2 = this.tmpBuf;
    let s2 = 0;
    do {
      const e3 = this.readByte();
      if (e3 < 0)
        throw new FormatError("unexpected EOF in bcmap");
      i2 = !(128 & e3);
      a2[s2++] = 127 & e3;
    } while (!i2);
    let r2 = t2, n2 = 0, g2 = 0;
    for (; r2 >= 0; ) {
      for (; g2 < 8 && a2.length > 0; ) {
        n2 |= a2[--s2] << g2;
        g2 += 7;
      }
      e2[r2] = 255 & n2;
      r2--;
      n2 >>= 8;
      g2 -= 8;
    }
  }
  readHexSigned(e2, t2) {
    this.readHexNumber(e2, t2);
    const i2 = 1 & e2[t2] ? 255 : 0;
    let a2 = 0;
    for (let s2 = 0; s2 <= t2; s2++) {
      a2 = (1 & a2) << 8 | e2[s2];
      e2[s2] = a2 >> 1 ^ i2;
    }
  }
  readString() {
    const e2 = this.readNumber(), t2 = new Array(e2);
    for (let i2 = 0; i2 < e2; i2++)
      t2[i2] = this.readNumber();
    return String.fromCharCode(...t2);
  }
};
var BinaryCMapReader = class {
  async process(e2, t2, i2) {
    const a2 = new BinaryCMapStream(e2), s2 = a2.readByte();
    t2.vertical = !!(1 & s2);
    let r2 = null;
    const n2 = new Uint8Array(Gt), g2 = new Uint8Array(Gt), o2 = new Uint8Array(Gt), c2 = new Uint8Array(Gt), C2 = new Uint8Array(Gt);
    let h2, l2;
    for (; (l2 = a2.readByte()) >= 0; ) {
      const e3 = l2 >> 5;
      if (7 === e3) {
        switch (31 & l2) {
          case 0:
            a2.readString();
            break;
          case 1:
            r2 = a2.readString();
        }
        continue;
      }
      const i3 = !!(16 & l2), s3 = 15 & l2;
      if (s3 + 1 > Gt)
        throw new Error("BinaryCMapReader.process: Invalid dataSize.");
      const Q2 = 1, E2 = a2.readNumber();
      switch (e3) {
        case 0:
          a2.readHex(n2, s3);
          a2.readHexNumber(g2, s3);
          addHex(g2, n2, s3);
          t2.addCodespaceRange(s3 + 1, hexToInt(n2, s3), hexToInt(g2, s3));
          for (let e4 = 1; e4 < E2; e4++) {
            incHex(g2, s3);
            a2.readHexNumber(n2, s3);
            addHex(n2, g2, s3);
            a2.readHexNumber(g2, s3);
            addHex(g2, n2, s3);
            t2.addCodespaceRange(s3 + 1, hexToInt(n2, s3), hexToInt(g2, s3));
          }
          break;
        case 1:
          a2.readHex(n2, s3);
          a2.readHexNumber(g2, s3);
          addHex(g2, n2, s3);
          a2.readNumber();
          for (let e4 = 1; e4 < E2; e4++) {
            incHex(g2, s3);
            a2.readHexNumber(n2, s3);
            addHex(n2, g2, s3);
            a2.readHexNumber(g2, s3);
            addHex(g2, n2, s3);
            a2.readNumber();
          }
          break;
        case 2:
          a2.readHex(o2, s3);
          h2 = a2.readNumber();
          t2.mapOne(hexToInt(o2, s3), h2);
          for (let e4 = 1; e4 < E2; e4++) {
            incHex(o2, s3);
            if (!i3) {
              a2.readHexNumber(C2, s3);
              addHex(o2, C2, s3);
            }
            h2 = a2.readSigned() + (h2 + 1);
            t2.mapOne(hexToInt(o2, s3), h2);
          }
          break;
        case 3:
          a2.readHex(n2, s3);
          a2.readHexNumber(g2, s3);
          addHex(g2, n2, s3);
          h2 = a2.readNumber();
          t2.mapCidRange(hexToInt(n2, s3), hexToInt(g2, s3), h2);
          for (let e4 = 1; e4 < E2; e4++) {
            incHex(g2, s3);
            if (i3)
              n2.set(g2);
            else {
              a2.readHexNumber(n2, s3);
              addHex(n2, g2, s3);
            }
            a2.readHexNumber(g2, s3);
            addHex(g2, n2, s3);
            h2 = a2.readNumber();
            t2.mapCidRange(hexToInt(n2, s3), hexToInt(g2, s3), h2);
          }
          break;
        case 4:
          a2.readHex(o2, Q2);
          a2.readHex(c2, s3);
          t2.mapOne(hexToInt(o2, Q2), hexToStr(c2, s3));
          for (let e4 = 1; e4 < E2; e4++) {
            incHex(o2, Q2);
            if (!i3) {
              a2.readHexNumber(C2, Q2);
              addHex(o2, C2, Q2);
            }
            incHex(c2, s3);
            a2.readHexSigned(C2, s3);
            addHex(c2, C2, s3);
            t2.mapOne(hexToInt(o2, Q2), hexToStr(c2, s3));
          }
          break;
        case 5:
          a2.readHex(n2, Q2);
          a2.readHexNumber(g2, Q2);
          addHex(g2, n2, Q2);
          a2.readHex(c2, s3);
          t2.mapBfRange(hexToInt(n2, Q2), hexToInt(g2, Q2), hexToStr(c2, s3));
          for (let e4 = 1; e4 < E2; e4++) {
            incHex(g2, Q2);
            if (i3)
              n2.set(g2);
            else {
              a2.readHexNumber(n2, Q2);
              addHex(n2, g2, Q2);
            }
            a2.readHexNumber(g2, Q2);
            addHex(g2, n2, Q2);
            a2.readHex(c2, s3);
            t2.mapBfRange(hexToInt(n2, Q2), hexToInt(g2, Q2), hexToStr(c2, s3));
          }
          break;
        default:
          throw new Error(`BinaryCMapReader.process - unknown type: ${e3}`);
      }
    }
    return r2 ? i2(r2) : t2;
  }
};
var xt = new Uint8Array(0);
var DecodeStream = class extends BaseStream {
  constructor(e2) {
    super();
    this._rawMinBufferLength = e2 || 0;
    this.pos = 0;
    this.bufferLength = 0;
    this.eof = false;
    this.buffer = xt;
    this.minBufferLength = 512;
    if (e2)
      for (; this.minBufferLength < e2; )
        this.minBufferLength *= 2;
  }
  get isEmpty() {
    for (; !this.eof && 0 === this.bufferLength; )
      this.readBlock();
    return 0 === this.bufferLength;
  }
  ensureBuffer(e2) {
    const t2 = this.buffer;
    if (e2 <= t2.byteLength)
      return t2;
    let i2 = this.minBufferLength;
    for (; i2 < e2; )
      i2 *= 2;
    const a2 = new Uint8Array(i2);
    a2.set(t2);
    return this.buffer = a2;
  }
  getByte() {
    const e2 = this.pos;
    for (; this.bufferLength <= e2; ) {
      if (this.eof)
        return -1;
      this.readBlock();
    }
    return this.buffer[this.pos++];
  }
  getBytes(e2, t2 = null) {
    const i2 = this.pos;
    let a2;
    if (e2) {
      this.ensureBuffer(i2 + e2);
      a2 = i2 + e2;
      for (; !this.eof && this.bufferLength < a2; )
        this.readBlock(t2);
      const s2 = this.bufferLength;
      a2 > s2 && (a2 = s2);
    } else {
      for (; !this.eof; )
        this.readBlock(t2);
      a2 = this.bufferLength;
    }
    this.pos = a2;
    return this.buffer.subarray(i2, a2);
  }
  async getImageData(e2, t2 = null) {
    if (!this.canAsyncDecodeImageFromBuffer)
      return this.getBytes(e2, t2);
    const i2 = await this.stream.asyncGetBytes();
    return this.decodeImage(i2, t2);
  }
  reset() {
    this.pos = 0;
  }
  makeSubStream(e2, t2, i2 = null) {
    if (void 0 === t2)
      for (; !this.eof; )
        this.readBlock();
    else {
      const i3 = e2 + t2;
      for (; this.bufferLength <= i3 && !this.eof; )
        this.readBlock();
    }
    return new Stream(this.buffer, e2, t2, i2);
  }
  getBaseStreams() {
    return this.str ? this.str.getBaseStreams() : null;
  }
};
var StreamsSequenceStream = class extends DecodeStream {
  constructor(e2, t2 = null) {
    let i2 = 0;
    for (const t3 of e2)
      i2 += t3 instanceof DecodeStream ? t3._rawMinBufferLength : t3.length;
    super(i2);
    this.streams = e2;
    this._onError = t2;
  }
  readBlock() {
    var _a4;
    const e2 = this.streams;
    if (0 === e2.length) {
      this.eof = true;
      return;
    }
    const t2 = e2.shift();
    let i2;
    try {
      i2 = t2.getBytes();
    } catch (e3) {
      if (this._onError) {
        this._onError(e3, (_a4 = t2.dict) == null ? void 0 : _a4.objId);
        return;
      }
      throw e3;
    }
    const a2 = this.bufferLength, s2 = a2 + i2.length;
    this.ensureBuffer(s2).set(i2, a2);
    this.bufferLength = s2;
  }
  getBaseStreams() {
    const e2 = [];
    for (const t2 of this.streams) {
      const i2 = t2.getBaseStreams();
      i2 && e2.push(...i2);
    }
    return e2.length > 0 ? e2 : null;
  }
};
var Ascii85Stream = class extends DecodeStream {
  constructor(e2, t2) {
    t2 && (t2 *= 0.8);
    super(t2);
    this.str = e2;
    this.dict = e2.dict;
    this.input = new Uint8Array(5);
  }
  readBlock() {
    const e2 = this.str;
    let t2 = e2.getByte();
    for (; isWhiteSpace(t2); )
      t2 = e2.getByte();
    if (-1 === t2 || 126 === t2) {
      this.eof = true;
      return;
    }
    const i2 = this.bufferLength;
    let a2, s2;
    if (122 === t2) {
      a2 = this.ensureBuffer(i2 + 4);
      for (s2 = 0; s2 < 4; ++s2)
        a2[i2 + s2] = 0;
      this.bufferLength += 4;
    } else {
      const r2 = this.input;
      r2[0] = t2;
      for (s2 = 1; s2 < 5; ++s2) {
        t2 = e2.getByte();
        for (; isWhiteSpace(t2); )
          t2 = e2.getByte();
        r2[s2] = t2;
        if (-1 === t2 || 126 === t2)
          break;
      }
      a2 = this.ensureBuffer(i2 + s2 - 1);
      this.bufferLength += s2 - 1;
      if (s2 < 5) {
        for (; s2 < 5; ++s2)
          r2[s2] = 117;
        this.eof = true;
      }
      let n2 = 0;
      for (s2 = 0; s2 < 5; ++s2)
        n2 = 85 * n2 + (r2[s2] - 33);
      for (s2 = 3; s2 >= 0; --s2) {
        a2[i2 + s2] = 255 & n2;
        n2 >>= 8;
      }
    }
  }
};
var AsciiHexStream = class extends DecodeStream {
  constructor(e2, t2) {
    t2 && (t2 *= 0.5);
    super(t2);
    this.str = e2;
    this.dict = e2.dict;
    this.firstDigit = -1;
  }
  readBlock() {
    const e2 = this.str.getBytes(8e3);
    if (!e2.length) {
      this.eof = true;
      return;
    }
    const t2 = e2.length + 1 >> 1, i2 = this.ensureBuffer(this.bufferLength + t2);
    let a2 = this.bufferLength, s2 = this.firstDigit;
    for (const t3 of e2) {
      let e3;
      if (t3 >= 48 && t3 <= 57)
        e3 = 15 & t3;
      else {
        if (!(t3 >= 65 && t3 <= 70 || t3 >= 97 && t3 <= 102)) {
          if (62 === t3) {
            this.eof = true;
            break;
          }
          continue;
        }
        e3 = 9 + (15 & t3);
      }
      if (s2 < 0)
        s2 = e3;
      else {
        i2[a2++] = s2 << 4 | e3;
        s2 = -1;
      }
    }
    if (s2 >= 0 && this.eof) {
      i2[a2++] = s2 << 4;
      s2 = -1;
    }
    this.firstDigit = s2;
    this.bufferLength = a2;
  }
};
var Ut = -1;
var Mt = [[-1, -1], [-1, -1], [7, 8], [7, 7], [6, 6], [6, 6], [6, 5], [6, 5], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]];
var Lt = [[-1, -1], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
var Ht = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
var Jt = [[-1, -1], [-1, -1], [12, -2], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
var Yt = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
var vt = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
var CCITTFaxDecoder = class {
  constructor(e2, t2 = {}) {
    if (!e2 || "function" != typeof e2.next)
      throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
    this.source = e2;
    this.eof = false;
    this.encoding = t2.K || 0;
    this.eoline = t2.EndOfLine || false;
    this.byteAlign = t2.EncodedByteAlign || false;
    this.columns = t2.Columns || 1728;
    this.rows = t2.Rows || 0;
    this.eoblock = t2.EndOfBlock ?? true;
    this.black = t2.BlackIs1 || false;
    this.codingLine = new Uint32Array(this.columns + 1);
    this.refLine = new Uint32Array(this.columns + 2);
    this.codingLine[0] = this.columns;
    this.codingPos = 0;
    this.row = 0;
    this.nextLine2D = this.encoding < 0;
    this.inputBits = 0;
    this.inputBuf = 0;
    this.outputBits = 0;
    this.rowsDone = false;
    let i2;
    for (; 0 === (i2 = this._lookBits(12)); )
      this._eatBits(1);
    1 === i2 && this._eatBits(12);
    if (this.encoding > 0) {
      this.nextLine2D = !this._lookBits(1);
      this._eatBits(1);
    }
  }
  readNextChar() {
    if (this.eof)
      return -1;
    const e2 = this.refLine, t2 = this.codingLine, i2 = this.columns;
    let a2, s2, r2, n2, g2;
    if (0 === this.outputBits) {
      this.rowsDone && (this.eof = true);
      if (this.eof)
        return -1;
      this.err = false;
      let r3, g3, o2;
      if (this.nextLine2D) {
        for (n2 = 0; t2[n2] < i2; ++n2)
          e2[n2] = t2[n2];
        e2[n2++] = i2;
        e2[n2] = i2;
        t2[0] = 0;
        this.codingPos = 0;
        a2 = 0;
        s2 = 0;
        for (; t2[this.codingPos] < i2; ) {
          r3 = this._getTwoDimCode();
          switch (r3) {
            case 0:
              this._addPixels(e2[a2 + 1], s2);
              e2[a2 + 1] < i2 && (a2 += 2);
              break;
            case 1:
              r3 = g3 = 0;
              if (s2) {
                do {
                  r3 += o2 = this._getBlackCode();
                } while (o2 >= 64);
                do {
                  g3 += o2 = this._getWhiteCode();
                } while (o2 >= 64);
              } else {
                do {
                  r3 += o2 = this._getWhiteCode();
                } while (o2 >= 64);
                do {
                  g3 += o2 = this._getBlackCode();
                } while (o2 >= 64);
              }
              this._addPixels(t2[this.codingPos] + r3, s2);
              t2[this.codingPos] < i2 && this._addPixels(t2[this.codingPos] + g3, 1 ^ s2);
              for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                a2 += 2;
              break;
            case 7:
              this._addPixels(e2[a2] + 3, s2);
              s2 ^= 1;
              if (t2[this.codingPos] < i2) {
                ++a2;
                for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                  a2 += 2;
              }
              break;
            case 5:
              this._addPixels(e2[a2] + 2, s2);
              s2 ^= 1;
              if (t2[this.codingPos] < i2) {
                ++a2;
                for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                  a2 += 2;
              }
              break;
            case 3:
              this._addPixels(e2[a2] + 1, s2);
              s2 ^= 1;
              if (t2[this.codingPos] < i2) {
                ++a2;
                for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                  a2 += 2;
              }
              break;
            case 2:
              this._addPixels(e2[a2], s2);
              s2 ^= 1;
              if (t2[this.codingPos] < i2) {
                ++a2;
                for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                  a2 += 2;
              }
              break;
            case 8:
              this._addPixelsNeg(e2[a2] - 3, s2);
              s2 ^= 1;
              if (t2[this.codingPos] < i2) {
                a2 > 0 ? --a2 : ++a2;
                for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                  a2 += 2;
              }
              break;
            case 6:
              this._addPixelsNeg(e2[a2] - 2, s2);
              s2 ^= 1;
              if (t2[this.codingPos] < i2) {
                a2 > 0 ? --a2 : ++a2;
                for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                  a2 += 2;
              }
              break;
            case 4:
              this._addPixelsNeg(e2[a2] - 1, s2);
              s2 ^= 1;
              if (t2[this.codingPos] < i2) {
                a2 > 0 ? --a2 : ++a2;
                for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                  a2 += 2;
              }
              break;
            case Ut:
              this._addPixels(i2, 0);
              this.eof = true;
              break;
            default:
              info("bad 2d code");
              this._addPixels(i2, 0);
              this.err = true;
          }
        }
      } else {
        t2[0] = 0;
        this.codingPos = 0;
        s2 = 0;
        for (; t2[this.codingPos] < i2; ) {
          r3 = 0;
          if (s2)
            do {
              r3 += o2 = this._getBlackCode();
            } while (o2 >= 64);
          else
            do {
              r3 += o2 = this._getWhiteCode();
            } while (o2 >= 64);
          this._addPixels(t2[this.codingPos] + r3, s2);
          s2 ^= 1;
        }
      }
      let c2 = false;
      this.byteAlign && (this.inputBits &= -8);
      if (this.eoblock || this.row !== this.rows - 1) {
        r3 = this._lookBits(12);
        if (this.eoline)
          for (; r3 !== Ut && 1 !== r3; ) {
            this._eatBits(1);
            r3 = this._lookBits(12);
          }
        else
          for (; 0 === r3; ) {
            this._eatBits(1);
            r3 = this._lookBits(12);
          }
        if (1 === r3) {
          this._eatBits(12);
          c2 = true;
        } else
          r3 === Ut && (this.eof = true);
      } else
        this.rowsDone = true;
      if (!this.eof && this.encoding > 0 && !this.rowsDone) {
        this.nextLine2D = !this._lookBits(1);
        this._eatBits(1);
      }
      if (this.eoblock && c2 && this.byteAlign) {
        r3 = this._lookBits(12);
        if (1 === r3) {
          this._eatBits(12);
          if (this.encoding > 0) {
            this._lookBits(1);
            this._eatBits(1);
          }
          if (this.encoding >= 0)
            for (n2 = 0; n2 < 4; ++n2) {
              r3 = this._lookBits(12);
              1 !== r3 && info("bad rtc code: " + r3);
              this._eatBits(12);
              if (this.encoding > 0) {
                this._lookBits(1);
                this._eatBits(1);
              }
            }
          this.eof = true;
        }
      } else if (this.err && this.eoline) {
        for (; ; ) {
          r3 = this._lookBits(13);
          if (r3 === Ut) {
            this.eof = true;
            return -1;
          }
          if (r3 >> 1 == 1)
            break;
          this._eatBits(1);
        }
        this._eatBits(12);
        if (this.encoding > 0) {
          this._eatBits(1);
          this.nextLine2D = !(1 & r3);
        }
      }
      this.outputBits = t2[0] > 0 ? t2[this.codingPos = 0] : t2[this.codingPos = 1];
      this.row++;
    }
    if (this.outputBits >= 8) {
      g2 = 1 & this.codingPos ? 0 : 255;
      this.outputBits -= 8;
      if (0 === this.outputBits && t2[this.codingPos] < i2) {
        this.codingPos++;
        this.outputBits = t2[this.codingPos] - t2[this.codingPos - 1];
      }
    } else {
      r2 = 8;
      g2 = 0;
      do {
        if ("number" != typeof this.outputBits)
          throw new FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
        if (this.outputBits > r2) {
          g2 <<= r2;
          1 & this.codingPos || (g2 |= 255 >> 8 - r2);
          this.outputBits -= r2;
          r2 = 0;
        } else {
          g2 <<= this.outputBits;
          1 & this.codingPos || (g2 |= 255 >> 8 - this.outputBits);
          r2 -= this.outputBits;
          this.outputBits = 0;
          if (t2[this.codingPos] < i2) {
            this.codingPos++;
            this.outputBits = t2[this.codingPos] - t2[this.codingPos - 1];
          } else if (r2 > 0) {
            g2 <<= r2;
            r2 = 0;
          }
        }
      } while (r2);
    }
    this.black && (g2 ^= 255);
    return g2;
  }
  _addPixels(e2, t2) {
    const i2 = this.codingLine;
    let a2 = this.codingPos;
    if (e2 > i2[a2]) {
      if (e2 > this.columns) {
        info("row is wrong length");
        this.err = true;
        e2 = this.columns;
      }
      1 & a2 ^ t2 && ++a2;
      i2[a2] = e2;
    }
    this.codingPos = a2;
  }
  _addPixelsNeg(e2, t2) {
    const i2 = this.codingLine;
    let a2 = this.codingPos;
    if (e2 > i2[a2]) {
      if (e2 > this.columns) {
        info("row is wrong length");
        this.err = true;
        e2 = this.columns;
      }
      1 & a2 ^ t2 && ++a2;
      i2[a2] = e2;
    } else if (e2 < i2[a2]) {
      if (e2 < 0) {
        info("invalid code");
        this.err = true;
        e2 = 0;
      }
      for (; a2 > 0 && e2 < i2[a2 - 1]; )
        --a2;
      i2[a2] = e2;
    }
    this.codingPos = a2;
  }
  _findTableCode(e2, t2, i2, a2) {
    const s2 = a2 || 0;
    for (let a3 = e2; a3 <= t2; ++a3) {
      let e3 = this._lookBits(a3);
      if (e3 === Ut)
        return [true, 1, false];
      a3 < t2 && (e3 <<= t2 - a3);
      if (!s2 || e3 >= s2) {
        const t3 = i2[e3 - s2];
        if (t3[0] === a3) {
          this._eatBits(a3);
          return [true, t3[1], true];
        }
      }
    }
    return [false, 0, false];
  }
  _getTwoDimCode() {
    let e2, t2 = 0;
    if (this.eoblock) {
      t2 = this._lookBits(7);
      e2 = Mt[t2];
      if ((e2 == null ? void 0 : e2[0]) > 0) {
        this._eatBits(e2[0]);
        return e2[1];
      }
    } else {
      const e3 = this._findTableCode(1, 7, Mt);
      if (e3[0] && e3[2])
        return e3[1];
    }
    info("Bad two dim code");
    return Ut;
  }
  _getWhiteCode() {
    let e2, t2 = 0;
    if (this.eoblock) {
      t2 = this._lookBits(12);
      if (t2 === Ut)
        return 1;
      e2 = t2 >> 5 == 0 ? Lt[t2] : Ht[t2 >> 3];
      if (e2[0] > 0) {
        this._eatBits(e2[0]);
        return e2[1];
      }
    } else {
      let e3 = this._findTableCode(1, 9, Ht);
      if (e3[0])
        return e3[1];
      e3 = this._findTableCode(11, 12, Lt);
      if (e3[0])
        return e3[1];
    }
    info("bad white code");
    this._eatBits(1);
    return 1;
  }
  _getBlackCode() {
    let e2, t2;
    if (this.eoblock) {
      e2 = this._lookBits(13);
      if (e2 === Ut)
        return 1;
      t2 = e2 >> 7 == 0 ? Jt[e2] : e2 >> 9 == 0 && e2 >> 7 != 0 ? Yt[(e2 >> 1) - 64] : vt[e2 >> 7];
      if (t2[0] > 0) {
        this._eatBits(t2[0]);
        return t2[1];
      }
    } else {
      let e3 = this._findTableCode(2, 6, vt);
      if (e3[0])
        return e3[1];
      e3 = this._findTableCode(7, 12, Yt, 64);
      if (e3[0])
        return e3[1];
      e3 = this._findTableCode(10, 13, Jt);
      if (e3[0])
        return e3[1];
    }
    info("bad black code");
    this._eatBits(1);
    return 1;
  }
  _lookBits(e2) {
    let t2;
    for (; this.inputBits < e2; ) {
      if (-1 === (t2 = this.source.next()))
        return 0 === this.inputBits ? Ut : this.inputBuf << e2 - this.inputBits & 65535 >> 16 - e2;
      this.inputBuf = this.inputBuf << 8 | t2;
      this.inputBits += 8;
    }
    return this.inputBuf >> this.inputBits - e2 & 65535 >> 16 - e2;
  }
  _eatBits(e2) {
    (this.inputBits -= e2) < 0 && (this.inputBits = 0);
  }
};
var CCITTFaxStream = class extends DecodeStream {
  constructor(e2, t2, i2) {
    super(t2);
    this.str = e2;
    this.dict = e2.dict;
    i2 instanceof Dict || (i2 = Dict.empty);
    const a2 = { next: () => e2.getByte() };
    this.ccittFaxDecoder = new CCITTFaxDecoder(a2, { K: i2.get("K"), EndOfLine: i2.get("EndOfLine"), EncodedByteAlign: i2.get("EncodedByteAlign"), Columns: i2.get("Columns"), Rows: i2.get("Rows"), EndOfBlock: i2.get("EndOfBlock"), BlackIs1: i2.get("BlackIs1") });
  }
  readBlock() {
    for (; !this.eof; ) {
      const e2 = this.ccittFaxDecoder.readNextChar();
      if (-1 === e2) {
        this.eof = true;
        return;
      }
      this.ensureBuffer(this.bufferLength + 1);
      this.buffer[this.bufferLength++] = e2;
    }
  }
};
var Kt = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var Tt = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
var qt = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
var Ot = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
var Pt = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
var _m, m_fn;
var FlateStream = class extends DecodeStream {
  constructor(e2, t2) {
    super(t2);
    __privateAdd(this, _m);
    this.str = e2;
    this.dict = e2.dict;
    const i2 = e2.getByte(), a2 = e2.getByte();
    if (-1 === i2 || -1 === a2)
      throw new FormatError(`Invalid header in flate stream: ${i2}, ${a2}`);
    if (8 != (15 & i2))
      throw new FormatError(`Unknown compression method in flate stream: ${i2}, ${a2}`);
    if (((i2 << 8) + a2) % 31 != 0)
      throw new FormatError(`Bad FCHECK in flate stream: ${i2}, ${a2}`);
    if (32 & a2)
      throw new FormatError(`FDICT bit set in flate stream: ${i2}, ${a2}`);
    this.codeSize = 0;
    this.codeBuf = 0;
  }
  async getImageData(e2, t2) {
    const i2 = await this.asyncGetBytes();
    return (i2 == null ? void 0 : i2.subarray(0, e2)) || this.getBytes(e2);
  }
  async asyncGetBytes() {
    this.str.reset();
    const e2 = this.str.getBytes();
    try {
      const { readable: t2, writable: i2 } = new DecompressionStream("deflate"), a2 = i2.getWriter();
      a2.write(e2);
      a2.close();
      const s2 = [];
      let r2 = 0;
      for await (const e3 of t2) {
        s2.push(e3);
        r2 += e3.byteLength;
      }
      const n2 = new Uint8Array(r2);
      let g2 = 0;
      for (const e3 of s2) {
        n2.set(e3, g2);
        g2 += e3.byteLength;
      }
      return n2;
    } catch {
      this.str = new Stream(e2, 2, e2.length, this.str.dict);
      this.reset();
      return null;
    }
  }
  get isAsync() {
    return true;
  }
  getBits(e2) {
    const t2 = this.str;
    let i2, a2 = this.codeSize, s2 = this.codeBuf;
    for (; a2 < e2; ) {
      if (-1 === (i2 = t2.getByte()))
        throw new FormatError("Bad encoding in flate stream");
      s2 |= i2 << a2;
      a2 += 8;
    }
    i2 = s2 & (1 << e2) - 1;
    this.codeBuf = s2 >> e2;
    this.codeSize = a2 -= e2;
    return i2;
  }
  getCode(e2) {
    const t2 = this.str, i2 = e2[0], a2 = e2[1];
    let s2, r2 = this.codeSize, n2 = this.codeBuf;
    for (; r2 < a2 && -1 !== (s2 = t2.getByte()); ) {
      n2 |= s2 << r2;
      r2 += 8;
    }
    const g2 = i2[n2 & (1 << a2) - 1], o2 = g2 >> 16, c2 = 65535 & g2;
    if (o2 < 1 || r2 < o2)
      throw new FormatError("Bad encoding in flate stream");
    this.codeBuf = n2 >> o2;
    this.codeSize = r2 - o2;
    return c2;
  }
  generateHuffmanTable(e2) {
    const t2 = e2.length;
    let i2, a2 = 0;
    for (i2 = 0; i2 < t2; ++i2)
      e2[i2] > a2 && (a2 = e2[i2]);
    const s2 = 1 << a2, r2 = new Int32Array(s2);
    for (let n2 = 1, g2 = 0, o2 = 2; n2 <= a2; ++n2, g2 <<= 1, o2 <<= 1)
      for (let a3 = 0; a3 < t2; ++a3)
        if (e2[a3] === n2) {
          let e3 = 0, t3 = g2;
          for (i2 = 0; i2 < n2; ++i2) {
            e3 = e3 << 1 | 1 & t3;
            t3 >>= 1;
          }
          for (i2 = e3; i2 < s2; i2 += o2)
            r2[i2] = n2 << 16 | a3;
          ++g2;
        }
    return [r2, a2];
  }
  readBlock() {
    let e2, t2, i2;
    const a2 = this.str;
    try {
      t2 = this.getBits(3);
    } catch (e3) {
      __privateMethod(this, _m, m_fn).call(this, e3.message);
      return;
    }
    1 & t2 && (this.eof = true);
    t2 >>= 1;
    if (0 === t2) {
      let t3;
      if (-1 === (t3 = a2.getByte())) {
        __privateMethod(this, _m, m_fn).call(this, "Bad block header in flate stream");
        return;
      }
      let i3 = t3;
      if (-1 === (t3 = a2.getByte())) {
        __privateMethod(this, _m, m_fn).call(this, "Bad block header in flate stream");
        return;
      }
      i3 |= t3 << 8;
      if (-1 === (t3 = a2.getByte())) {
        __privateMethod(this, _m, m_fn).call(this, "Bad block header in flate stream");
        return;
      }
      let s3 = t3;
      if (-1 === (t3 = a2.getByte())) {
        __privateMethod(this, _m, m_fn).call(this, "Bad block header in flate stream");
        return;
      }
      s3 |= t3 << 8;
      if (s3 !== (65535 & ~i3) && (0 !== i3 || 0 !== s3))
        throw new FormatError("Bad uncompressed block length in flate stream");
      this.codeBuf = 0;
      this.codeSize = 0;
      const r3 = this.bufferLength, n3 = r3 + i3;
      e2 = this.ensureBuffer(n3);
      this.bufferLength = n3;
      if (0 === i3)
        -1 === a2.peekByte() && (this.eof = true);
      else {
        const t4 = a2.getBytes(i3);
        e2.set(t4, r3);
        t4.length < i3 && (this.eof = true);
      }
      return;
    }
    let s2, r2;
    if (1 === t2) {
      s2 = Ot;
      r2 = Pt;
    } else {
      if (2 !== t2)
        throw new FormatError("Unknown block type in flate stream");
      {
        const e3 = this.getBits(5) + 257, t3 = this.getBits(5) + 1, a3 = this.getBits(4) + 4, n3 = new Uint8Array(Kt.length);
        let g3;
        for (g3 = 0; g3 < a3; ++g3)
          n3[Kt[g3]] = this.getBits(3);
        const o2 = this.generateHuffmanTable(n3);
        i2 = 0;
        g3 = 0;
        const c2 = e3 + t3, C2 = new Uint8Array(c2);
        let h2, l2, Q2;
        for (; g3 < c2; ) {
          const e4 = this.getCode(o2);
          if (16 === e4) {
            h2 = 2;
            l2 = 3;
            Q2 = i2;
          } else if (17 === e4) {
            h2 = 3;
            l2 = 3;
            Q2 = i2 = 0;
          } else {
            if (18 !== e4) {
              C2[g3++] = i2 = e4;
              continue;
            }
            h2 = 7;
            l2 = 11;
            Q2 = i2 = 0;
          }
          let t4 = this.getBits(h2) + l2;
          for (; t4-- > 0; )
            C2[g3++] = Q2;
        }
        s2 = this.generateHuffmanTable(C2.subarray(0, e3));
        r2 = this.generateHuffmanTable(C2.subarray(e3, c2));
      }
    }
    e2 = this.buffer;
    let n2 = e2 ? e2.length : 0, g2 = this.bufferLength;
    for (; ; ) {
      let t3 = this.getCode(s2);
      if (t3 < 256) {
        if (g2 + 1 >= n2) {
          e2 = this.ensureBuffer(g2 + 1);
          n2 = e2.length;
        }
        e2[g2++] = t3;
        continue;
      }
      if (256 === t3) {
        this.bufferLength = g2;
        return;
      }
      t3 -= 257;
      t3 = Tt[t3];
      let a3 = t3 >> 16;
      a3 > 0 && (a3 = this.getBits(a3));
      i2 = (65535 & t3) + a3;
      t3 = this.getCode(r2);
      t3 = qt[t3];
      a3 = t3 >> 16;
      a3 > 0 && (a3 = this.getBits(a3));
      const o2 = (65535 & t3) + a3;
      if (g2 + i2 >= n2) {
        e2 = this.ensureBuffer(g2 + i2);
        n2 = e2.length;
      }
      for (let t4 = 0; t4 < i2; ++t4, ++g2)
        e2[g2] = e2[g2 - o2];
    }
  }
};
_m = new WeakSet();
m_fn = function(e2) {
  info(e2);
  this.eof = true;
};
var Wt = [{ qe: 22017, nmps: 1, nlps: 1, switchFlag: 1 }, { qe: 13313, nmps: 2, nlps: 6, switchFlag: 0 }, { qe: 6145, nmps: 3, nlps: 9, switchFlag: 0 }, { qe: 2753, nmps: 4, nlps: 12, switchFlag: 0 }, { qe: 1313, nmps: 5, nlps: 29, switchFlag: 0 }, { qe: 545, nmps: 38, nlps: 33, switchFlag: 0 }, { qe: 22017, nmps: 7, nlps: 6, switchFlag: 1 }, { qe: 21505, nmps: 8, nlps: 14, switchFlag: 0 }, { qe: 18433, nmps: 9, nlps: 14, switchFlag: 0 }, { qe: 14337, nmps: 10, nlps: 14, switchFlag: 0 }, { qe: 12289, nmps: 11, nlps: 17, switchFlag: 0 }, { qe: 9217, nmps: 12, nlps: 18, switchFlag: 0 }, { qe: 7169, nmps: 13, nlps: 20, switchFlag: 0 }, { qe: 5633, nmps: 29, nlps: 21, switchFlag: 0 }, { qe: 22017, nmps: 15, nlps: 14, switchFlag: 1 }, { qe: 21505, nmps: 16, nlps: 14, switchFlag: 0 }, { qe: 20737, nmps: 17, nlps: 15, switchFlag: 0 }, { qe: 18433, nmps: 18, nlps: 16, switchFlag: 0 }, { qe: 14337, nmps: 19, nlps: 17, switchFlag: 0 }, { qe: 13313, nmps: 20, nlps: 18, switchFlag: 0 }, { qe: 12289, nmps: 21, nlps: 19, switchFlag: 0 }, { qe: 10241, nmps: 22, nlps: 19, switchFlag: 0 }, { qe: 9217, nmps: 23, nlps: 20, switchFlag: 0 }, { qe: 8705, nmps: 24, nlps: 21, switchFlag: 0 }, { qe: 7169, nmps: 25, nlps: 22, switchFlag: 0 }, { qe: 6145, nmps: 26, nlps: 23, switchFlag: 0 }, { qe: 5633, nmps: 27, nlps: 24, switchFlag: 0 }, { qe: 5121, nmps: 28, nlps: 25, switchFlag: 0 }, { qe: 4609, nmps: 29, nlps: 26, switchFlag: 0 }, { qe: 4353, nmps: 30, nlps: 27, switchFlag: 0 }, { qe: 2753, nmps: 31, nlps: 28, switchFlag: 0 }, { qe: 2497, nmps: 32, nlps: 29, switchFlag: 0 }, { qe: 2209, nmps: 33, nlps: 30, switchFlag: 0 }, { qe: 1313, nmps: 34, nlps: 31, switchFlag: 0 }, { qe: 1089, nmps: 35, nlps: 32, switchFlag: 0 }, { qe: 673, nmps: 36, nlps: 33, switchFlag: 0 }, { qe: 545, nmps: 37, nlps: 34, switchFlag: 0 }, { qe: 321, nmps: 38, nlps: 35, switchFlag: 0 }, { qe: 273, nmps: 39, nlps: 36, switchFlag: 0 }, { qe: 133, nmps: 40, nlps: 37, switchFlag: 0 }, { qe: 73, nmps: 41, nlps: 38, switchFlag: 0 }, { qe: 37, nmps: 42, nlps: 39, switchFlag: 0 }, { qe: 21, nmps: 43, nlps: 40, switchFlag: 0 }, { qe: 9, nmps: 44, nlps: 41, switchFlag: 0 }, { qe: 5, nmps: 45, nlps: 42, switchFlag: 0 }, { qe: 1, nmps: 45, nlps: 43, switchFlag: 0 }, { qe: 22017, nmps: 46, nlps: 46, switchFlag: 0 }];
var ArithmeticDecoder = class {
  constructor(e2, t2, i2) {
    this.data = e2;
    this.bp = t2;
    this.dataEnd = i2;
    this.chigh = e2[t2];
    this.clow = 0;
    this.byteIn();
    this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
    this.clow = this.clow << 7 & 65535;
    this.ct -= 7;
    this.a = 32768;
  }
  byteIn() {
    const e2 = this.data;
    let t2 = this.bp;
    if (255 === e2[t2])
      if (e2[t2 + 1] > 143) {
        this.clow += 65280;
        this.ct = 8;
      } else {
        t2++;
        this.clow += e2[t2] << 9;
        this.ct = 7;
        this.bp = t2;
      }
    else {
      t2++;
      this.clow += t2 < this.dataEnd ? e2[t2] << 8 : 65280;
      this.ct = 8;
      this.bp = t2;
    }
    if (this.clow > 65535) {
      this.chigh += this.clow >> 16;
      this.clow &= 65535;
    }
  }
  readBit(e2, t2) {
    let i2 = e2[t2] >> 1, a2 = 1 & e2[t2];
    const s2 = Wt[i2], r2 = s2.qe;
    let n2, g2 = this.a - r2;
    if (this.chigh < r2)
      if (g2 < r2) {
        g2 = r2;
        n2 = a2;
        i2 = s2.nmps;
      } else {
        g2 = r2;
        n2 = 1 ^ a2;
        1 === s2.switchFlag && (a2 = n2);
        i2 = s2.nlps;
      }
    else {
      this.chigh -= r2;
      if (0 != (32768 & g2)) {
        this.a = g2;
        return a2;
      }
      if (g2 < r2) {
        n2 = 1 ^ a2;
        1 === s2.switchFlag && (a2 = n2);
        i2 = s2.nlps;
      } else {
        n2 = a2;
        i2 = s2.nmps;
      }
    }
    do {
      0 === this.ct && this.byteIn();
      g2 <<= 1;
      this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
      this.clow = this.clow << 1 & 65535;
      this.ct--;
    } while (0 == (32768 & g2));
    this.a = g2;
    e2[t2] = i2 << 1 | a2;
    return n2;
  }
};
var Jbig2Error = class extends ot {
  constructor(e2) {
    super(e2, "Jbig2Error");
  }
};
var ContextCache = class {
  getContexts(e2) {
    return e2 in this ? this[e2] : this[e2] = new Int8Array(65536);
  }
};
var DecodingContext = class {
  constructor(e2, t2, i2) {
    this.data = e2;
    this.start = t2;
    this.end = i2;
  }
  get decoder() {
    return shadow(this, "decoder", new ArithmeticDecoder(this.data, this.start, this.end));
  }
  get contextCache() {
    return shadow(this, "contextCache", new ContextCache());
  }
};
var jt = 2 ** 31 - 1;
var Xt = -(2 ** 31);
function decodeInteger(e2, t2, i2) {
  const a2 = e2.getContexts(t2);
  let s2 = 1;
  function readBits(e3) {
    let t3 = 0;
    for (let r3 = 0; r3 < e3; r3++) {
      const e4 = i2.readBit(a2, s2);
      s2 = s2 < 256 ? s2 << 1 | e4 : 511 & (s2 << 1 | e4) | 256;
      t3 = t3 << 1 | e4;
    }
    return t3 >>> 0;
  }
  const r2 = readBits(1), n2 = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
  let g2;
  0 === r2 ? g2 = n2 : n2 > 0 && (g2 = -n2);
  return g2 >= Xt && g2 <= jt ? g2 : null;
}
function decodeIAID(e2, t2, i2) {
  const a2 = e2.getContexts("IAID");
  let s2 = 1;
  for (let e3 = 0; e3 < i2; e3++) {
    s2 = s2 << 1 | t2.readBit(a2, s2);
  }
  return i2 < 31 ? s2 & (1 << i2) - 1 : 2147483647 & s2;
}
var Zt = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
var Vt = [[{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: 2, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -3, y: -1 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }]];
var zt = [{ coding: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }, { coding: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }];
var _t5 = [39717, 1941, 229, 405];
var $t = [32, 8];
function decodeBitmap(e2, t2, i2, a2, s2, r2, n2, g2) {
  if (e2) {
    return decodeMMRBitmap(new Reader(g2.data, g2.start, g2.end), t2, i2, false);
  }
  if (0 === a2 && !r2 && !s2 && 4 === n2.length && 3 === n2[0].x && -1 === n2[0].y && -3 === n2[1].x && -1 === n2[1].y && 2 === n2[2].x && -2 === n2[2].y && -2 === n2[3].x && -2 === n2[3].y)
    return function decodeBitmapTemplate0(e3, t3, i3) {
      const a3 = i3.decoder, s3 = i3.contextCache.getContexts("GB"), r3 = [];
      let n3, g3, o3, c3, C3, h3, l3;
      for (g3 = 0; g3 < t3; g3++) {
        C3 = r3[g3] = new Uint8Array(e3);
        h3 = g3 < 1 ? C3 : r3[g3 - 1];
        l3 = g3 < 2 ? C3 : r3[g3 - 2];
        n3 = l3[0] << 13 | l3[1] << 12 | l3[2] << 11 | h3[0] << 7 | h3[1] << 6 | h3[2] << 5 | h3[3] << 4;
        for (o3 = 0; o3 < e3; o3++) {
          C3[o3] = c3 = a3.readBit(s3, n3);
          n3 = (31735 & n3) << 1 | (o3 + 3 < e3 ? l3[o3 + 3] << 11 : 0) | (o3 + 4 < e3 ? h3[o3 + 4] << 4 : 0) | c3;
        }
      }
      return r3;
    }(t2, i2, g2);
  const o2 = !!r2, c2 = Vt[a2].concat(n2);
  c2.sort(function(e3, t3) {
    return e3.y - t3.y || e3.x - t3.x;
  });
  const C2 = c2.length, h2 = new Int8Array(C2), l2 = new Int8Array(C2), Q2 = [];
  let E2, u2, d2 = 0, f2 = 0, p2 = 0, m2 = 0;
  for (u2 = 0; u2 < C2; u2++) {
    h2[u2] = c2[u2].x;
    l2[u2] = c2[u2].y;
    f2 = Math.min(f2, c2[u2].x);
    p2 = Math.max(p2, c2[u2].x);
    m2 = Math.min(m2, c2[u2].y);
    u2 < C2 - 1 && c2[u2].y === c2[u2 + 1].y && c2[u2].x === c2[u2 + 1].x - 1 ? d2 |= 1 << C2 - 1 - u2 : Q2.push(u2);
  }
  const y2 = Q2.length, w2 = new Int8Array(y2), D2 = new Int8Array(y2), b2 = new Uint16Array(y2);
  for (E2 = 0; E2 < y2; E2++) {
    u2 = Q2[E2];
    w2[E2] = c2[u2].x;
    D2[E2] = c2[u2].y;
    b2[E2] = 1 << C2 - 1 - u2;
  }
  const F2 = -f2, S2 = -m2, k2 = t2 - p2, R2 = _t5[a2];
  let N2 = new Uint8Array(t2);
  const G2 = [], x2 = g2.decoder, U2 = g2.contextCache.getContexts("GB");
  let M2, L2, H2, J2, Y2, v2 = 0, K2 = 0;
  for (let e3 = 0; e3 < i2; e3++) {
    if (s2) {
      v2 ^= x2.readBit(U2, R2);
      if (v2) {
        G2.push(N2);
        continue;
      }
    }
    N2 = new Uint8Array(N2);
    G2.push(N2);
    for (M2 = 0; M2 < t2; M2++) {
      if (o2 && r2[e3][M2]) {
        N2[M2] = 0;
        continue;
      }
      if (M2 >= F2 && M2 < k2 && e3 >= S2) {
        K2 = K2 << 1 & d2;
        for (u2 = 0; u2 < y2; u2++) {
          L2 = e3 + D2[u2];
          H2 = M2 + w2[u2];
          J2 = G2[L2][H2];
          if (J2) {
            J2 = b2[u2];
            K2 |= J2;
          }
        }
      } else {
        K2 = 0;
        Y2 = C2 - 1;
        for (u2 = 0; u2 < C2; u2++, Y2--) {
          H2 = M2 + h2[u2];
          if (H2 >= 0 && H2 < t2) {
            L2 = e3 + l2[u2];
            if (L2 >= 0) {
              J2 = G2[L2][H2];
              J2 && (K2 |= J2 << Y2);
            }
          }
        }
      }
      const i3 = x2.readBit(U2, K2);
      N2[M2] = i3;
    }
  }
  return G2;
}
function decodeRefinement(e2, t2, i2, a2, s2, r2, n2, g2, o2) {
  let c2 = zt[i2].coding;
  0 === i2 && (c2 = c2.concat([g2[0]]));
  const C2 = c2.length, h2 = new Int32Array(C2), l2 = new Int32Array(C2);
  let Q2;
  for (Q2 = 0; Q2 < C2; Q2++) {
    h2[Q2] = c2[Q2].x;
    l2[Q2] = c2[Q2].y;
  }
  let E2 = zt[i2].reference;
  0 === i2 && (E2 = E2.concat([g2[1]]));
  const u2 = E2.length, d2 = new Int32Array(u2), f2 = new Int32Array(u2);
  for (Q2 = 0; Q2 < u2; Q2++) {
    d2[Q2] = E2[Q2].x;
    f2[Q2] = E2[Q2].y;
  }
  const p2 = a2[0].length, m2 = a2.length, y2 = $t[i2], w2 = [], D2 = o2.decoder, b2 = o2.contextCache.getContexts("GR");
  let F2 = 0;
  for (let i3 = 0; i3 < t2; i3++) {
    if (n2) {
      F2 ^= D2.readBit(b2, y2);
      if (F2)
        throw new Jbig2Error("prediction is not supported");
    }
    const t3 = new Uint8Array(e2);
    w2.push(t3);
    for (let n3 = 0; n3 < e2; n3++) {
      let g3, o3, c3 = 0;
      for (Q2 = 0; Q2 < C2; Q2++) {
        g3 = i3 + l2[Q2];
        o3 = n3 + h2[Q2];
        g3 < 0 || o3 < 0 || o3 >= e2 ? c3 <<= 1 : c3 = c3 << 1 | w2[g3][o3];
      }
      for (Q2 = 0; Q2 < u2; Q2++) {
        g3 = i3 + f2[Q2] - r2;
        o3 = n3 + d2[Q2] - s2;
        g3 < 0 || g3 >= m2 || o3 < 0 || o3 >= p2 ? c3 <<= 1 : c3 = c3 << 1 | a2[g3][o3];
      }
      const E3 = D2.readBit(b2, c3);
      t3[n3] = E3;
    }
  }
  return w2;
}
function decodeTextRegion(e2, t2, i2, a2, s2, r2, n2, g2, o2, c2, C2, h2, l2, Q2, E2, u2, d2, f2, p2) {
  if (e2 && t2)
    throw new Jbig2Error("refinement with Huffman is not supported");
  const m2 = [];
  let y2, w2;
  for (y2 = 0; y2 < a2; y2++) {
    w2 = new Uint8Array(i2);
    if (s2)
      for (let e3 = 0; e3 < i2; e3++)
        w2[e3] = s2;
    m2.push(w2);
  }
  const D2 = d2.decoder, b2 = d2.contextCache;
  let F2 = e2 ? -Q2.tableDeltaT.decode(p2) : -decodeInteger(b2, "IADT", D2), S2 = 0;
  y2 = 0;
  for (; y2 < r2; ) {
    F2 += e2 ? Q2.tableDeltaT.decode(p2) : decodeInteger(b2, "IADT", D2);
    S2 += e2 ? Q2.tableFirstS.decode(p2) : decodeInteger(b2, "IAFS", D2);
    let a3 = S2;
    for (; ; ) {
      let s3 = 0;
      n2 > 1 && (s3 = e2 ? p2.readBits(f2) : decodeInteger(b2, "IAIT", D2));
      const r3 = n2 * F2 + s3, S3 = e2 ? Q2.symbolIDTable.decode(p2) : decodeIAID(b2, D2, o2), k2 = t2 && (e2 ? p2.readBit() : decodeInteger(b2, "IARI", D2));
      let R2 = g2[S3], N2 = R2[0].length, G2 = R2.length;
      if (k2) {
        const e3 = decodeInteger(b2, "IARDW", D2), t3 = decodeInteger(b2, "IARDH", D2);
        N2 += e3;
        G2 += t3;
        R2 = decodeRefinement(N2, G2, E2, R2, (e3 >> 1) + decodeInteger(b2, "IARDX", D2), (t3 >> 1) + decodeInteger(b2, "IARDY", D2), false, u2, d2);
      }
      let x2 = 0;
      c2 ? 1 & h2 ? x2 = G2 - 1 : a3 += G2 - 1 : h2 > 1 ? a3 += N2 - 1 : x2 = N2 - 1;
      const U2 = r3 - (1 & h2 ? 0 : G2 - 1), M2 = a3 - (2 & h2 ? N2 - 1 : 0);
      let L2, H2, J2;
      if (c2)
        for (L2 = 0; L2 < G2; L2++) {
          w2 = m2[M2 + L2];
          if (!w2)
            continue;
          J2 = R2[L2];
          const e3 = Math.min(i2 - U2, N2);
          switch (l2) {
            case 0:
              for (H2 = 0; H2 < e3; H2++)
                w2[U2 + H2] |= J2[H2];
              break;
            case 2:
              for (H2 = 0; H2 < e3; H2++)
                w2[U2 + H2] ^= J2[H2];
              break;
            default:
              throw new Jbig2Error(`operator ${l2} is not supported`);
          }
        }
      else
        for (H2 = 0; H2 < G2; H2++) {
          w2 = m2[U2 + H2];
          if (w2) {
            J2 = R2[H2];
            switch (l2) {
              case 0:
                for (L2 = 0; L2 < N2; L2++)
                  w2[M2 + L2] |= J2[L2];
                break;
              case 2:
                for (L2 = 0; L2 < N2; L2++)
                  w2[M2 + L2] ^= J2[L2];
                break;
              default:
                throw new Jbig2Error(`operator ${l2} is not supported`);
            }
          }
        }
      y2++;
      const Y2 = e2 ? Q2.tableDeltaS.decode(p2) : decodeInteger(b2, "IADS", D2);
      if (null === Y2)
        break;
      a3 += x2 + Y2 + C2;
    }
  }
  return m2;
}
function readSegmentHeader(e2, t2) {
  const i2 = {};
  i2.number = readUint32(e2, t2);
  const a2 = e2[t2 + 4], s2 = 63 & a2;
  if (!Zt[s2])
    throw new Jbig2Error("invalid segment type: " + s2);
  i2.type = s2;
  i2.typeName = Zt[s2];
  i2.deferredNonRetain = !!(128 & a2);
  const r2 = !!(64 & a2), n2 = e2[t2 + 5];
  let g2 = n2 >> 5 & 7;
  const o2 = [31 & n2];
  let c2 = t2 + 6;
  if (7 === n2) {
    g2 = 536870911 & readUint32(e2, c2 - 1);
    c2 += 3;
    let t3 = g2 + 7 >> 3;
    o2[0] = e2[c2++];
    for (; --t3 > 0; )
      o2.push(e2[c2++]);
  } else if (5 === n2 || 6 === n2)
    throw new Jbig2Error("invalid referred-to flags");
  i2.retainBits = o2;
  let C2 = 4;
  i2.number <= 256 ? C2 = 1 : i2.number <= 65536 && (C2 = 2);
  const h2 = [];
  let l2, Q2;
  for (l2 = 0; l2 < g2; l2++) {
    let t3;
    t3 = 1 === C2 ? e2[c2] : 2 === C2 ? readUint16(e2, c2) : readUint32(e2, c2);
    h2.push(t3);
    c2 += C2;
  }
  i2.referredTo = h2;
  if (r2) {
    i2.pageAssociation = readUint32(e2, c2);
    c2 += 4;
  } else
    i2.pageAssociation = e2[c2++];
  i2.length = readUint32(e2, c2);
  c2 += 4;
  if (4294967295 === i2.length) {
    if (38 !== s2)
      throw new Jbig2Error("invalid unknown segment length");
    {
      const t3 = readRegionSegmentInformation(e2, c2), a3 = !!(1 & e2[c2 + Ai]), s3 = 6, r3 = new Uint8Array(s3);
      if (!a3) {
        r3[0] = 255;
        r3[1] = 172;
      }
      r3[2] = t3.height >>> 24 & 255;
      r3[3] = t3.height >> 16 & 255;
      r3[4] = t3.height >> 8 & 255;
      r3[5] = 255 & t3.height;
      for (l2 = c2, Q2 = e2.length; l2 < Q2; l2++) {
        let t4 = 0;
        for (; t4 < s3 && r3[t4] === e2[l2 + t4]; )
          t4++;
        if (t4 === s3) {
          i2.length = l2 + s3;
          break;
        }
      }
      if (4294967295 === i2.length)
        throw new Jbig2Error("segment end was not found");
    }
  }
  i2.headerEnd = c2;
  return i2;
}
function readSegments(e2, t2, i2, a2) {
  const s2 = [];
  let r2 = i2;
  for (; r2 < a2; ) {
    const i3 = readSegmentHeader(t2, r2);
    r2 = i3.headerEnd;
    const a3 = { header: i3, data: t2 };
    if (!e2.randomAccess) {
      a3.start = r2;
      r2 += i3.length;
      a3.end = r2;
    }
    s2.push(a3);
    if (51 === i3.type)
      break;
  }
  if (e2.randomAccess)
    for (let e3 = 0, t3 = s2.length; e3 < t3; e3++) {
      s2[e3].start = r2;
      r2 += s2[e3].header.length;
      s2[e3].end = r2;
    }
  return s2;
}
function readRegionSegmentInformation(e2, t2) {
  return { width: readUint32(e2, t2), height: readUint32(e2, t2 + 4), x: readUint32(e2, t2 + 8), y: readUint32(e2, t2 + 12), combinationOperator: 7 & e2[t2 + 16] };
}
var Ai = 17;
function processSegment(e2, t2) {
  const i2 = e2.header, a2 = e2.data, s2 = e2.end;
  let r2, n2, g2, o2, c2 = e2.start;
  switch (i2.type) {
    case 0:
      const e3 = {}, t3 = readUint16(a2, c2);
      e3.huffman = !!(1 & t3);
      e3.refinement = !!(2 & t3);
      e3.huffmanDHSelector = t3 >> 2 & 3;
      e3.huffmanDWSelector = t3 >> 4 & 3;
      e3.bitmapSizeSelector = t3 >> 6 & 1;
      e3.aggregationInstancesSelector = t3 >> 7 & 1;
      e3.bitmapCodingContextUsed = !!(256 & t3);
      e3.bitmapCodingContextRetained = !!(512 & t3);
      e3.template = t3 >> 10 & 3;
      e3.refinementTemplate = t3 >> 12 & 1;
      c2 += 2;
      if (!e3.huffman) {
        o2 = 0 === e3.template ? 4 : 1;
        n2 = [];
        for (g2 = 0; g2 < o2; g2++) {
          n2.push({ x: readInt8(a2, c2), y: readInt8(a2, c2 + 1) });
          c2 += 2;
        }
        e3.at = n2;
      }
      if (e3.refinement && !e3.refinementTemplate) {
        n2 = [];
        for (g2 = 0; g2 < 2; g2++) {
          n2.push({ x: readInt8(a2, c2), y: readInt8(a2, c2 + 1) });
          c2 += 2;
        }
        e3.refinementAt = n2;
      }
      e3.numberOfExportedSymbols = readUint32(a2, c2);
      c2 += 4;
      e3.numberOfNewSymbols = readUint32(a2, c2);
      c2 += 4;
      r2 = [e3, i2.number, i2.referredTo, a2, c2, s2];
      break;
    case 6:
    case 7:
      const C3 = {};
      C3.info = readRegionSegmentInformation(a2, c2);
      c2 += Ai;
      const h2 = readUint16(a2, c2);
      c2 += 2;
      C3.huffman = !!(1 & h2);
      C3.refinement = !!(2 & h2);
      C3.logStripSize = h2 >> 2 & 3;
      C3.stripSize = 1 << C3.logStripSize;
      C3.referenceCorner = h2 >> 4 & 3;
      C3.transposed = !!(64 & h2);
      C3.combinationOperator = h2 >> 7 & 3;
      C3.defaultPixelValue = h2 >> 9 & 1;
      C3.dsOffset = h2 << 17 >> 27;
      C3.refinementTemplate = h2 >> 15 & 1;
      if (C3.huffman) {
        const e4 = readUint16(a2, c2);
        c2 += 2;
        C3.huffmanFS = 3 & e4;
        C3.huffmanDS = e4 >> 2 & 3;
        C3.huffmanDT = e4 >> 4 & 3;
        C3.huffmanRefinementDW = e4 >> 6 & 3;
        C3.huffmanRefinementDH = e4 >> 8 & 3;
        C3.huffmanRefinementDX = e4 >> 10 & 3;
        C3.huffmanRefinementDY = e4 >> 12 & 3;
        C3.huffmanRefinementSizeSelector = !!(16384 & e4);
      }
      if (C3.refinement && !C3.refinementTemplate) {
        n2 = [];
        for (g2 = 0; g2 < 2; g2++) {
          n2.push({ x: readInt8(a2, c2), y: readInt8(a2, c2 + 1) });
          c2 += 2;
        }
        C3.refinementAt = n2;
      }
      C3.numberOfSymbolInstances = readUint32(a2, c2);
      c2 += 4;
      r2 = [C3, i2.referredTo, a2, c2, s2];
      break;
    case 16:
      const l2 = {}, Q2 = a2[c2++];
      l2.mmr = !!(1 & Q2);
      l2.template = Q2 >> 1 & 3;
      l2.patternWidth = a2[c2++];
      l2.patternHeight = a2[c2++];
      l2.maxPatternIndex = readUint32(a2, c2);
      c2 += 4;
      r2 = [l2, i2.number, a2, c2, s2];
      break;
    case 22:
    case 23:
      const E2 = {};
      E2.info = readRegionSegmentInformation(a2, c2);
      c2 += Ai;
      const u2 = a2[c2++];
      E2.mmr = !!(1 & u2);
      E2.template = u2 >> 1 & 3;
      E2.enableSkip = !!(8 & u2);
      E2.combinationOperator = u2 >> 4 & 7;
      E2.defaultPixelValue = u2 >> 7 & 1;
      E2.gridWidth = readUint32(a2, c2);
      c2 += 4;
      E2.gridHeight = readUint32(a2, c2);
      c2 += 4;
      E2.gridOffsetX = 4294967295 & readUint32(a2, c2);
      c2 += 4;
      E2.gridOffsetY = 4294967295 & readUint32(a2, c2);
      c2 += 4;
      E2.gridVectorX = readUint16(a2, c2);
      c2 += 2;
      E2.gridVectorY = readUint16(a2, c2);
      c2 += 2;
      r2 = [E2, i2.referredTo, a2, c2, s2];
      break;
    case 38:
    case 39:
      const d2 = {};
      d2.info = readRegionSegmentInformation(a2, c2);
      c2 += Ai;
      const f2 = a2[c2++];
      d2.mmr = !!(1 & f2);
      d2.template = f2 >> 1 & 3;
      d2.prediction = !!(8 & f2);
      if (!d2.mmr) {
        o2 = 0 === d2.template ? 4 : 1;
        n2 = [];
        for (g2 = 0; g2 < o2; g2++) {
          n2.push({ x: readInt8(a2, c2), y: readInt8(a2, c2 + 1) });
          c2 += 2;
        }
        d2.at = n2;
      }
      r2 = [d2, a2, c2, s2];
      break;
    case 48:
      const p2 = { width: readUint32(a2, c2), height: readUint32(a2, c2 + 4), resolutionX: readUint32(a2, c2 + 8), resolutionY: readUint32(a2, c2 + 12) };
      4294967295 === p2.height && delete p2.height;
      const m2 = a2[c2 + 16];
      readUint16(a2, c2 + 17);
      p2.lossless = !!(1 & m2);
      p2.refinement = !!(2 & m2);
      p2.defaultPixelValue = m2 >> 2 & 1;
      p2.combinationOperator = m2 >> 3 & 3;
      p2.requiresBuffer = !!(32 & m2);
      p2.combinationOperatorOverride = !!(64 & m2);
      r2 = [p2];
      break;
    case 49:
    case 50:
    case 51:
    case 62:
      break;
    case 53:
      r2 = [i2.number, a2, c2, s2];
      break;
    default:
      throw new Jbig2Error(`segment type ${i2.typeName}(${i2.type}) is not implemented`);
  }
  const C2 = "on" + i2.typeName;
  C2 in t2 && t2[C2].apply(t2, r2);
}
function processSegments(e2, t2) {
  for (let i2 = 0, a2 = e2.length; i2 < a2; i2++)
    processSegment(e2[i2], t2);
}
var SimpleSegmentVisitor = class {
  onPageInformation(e2) {
    this.currentPageInfo = e2;
    const t2 = e2.width + 7 >> 3, i2 = new Uint8ClampedArray(t2 * e2.height);
    e2.defaultPixelValue && i2.fill(255);
    this.buffer = i2;
  }
  drawBitmap(e2, t2) {
    const i2 = this.currentPageInfo, a2 = e2.width, s2 = e2.height, r2 = i2.width + 7 >> 3, n2 = i2.combinationOperatorOverride ? e2.combinationOperator : i2.combinationOperator, g2 = this.buffer, o2 = 128 >> (7 & e2.x);
    let c2, C2, h2, l2, Q2 = e2.y * r2 + (e2.x >> 3);
    switch (n2) {
      case 0:
        for (c2 = 0; c2 < s2; c2++) {
          h2 = o2;
          l2 = Q2;
          for (C2 = 0; C2 < a2; C2++) {
            t2[c2][C2] && (g2[l2] |= h2);
            h2 >>= 1;
            if (!h2) {
              h2 = 128;
              l2++;
            }
          }
          Q2 += r2;
        }
        break;
      case 2:
        for (c2 = 0; c2 < s2; c2++) {
          h2 = o2;
          l2 = Q2;
          for (C2 = 0; C2 < a2; C2++) {
            t2[c2][C2] && (g2[l2] ^= h2);
            h2 >>= 1;
            if (!h2) {
              h2 = 128;
              l2++;
            }
          }
          Q2 += r2;
        }
        break;
      default:
        throw new Jbig2Error(`operator ${n2} is not supported`);
    }
  }
  onImmediateGenericRegion(e2, t2, i2, a2) {
    const s2 = e2.info, r2 = new DecodingContext(t2, i2, a2), n2 = decodeBitmap(e2.mmr, s2.width, s2.height, e2.template, e2.prediction, null, e2.at, r2);
    this.drawBitmap(s2, n2);
  }
  onImmediateLosslessGenericRegion() {
    this.onImmediateGenericRegion(...arguments);
  }
  onSymbolDictionary(e2, t2, i2, a2, s2, r2) {
    let n2, g2;
    if (e2.huffman) {
      n2 = function getSymbolDictionaryHuffmanTables(e3, t3, i3) {
        let a3, s3, r3, n3, g3 = 0;
        switch (e3.huffmanDHSelector) {
          case 0:
          case 1:
            a3 = getStandardTable(e3.huffmanDHSelector + 4);
            break;
          case 3:
            a3 = getCustomHuffmanTable(g3, t3, i3);
            g3++;
            break;
          default:
            throw new Jbig2Error("invalid Huffman DH selector");
        }
        switch (e3.huffmanDWSelector) {
          case 0:
          case 1:
            s3 = getStandardTable(e3.huffmanDWSelector + 2);
            break;
          case 3:
            s3 = getCustomHuffmanTable(g3, t3, i3);
            g3++;
            break;
          default:
            throw new Jbig2Error("invalid Huffman DW selector");
        }
        if (e3.bitmapSizeSelector) {
          r3 = getCustomHuffmanTable(g3, t3, i3);
          g3++;
        } else
          r3 = getStandardTable(1);
        n3 = e3.aggregationInstancesSelector ? getCustomHuffmanTable(g3, t3, i3) : getStandardTable(1);
        return { tableDeltaHeight: a3, tableDeltaWidth: s3, tableBitmapSize: r3, tableAggregateInstances: n3 };
      }(e2, i2, this.customTables);
      g2 = new Reader(a2, s2, r2);
    }
    let o2 = this.symbols;
    o2 || (this.symbols = o2 = {});
    const c2 = [];
    for (const e3 of i2) {
      const t3 = o2[e3];
      t3 && c2.push(...t3);
    }
    const C2 = new DecodingContext(a2, s2, r2);
    o2[t2] = function decodeSymbolDictionary(e3, t3, i3, a3, s3, r3, n3, g3, o3, c3, C3, h2) {
      if (e3 && t3)
        throw new Jbig2Error("symbol refinement with Huffman is not supported");
      const l2 = [];
      let Q2 = 0, E2 = log2(i3.length + a3);
      const u2 = C3.decoder, d2 = C3.contextCache;
      let f2, p2;
      if (e3) {
        f2 = getStandardTable(1);
        p2 = [];
        E2 = Math.max(E2, 1);
      }
      for (; l2.length < a3; ) {
        Q2 += e3 ? r3.tableDeltaHeight.decode(h2) : decodeInteger(d2, "IADH", u2);
        let a4 = 0, s4 = 0;
        const f3 = e3 ? p2.length : 0;
        for (; ; ) {
          const f4 = e3 ? r3.tableDeltaWidth.decode(h2) : decodeInteger(d2, "IADW", u2);
          if (null === f4)
            break;
          a4 += f4;
          s4 += a4;
          let m3;
          if (t3) {
            const s5 = decodeInteger(d2, "IAAI", u2);
            if (s5 > 1)
              m3 = decodeTextRegion(e3, t3, a4, Q2, 0, s5, 1, i3.concat(l2), E2, 0, 0, 1, 0, r3, o3, c3, C3, 0, h2);
            else {
              const e4 = decodeIAID(d2, u2, E2), t4 = decodeInteger(d2, "IARDX", u2), s6 = decodeInteger(d2, "IARDY", u2);
              m3 = decodeRefinement(a4, Q2, o3, e4 < i3.length ? i3[e4] : l2[e4 - i3.length], t4, s6, false, c3, C3);
            }
            l2.push(m3);
          } else if (e3)
            p2.push(a4);
          else {
            m3 = decodeBitmap(false, a4, Q2, n3, false, null, g3, C3);
            l2.push(m3);
          }
        }
        if (e3 && !t3) {
          const e4 = r3.tableBitmapSize.decode(h2);
          h2.byteAlign();
          let t4;
          if (0 === e4)
            t4 = readUncompressedBitmap(h2, s4, Q2);
          else {
            const i5 = h2.end, a5 = h2.position + e4;
            h2.end = a5;
            t4 = decodeMMRBitmap(h2, s4, Q2, false);
            h2.end = i5;
            h2.position = a5;
          }
          const i4 = p2.length;
          if (f3 === i4 - 1)
            l2.push(t4);
          else {
            let e5, a5, s5, r4, n4, g4 = 0;
            for (e5 = f3; e5 < i4; e5++) {
              r4 = p2[e5];
              s5 = g4 + r4;
              n4 = [];
              for (a5 = 0; a5 < Q2; a5++)
                n4.push(t4[a5].subarray(g4, s5));
              l2.push(n4);
              g4 = s5;
            }
          }
        }
      }
      const m2 = [], y2 = [];
      let w2, D2, b2 = false;
      const F2 = i3.length + a3;
      for (; y2.length < F2; ) {
        let t4 = e3 ? f2.decode(h2) : decodeInteger(d2, "IAEX", u2);
        for (; t4--; )
          y2.push(b2);
        b2 = !b2;
      }
      for (w2 = 0, D2 = i3.length; w2 < D2; w2++)
        y2[w2] && m2.push(i3[w2]);
      for (let e4 = 0; e4 < a3; w2++, e4++)
        y2[w2] && m2.push(l2[e4]);
      return m2;
    }(e2.huffman, e2.refinement, c2, e2.numberOfNewSymbols, e2.numberOfExportedSymbols, n2, e2.template, e2.at, e2.refinementTemplate, e2.refinementAt, C2, g2);
  }
  onImmediateTextRegion(e2, t2, i2, a2, s2) {
    const r2 = e2.info;
    let n2, g2;
    const o2 = this.symbols, c2 = [];
    for (const e3 of t2) {
      const t3 = o2[e3];
      t3 && c2.push(...t3);
    }
    const C2 = log2(c2.length);
    if (e2.huffman) {
      g2 = new Reader(i2, a2, s2);
      n2 = function getTextRegionHuffmanTables(e3, t3, i3, a3, s3) {
        const r3 = [];
        for (let e4 = 0; e4 <= 34; e4++) {
          const t4 = s3.readBits(4);
          r3.push(new HuffmanLine([e4, t4, 0, 0]));
        }
        const n3 = new HuffmanTable(r3, false);
        r3.length = 0;
        for (let e4 = 0; e4 < a3; ) {
          const t4 = n3.decode(s3);
          if (t4 >= 32) {
            let i4, a4, n4;
            switch (t4) {
              case 32:
                if (0 === e4)
                  throw new Jbig2Error("no previous value in symbol ID table");
                a4 = s3.readBits(2) + 3;
                i4 = r3[e4 - 1].prefixLength;
                break;
              case 33:
                a4 = s3.readBits(3) + 3;
                i4 = 0;
                break;
              case 34:
                a4 = s3.readBits(7) + 11;
                i4 = 0;
                break;
              default:
                throw new Jbig2Error("invalid code length in symbol ID table");
            }
            for (n4 = 0; n4 < a4; n4++) {
              r3.push(new HuffmanLine([e4, i4, 0, 0]));
              e4++;
            }
          } else {
            r3.push(new HuffmanLine([e4, t4, 0, 0]));
            e4++;
          }
        }
        s3.byteAlign();
        const g3 = new HuffmanTable(r3, false);
        let o3, c3, C3, h3 = 0;
        switch (e3.huffmanFS) {
          case 0:
          case 1:
            o3 = getStandardTable(e3.huffmanFS + 6);
            break;
          case 3:
            o3 = getCustomHuffmanTable(h3, t3, i3);
            h3++;
            break;
          default:
            throw new Jbig2Error("invalid Huffman FS selector");
        }
        switch (e3.huffmanDS) {
          case 0:
          case 1:
          case 2:
            c3 = getStandardTable(e3.huffmanDS + 8);
            break;
          case 3:
            c3 = getCustomHuffmanTable(h3, t3, i3);
            h3++;
            break;
          default:
            throw new Jbig2Error("invalid Huffman DS selector");
        }
        switch (e3.huffmanDT) {
          case 0:
          case 1:
          case 2:
            C3 = getStandardTable(e3.huffmanDT + 11);
            break;
          case 3:
            C3 = getCustomHuffmanTable(h3, t3, i3);
            h3++;
            break;
          default:
            throw new Jbig2Error("invalid Huffman DT selector");
        }
        if (e3.refinement)
          throw new Jbig2Error("refinement with Huffman is not supported");
        return { symbolIDTable: g3, tableFirstS: o3, tableDeltaS: c3, tableDeltaT: C3 };
      }(e2, t2, this.customTables, c2.length, g2);
    }
    const h2 = new DecodingContext(i2, a2, s2), l2 = decodeTextRegion(e2.huffman, e2.refinement, r2.width, r2.height, e2.defaultPixelValue, e2.numberOfSymbolInstances, e2.stripSize, c2, C2, e2.transposed, e2.dsOffset, e2.referenceCorner, e2.combinationOperator, n2, e2.refinementTemplate, e2.refinementAt, h2, e2.logStripSize, g2);
    this.drawBitmap(r2, l2);
  }
  onImmediateLosslessTextRegion() {
    this.onImmediateTextRegion(...arguments);
  }
  onPatternDictionary(e2, t2, i2, a2, s2) {
    let r2 = this.patterns;
    r2 || (this.patterns = r2 = {});
    const n2 = new DecodingContext(i2, a2, s2);
    r2[t2] = function decodePatternDictionary(e3, t3, i3, a3, s3, r3) {
      const n3 = [];
      if (!e3) {
        n3.push({ x: -t3, y: 0 });
        0 === s3 && n3.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 });
      }
      const g2 = decodeBitmap(e3, (a3 + 1) * t3, i3, s3, false, null, n3, r3), o2 = [];
      for (let e4 = 0; e4 <= a3; e4++) {
        const a4 = [], s4 = t3 * e4, r4 = s4 + t3;
        for (let e5 = 0; e5 < i3; e5++)
          a4.push(g2[e5].subarray(s4, r4));
        o2.push(a4);
      }
      return o2;
    }(e2.mmr, e2.patternWidth, e2.patternHeight, e2.maxPatternIndex, e2.template, n2);
  }
  onImmediateHalftoneRegion(e2, t2, i2, a2, s2) {
    const r2 = this.patterns[t2[0]], n2 = e2.info, g2 = new DecodingContext(i2, a2, s2), o2 = function decodeHalftoneRegion(e3, t3, i3, a3, s3, r3, n3, g3, o3, c2, C2, h2, l2, Q2, E2) {
      if (n3)
        throw new Jbig2Error("skip is not supported");
      if (0 !== g3)
        throw new Jbig2Error(`operator "${g3}" is not supported in halftone region`);
      const u2 = [];
      let d2, f2, p2;
      for (d2 = 0; d2 < s3; d2++) {
        p2 = new Uint8Array(a3);
        if (r3)
          for (f2 = 0; f2 < a3; f2++)
            p2[f2] = r3;
        u2.push(p2);
      }
      const m2 = t3.length, y2 = t3[0], w2 = y2[0].length, D2 = y2.length, b2 = log2(m2), F2 = [];
      if (!e3) {
        F2.push({ x: i3 <= 1 ? 3 : 2, y: -1 });
        0 === i3 && F2.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 });
      }
      const S2 = [];
      let k2, R2, N2, G2, x2, U2, M2, L2, H2, J2, Y2;
      e3 && (k2 = new Reader(E2.data, E2.start, E2.end));
      for (d2 = b2 - 1; d2 >= 0; d2--) {
        R2 = e3 ? decodeMMRBitmap(k2, o3, c2, true) : decodeBitmap(false, o3, c2, i3, false, null, F2, E2);
        S2[d2] = R2;
      }
      for (N2 = 0; N2 < c2; N2++)
        for (G2 = 0; G2 < o3; G2++) {
          x2 = 0;
          U2 = 0;
          for (f2 = b2 - 1; f2 >= 0; f2--) {
            x2 ^= S2[f2][N2][G2];
            U2 |= x2 << f2;
          }
          M2 = t3[U2];
          L2 = C2 + N2 * Q2 + G2 * l2 >> 8;
          H2 = h2 + N2 * l2 - G2 * Q2 >> 8;
          if (L2 >= 0 && L2 + w2 <= a3 && H2 >= 0 && H2 + D2 <= s3)
            for (d2 = 0; d2 < D2; d2++) {
              Y2 = u2[H2 + d2];
              J2 = M2[d2];
              for (f2 = 0; f2 < w2; f2++)
                Y2[L2 + f2] |= J2[f2];
            }
          else {
            let e4, t4;
            for (d2 = 0; d2 < D2; d2++) {
              t4 = H2 + d2;
              if (!(t4 < 0 || t4 >= s3)) {
                Y2 = u2[t4];
                J2 = M2[d2];
                for (f2 = 0; f2 < w2; f2++) {
                  e4 = L2 + f2;
                  e4 >= 0 && e4 < a3 && (Y2[e4] |= J2[f2]);
                }
              }
            }
          }
        }
      return u2;
    }(e2.mmr, r2, e2.template, n2.width, n2.height, e2.defaultPixelValue, e2.enableSkip, e2.combinationOperator, e2.gridWidth, e2.gridHeight, e2.gridOffsetX, e2.gridOffsetY, e2.gridVectorX, e2.gridVectorY, g2);
    this.drawBitmap(n2, o2);
  }
  onImmediateLosslessHalftoneRegion() {
    this.onImmediateHalftoneRegion(...arguments);
  }
  onTables(e2, t2, i2, a2) {
    let s2 = this.customTables;
    s2 || (this.customTables = s2 = {});
    s2[e2] = function decodeTablesSegment(e3, t3, i3) {
      const a3 = e3[t3], s3 = 4294967295 & readUint32(e3, t3 + 1), r2 = 4294967295 & readUint32(e3, t3 + 5), n2 = new Reader(e3, t3 + 9, i3), g2 = 1 + (a3 >> 1 & 7), o2 = 1 + (a3 >> 4 & 7), c2 = [];
      let C2, h2, l2 = s3;
      do {
        C2 = n2.readBits(g2);
        h2 = n2.readBits(o2);
        c2.push(new HuffmanLine([l2, C2, h2, 0]));
        l2 += 1 << h2;
      } while (l2 < r2);
      C2 = n2.readBits(g2);
      c2.push(new HuffmanLine([s3 - 1, C2, 32, 0, "lower"]));
      C2 = n2.readBits(g2);
      c2.push(new HuffmanLine([r2, C2, 32, 0]));
      if (1 & a3) {
        C2 = n2.readBits(g2);
        c2.push(new HuffmanLine([C2, 0]));
      }
      return new HuffmanTable(c2, false);
    }(t2, i2, a2);
  }
};
var HuffmanLine = class {
  constructor(e2) {
    if (2 === e2.length) {
      this.isOOB = true;
      this.rangeLow = 0;
      this.prefixLength = e2[0];
      this.rangeLength = 0;
      this.prefixCode = e2[1];
      this.isLowerRange = false;
    } else {
      this.isOOB = false;
      this.rangeLow = e2[0];
      this.prefixLength = e2[1];
      this.rangeLength = e2[2];
      this.prefixCode = e2[3];
      this.isLowerRange = "lower" === e2[4];
    }
  }
};
var HuffmanTreeNode = class _HuffmanTreeNode {
  constructor(e2) {
    this.children = [];
    if (e2) {
      this.isLeaf = true;
      this.rangeLength = e2.rangeLength;
      this.rangeLow = e2.rangeLow;
      this.isLowerRange = e2.isLowerRange;
      this.isOOB = e2.isOOB;
    } else
      this.isLeaf = false;
  }
  buildTree(e2, t2) {
    const i2 = e2.prefixCode >> t2 & 1;
    if (t2 <= 0)
      this.children[i2] = new _HuffmanTreeNode(e2);
    else {
      let a2 = this.children[i2];
      a2 || (this.children[i2] = a2 = new _HuffmanTreeNode(null));
      a2.buildTree(e2, t2 - 1);
    }
  }
  decodeNode(e2) {
    if (this.isLeaf) {
      if (this.isOOB)
        return null;
      const t3 = e2.readBits(this.rangeLength);
      return this.rangeLow + (this.isLowerRange ? -t3 : t3);
    }
    const t2 = this.children[e2.readBit()];
    if (!t2)
      throw new Jbig2Error("invalid Huffman data");
    return t2.decodeNode(e2);
  }
};
var HuffmanTable = class {
  constructor(e2, t2) {
    t2 || this.assignPrefixCodes(e2);
    this.rootNode = new HuffmanTreeNode(null);
    for (let t3 = 0, i2 = e2.length; t3 < i2; t3++) {
      const i3 = e2[t3];
      i3.prefixLength > 0 && this.rootNode.buildTree(i3, i3.prefixLength - 1);
    }
  }
  decode(e2) {
    return this.rootNode.decodeNode(e2);
  }
  assignPrefixCodes(e2) {
    const t2 = e2.length;
    let i2 = 0;
    for (let a3 = 0; a3 < t2; a3++)
      i2 = Math.max(i2, e2[a3].prefixLength);
    const a2 = new Uint32Array(i2 + 1);
    for (let i3 = 0; i3 < t2; i3++)
      a2[e2[i3].prefixLength]++;
    let s2, r2, n2, g2 = 1, o2 = 0;
    a2[0] = 0;
    for (; g2 <= i2; ) {
      o2 = o2 + a2[g2 - 1] << 1;
      s2 = o2;
      r2 = 0;
      for (; r2 < t2; ) {
        n2 = e2[r2];
        if (n2.prefixLength === g2) {
          n2.prefixCode = s2;
          s2++;
        }
        r2++;
      }
      g2++;
    }
  }
};
var ei = {};
function getStandardTable(e2) {
  let t2, i2 = ei[e2];
  if (i2)
    return i2;
  switch (e2) {
    case 1:
      t2 = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
      break;
    case 2:
      t2 = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
      break;
    case 3:
      t2 = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
      break;
    case 4:
      t2 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
      break;
    case 5:
      t2 = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
      break;
    case 6:
      t2 = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
      break;
    case 7:
      t2 = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
      break;
    case 8:
      t2 = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
      break;
    case 9:
      t2 = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
      break;
    case 10:
      t2 = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
      break;
    case 11:
      t2 = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 12:
      t2 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
      break;
    case 13:
      t2 = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 14:
      t2 = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
      break;
    case 15:
      t2 = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
      break;
    default:
      throw new Jbig2Error(`standard table B.${e2} does not exist`);
  }
  for (let e3 = 0, i3 = t2.length; e3 < i3; e3++)
    t2[e3] = new HuffmanLine(t2[e3]);
  i2 = new HuffmanTable(t2, true);
  ei[e2] = i2;
  return i2;
}
var Reader = class {
  constructor(e2, t2, i2) {
    this.data = e2;
    this.start = t2;
    this.end = i2;
    this.position = t2;
    this.shift = -1;
    this.currentByte = 0;
  }
  readBit() {
    if (this.shift < 0) {
      if (this.position >= this.end)
        throw new Jbig2Error("end of data while reading bit");
      this.currentByte = this.data[this.position++];
      this.shift = 7;
    }
    const e2 = this.currentByte >> this.shift & 1;
    this.shift--;
    return e2;
  }
  readBits(e2) {
    let t2, i2 = 0;
    for (t2 = e2 - 1; t2 >= 0; t2--)
      i2 |= this.readBit() << t2;
    return i2;
  }
  byteAlign() {
    this.shift = -1;
  }
  next() {
    return this.position >= this.end ? -1 : this.data[this.position++];
  }
};
function getCustomHuffmanTable(e2, t2, i2) {
  let a2 = 0;
  for (let s2 = 0, r2 = t2.length; s2 < r2; s2++) {
    const r3 = i2[t2[s2]];
    if (r3) {
      if (e2 === a2)
        return r3;
      a2++;
    }
  }
  throw new Jbig2Error("can't find custom Huffman table");
}
function readUncompressedBitmap(e2, t2, i2) {
  const a2 = [];
  for (let s2 = 0; s2 < i2; s2++) {
    const i3 = new Uint8Array(t2);
    a2.push(i3);
    for (let a3 = 0; a3 < t2; a3++)
      i3[a3] = e2.readBit();
    e2.byteAlign();
  }
  return a2;
}
function decodeMMRBitmap(e2, t2, i2, a2) {
  const s2 = new CCITTFaxDecoder(e2, { K: -1, Columns: t2, Rows: i2, BlackIs1: true, EndOfBlock: a2 }), r2 = [];
  let n2, g2 = false;
  for (let e3 = 0; e3 < i2; e3++) {
    const e4 = new Uint8Array(t2);
    r2.push(e4);
    let i3 = -1;
    for (let a3 = 0; a3 < t2; a3++) {
      if (i3 < 0) {
        n2 = s2.readNextChar();
        if (-1 === n2) {
          n2 = 0;
          g2 = true;
        }
        i3 = 7;
      }
      e4[a3] = n2 >> i3 & 1;
      i3--;
    }
  }
  if (a2 && !g2) {
    const e3 = 5;
    for (let t3 = 0; t3 < e3 && -1 !== s2.readNextChar(); t3++)
      ;
  }
  return r2;
}
var Jbig2Image = class {
  parseChunks(e2) {
    return function parseJbig2Chunks(e3) {
      const t2 = new SimpleSegmentVisitor();
      for (let i2 = 0, a2 = e3.length; i2 < a2; i2++) {
        const a3 = e3[i2];
        processSegments(readSegments({}, a3.data, a3.start, a3.end), t2);
      }
      return t2.buffer;
    }(e2);
  }
  parse(e2) {
    throw new Error("Not implemented: Jbig2Image.parse");
  }
};
var Jbig2Stream = class extends DecodeStream {
  constructor(e2, t2, i2) {
    super(t2);
    this.stream = e2;
    this.dict = e2.dict;
    this.maybeLength = t2;
    this.params = i2;
  }
  get bytes() {
    return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(e2) {
  }
  readBlock() {
    this.decodeImage();
  }
  decodeImage(e2) {
    if (this.eof)
      return this.buffer;
    e2 || (e2 = this.bytes);
    const t2 = new Jbig2Image(), i2 = [];
    if (this.params instanceof Dict) {
      const e3 = this.params.get("JBIG2Globals");
      if (e3 instanceof BaseStream) {
        const t3 = e3.getBytes();
        i2.push({ data: t3, start: 0, end: t3.length });
      }
    }
    i2.push({ data: e2, start: 0, end: e2.length });
    const a2 = t2.parseChunks(i2), s2 = a2.length;
    for (let e3 = 0; e3 < s2; e3++)
      a2[e3] ^= 255;
    this.buffer = a2;
    this.bufferLength = s2;
    this.eof = true;
    return this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
};
function convertToRGBA(e2) {
  switch (e2.kind) {
    case b:
      return convertBlackAndWhiteToRGBA(e2);
    case F:
      return function convertRGBToRGBA({ src: e3, srcPos: t2 = 0, dest: i2, destPos: a2 = 0, width: s2, height: r2 }) {
        let n2 = 0;
        const g2 = e3.length >> 2, o2 = new Uint32Array(e3.buffer, t2, g2);
        if (FeatureTest.isLittleEndian) {
          for (; n2 < g2 - 2; n2 += 3, a2 += 4) {
            const e4 = o2[n2], t3 = o2[n2 + 1], s3 = o2[n2 + 2];
            i2[a2] = 4278190080 | e4;
            i2[a2 + 1] = e4 >>> 24 | t3 << 8 | 4278190080;
            i2[a2 + 2] = t3 >>> 16 | s3 << 16 | 4278190080;
            i2[a2 + 3] = s3 >>> 8 | 4278190080;
          }
          for (let t3 = 4 * n2, s3 = e3.length; t3 < s3; t3 += 3)
            i2[a2++] = e3[t3] | e3[t3 + 1] << 8 | e3[t3 + 2] << 16 | 4278190080;
        } else {
          for (; n2 < g2 - 2; n2 += 3, a2 += 4) {
            const e4 = o2[n2], t3 = o2[n2 + 1], s3 = o2[n2 + 2];
            i2[a2] = 255 | e4;
            i2[a2 + 1] = e4 << 24 | t3 >>> 8 | 255;
            i2[a2 + 2] = t3 << 16 | s3 >>> 16 | 255;
            i2[a2 + 3] = s3 << 8 | 255;
          }
          for (let t3 = 4 * n2, s3 = e3.length; t3 < s3; t3 += 3)
            i2[a2++] = e3[t3] << 24 | e3[t3 + 1] << 16 | e3[t3 + 2] << 8 | 255;
        }
        return { srcPos: t2, destPos: a2 };
      }(e2);
  }
  return null;
}
function convertBlackAndWhiteToRGBA({ src: e2, srcPos: t2 = 0, dest: i2, width: a2, height: s2, nonBlackColor: r2 = 4294967295, inverseDecode: n2 = false }) {
  const g2 = FeatureTest.isLittleEndian ? 4278190080 : 255, [o2, c2] = n2 ? [r2, g2] : [g2, r2], C2 = a2 >> 3, h2 = 7 & a2, l2 = e2.length;
  i2 = new Uint32Array(i2.buffer);
  let Q2 = 0;
  for (let a3 = 0; a3 < s2; a3++) {
    for (const a5 = t2 + C2; t2 < a5; t2++) {
      const a6 = t2 < l2 ? e2[t2] : 255;
      i2[Q2++] = 128 & a6 ? c2 : o2;
      i2[Q2++] = 64 & a6 ? c2 : o2;
      i2[Q2++] = 32 & a6 ? c2 : o2;
      i2[Q2++] = 16 & a6 ? c2 : o2;
      i2[Q2++] = 8 & a6 ? c2 : o2;
      i2[Q2++] = 4 & a6 ? c2 : o2;
      i2[Q2++] = 2 & a6 ? c2 : o2;
      i2[Q2++] = 1 & a6 ? c2 : o2;
    }
    if (0 === h2)
      continue;
    const a4 = t2 < l2 ? e2[t2++] : 255;
    for (let e3 = 0; e3 < h2; e3++)
      i2[Q2++] = a4 & 1 << 7 - e3 ? c2 : o2;
  }
  return { srcPos: t2, destPos: Q2 };
}
var JpegError = class extends ot {
  constructor(e2) {
    super(e2, "JpegError");
  }
};
var DNLMarkerError = class extends ot {
  constructor(e2, t2) {
    super(e2, "DNLMarkerError");
    this.scanLines = t2;
  }
};
var EOIMarkerError = class extends ot {
  constructor(e2) {
    super(e2, "EOIMarkerError");
  }
};
var ti = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
var ii = 4017;
var ai = 799;
var si = 3406;
var ri = 2276;
var ni = 1567;
var gi = 3784;
var oi = 5793;
var Ii = 2896;
function buildHuffmanTable(e2, t2) {
  let i2, a2, s2 = 0, r2 = 16;
  for (; r2 > 0 && !e2[r2 - 1]; )
    r2--;
  const n2 = [{ children: [], index: 0 }];
  let g2, o2 = n2[0];
  for (i2 = 0; i2 < r2; i2++) {
    for (a2 = 0; a2 < e2[i2]; a2++) {
      o2 = n2.pop();
      o2.children[o2.index] = t2[s2];
      for (; o2.index > 0; )
        o2 = n2.pop();
      o2.index++;
      n2.push(o2);
      for (; n2.length <= i2; ) {
        n2.push(g2 = { children: [], index: 0 });
        o2.children[o2.index] = g2.children;
        o2 = g2;
      }
      s2++;
    }
    if (i2 + 1 < r2) {
      n2.push(g2 = { children: [], index: 0 });
      o2.children[o2.index] = g2.children;
      o2 = g2;
    }
  }
  return n2[0].children;
}
function getBlockBufferOffset(e2, t2, i2) {
  return 64 * ((e2.blocksPerLine + 1) * t2 + i2);
}
function decodeScan(e2, t2, i2, a2, s2, r2, n2, g2, o2, c2 = false) {
  const C2 = i2.mcusPerLine, h2 = i2.progressive, l2 = t2;
  let Q2 = 0, E2 = 0;
  function readBit() {
    if (E2 > 0) {
      E2--;
      return Q2 >> E2 & 1;
    }
    Q2 = e2[t2++];
    if (255 === Q2) {
      const a3 = e2[t2++];
      if (a3) {
        if (220 === a3 && c2) {
          const a4 = readUint16(e2, t2 += 2);
          t2 += 2;
          if (a4 > 0 && a4 !== i2.scanLines)
            throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", a4);
        } else if (217 === a3) {
          if (c2) {
            const e3 = p2 * (8 === i2.precision ? 8 : 0);
            if (e3 > 0 && Math.round(i2.scanLines / e3) >= 5)
              throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", e3);
          }
          throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
        }
        throw new JpegError(`unexpected marker ${(Q2 << 8 | a3).toString(16)}`);
      }
    }
    E2 = 7;
    return Q2 >>> 7;
  }
  function decodeHuffman(e3) {
    let t3 = e3;
    for (; ; ) {
      t3 = t3[readBit()];
      switch (typeof t3) {
        case "number":
          return t3;
        case "object":
          continue;
      }
      throw new JpegError("invalid huffman sequence");
    }
  }
  function receive(e3) {
    let t3 = 0;
    for (; e3 > 0; ) {
      t3 = t3 << 1 | readBit();
      e3--;
    }
    return t3;
  }
  function receiveAndExtend(e3) {
    if (1 === e3)
      return 1 === readBit() ? 1 : -1;
    const t3 = receive(e3);
    return t3 >= 1 << e3 - 1 ? t3 : t3 + (-1 << e3) + 1;
  }
  let u2 = 0;
  let d2, f2 = 0;
  let p2 = 0;
  function decodeMcu(e3, t3, i3, a3, s3) {
    const r3 = i3 % C2;
    p2 = (i3 / C2 | 0) * e3.v + a3;
    const n3 = r3 * e3.h + s3;
    t3(e3, getBlockBufferOffset(e3, p2, n3));
  }
  function decodeBlock(e3, t3, i3) {
    p2 = i3 / e3.blocksPerLine | 0;
    const a3 = i3 % e3.blocksPerLine;
    t3(e3, getBlockBufferOffset(e3, p2, a3));
  }
  const m2 = a2.length;
  let y2, w2, D2, b2, F2, S2;
  S2 = h2 ? 0 === r2 ? 0 === g2 ? function decodeDCFirst(e3, t3) {
    const i3 = decodeHuffman(e3.huffmanTableDC), a3 = 0 === i3 ? 0 : receiveAndExtend(i3) << o2;
    e3.blockData[t3] = e3.pred += a3;
  } : function decodeDCSuccessive(e3, t3) {
    e3.blockData[t3] |= readBit() << o2;
  } : 0 === g2 ? function decodeACFirst(e3, t3) {
    if (u2 > 0) {
      u2--;
      return;
    }
    let i3 = r2;
    const a3 = n2;
    for (; i3 <= a3; ) {
      const a4 = decodeHuffman(e3.huffmanTableAC), s3 = 15 & a4, r3 = a4 >> 4;
      if (0 === s3) {
        if (r3 < 15) {
          u2 = receive(r3) + (1 << r3) - 1;
          break;
        }
        i3 += 16;
        continue;
      }
      i3 += r3;
      const n3 = ti[i3];
      e3.blockData[t3 + n3] = receiveAndExtend(s3) * (1 << o2);
      i3++;
    }
  } : function decodeACSuccessive(e3, t3) {
    let i3 = r2;
    const a3 = n2;
    let s3, g3, c3 = 0;
    for (; i3 <= a3; ) {
      const a4 = t3 + ti[i3], r3 = e3.blockData[a4] < 0 ? -1 : 1;
      switch (f2) {
        case 0:
          g3 = decodeHuffman(e3.huffmanTableAC);
          s3 = 15 & g3;
          c3 = g3 >> 4;
          if (0 === s3)
            if (c3 < 15) {
              u2 = receive(c3) + (1 << c3);
              f2 = 4;
            } else {
              c3 = 16;
              f2 = 1;
            }
          else {
            if (1 !== s3)
              throw new JpegError("invalid ACn encoding");
            d2 = receiveAndExtend(s3);
            f2 = c3 ? 2 : 3;
          }
          continue;
        case 1:
        case 2:
          if (e3.blockData[a4])
            e3.blockData[a4] += r3 * (readBit() << o2);
          else {
            c3--;
            0 === c3 && (f2 = 2 === f2 ? 3 : 0);
          }
          break;
        case 3:
          if (e3.blockData[a4])
            e3.blockData[a4] += r3 * (readBit() << o2);
          else {
            e3.blockData[a4] = d2 << o2;
            f2 = 0;
          }
          break;
        case 4:
          e3.blockData[a4] && (e3.blockData[a4] += r3 * (readBit() << o2));
      }
      i3++;
    }
    if (4 === f2) {
      u2--;
      0 === u2 && (f2 = 0);
    }
  } : function decodeBaseline(e3, t3) {
    const i3 = decodeHuffman(e3.huffmanTableDC), a3 = 0 === i3 ? 0 : receiveAndExtend(i3);
    e3.blockData[t3] = e3.pred += a3;
    let s3 = 1;
    for (; s3 < 64; ) {
      const i4 = decodeHuffman(e3.huffmanTableAC), a4 = 15 & i4, r3 = i4 >> 4;
      if (0 === a4) {
        if (r3 < 15)
          break;
        s3 += 16;
        continue;
      }
      s3 += r3;
      const n3 = ti[s3];
      e3.blockData[t3 + n3] = receiveAndExtend(a4);
      s3++;
    }
  };
  let k2, R2 = 0;
  const N2 = 1 === m2 ? a2[0].blocksPerLine * a2[0].blocksPerColumn : C2 * i2.mcusPerColumn;
  let G2, x2;
  for (; R2 <= N2; ) {
    const i3 = s2 ? Math.min(N2 - R2, s2) : N2;
    if (i3 > 0) {
      for (w2 = 0; w2 < m2; w2++)
        a2[w2].pred = 0;
      u2 = 0;
      if (1 === m2) {
        y2 = a2[0];
        for (F2 = 0; F2 < i3; F2++) {
          decodeBlock(y2, S2, R2);
          R2++;
        }
      } else
        for (F2 = 0; F2 < i3; F2++) {
          for (w2 = 0; w2 < m2; w2++) {
            y2 = a2[w2];
            G2 = y2.h;
            x2 = y2.v;
            for (D2 = 0; D2 < x2; D2++)
              for (b2 = 0; b2 < G2; b2++)
                decodeMcu(y2, S2, R2, D2, b2);
          }
          R2++;
        }
    }
    E2 = 0;
    k2 = findNextFileMarker(e2, t2);
    if (!k2)
      break;
    if (k2.invalid) {
      warn(`decodeScan - ${i3 > 0 ? "unexpected" : "excessive"} MCU data, current marker is: ${k2.invalid}`);
      t2 = k2.offset;
    }
    if (!(k2.marker >= 65488 && k2.marker <= 65495))
      break;
    t2 += 2;
  }
  return t2 - l2;
}
function quantizeAndInverse(e2, t2, i2) {
  const a2 = e2.quantizationTable, s2 = e2.blockData;
  let r2, n2, g2, o2, c2, C2, h2, l2, Q2, E2, u2, d2, f2, p2, m2, y2, w2;
  if (!a2)
    throw new JpegError("missing required Quantization Table.");
  for (let e3 = 0; e3 < 64; e3 += 8) {
    Q2 = s2[t2 + e3];
    E2 = s2[t2 + e3 + 1];
    u2 = s2[t2 + e3 + 2];
    d2 = s2[t2 + e3 + 3];
    f2 = s2[t2 + e3 + 4];
    p2 = s2[t2 + e3 + 5];
    m2 = s2[t2 + e3 + 6];
    y2 = s2[t2 + e3 + 7];
    Q2 *= a2[e3];
    if (0 != (E2 | u2 | d2 | f2 | p2 | m2 | y2)) {
      E2 *= a2[e3 + 1];
      u2 *= a2[e3 + 2];
      d2 *= a2[e3 + 3];
      f2 *= a2[e3 + 4];
      p2 *= a2[e3 + 5];
      m2 *= a2[e3 + 6];
      y2 *= a2[e3 + 7];
      r2 = oi * Q2 + 128 >> 8;
      n2 = oi * f2 + 128 >> 8;
      g2 = u2;
      o2 = m2;
      c2 = Ii * (E2 - y2) + 128 >> 8;
      l2 = Ii * (E2 + y2) + 128 >> 8;
      C2 = d2 << 4;
      h2 = p2 << 4;
      r2 = r2 + n2 + 1 >> 1;
      n2 = r2 - n2;
      w2 = g2 * gi + o2 * ni + 128 >> 8;
      g2 = g2 * ni - o2 * gi + 128 >> 8;
      o2 = w2;
      c2 = c2 + h2 + 1 >> 1;
      h2 = c2 - h2;
      l2 = l2 + C2 + 1 >> 1;
      C2 = l2 - C2;
      r2 = r2 + o2 + 1 >> 1;
      o2 = r2 - o2;
      n2 = n2 + g2 + 1 >> 1;
      g2 = n2 - g2;
      w2 = c2 * ri + l2 * si + 2048 >> 12;
      c2 = c2 * si - l2 * ri + 2048 >> 12;
      l2 = w2;
      w2 = C2 * ai + h2 * ii + 2048 >> 12;
      C2 = C2 * ii - h2 * ai + 2048 >> 12;
      h2 = w2;
      i2[e3] = r2 + l2;
      i2[e3 + 7] = r2 - l2;
      i2[e3 + 1] = n2 + h2;
      i2[e3 + 6] = n2 - h2;
      i2[e3 + 2] = g2 + C2;
      i2[e3 + 5] = g2 - C2;
      i2[e3 + 3] = o2 + c2;
      i2[e3 + 4] = o2 - c2;
    } else {
      w2 = oi * Q2 + 512 >> 10;
      i2[e3] = w2;
      i2[e3 + 1] = w2;
      i2[e3 + 2] = w2;
      i2[e3 + 3] = w2;
      i2[e3 + 4] = w2;
      i2[e3 + 5] = w2;
      i2[e3 + 6] = w2;
      i2[e3 + 7] = w2;
    }
  }
  for (let e3 = 0; e3 < 8; ++e3) {
    Q2 = i2[e3];
    E2 = i2[e3 + 8];
    u2 = i2[e3 + 16];
    d2 = i2[e3 + 24];
    f2 = i2[e3 + 32];
    p2 = i2[e3 + 40];
    m2 = i2[e3 + 48];
    y2 = i2[e3 + 56];
    if (0 != (E2 | u2 | d2 | f2 | p2 | m2 | y2)) {
      r2 = oi * Q2 + 2048 >> 12;
      n2 = oi * f2 + 2048 >> 12;
      g2 = u2;
      o2 = m2;
      c2 = Ii * (E2 - y2) + 2048 >> 12;
      l2 = Ii * (E2 + y2) + 2048 >> 12;
      C2 = d2;
      h2 = p2;
      r2 = 4112 + (r2 + n2 + 1 >> 1);
      n2 = r2 - n2;
      w2 = g2 * gi + o2 * ni + 2048 >> 12;
      g2 = g2 * ni - o2 * gi + 2048 >> 12;
      o2 = w2;
      c2 = c2 + h2 + 1 >> 1;
      h2 = c2 - h2;
      l2 = l2 + C2 + 1 >> 1;
      C2 = l2 - C2;
      r2 = r2 + o2 + 1 >> 1;
      o2 = r2 - o2;
      n2 = n2 + g2 + 1 >> 1;
      g2 = n2 - g2;
      w2 = c2 * ri + l2 * si + 2048 >> 12;
      c2 = c2 * si - l2 * ri + 2048 >> 12;
      l2 = w2;
      w2 = C2 * ai + h2 * ii + 2048 >> 12;
      C2 = C2 * ii - h2 * ai + 2048 >> 12;
      h2 = w2;
      Q2 = r2 + l2;
      y2 = r2 - l2;
      E2 = n2 + h2;
      m2 = n2 - h2;
      u2 = g2 + C2;
      p2 = g2 - C2;
      d2 = o2 + c2;
      f2 = o2 - c2;
      Q2 < 16 ? Q2 = 0 : Q2 >= 4080 ? Q2 = 255 : Q2 >>= 4;
      E2 < 16 ? E2 = 0 : E2 >= 4080 ? E2 = 255 : E2 >>= 4;
      u2 < 16 ? u2 = 0 : u2 >= 4080 ? u2 = 255 : u2 >>= 4;
      d2 < 16 ? d2 = 0 : d2 >= 4080 ? d2 = 255 : d2 >>= 4;
      f2 < 16 ? f2 = 0 : f2 >= 4080 ? f2 = 255 : f2 >>= 4;
      p2 < 16 ? p2 = 0 : p2 >= 4080 ? p2 = 255 : p2 >>= 4;
      m2 < 16 ? m2 = 0 : m2 >= 4080 ? m2 = 255 : m2 >>= 4;
      y2 < 16 ? y2 = 0 : y2 >= 4080 ? y2 = 255 : y2 >>= 4;
      s2[t2 + e3] = Q2;
      s2[t2 + e3 + 8] = E2;
      s2[t2 + e3 + 16] = u2;
      s2[t2 + e3 + 24] = d2;
      s2[t2 + e3 + 32] = f2;
      s2[t2 + e3 + 40] = p2;
      s2[t2 + e3 + 48] = m2;
      s2[t2 + e3 + 56] = y2;
    } else {
      w2 = oi * Q2 + 8192 >> 14;
      w2 = w2 < -2040 ? 0 : w2 >= 2024 ? 255 : w2 + 2056 >> 4;
      s2[t2 + e3] = w2;
      s2[t2 + e3 + 8] = w2;
      s2[t2 + e3 + 16] = w2;
      s2[t2 + e3 + 24] = w2;
      s2[t2 + e3 + 32] = w2;
      s2[t2 + e3 + 40] = w2;
      s2[t2 + e3 + 48] = w2;
      s2[t2 + e3 + 56] = w2;
    }
  }
}
function buildComponentData(e2, t2) {
  const i2 = t2.blocksPerLine, a2 = t2.blocksPerColumn, s2 = new Int16Array(64);
  for (let e3 = 0; e3 < a2; e3++)
    for (let a3 = 0; a3 < i2; a3++) {
      quantizeAndInverse(t2, getBlockBufferOffset(t2, e3, a3), s2);
    }
  return t2.blockData;
}
function findNextFileMarker(e2, t2, i2 = t2) {
  const a2 = e2.length - 1;
  let s2 = i2 < t2 ? i2 : t2;
  if (t2 >= a2)
    return null;
  const r2 = readUint16(e2, t2);
  if (r2 >= 65472 && r2 <= 65534)
    return { invalid: null, marker: r2, offset: t2 };
  let n2 = readUint16(e2, s2);
  for (; !(n2 >= 65472 && n2 <= 65534); ) {
    if (++s2 >= a2)
      return null;
    n2 = readUint16(e2, s2);
  }
  return { invalid: r2.toString(16), marker: n2, offset: s2 };
}
var JpegImage = class {
  constructor({ decodeTransform: e2 = null, colorTransform: t2 = -1 } = {}) {
    this._decodeTransform = e2;
    this._colorTransform = t2;
  }
  parse(e2, { dnlScanLines: t2 = null } = {}) {
    function readDataBlock() {
      const t3 = readUint16(e2, s2);
      s2 += 2;
      let i3 = s2 + t3 - 2;
      const a3 = findNextFileMarker(e2, i3, s2);
      if (a3 == null ? void 0 : a3.invalid) {
        warn("readDataBlock - incorrect length, current marker is: " + a3.invalid);
        i3 = a3.offset;
      }
      const r3 = e2.subarray(s2, i3);
      s2 += r3.length;
      return r3;
    }
    function prepareComponents(e3) {
      const t3 = Math.ceil(e3.samplesPerLine / 8 / e3.maxH), i3 = Math.ceil(e3.scanLines / 8 / e3.maxV);
      for (const a3 of e3.components) {
        const s3 = Math.ceil(Math.ceil(e3.samplesPerLine / 8) * a3.h / e3.maxH), r3 = Math.ceil(Math.ceil(e3.scanLines / 8) * a3.v / e3.maxV), n3 = t3 * a3.h, g3 = 64 * (i3 * a3.v) * (n3 + 1);
        a3.blockData = new Int16Array(g3);
        a3.blocksPerLine = s3;
        a3.blocksPerColumn = r3;
      }
      e3.mcusPerLine = t3;
      e3.mcusPerColumn = i3;
    }
    let i2, a2, s2 = 0, r2 = null, n2 = null, g2 = 0;
    const o2 = [], c2 = [], C2 = [];
    let h2 = readUint16(e2, s2);
    s2 += 2;
    if (65496 !== h2)
      throw new JpegError("SOI not found");
    h2 = readUint16(e2, s2);
    s2 += 2;
    A:
      for (; 65497 !== h2; ) {
        let l2, Q2, E2;
        switch (h2) {
          case 65504:
          case 65505:
          case 65506:
          case 65507:
          case 65508:
          case 65509:
          case 65510:
          case 65511:
          case 65512:
          case 65513:
          case 65514:
          case 65515:
          case 65516:
          case 65517:
          case 65518:
          case 65519:
          case 65534:
            const u2 = readDataBlock();
            65504 === h2 && 74 === u2[0] && 70 === u2[1] && 73 === u2[2] && 70 === u2[3] && 0 === u2[4] && (r2 = { version: { major: u2[5], minor: u2[6] }, densityUnits: u2[7], xDensity: u2[8] << 8 | u2[9], yDensity: u2[10] << 8 | u2[11], thumbWidth: u2[12], thumbHeight: u2[13], thumbData: u2.subarray(14, 14 + 3 * u2[12] * u2[13]) });
            65518 === h2 && 65 === u2[0] && 100 === u2[1] && 111 === u2[2] && 98 === u2[3] && 101 === u2[4] && (n2 = { version: u2[5] << 8 | u2[6], flags0: u2[7] << 8 | u2[8], flags1: u2[9] << 8 | u2[10], transformCode: u2[11] });
            break;
          case 65499:
            const d2 = readUint16(e2, s2);
            s2 += 2;
            const f2 = d2 + s2 - 2;
            let p2;
            for (; s2 < f2; ) {
              const t3 = e2[s2++], i3 = new Uint16Array(64);
              if (t3 >> 4 == 0)
                for (Q2 = 0; Q2 < 64; Q2++) {
                  p2 = ti[Q2];
                  i3[p2] = e2[s2++];
                }
              else {
                if (t3 >> 4 != 1)
                  throw new JpegError("DQT - invalid table spec");
                for (Q2 = 0; Q2 < 64; Q2++) {
                  p2 = ti[Q2];
                  i3[p2] = readUint16(e2, s2);
                  s2 += 2;
                }
              }
              o2[15 & t3] = i3;
            }
            break;
          case 65472:
          case 65473:
          case 65474:
            if (i2)
              throw new JpegError("Only single frame JPEGs supported");
            s2 += 2;
            i2 = {};
            i2.extended = 65473 === h2;
            i2.progressive = 65474 === h2;
            i2.precision = e2[s2++];
            const m2 = readUint16(e2, s2);
            s2 += 2;
            i2.scanLines = t2 || m2;
            i2.samplesPerLine = readUint16(e2, s2);
            s2 += 2;
            i2.components = [];
            i2.componentIds = {};
            const y2 = e2[s2++];
            let w2 = 0, D2 = 0;
            for (l2 = 0; l2 < y2; l2++) {
              const t3 = e2[s2], a3 = e2[s2 + 1] >> 4, r3 = 15 & e2[s2 + 1];
              w2 < a3 && (w2 = a3);
              D2 < r3 && (D2 = r3);
              const n3 = e2[s2 + 2];
              E2 = i2.components.push({ h: a3, v: r3, quantizationId: n3, quantizationTable: null });
              i2.componentIds[t3] = E2 - 1;
              s2 += 3;
            }
            i2.maxH = w2;
            i2.maxV = D2;
            prepareComponents(i2);
            break;
          case 65476:
            const b2 = readUint16(e2, s2);
            s2 += 2;
            for (l2 = 2; l2 < b2; ) {
              const t3 = e2[s2++], i3 = new Uint8Array(16);
              let a3 = 0;
              for (Q2 = 0; Q2 < 16; Q2++, s2++)
                a3 += i3[Q2] = e2[s2];
              const r3 = new Uint8Array(a3);
              for (Q2 = 0; Q2 < a3; Q2++, s2++)
                r3[Q2] = e2[s2];
              l2 += 17 + a3;
              (t3 >> 4 == 0 ? C2 : c2)[15 & t3] = buildHuffmanTable(i3, r3);
            }
            break;
          case 65501:
            s2 += 2;
            a2 = readUint16(e2, s2);
            s2 += 2;
            break;
          case 65498:
            const F2 = 1 == ++g2 && !t2;
            s2 += 2;
            const S2 = e2[s2++], k2 = [];
            for (l2 = 0; l2 < S2; l2++) {
              const t3 = e2[s2++], a3 = i2.componentIds[t3], r3 = i2.components[a3];
              r3.index = t3;
              const n3 = e2[s2++];
              r3.huffmanTableDC = C2[n3 >> 4];
              r3.huffmanTableAC = c2[15 & n3];
              k2.push(r3);
            }
            const R2 = e2[s2++], N2 = e2[s2++], G2 = e2[s2++];
            try {
              const t3 = decodeScan(e2, s2, i2, k2, a2, R2, N2, G2 >> 4, 15 & G2, F2);
              s2 += t3;
            } catch (t3) {
              if (t3 instanceof DNLMarkerError) {
                warn(`${t3.message} -- attempting to re-parse the JPEG image.`);
                return this.parse(e2, { dnlScanLines: t3.scanLines });
              }
              if (t3 instanceof EOIMarkerError) {
                warn(`${t3.message} -- ignoring the rest of the image data.`);
                break A;
              }
              throw t3;
            }
            break;
          case 65500:
            s2 += 4;
            break;
          case 65535:
            255 !== e2[s2] && s2--;
            break;
          default:
            const x2 = findNextFileMarker(e2, s2 - 2, s2 - 3);
            if (x2 == null ? void 0 : x2.invalid) {
              warn("JpegImage.parse - unexpected data, current marker is: " + x2.invalid);
              s2 = x2.offset;
              break;
            }
            if (!x2 || s2 >= e2.length - 1) {
              warn("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
              break A;
            }
            throw new JpegError("JpegImage.parse - unknown marker: " + h2.toString(16));
        }
        h2 = readUint16(e2, s2);
        s2 += 2;
      }
    if (!i2)
      throw new JpegError("JpegImage.parse - no frame data found.");
    this.width = i2.samplesPerLine;
    this.height = i2.scanLines;
    this.jfif = r2;
    this.adobe = n2;
    this.components = [];
    for (const e3 of i2.components) {
      const t3 = o2[e3.quantizationId];
      t3 && (e3.quantizationTable = t3);
      this.components.push({ index: e3.index, output: buildComponentData(0, e3), scaleX: e3.h / i2.maxH, scaleY: e3.v / i2.maxV, blocksPerLine: e3.blocksPerLine, blocksPerColumn: e3.blocksPerColumn });
    }
    this.numComponents = this.components.length;
  }
  _getLinearizedBlockData(e2, t2, i2 = false) {
    const a2 = this.width / e2, s2 = this.height / t2;
    let r2, n2, g2, o2, c2, C2, h2, l2, Q2, E2, u2, d2 = 0;
    const f2 = this.components.length, p2 = e2 * t2 * f2, m2 = new Uint8ClampedArray(p2), y2 = new Uint32Array(e2), w2 = 4294967288;
    let D2;
    for (h2 = 0; h2 < f2; h2++) {
      r2 = this.components[h2];
      n2 = r2.scaleX * a2;
      g2 = r2.scaleY * s2;
      d2 = h2;
      u2 = r2.output;
      o2 = r2.blocksPerLine + 1 << 3;
      if (n2 !== D2) {
        for (c2 = 0; c2 < e2; c2++) {
          l2 = 0 | c2 * n2;
          y2[c2] = (l2 & w2) << 3 | 7 & l2;
        }
        D2 = n2;
      }
      for (C2 = 0; C2 < t2; C2++) {
        l2 = 0 | C2 * g2;
        E2 = o2 * (l2 & w2) | (7 & l2) << 3;
        for (c2 = 0; c2 < e2; c2++) {
          m2[d2] = u2[E2 + y2[c2]];
          d2 += f2;
        }
      }
    }
    let b2 = this._decodeTransform;
    i2 || 4 !== f2 || b2 || (b2 = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]));
    if (b2)
      for (h2 = 0; h2 < p2; )
        for (l2 = 0, Q2 = 0; l2 < f2; l2++, h2++, Q2 += 2)
          m2[h2] = (m2[h2] * b2[Q2] >> 8) + b2[Q2 + 1];
    return m2;
  }
  get _isColorConversionNeeded() {
    return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this._colorTransform && (82 !== this.components[0].index || 71 !== this.components[1].index || 66 !== this.components[2].index) : 1 === this._colorTransform;
  }
  _convertYccToRgb(e2) {
    let t2, i2, a2;
    for (let s2 = 0, r2 = e2.length; s2 < r2; s2 += 3) {
      t2 = e2[s2];
      i2 = e2[s2 + 1];
      a2 = e2[s2 + 2];
      e2[s2] = t2 - 179.456 + 1.402 * a2;
      e2[s2 + 1] = t2 + 135.459 - 0.344 * i2 - 0.714 * a2;
      e2[s2 + 2] = t2 - 226.816 + 1.772 * i2;
    }
    return e2;
  }
  _convertYccToRgba(e2, t2) {
    for (let i2 = 0, a2 = 0, s2 = e2.length; i2 < s2; i2 += 3, a2 += 4) {
      const s3 = e2[i2], r2 = e2[i2 + 1], n2 = e2[i2 + 2];
      t2[a2] = s3 - 179.456 + 1.402 * n2;
      t2[a2 + 1] = s3 + 135.459 - 0.344 * r2 - 0.714 * n2;
      t2[a2 + 2] = s3 - 226.816 + 1.772 * r2;
      t2[a2 + 3] = 255;
    }
    return t2;
  }
  _convertYcckToRgb(e2) {
    let t2, i2, a2, s2, r2 = 0;
    for (let n2 = 0, g2 = e2.length; n2 < g2; n2 += 4) {
      t2 = e2[n2];
      i2 = e2[n2 + 1];
      a2 = e2[n2 + 2];
      s2 = e2[n2 + 3];
      e2[r2++] = i2 * (-660635669420364e-19 * i2 + 437130475926232e-18 * a2 - 54080610064599e-18 * t2 + 48449797120281e-17 * s2 - 0.154362151871126) - 122.67195406894 + a2 * (-957964378445773e-18 * a2 + 817076911346625e-18 * t2 - 0.00477271405408747 * s2 + 1.53380253221734) + t2 * (961250184130688e-18 * t2 - 0.00266257332283933 * s2 + 0.48357088451265) + s2 * (-336197177618394e-18 * s2 + 0.484791561490776);
      e2[r2++] = 107.268039397724 + i2 * (219927104525741e-19 * i2 - 640992018297945e-18 * a2 + 659397001245577e-18 * t2 + 426105652938837e-18 * s2 - 0.176491792462875) + a2 * (-778269941513683e-18 * a2 + 0.00130872261408275 * t2 + 770482631801132e-18 * s2 - 0.151051492775562) + t2 * (0.00126935368114843 * t2 - 0.00265090189010898 * s2 + 0.25802910206845) + s2 * (-318913117588328e-18 * s2 - 0.213742400323665);
      e2[r2++] = i2 * (-570115196973677e-18 * i2 - 263409051004589e-19 * a2 + 0.0020741088115012 * t2 - 0.00288260236853442 * s2 + 0.814272968359295) - 20.810012546947 + a2 * (-153496057440975e-19 * a2 - 132689043961446e-18 * t2 + 560833691242812e-18 * s2 - 0.195152027534049) + t2 * (0.00174418132927582 * t2 - 0.00255243321439347 * s2 + 0.116935020465145) + s2 * (-343531996510555e-18 * s2 + 0.24165260232407);
    }
    return e2.subarray(0, r2);
  }
  _convertYcckToRgba(e2) {
    for (let t2 = 0, i2 = e2.length; t2 < i2; t2 += 4) {
      const i3 = e2[t2], a2 = e2[t2 + 1], s2 = e2[t2 + 2], r2 = e2[t2 + 3];
      e2[t2] = a2 * (-660635669420364e-19 * a2 + 437130475926232e-18 * s2 - 54080610064599e-18 * i3 + 48449797120281e-17 * r2 - 0.154362151871126) - 122.67195406894 + s2 * (-957964378445773e-18 * s2 + 817076911346625e-18 * i3 - 0.00477271405408747 * r2 + 1.53380253221734) + i3 * (961250184130688e-18 * i3 - 0.00266257332283933 * r2 + 0.48357088451265) + r2 * (-336197177618394e-18 * r2 + 0.484791561490776);
      e2[t2 + 1] = 107.268039397724 + a2 * (219927104525741e-19 * a2 - 640992018297945e-18 * s2 + 659397001245577e-18 * i3 + 426105652938837e-18 * r2 - 0.176491792462875) + s2 * (-778269941513683e-18 * s2 + 0.00130872261408275 * i3 + 770482631801132e-18 * r2 - 0.151051492775562) + i3 * (0.00126935368114843 * i3 - 0.00265090189010898 * r2 + 0.25802910206845) + r2 * (-318913117588328e-18 * r2 - 0.213742400323665);
      e2[t2 + 2] = a2 * (-570115196973677e-18 * a2 - 263409051004589e-19 * s2 + 0.0020741088115012 * i3 - 0.00288260236853442 * r2 + 0.814272968359295) - 20.810012546947 + s2 * (-153496057440975e-19 * s2 - 132689043961446e-18 * i3 + 560833691242812e-18 * r2 - 0.195152027534049) + i3 * (0.00174418132927582 * i3 - 0.00255243321439347 * r2 + 0.116935020465145) + r2 * (-343531996510555e-18 * r2 + 0.24165260232407);
      e2[t2 + 3] = 255;
    }
    return e2;
  }
  _convertYcckToCmyk(e2) {
    let t2, i2, a2;
    for (let s2 = 0, r2 = e2.length; s2 < r2; s2 += 4) {
      t2 = e2[s2];
      i2 = e2[s2 + 1];
      a2 = e2[s2 + 2];
      e2[s2] = 434.456 - t2 - 1.402 * a2;
      e2[s2 + 1] = 119.541 - t2 + 0.344 * i2 + 0.714 * a2;
      e2[s2 + 2] = 481.816 - t2 - 1.772 * i2;
    }
    return e2;
  }
  _convertCmykToRgb(e2) {
    let t2, i2, a2, s2, r2 = 0;
    for (let n2 = 0, g2 = e2.length; n2 < g2; n2 += 4) {
      t2 = e2[n2];
      i2 = e2[n2 + 1];
      a2 = e2[n2 + 2];
      s2 = e2[n2 + 3];
      e2[r2++] = 255 + t2 * (-6747147073602441e-20 * t2 + 8379262121013727e-19 * i2 + 2894718188643294e-19 * a2 + 0.003264231057537806 * s2 - 1.1185611867203937) + i2 * (26374107616089405e-21 * i2 - 8626949158638572e-20 * a2 - 2748769067499491e-19 * s2 - 0.02155688794978967) + a2 * (-3878099212869363e-20 * a2 - 3267808279485286e-19 * s2 + 0.0686742238595345) - s2 * (3361971776183937e-19 * s2 + 0.7430659151342254);
      e2[r2++] = 255 + t2 * (13596372813588848e-20 * t2 + 924537132573585e-18 * i2 + 10567359618683593e-20 * a2 + 4791864687436512e-19 * s2 - 0.3109689587515875) + i2 * (-23545346108370344e-20 * i2 + 2702845253534714e-19 * a2 + 0.0020200308977307156 * s2 - 0.7488052167015494) + a2 * (6834815998235662e-20 * a2 + 15168452363460973e-20 * s2 - 0.09751927774728933) - s2 * (3189131175883281e-19 * s2 + 0.7364883807733168);
      e2[r2++] = 255 + t2 * (13598650411385307e-21 * t2 + 12423956175490851e-20 * i2 + 4751985097583589e-19 * a2 - 36729317476630422e-22 * s2 - 0.05562186980264034) + i2 * (16141380598724676e-20 * i2 + 9692239130725186e-19 * a2 + 7782692450036253e-19 * s2 - 0.44015232367526463) + a2 * (5068882914068769e-22 * a2 + 0.0017778369011375071 * s2 - 0.7591454649749609) - s2 * (3435319965105553e-19 * s2 + 0.7063770186160144);
    }
    return e2.subarray(0, r2);
  }
  _convertCmykToRgba(e2) {
    for (let t2 = 0, i2 = e2.length; t2 < i2; t2 += 4) {
      const i3 = e2[t2], a2 = e2[t2 + 1], s2 = e2[t2 + 2], r2 = e2[t2 + 3];
      e2[t2] = 255 + i3 * (-6747147073602441e-20 * i3 + 8379262121013727e-19 * a2 + 2894718188643294e-19 * s2 + 0.003264231057537806 * r2 - 1.1185611867203937) + a2 * (26374107616089405e-21 * a2 - 8626949158638572e-20 * s2 - 2748769067499491e-19 * r2 - 0.02155688794978967) + s2 * (-3878099212869363e-20 * s2 - 3267808279485286e-19 * r2 + 0.0686742238595345) - r2 * (3361971776183937e-19 * r2 + 0.7430659151342254);
      e2[t2 + 1] = 255 + i3 * (13596372813588848e-20 * i3 + 924537132573585e-18 * a2 + 10567359618683593e-20 * s2 + 4791864687436512e-19 * r2 - 0.3109689587515875) + a2 * (-23545346108370344e-20 * a2 + 2702845253534714e-19 * s2 + 0.0020200308977307156 * r2 - 0.7488052167015494) + s2 * (6834815998235662e-20 * s2 + 15168452363460973e-20 * r2 - 0.09751927774728933) - r2 * (3189131175883281e-19 * r2 + 0.7364883807733168);
      e2[t2 + 2] = 255 + i3 * (13598650411385307e-21 * i3 + 12423956175490851e-20 * a2 + 4751985097583589e-19 * s2 - 36729317476630422e-22 * r2 - 0.05562186980264034) + a2 * (16141380598724676e-20 * a2 + 9692239130725186e-19 * s2 + 7782692450036253e-19 * r2 - 0.44015232367526463) + s2 * (5068882914068769e-22 * s2 + 0.0017778369011375071 * r2 - 0.7591454649749609) - r2 * (3435319965105553e-19 * r2 + 0.7063770186160144);
      e2[t2 + 3] = 255;
    }
    return e2;
  }
  getData({ width: e2, height: t2, forceRGBA: i2 = false, forceRGB: a2 = false, isSourcePDF: s2 = false }) {
    if (this.numComponents > 4)
      throw new JpegError("Unsupported color mode");
    const r2 = this._getLinearizedBlockData(e2, t2, s2);
    if (1 === this.numComponents && (i2 || a2)) {
      const e3 = r2.length * (i2 ? 4 : 3), t3 = new Uint8ClampedArray(e3);
      let a3 = 0;
      if (i2)
        !function grayToRGBA(e4, t4) {
          if (FeatureTest.isLittleEndian)
            for (let i3 = 0, a4 = e4.length; i3 < a4; i3++)
              t4[i3] = 65793 * e4[i3] | 4278190080;
          else
            for (let i3 = 0, a4 = e4.length; i3 < a4; i3++)
              t4[i3] = 16843008 * e4[i3] | 255;
        }(r2, new Uint32Array(t3.buffer));
      else
        for (const e4 of r2) {
          t3[a3++] = e4;
          t3[a3++] = e4;
          t3[a3++] = e4;
        }
      return t3;
    }
    if (3 === this.numComponents && this._isColorConversionNeeded) {
      if (i2) {
        const e3 = new Uint8ClampedArray(r2.length / 3 * 4);
        return this._convertYccToRgba(r2, e3);
      }
      return this._convertYccToRgb(r2);
    }
    if (4 === this.numComponents) {
      if (this._isColorConversionNeeded)
        return i2 ? this._convertYcckToRgba(r2) : a2 ? this._convertYcckToRgb(r2) : this._convertYcckToCmyk(r2);
      if (i2)
        return this._convertCmykToRgba(r2);
      if (a2)
        return this._convertCmykToRgb(r2);
    }
    return r2;
  }
};
var JpegStream = class extends DecodeStream {
  constructor(e2, t2, i2) {
    super(t2);
    this.stream = e2;
    this.dict = e2.dict;
    this.maybeLength = t2;
    this.params = i2;
  }
  get bytes() {
    return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(e2) {
  }
  readBlock() {
    this.decodeImage();
  }
  decodeImage(e2) {
    if (this.eof)
      return this.buffer;
    e2 || (e2 = this.bytes);
    for (let t3 = 0, i3 = e2.length - 1; t3 < i3; t3++)
      if (255 === e2[t3] && 216 === e2[t3 + 1]) {
        t3 > 0 && (e2 = e2.subarray(t3));
        break;
      }
    const t2 = { decodeTransform: void 0, colorTransform: void 0 }, i2 = this.dict.getArray("D", "Decode");
    if ((this.forceRGBA || this.forceRGB) && Array.isArray(i2)) {
      const e3 = this.dict.get("BPC", "BitsPerComponent") || 8, a3 = i2.length, s3 = new Int32Array(a3);
      let r2 = false;
      const n2 = (1 << e3) - 1;
      for (let e4 = 0; e4 < a3; e4 += 2) {
        s3[e4] = 256 * (i2[e4 + 1] - i2[e4]) | 0;
        s3[e4 + 1] = i2[e4] * n2 | 0;
        256 === s3[e4] && 0 === s3[e4 + 1] || (r2 = true);
      }
      r2 && (t2.decodeTransform = s3);
    }
    if (this.params instanceof Dict) {
      const e3 = this.params.get("ColorTransform");
      Number.isInteger(e3) && (t2.colorTransform = e3);
    }
    const a2 = new JpegImage(t2);
    a2.parse(e2);
    const s2 = a2.getData({ width: this.drawWidth, height: this.drawHeight, forceRGBA: this.forceRGBA, forceRGB: this.forceRGB, isSourcePDF: true });
    this.buffer = s2;
    this.bufferLength = s2.length;
    this.eof = true;
    return this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
};
var ci;
var _a2;
var Ci = (ci = "undefined" != typeof document ? (_a2 = document.currentScript) == null ? void 0 : _a2.src : void 0, function(e2 = {}) {
  var t2, i2, a2 = e2;
  new Promise((e3, a3) => {
    t2 = e3;
    i2 = a3;
  });
  a2.decode = function(e3, { numComponents: t3 = 4, isIndexedColormap: i3 = false, smaskInData: s3 = false }) {
    const r3 = e3.length, n3 = a2._malloc(r3);
    a2.HEAPU8.set(e3, n3);
    const g3 = a2._jp2_decode(n3, r3, t3 > 0 ? t3 : 0, !!i3, !!s3);
    a2._free(n3);
    if (g3) {
      const { errorMessages: e4 } = a2;
      if (e4) {
        delete a2.errorMessages;
        return e4;
      }
      return "Unknown error";
    }
    const { imageData: o3 } = a2;
    a2.imageData = null;
    return o3;
  };
  var s2, r2 = Object.assign({}, a2), n2 = "./this.program", g2 = "";
  "undefined" != typeof document && document.currentScript && (g2 = document.currentScript.src);
  ci && (g2 = ci);
  g2 = g2.startsWith("blob:") ? "" : g2.substr(0, g2.replace(/[?#].*/, "").lastIndexOf("/") + 1);
  var o2, c2, C2, h2, l2, Q2 = a2.print || console.log.bind(console), E2 = a2.printErr || console.error.bind(console);
  Object.assign(a2, r2);
  r2 = null;
  a2.arguments && a2.arguments;
  a2.thisProgram && (n2 = a2.thisProgram);
  a2.quit && a2.quit;
  a2.wasmBinary && (o2 = a2.wasmBinary);
  function tryParseAsDataURI(e3) {
    if (isDataURI(e3))
      return function intArrayFromBase64(e4) {
        for (var t3 = atob(e4), i3 = new Uint8Array(t3.length), a3 = 0; a3 < t3.length; ++a3)
          i3[a3] = t3.charCodeAt(a3);
        return i3;
      }(e3.slice(D2.length));
  }
  function updateMemoryViews() {
    var e3 = c2.buffer;
    a2.HEAP8 = C2 = new Int8Array(e3);
    a2.HEAP16 = new Int16Array(e3);
    a2.HEAPU8 = h2 = new Uint8Array(e3);
    a2.HEAPU16 = new Uint16Array(e3);
    a2.HEAP32 = new Int32Array(e3);
    a2.HEAPU32 = l2 = new Uint32Array(e3);
    a2.HEAPF32 = new Float32Array(e3);
    a2.HEAPF64 = new Float64Array(e3);
  }
  var u2, d2 = [], f2 = [], p2 = [], m2 = 0, y2 = null, w2 = null, D2 = "data:application/octet-stream;base64,", isDataURI = (e3) => e3.startsWith(D2);
  function instantiateSync(e3, t3) {
    var i3, a3 = function getBinarySync(e4) {
      if (e4 == u2 && o2)
        return new Uint8Array(o2);
      var t4 = tryParseAsDataURI(e4);
      if (t4)
        return t4;
      if (s2)
        return s2(e4);
      throw 'sync fetching of the wasm failed: you can preload it to Module["wasmBinary"] manually, or emcc.py will do that for you when generating HTML (but not JS)';
    }(e3);
    i3 = new WebAssembly.Module(a3);
    return [new WebAssembly.Instance(i3, t3), i3];
  }
  var callRuntimeCallbacks = (e3) => {
    for (; e3.length > 0; )
      e3.shift()(a2);
  };
  a2.noExitRuntime;
  var b2, growMemory = (e3) => {
    var t3 = (e3 - c2.buffer.byteLength + 65535) / 65536;
    try {
      c2.grow(t3);
      updateMemoryViews();
      return 1;
    } catch (e4) {
    }
  }, F2 = {}, getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var e3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: n2 || "./this.program" };
      for (var t3 in F2)
        void 0 === F2[t3] ? delete e3[t3] : e3[t3] = F2[t3];
      var i3 = [];
      for (var t3 in e3)
        i3.push(`${t3}=${e3[t3]}`);
      getEnvStrings.strings = i3;
    }
    return getEnvStrings.strings;
  }, S2 = [null, [], []], k2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, UTF8ArrayToString = (e3, t3, i3) => {
    for (var a3 = t3 + i3, s3 = t3; e3[s3] && !(s3 >= a3); )
      ++s3;
    if (s3 - t3 > 16 && e3.buffer && k2)
      return k2.decode(e3.subarray(t3, s3));
    for (var r3 = ""; t3 < s3; ) {
      var n3 = e3[t3++];
      if (128 & n3) {
        var g3 = 63 & e3[t3++];
        if (192 != (224 & n3)) {
          var o3 = 63 & e3[t3++];
          if ((n3 = 224 == (240 & n3) ? (15 & n3) << 12 | g3 << 6 | o3 : (7 & n3) << 18 | g3 << 12 | o3 << 6 | 63 & e3[t3++]) < 65536)
            r3 += String.fromCharCode(n3);
          else {
            var c3 = n3 - 65536;
            r3 += String.fromCharCode(55296 | c3 >> 10, 56320 | 1023 & c3);
          }
        } else
          r3 += String.fromCharCode((31 & n3) << 6 | g3);
      } else
        r3 += String.fromCharCode(n3);
    }
    return r3;
  }, printChar = (e3, t3) => {
    var i3 = S2[e3];
    if (0 === t3 || 10 === t3) {
      (1 === e3 ? Q2 : E2)(UTF8ArrayToString(i3, 0));
      i3.length = 0;
    } else
      i3.push(t3);
  }, UTF8ToString = (e3, t3) => e3 ? UTF8ArrayToString(h2, e3, t3) : "", R2 = { c: (e3, t3, i3) => h2.copyWithin(e3, t3, t3 + i3), g: function _copy_pixels_1(e3, t3) {
    e3 >>= 2;
    const i3 = a2.imageData = new Uint8ClampedArray(t3), s3 = a2.HEAP32.subarray(e3, e3 + t3);
    i3.set(s3);
  }, f: function _copy_pixels_3(e3, t3, i3, s3) {
    e3 >>= 2;
    t3 >>= 2;
    i3 >>= 2;
    const r3 = a2.imageData = new Uint8ClampedArray(3 * s3), n3 = a2.HEAP32.subarray(e3, e3 + s3), g3 = a2.HEAP32.subarray(t3, t3 + s3), o3 = a2.HEAP32.subarray(i3, i3 + s3);
    for (let e4 = 0; e4 < s3; e4++) {
      r3[3 * e4] = n3[e4];
      r3[3 * e4 + 1] = g3[e4];
      r3[3 * e4 + 2] = o3[e4];
    }
  }, e: function _copy_pixels_4(e3, t3, i3, s3, r3) {
    e3 >>= 2;
    t3 >>= 2;
    i3 >>= 2;
    s3 >>= 2;
    const n3 = a2.imageData = new Uint8ClampedArray(4 * r3), g3 = a2.HEAP32.subarray(e3, e3 + r3), o3 = a2.HEAP32.subarray(t3, t3 + r3), c3 = a2.HEAP32.subarray(i3, i3 + r3), C3 = a2.HEAP32.subarray(s3, s3 + r3);
    for (let e4 = 0; e4 < r3; e4++) {
      n3[4 * e4] = g3[e4];
      n3[4 * e4 + 1] = o3[e4];
      n3[4 * e4 + 2] = c3[e4];
      n3[4 * e4 + 3] = C3[e4];
    }
  }, k: (e3) => {
    var t3 = h2.length, i3 = 2147483648;
    if ((e3 >>>= 0) > i3)
      return false;
    for (var a3, s3, r3 = 1; r3 <= 4; r3 *= 2) {
      var n3 = t3 * (1 + 0.2 / r3);
      n3 = Math.min(n3, e3 + 100663296);
      var g3 = Math.min(i3, (a3 = Math.max(e3, n3)) + ((s3 = 65536) - a3 % s3) % s3);
      if (growMemory(g3))
        return true;
    }
    return false;
  }, l: (e3, t3) => {
    var i3 = 0;
    getEnvStrings().forEach((a3, s3) => {
      var r3 = t3 + i3;
      l2[e3 + 4 * s3 >> 2] = r3;
      ((e4, t4) => {
        for (var i4 = 0; i4 < e4.length; ++i4)
          C2[t4++] = e4.charCodeAt(i4);
        C2[t4] = 0;
      })(a3, r3);
      i3 += a3.length + 1;
    });
    return 0;
  }, m: (e3, t3) => {
    var i3 = getEnvStrings();
    l2[e3 >> 2] = i3.length;
    var a3 = 0;
    i3.forEach((e4) => a3 += e4.length + 1);
    l2[t3 >> 2] = a3;
    return 0;
  }, n: (e3) => 52, j: function _fd_seek(e3, t3, i3, a3, s3) {
    return 70;
  }, b: (e3, t3, i3, a3) => {
    for (var s3 = 0, r3 = 0; r3 < i3; r3++) {
      var n3 = l2[t3 >> 2], g3 = l2[t3 + 4 >> 2];
      t3 += 8;
      for (var o3 = 0; o3 < g3; o3++)
        printChar(e3, h2[n3 + o3]);
      s3 += g3;
    }
    l2[a3 >> 2] = s3;
    return 0;
  }, o: function _gray_to_rgba(e3, t3) {
    e3 >>= 2;
    const i3 = a2.imageData = new Uint8ClampedArray(4 * t3), s3 = a2.HEAP32.subarray(e3, e3 + t3);
    for (let e4 = 0; e4 < t3; e4++) {
      i3[4 * e4] = i3[4 * e4 + 1] = i3[4 * e4 + 2] = s3[e4];
      i3[4 * e4 + 3] = 255;
    }
  }, i: function _graya_to_rgba(e3, t3, i3) {
    e3 >>= 2;
    t3 >>= 2;
    const s3 = a2.imageData = new Uint8ClampedArray(4 * i3), r3 = a2.HEAP32.subarray(e3, e3 + i3), n3 = a2.HEAP32.subarray(t3, t3 + i3);
    for (let e4 = 0; e4 < i3; e4++) {
      s3[4 * e4] = s3[4 * e4 + 1] = s3[4 * e4 + 2] = r3[e4];
      s3[4 * e4 + 3] = n3[e4];
    }
  }, d: function _jsPrintWarning(e3) {
    const t3 = UTF8ToString(e3);
    (a2.warn || console.warn)(`OpenJPEG: ${t3}`);
  }, h: function _rgb_to_rgba(e3, t3, i3, s3) {
    e3 >>= 2;
    t3 >>= 2;
    i3 >>= 2;
    const r3 = a2.imageData = new Uint8ClampedArray(4 * s3), n3 = a2.HEAP32.subarray(e3, e3 + s3), g3 = a2.HEAP32.subarray(t3, t3 + s3), o3 = a2.HEAP32.subarray(i3, i3 + s3);
    for (let e4 = 0; e4 < s3; e4++) {
      r3[4 * e4] = n3[e4];
      r3[4 * e4 + 1] = g3[e4];
      r3[4 * e4 + 2] = o3[e4];
      r3[4 * e4 + 3] = 255;
    }
  }, a: function _storeErrorMessage(e3) {
    const t3 = UTF8ToString(e3);
    a2.errorMessages ? a2.errorMessages += "\n" + t3 : a2.errorMessages = t3;
  } }, N2 = function createWasm() {
    var e3 = /* @__PURE__ */ function getWasmImports() {
      return { a: R2 };
    }();
    function receiveInstance(e4, t3) {
      N2 = e4.exports;
      c2 = N2.p;
      updateMemoryViews();
      !function addOnInit(e5) {
        f2.unshift(e5);
      }(N2.q);
      !function removeRunDependency(e5) {
        var _a4;
        m2--;
        (_a4 = a2.monitorRunDependencies) == null ? void 0 : _a4.call(a2, m2);
        if (0 == m2) {
          if (null !== y2) {
            clearInterval(y2);
            y2 = null;
          }
          if (w2) {
            var t4 = w2;
            w2 = null;
            t4();
          }
        }
      }();
      return N2;
    }
    !function addRunDependency(e4) {
      var _a4;
      m2++;
      (_a4 = a2.monitorRunDependencies) == null ? void 0 : _a4.call(a2, m2);
    }();
    if (a2.instantiateWasm)
      try {
        return a2.instantiateWasm(e3, receiveInstance);
      } catch (e4) {
        E2(`Module.instantiateWasm callback failed with error: ${e4}`);
        i2(e4);
      }
    u2 || (u2 = "data:application/octet-stream;base64,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A0kNAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAswAQF/AkAgAEUNACABRQ0AQQggACABbCIBECUiAARAIABBACABEBUaCyAAIQILIAILEQAgAEUEQEEADwtBCCAAECUL8gICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLIAALJwEBfyMAQRBrIgMkACADIAI2AgwgACABIAJBAEEAEGsgA0EQaiQAC+gFAQl/IAFFBEBBAA8LAn8gAEUE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ACAEIE5BCmpBAiAFEBpBAkcEQCAFQQFBAiAAKAK4ARtBlhJBABAPIAAoArgBRSFnDAELIE5BCmogTkEMakECEBEgTigCDCIBQZD/A0YNACABQdn/A0YEQCAAQYACNgIIIABBADYCzAEMAQsgBCkDCCKGAVAEfkIABSCGASAEKQM4fQtQBEAgAEHAADYCCCAFQQJBrD9BABAPDAELQQAhZyAFQQFB7D5BABAPCyBOQRBqJAAgZwsLACAABEAgABAQCwu0AQEBfyAAKAIMRQRAIAIgACgCJCABEQMADwsCQEEIEBQiA0UNACADIAI2AgQgAyABNgIAQQgQFCIBRQRAIAMQEA8LIAEgAzYCACAAIAAoAgRB5ABsIgI2AigDQCAAKAIYIAJKDQALIAEgACgCFDYCBCAAIAE2AhQgACAAKAIYQQFqNgIYIAAoAhwiAUUNACABKAIAQQA2AgggACABKAIENgIcIAAgACgCIEEBazYCICABEBALC/oCAQR/AkAgAEUNACAAKAKsKCIBBEAgACgCqCgiAgRAQQAhAQNAIAAoAqwoIAFBA3RqKAIAIgMEQCADEBAgACgCqCghAgsgAUEBaiIBIAJJDQALIAAoAqwoIQELIABBADYCqCggARAQIABBADYCrCgLIAAoArQoIgEEQCABEBAgAEEANgK0KAsgACgC0CsiAQRAIAEQECAAQQA2AtArCyAAKALsKyIBBEAgARAQIABBADYC7CsLIAAoAugrIgEEQCABEBAgAEEANgLoKwsgACgC/CsiAQRAIAEQECAAQQA2AoQsIABCADcC/CsLIAAoAvArIgEEQCAAKAL0KyIDBH9BACECA0AgASgCDCIEBEAgBBAQIAFBADYCDCAAKAL0KyEDCyABQRRqIQEgAkEBaiICIANJDQALIAAoAvArBSABCxAQIABBADYC8CsLIAAoAuQrIgEEQCABEBAgAEEANgLkKwsgACgC3CsiAUUNACABEBAgAEIANwLcKwsLyAcCEX8BfiAAKAIQIghBIE8EQCAAKQMIpw8LAkAgACgCFCIDQQROBEAgACgCACICQQNrKAIAIQEgACADQQRrIgM2AhQgACACQQRrNgIADAELIANBAEwEQAwBCyADQQFxIQ0gACgCACECAkAgA0EBRgRAQRghBAwBCyADQf7///8HcSEJQRghBANAIAAgAkEB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IABBADYCiAEgACgCZBAQIABBADYCZCAALQC8AUECcUUEQCAAKAKoARAQCyAAQdAAakEAQfAAEBUaIAAoAsABEDIgAEEANgLAASAAKALEARAyIABBADYCwAEgACgCyAEiAQRAIAEoAhwiAgRAIAIQECABQQA2AhwLIAEoAigiAgRAIAEoAiQEQANAIAIgBUEobCIDaigCJCIEBEAgBBAQIAEoAigiAiADakEANgIkCyACIANqKAIQIgQEQCAEEBAgASgCKCICIANqQQA2AhALIAIgA2ooAhgiBARAIAQQECABKAIoIgIgA2pBADYCGAsgBUEBaiIFIAEoAiRJDQALCyACEBAgAUEANgIoCyABEBALIABBADYCyAEgACgCSBAhIABBADYCSCAAKAJMECEgAEEANgJMIAAoAtQBIgMEQAJAIAMoAghFDQAgAygCDARAIANBADYCKANAIAMoAhhBAEoNAAsLIANBATYCECADKAIAEBAgAygCHCICRQ0AA0AgAigCBCEBIAIQECADIAE2AhwgASICDQALCyADKAIkIgIEQCACKAIEIgVBAEoEQEEAIQEDQCACKAIAIAFBDGxqIgQoAggiBgRAIAQoAgQgBhECACACKAIEIQULIAFBAWoiASAFSA0ACwsgAigCABAQIAIQEAsgAxAQCyAAQQA2AtQBIAAQEAsL5gMCCH8EfiAAKAIUKAIAKAIUIAFBzABsaiIJKAIMIgggACgCGCgCGCABQTRsaiIKNQIEIhBCAX0iEiAANQI8fCAQgKciCyAIIAtJGyEMIAkoAggiCCAKNQIAIhFCAX0iEyAANQI4fCARgKciCiAIIApJGyEKIAkoAgQiCCASIAA1AjR8IBCApyILIAggC0sbIQsgCSgCACIIIBMgADUCMHwgEYCnIg0gCCANSxshDUEAIQggACgCICgC0CsgAUG4CGxqKAIUIQ4CQCAJKAIUQQAgAmtBfyACG2oiAkUEQCAKIQAgDSEIIAshAQwBCyADQQFxIAJBAWsiD3QiCSANSQRAIA0gCWutQn8gAq0iEIZCf4V8IBCIpyEIC0EAIQBBACEBIANBAXYgD3QiAyALSQRAIAsgA2utQn8gAq0iEIZCf4V8IBCIpyEBCyAJIApJBEAgCiAJa61CfyACrSIQhkJ/hXwgEIinIQALIAMgDE8EQEEAIQwMAQsgDCAD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IABBADYCPCAAQucHNwI0IABBADYCLCAAQucHNwIkIABBADYCHCAAQucHNwIUIABBADYCDCAAQucHNwIEIABBQGshACACQQRqIgIgA0cNAAsLIAFBA3EiAUUNAEEAIQIDQCAAQQA2AgwgAELnBzcCBCAAQRBqIQAgAkEBaiICIAFHDQALCwv7BQEQfyMAQYACayIIJAACf0EBQRQQEyIGRQRAIAJBAUH0MEEAEA9BAAwBCyAGIAE2AgQgBiAANgIAIAggATYCACAIIAA2AoABA0AgCCAFIg1BAWoiBUECdCIHaiABQQFqQQJtIgM2AgAgCEGAAWogB2ogAEEBakECbSIHNgIAIAQgACABbCIJaiEEIAMhASAHIQAgCUEBSw0ACyAGIAQ2AgggBEUEQCAGEBBBAAwBCyAGIARBEBATIgM2AgwgA0UEQCACQQFB2hpBABAPIAYQEEEADAELIAYgBigCCCILQQR0NgIQIAMhACANBEAgAyAGKAIEIAYoAgBsQQR0aiIEIQEDQAJAIAggDkECdCICaigCACIJQQBMDQAgCUEBayEMQQAhBwJAIAhBgAFqIAJqKAIAIgJBAEwEQEEAIQUgCUEBRwRAIAlB/v///wdxIQoDQCAFIAxGIQ8gBUECaiEFIAEgBCAPGyIEIQEgB0ECaiIHIApHDQALCyAJQQFxDQEgBCEBDAILA0AgBCEFIAIhBANAAkAgACABNgIAIARBAUYEQCAAQRBqIQAgAUEQaiEBDAELIAAgATYCECABQRBqIQEgAEEgaiEAIARBAkohECAEQQJrIQQgEA0BCwsgASAFIAJBBHRqIAcgByAMRnJBAXEiChshBCABIAUgChshASAHQQFqIgcgCUcNAAsMAQsgASAEIAJBBHRqIAUgBSAMRnJBAXEiBRshESABIAQgBRshASARIQQLIA5BAWoiDiANRw0ACwsgAEEANgIAAkAgC0UNACALQQRPBEAgC0F8cSEAQQAhAQNAIANBADYCPCADQucHNwI0IANBADYCLCADQucHNwIkIANBADYCHCADQucHNwIUIANBADYCDCADQucHNwIEIANBQGshAyABQQRqIgEgAEcNAAsLIAtBA3EiAEUNAEEAIQEDQCADQQA2AgwgA0LnBzcCBCADQRBqIQMgAUEBaiIBIABHDQALCyAGCyESIAhBgAJqJAAgEgtTAQF/An8gAC0ADEH/AUYEQCAAQoD+g4DwADcCDEEAIAAoAggiASAAKAIETw0BGiAAIAFBAWo2AgggACABLQAAQYD+A3I2AgwLIABBADYCEEEBCwt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARBlIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLSQEBfwJAQQFBLBATIgEEQCABQQA2AhACQCAAQQBMBEAgAUEBQQgQEyIANgIkIABFDQEMAwsgAUEANgIMCyABEBALQQAhAQsgAQuRAgAgAEUEQEEADwsCfwJAIAFB/wBNDQACQEGU0AEoAgAoAgBFBEAgAUGAf3FBgL8DRg0CDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMAwsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMAwsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMAwsLQZTHAUEZNgIAQX8MAQsgACABOgAAQQELC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAwALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC3MBBn8gACgCACIDLAAAQTBrIgFBCUsEQEEADwsDQEF/IQQgAkHMmbPmAE0EQEF/IAEgAkEKbCIFaiABIAVB/////wdzSxshBAsgACADQQFqIgU2AgAgAywAASEGIAQhAiAFIQMgBkEwayIBQQpJDQALIAILtBQCFX8BfiMAQUBqIggkACAIIAE2AjwgCEEnaiEWIAhBKGohEQJAAkACQAJAA0BBACEHA0AgASENIAcgDkH/////B3NKDQIgByAOaiEOAkACQAJAAkAgASIHLQAAIgsEQANAAkACQCALQf8BcSIBRQRAIAchAQwBCyABQSVHDQEgByELA0AgCy0AAUElRwRAIAshAQwCCyAHQQFqIQcgCy0AAiEZIAtBAmoiASELIBlBJUYNAAsLIAcgDWsiByAOQf////8HcyIXSg0JIAAEQCAAIA0gBxAZCyAHDQcgCCABNgI8IAFBAWohB0F/IRACQCABLAABQTBrIglBCUsNACABLQACQSRHDQAgAUEDaiEHQQEhEiAJIRALIAggBzYCPEEAIQwCQCAHLAAAIgtBIGsiAUEfSwRAIAchCQwBCyAHIQlBASABdCIBQYnRBHFFDQADQCAIIAdBAWoiCTYCPCABIAxyIQwgBywAASILQSBrIgFBIE8NASAJIQdBASABdCIBQYnRBHENAAsLAkAgC0EqRgRAAn8CQCAJLAABQTBrIgFBCUsNACAJLQACQSRHDQACfyAARQRAIAQgAUECdGpBCjYCAEEADAELIAMgAUEDdGooAgALIQ8gCUEDaiEBQQEMAQsgEg0GIAlBAWohASAARQRAIAggATYCPEEAIRJBACEPDAMLIAIgAigCACIHQQRqNgIAIAcoAgAhD0EACyESIAggATYCPCAPQQBODQFBACAPayEPIAxBgMAAciEMDAELIAhBPGoQaSIPQQBIDQogCCgCPCEBC0EAIQdBfyEKAn9BACABLQAAQS5HDQAaIAEtAAFBKkYEQAJ/AkAgASwAAkEwayIJQQlLDQAgAS0AA0EkRw0AIAFBBGohAQJ/IABFBEAgBCAJQQJ0akEKNgIAQQAMAQsgAyAJQQN0aigCAAsMAQsgEg0GIAFBAmohAUEAIABFDQAaIAIgAigCACIJQQRqNgIAIAkoAgALIQogCCABNgI8IApBAE4MAQsgCCABQQFqNgI8IAhBPGoQaSEKIAgoAjwhAUEBCyETA0AgByEUQRwhCSABIhgsAAAiB0H7AGtBRkkNCyABQQFqIQEgByAUQTpsakG/wAFqLQAAIgdBAWtBCEkNAAsgCCABNgI8AkAgB0EbRwRAIAdFDQwgEEEATgRAIABFBEAgBCAQQQJ0aiAHNgIADAwLIAggAyAQQQN0aikDADcDMAwCCyAARQ0IIAhBMGogByACIAYQaAwBCyAQQQBODQtBACEHIABFDQgLIAAtAABBIHENCyAMQf//e3EiCyAMIAxBgMAAcRshDEEAIRBBsAghFSARIQkCQAJAAn8CQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIBgsAAAiB0FTcSAHIAdBD3FBA0YbIAcgFBsiB0HYAGsOIQQWFhYWFhYWFhAWCQYQEBAWBhYWFhYCBQMWFgoWARYWBAALAkAgB0HBAGsOBxAWCxYQEBAACyAHQdMARg0LDBULIAgpAzAhHEGwCAwFC0EAIQcCQAJAAkACQAJAAkACQCAUQf8BcQ4IAAECAwQcBQYcCyAIKAIwIA42AgAMGwsgCCgCMCAONgIADBoLIAgoAjAgDqw3AwAMGQsgCCgCMCAOOwEADBgLIAgoAjAgDjoAAAwXCyAIKAIwIA42AgAMFgsgCCgCMCAOrDcDAAwVC0EIIAogCkEITRshCiAMQQhyIQxB+AAhBwsgESEBIAgpAzAiHEIAUgRAIAdBIHEhDQNAIAFBAWsiASAcp0EPcUHQxAFqLQAAIA1yOgAAIBxCD1YhGiAcQgSIIRwgGg0ACwsgASENIAgpAzBQDQMgDEEIcUUNAyAHQQR2QbAIaiEVQQIhEAwDCyARIQEgCCkDMCIcQgBSBEADQCABQQFrIgEgHKdBB3FBMHI6AAAgHEIHViEbIBxCA4ghHCAbDQALCyABIQ0gDEEIcUUNAiAKIBEgAWsiAUEBaiABIApIGyEKDAILIAgpAzAiHEIAUwRAIAhCACAcfSIcNwMwQQEhEEGwCAwBCyAMQYAQcQRAQQEhEEGxCAwBC0GyCEGwCCAMQQFxIhAbCyEVIBwgERAqIQ0LIBMgCkEASHENESAMQf//e3EgDCATGyEMAkAgCCkDMCIcQgBSDQAgCg0AIBEhDUEAIQoMDgsgCiAcUCARIA1raiIBIAEgCkgbIQoMDQsgCCkDMCEcDAsLAn9B/////wcgCiAKQf////8HTxsiDCIHQQBHIQkCQAJAAkAgCCgCMCIBQYQMIAEbIg0iAUEDcUUNACAHRQ0AA0AgAS0AAEUNAiAHQQFrIgdBAEchCSABQQFqIgFBA3FFDQEgBw0ACwsgCUUNAQJAIAEtAABFDQAgB0EESQ0AA0BBgIKECCABKAIAIglrIAlyQYCBgoR4cUGAgYKEeEcNAiABQQRqIQEgB0EEayIHQQNLDQALCyAHRQ0BCwNAIAEgAS0AAEUNAhogAUEBaiEBIAdBAWsiBw0ACwtBAAsiASANayAMIAEbIgEgDWohCSAKQQBOBEAgCyEMIAEhCgwMCyALIQwgASEKIAktAAANDwwLCyAIKQMwIhxCAFINAUIAIRwMCQsgCgRAIAgoAjAMAgtBACEHIABBICAPQQAgDBAcDAILIAhBADYCDCAIIBw+AgggCCAIQQhqIgc2AjBBfyEKIAcLIQtBACEHA0ACQCALKAIAIg1FDQAgCEEEaiANEGciDUEASA0PIA0gCiAHa0sNACALQQRqIQsgByANaiIHIApJDQELC0E9IQkgB0EASA0MIABBICAPIAcgDBAcIAdFBEBBACEHDAELQQAhCSAIKAIwIQsDQCALKAIAIg1FDQEgCEEEaiIKIA0QZyINIAlqIgkgB0sNASAAIAogDRAZIAtBBGohCyAHIAlLDQALCyAAQSAgDyAHIAxBgMAAcxAcIA8gByAHIA9IGyEHDAgLIBMgCkEASHENCUE9IQkgACAIKwMwIA8gCiAMIAcgBRETACIHQQBODQcMCgsgBy0AASELIAdBAWohBwwACwALIAANCSASRQ0DQQEhBwNAIAQgB0ECdGooAgAiAARAIAMgB0EDdGogACACIAYQaEEBIQ4gB0EBaiIHQQpHDQEMCwsLQQEhDiAHQQpPDQkDQCAEIAdBAnRqKAIADQEgB0EBaiIHQQpHDQALDAkLQRwhCQwGCyAIIBw8ACdBASEKIBYhDSALIQwLIAogCSANayILIAogC0obIgogEEH/////B3NKDQNBPSEJIA8gCiAQaiIBIAEgD0gbIgcgF0oNBCAAQSAgByABIAwQHCAAIBUgEBAZIABBMCAHIAEgDEGAgARzEBwgAEEwIAogC0EAEBwgACANIAsQGSAAQSAgByABIAxBgMAAcxAcIAgoAjwhAQwBCwsLQQAhDgwDC0E9IQkLQZTHASAJNgIAC0F/IQ4LIAhBQGskACAOC6gCAQR/IwBB0AFrIgUkACAFIAI2AswBIAVBoAFqIgJBAEEoEBUaIAUgBSgCzAE2AsgBAkBBACABIAVByAFqIAVB0ABqIAIgAyAEEGpBAEgNACAAKAJMQQBIIQggACAAKAIAIgdBX3E2AgACfwJAAkAgACgCMEUEQCAAQdAANgIwIABBADYCHCAAQgA3AxAgACgCLCEGIAAgBTYCLAwBCyAAKAIQDQELQX8gABA+DQEaCyAAIAEgBUHIAWogBUHQAGogBUGgAWogAyAEEGoLIQEgBgR/IABBAEEAIAAoAiQRAAAaIABBADYCMCAAIAY2AiwgAEEANgIcIAAoAhQaIABCADcDEEEABSABCxogACAAKAIAIAdBIHFyNgIAIAgNAAsgBUHQAWokAAsnAQF/QRwhAyABQQNxBH9BHAUgACABIAIQJSIANgIAQQBBMCAAGwsL/QMBBX8Cf0HgxAEoAgAiAiAAQQdqQXhxIgFBB2pBeHEiA2ohAAJAIANBACAAIAJNG0UEQCAAPwBBEHRNDQEgABAKDQELQZTHAUEwNgIAQX8MAQtB4MQBIAA2AgAgAgsiAkF/RwRAIAEgAmoiAEEEa0EQNgIAIABBEGsiA0EQNgIAAkACf0GgzwEoAgAiAQR/IAEoAggFQQALIAJGBEAgAiACQQRrKAIAQX5xayIEQQRrKAIAIQUgASAANgIIIAQgBUF+cWsiACAAKAIAakEEay0AAEEBcQRAIAAoAgQiASAAKAIIIgQ2AgggBCABNgIEIAAgAyAAayIBNgIADAMLIAJBEGsMAQsgAkEQNgIAIAIgADYCCCACIAE2AgQgAkEQNgIMQaDPASACNgIAIAJBEGoLIgAgAyAAayIBNgIACyAAIAFBfHFqQQRrIAFBAXI2AgAgAAJ/IAAoAgBBCGsiAUH/AE0EQCABQQN2QQFrDAELIAFBHSABZyIDa3ZBBHMgA0ECdGtB7gBqIAFB/x9NDQAaQT8gAUEeIANrdkECcyADQQF0a0HHAGoiASABQT9PGwsiAUEEdCIDQaDHAWo2AgQgACADQajHAWoiAygCADYCCCADIAA2AgAgACgCCCAANgIEQajPAUGozwEpAwBCASABrYaENwMACyACQX9HC70BAQJ/AkAgACgCTCIBQQBOBEAgAUUNAUHMzwEoAgAgAUH/////A3FHDQELAkAgACgCUEEKRg0AIAAoAhQiASAAKAIQRg0AIAAgAUEBajYCFCABQQo6AAAPCyAAEG8PCyAAQcwAaiIBIAEoAgAiAkH/////AyACGzYCAAJAAkAgACgCUEEKRg0AIAAoAhQiAiAAKAIQRg0AIAAgAkEBajYCFCACQQo6AAAMAQsgABBvCyABKAIAGiABQQA2AgALfAECfyMAQRBrIgEkACABQQo6AA8CQAJAIAAoAhAiAgR/IAIFIAAQPg0CIAAoAhALIAAoAhQiAkYNACAAKAJQQQpGDQAgACACQQFqNgIUIAJBCjoAAAwBCyAAIAFBD2pBASAAKAIkEQAAQQFHDQAgAS0ADxoLIAFBEGokAAuwAgECfyAABEAgACgCABA4IABBADYCACAAKAJIIgEEQCABEBAgAEEANgJICyAAKAJEIgEEQCABEBAgAEEANgJECyAAKAJsIgEEQCABEBAgAEEANgJsCyAAKAJ0IgEEQCABKAIAIgIEQCACEBAgACgCdCIBQQA2AgALIAEQECAAQQA2AnQLIAAoAngiAQRAIAEoAgwiAgRAIAIQECAAKAJ4IgFBADYCDAsgASgCBCICBEAgAhAQIAAoAngiAUEANgIECyABKAIIIgIEQCACEBAgACgCeCIBQQA2AggLIAEoAgAiAgRAIAIQECAAKAJ4IgFBADYCAAsgARAQIABBADYCeAsgACgCBCIBBEAgARAyIABBADYCBAsgACgCCCIBBEAgARAyIABBADYCCAsgABAQCwuLGwIefwV7IwBB8AFrIgkkAEEBIQ4CQCAAKAIAKAI8DQAgACgCgAENAAJAAkAgACgCdCIIRQRAIAAoAnghBAwBCyABKAIQIQMgCC8BBCEGAkAgACgCeCIERQ0AIAQoAgxFDQAgBC0AEiEDCwJAIAYEQCAIKAIAIQgDQCAIIAVBBmxqIgovAQAiByADTwRAIAkgAzYCtAEgCSAHNgKwASACQQFBoOYAIAlBsAFqEA9BACEODAYLAkAgCi8BBCIKRQ0AIApB//8DRg0AIApBAWsiCiADSQ0AIAkgAzYCpAEgCSAKNgKgASACQQFBoOYAIAlBoAFqEA9BACEODAYLIAVBAWoiBSAGRw0ACwwBCyADDQIMAQsDQCADQQFrIQNBACEFA0AgCCAFQQZsai8BACADRwRAIAVBAWoiBSAGRw0BDAQLCyADDQALCwJAIARFDQAgBCgCDCIKRQ0AAkACQCAELQASIggEQEEAIQVBASEHA0AgASgCECIDIAogBUECdGovAQAiBE0EQCAJIAM2ApQBIAkgBDYCkAEgAkEBQaDmACAJQZABahAPQQAhBwsgBUEBaiIFIAhHDQALIAhBBBATIgNFDQFBACEFA0ACQCAKIAVBAnRqIgQtAAIiBkECTwRAIAkgBjYCRCAJIAU2AkAgAkEBQcvZACAJQUBrEA9BACEHDAELIAggBC0AAyIETQRAIAkgBDYCgAEgAkEBQZPZACAJQYABahAPQQAhBwwBCyADIARBAnRqIQsCQCAGQQFHIgwNACALKAIARQ0AIAkgBDYCUCACQQFBvNUAIAlB0ABqEA9BACEHDAELAkAgBg0AIARFDQAgCSAENgJkIAkgBTYCYCACQQFBitgAIAlB4ABqEA9BACEHDAELAkAgDA0AIAQgBUYNACAJIAQ2AnggCSAFNgJ0IAkgBTYCcCACQQFBrtgAIAlB8ABqEA9BACEHDAELIAtBATYCAAsgBUEBaiIFIAhHDQALQQAhBQNAAkACQCADIAVBAnQiBGooAgBFBEAgBCAKai0AAg0BCyAFQQFqIgUgCEcNAiAHRQ0BIAEoAhBBAUcNBUEAIQUDQCADIAVBAnRqKAIABEAgCCAFQQFqIgVHDQEMBwsLQQAhByACQQJB7sUAQQAQDyAIQRBPBEAgCEHwAXEhB0EAIQQDQCAKIARBAnRqIgZBAToAAiAGIAQ6AAMgBkEBOgA+IAZBAToAOiAGQQE6ADYgBkEBOgAyIAZBAToALiAGQQE6ACogBkEBOgAmIAZBAToAIiAGQQE6AB4gBkEBOgAaIAZBAToAFiAGQQE6ABIgBkEBOgAOIAZBAToACiAGQQE6AAYgBiAEQQFyOgAHIAYgBEEPcjoAPyAGIARBDnI6ADsgBiAEQQ1yOgA3IAYgBEEMcjoAMyAGIARBC3I6AC8gBiAEQQpyOgArIAYgBEEJcjoAJyAGIARBCHI6ACMgBiAEQQdyOgAfIAYgBEEGcjoAGyAGIARBBXI6ABcgBiAEQQRyOgATIAYgBEEDcjoADyAGIARBAnI6AAsgBEEQaiIEIAdHDQALIAcgCEYNBgsDQCAKIAdBAnRqIgQgBzoAAyAEQQE6AAIgB0EBaiIHIAhHDQALDAULIAkgBTYCMCACQQFByNIAIAlBMGoQD0EAIQcgBUEBaiIFIAhHDQELCyADEBBBACEODAULIAhBBBATIgMNAQtBACEOIAJBAUGK2wBBABAPDAMLIAMQEAsCQCAAKAJ4IgNFDQAgAygCDCIPRQRAIAMoAgQQECAAKAJ4KAIIEBAgACgCeCgCABAQIAAoAngiAygCDCIEBH8gBBAQIAAoAngFIAMLEBAgAEEANgJ4DAELIAEoAhghDQJAAkAgAy0AEiIKBEAgAygCACEUIAMoAgQhBiADKAIIIQhBACEFAkADQCANIA8gBUECdGovAQBBNGxqKAIsBEAgCiAFQQFqIgVHDQEMAgsLIAkgBTYCICACQQFBwucAIAlBIGoQD0EAIQ4MBgsgCkE0bBAUIgtFDQFBACEFA0AgDyAFQQJ0aiIDLwEAIQcgCyADLQACBH8gAy0AAwUgBQtBNGxqIgQgDSAHQTRsaiID/QACAP0LAgAgBCADKAIwNgIwIAQgA/0AAiD9CwIgIAQgA/0AAhD9CwIQIAsgBUE0bGoiBCADKAIIIAMoAgxsQQJ0EBgiAzYCLCADRQRAIAUEQCAFQf//A3EhAANAIABBNGwgC2pBCGsoAgAQECAAQQFrIgANAAsLIAsQEEEAIQ4gAkEBQY7nAEEAEA8MBwsgBCAFIAhqLQAANgIYIAQgBSAGai0AADYCICAFQQFqIgUgCkcNAAsgACgCeC8BECIQQQFrIRIDQCALIBNBNGxqIgMoAgwgAygCCGwhBiANIA8gE0ECdGoiBC8BAEE0bGooAiwhCAJAIAQtAAJFBEAgBkUNASADKAIsIQVBACEHQQAhBAJAIAZBBEkNACAFIAhrQRBJDQAgBkF8cSEEQQAhAwNAIAUgA0ECdCIMaiAIIAxq/QACAP0LAgAgA0EEaiIDIARHDQALIAQgBkYNAgsgBCEDIAZBA3EiDARAA0AgBSADQQJ0IhFqIAggEWooAgA2AgAgA0EBaiEDIAdBAWoiByAMRw0ACwsgBCAGa0F8Sw0BA0AgBSADQQJ0IgRqIAQgCGooAgA2AgAgBSAEQQRqIgdqIAcgCGooAgA2AgAgBSAEQQhqIgdqIAcgCGooAgA2AgAgBSAEQQxqIgRqIAQgCGooAgA2AgAgA0EEaiIDIAZHDQALDAELIAZFDQAgFCAELQADIgNBAnRqIQQgCyADQTRsaigCLCEFQQAhAyAGQQFHBEAgBkF+cSEVQQAhDANAIAUgA0ECdCIHaiAEIAcgCGooAgAiESASIBAgEUobQQAgEUEAThsgCmxBAnRqKAIANgIAIAUgB0EEciIHaiAEIAcgCGooAgAiByASIAcgEEgbQQAgB0EAThsgCmxBAnRqKAIANgIAIANBAmohAyAMQQJqIgwgFUcNAAsLIAZBAXFFDQAgBSADQQJ0IgNqIAQgAyAIaigCACIDIBIgAyAQSBtBACADQQBOGyAKbEECdGooAgA2AgALIBNBAWoiEyAKRw0ACwwCCyAKQTRsEBQiCw0BC0EAIQ4gAkEBQY7nAEEAEA8MAwsgASgCECIDBEBBACEFA0AgDSAFQTRsaigCLCIEBEAgBBAQCyAFQQFqIgUgA0cNAAsLIA0QECABIAo2AhAgASALNgIYCyAAKAJ0IgVFDQEgBSgCACEHIAUvAQQiCwRAIAdBKmohEiAHQSRqIRMgB0EeaiERIAdBGGohFCAHQRJqIRUgB0EMaiEWIAdBBmohFyALQQJrIRhBACEFQQEhBANAAkAgASgCECIDIAcgBUEGbGoiDS8BACIGTQRAIAkgAzYCFCAJIAY2AhAgAkECQcw3IAlBEGoQDwwBCyANLwEEIghBAWpB//8DcUEBTQRAIAEoAhggBkE0bGogDS8BAjsBMAwBCyAIQQFrIgpB//8DcSIPIANPBEAgCSADNgIEIAkgDzYCACACQQJBozcgCRAPDAELAkAgBiAPRg0AIA0vAQINACAJIAEoAhgiCCAGQTRsaiIDKAIwNgLoASAJIAP9AAIg/QsD2AEgCSAD/QACEP0LA8gBIAkgA/0AAgD9CwO4ASADIAggD0E0bCIMaiIIKQIINwIIIAMgCCkCEDcCECADIAgpAhg3AhggAyAIKQIgNwIgIAMgCCkCKDcCKCADIAgoAjA2AjAgAyAIKQIANwIAIAEoAhggDGoiAyAJ/QADuAH9CwIAIAMgCf0AA9gB/QsCICADIAn9AAPIAf0LAhAgAyAJKALoATYCMCAFQQFqIAtPDQAgBCEIIBggBWtB//8DcSIDQQdPBEAgBCADQQFqIhlB+P8HcSIQaiEIIAr9ECEkIAb9ECEjQQAhDANAICMgJCASIAQgDGpBBmwiA2oiGiADIBNqIhsgAyARaiIcIAMgFGoiHSADIBVqIh4gAyAWaiIfIAMgF2oiICADIAdqIgP9CAEA/VUBAAH9VQEAAv1VAQAD/VUBAAT9VQEABf1VAQAG/VUBAAciISAj/S4gISAk/S0iJf1O/VIhIiAhICP9LSAl/VAiIf0ZAEEBcQRAIAMgIv1ZAQAACyAh/RkBQQFxBEAgICAi/VkBAAELICH9GQJBAXEEQCAfICL9WQEAAgsgIf0ZA0EBcQRAIB4gIv1ZAQADCyAh/RkEQQFxBEAgHSAi/VkBAAQLICH9GQVBAXEEQCAcICL9WQEABQsgIf0ZBkEBcQRAIBsgIv1ZAQAGCyAh/RkHQQFxBEAgGiAi/VkBAAcLIAxBCGoiDCAQRw0ACyAQIBlGDQELA0AgCiEDAkAgBiAHIAhBBmxqIgwvAQAiEEcEQCAGIQMgDyAQRw0BCyAMIAM7AQALIAsgCEEBaiIIQf//A3FHDQALCyABKAIYIAZBNGxqIA0vAQI7ATALIARBAWohBCAFQQFqIgUgC0cNAAsgACgCdCIFKAIAIQcLIAcEfyAHEBAgACgCdAUgBQsQECAAQQA2AnQMAQtBACEOIAJBAUGhxgBBABAPCyAJQfABaiQAIA4L6QEBBn8jAEEgayIEJAACfwJAIAAoAjwiAwRAQQEhBQNAIAAoAkwoAhggACgCQCACQQJ0aigCACIGQTRsaigCLEUEQCAEIAY2AhAgAUECQdo5IARBEGoQD0EAIQUgACgCPCEDCyACQQFqIgIgA0kNAAsMAQtBASEFQQEgACgCTCIDKAIQRQ0BGgNAIAMoAhggAkE0bGooAixFBEAgBCACNgIAIAFBAkHaOSAEEA9BACEFIAAoAkwhAwsgAkEBaiICIAMoAhBJDQALC0EBIAUNABogAUEBQb8VQQAQD0EACyEHIARBIGokACAHCwQAQX8LhgcCFn8CfiAAKAIYIhAoAhBFBEBBAQ8LIBAoAhghDSAAKAIUKAIAKAIUIQsDQCABIA0oAiQiAjYCJCALKAIcIgYgAkGYAWxqIQMCQAJAAn8gACgCQCIRBEAgBiALKAIYQZgBbGoiAkGQAWsoAgAgAkGYAWsoAgBrIQwgA0EMaiEGIANBBGohBCADKAIIIQIgAygCACEFQSQMAQsgA0GUAWohBiADQYwBaiEEIAMoApABIgIgAygCiAEiBWshDEE0CyALaigCACISRQ0AIAQoAgAhByAGKAIAIQkgAiAFayEGIAEoAggiA0J/IAE1AigiGIZCf4UiGSABNQIQfCAYiKciCGohBAJ/IAUgCEsEQCAFIAhrIQ5BACEIQQAgAiAETQ0BGiAGIAQgBWsiBmsMAQsgCCAFayEIIAIgBE0EQCAGIAhrIQZBACEOQQAMAQtBACEOIAMhBiACIARrCyEVIAkgB2shAiABKAIMIgQgGSABNQIUfCAYiKciCmohBQJ/IAcgCksEQCAHIAprIQ9BACEKQQAgBSAJTw0BGiACIAUgB2siAmsMAQsgCiAHayEKIAUgCU8EQCACIAprIQJBACEPQQAMAQtBACEPIAQhAiAJIAVrCyEHQQAhBSAIQQBIDQEgCkEASA0BIBVBAEgNASAHQQBIDQEgBkEASA0BIAJBAEgNASADIA9sIA5qIQcgCiAMbCAIaiEJAkACQAJAIAEoAiwiCA0AIAkNACAHDQAgAyAMRw0AIAMgBkcNACACIARHDQEgASALQSRBNCARG2oiAigCADYCLCACQQA2AgAMAwsgCA0BCyAERQ0CIAStIAOtfkIgiKcNAiADIARsIgNB/////wNLDQIgASADQQJ0EBgiAzYCLCADRQ0CIAYgASgCCCIERiABKAIMIgUgAkZxDQAgA0EAIAQgBWxBAnQQFRoLIAJFDQAgAkEBcSEXIAZBAnQhBiABKAIsIAdBAnRqIQQgEiAJQQJ0aiEFIAJBAUcEQCACQf7///8HcSEHQQAhAgNAIAQgBSAGEBIhFiAFIAxBAnQiCWoiCCAJaiEFIBYgASgCCEECdGogCCAGEBIgASgCCEECdGohBCACQQJqIgIgB0cNAAsLIBdFDQAgBCAFIAYQEhoLIAtBzABqIQsgDUE0aiENIAFBNGohAUEBIQUgFEEBaiIUIBAoAhBJDQELCyAFC9USAgl/DH4jAEGgAWsiBSQAAkAgAkEjTQRAQQAhAiADQQFBti5BABAPDAELIAJBJGsiAiACQQNuIglBA2xHBEBBACECIANBAUG2LkEAEA8MAQsgACgCSCEGIAEgBUGcAWoiAkECEBEgACAFKAKcATsBUCABQQJqIAZBCGpBBBARIAFBBmogBkEMakEEEBEgAUEKaiAGQQQQESABQQ5qIAZBBGpBBBARIAFBEmogAEHcAGpBBBARIAFBFmogAEHgAGpBBBARIAFBGmogAEHUAGpBBBARIAFBHmogAEHYAGpBBBARIAFBImogAkECEBECQAJAAkAgBSgCnAEiAkGAgAFNBEAgBiACNgIQIAIgCUcEQCAFIAk2AoQBIAUgAjYCgAEgA0EBQZHwACAFQYABahAPQQAhAgwFCyAGKAIEIgIgBigCDCIISSAGKAIIIgsgBigCACIES3FFBEAgBSAIrSACrX03A3ggBSALrSAErX03A3AgA0EBQdvsACAFQfAAahAPQQAhAgwFCyAAKAJcIgdBACAAKAJgIgobRQRAIAUgCjYCBCAFIAc2AgAgA0EBQYPxACAFEA9BACECDAULAkACQCAAKAJUIgwgBEsNAEF/IAcgDGoiByAHIAxJGyAETQ0AIAAoAlgiByACSw0AQX8gByAKaiIKIAcgCksbIAJLDQELQQAhAiADQQFB1hRBABAPDAULAkAgACgC4AENACAAKALYASIHRQ0AIAAoAtwBIgpFDQAgCyAEayIEIAdGIAggAmsiAiAKRnENACAFIAI2AmwgBSAENgJoIAUgCjYCZCAFIAc2AmAgA0EBQcPoACAFQeAAahAPQQAhAgwFCyAGIAlBNBATIgQ2AhggBEUNAQJAIAYoAhBFDQAgAUEkaiAFQZgBaiICQQEQESAEIAUoApgBIglBB3YiCjYCICAEIAlB/wBxQQFqIgw2AhggACgC4AEhCyABQSVqIAJBARARIAQgBSgCmAE2AgAgAUEmaiACQQEQESAEIAUoApgBIgg2AgRBACECIAQoAgAiB0GAAmtBgX5JBEBBACEJDAULQQAhCSAIQYACa0GBfkkNBCAEKAIYIghBH0sNAyAEQQA2AiQgBCAAKAKgATYCKEEBIQkgBigCEEEBTQ0AQQAgCiALGyEKQQAgDCALGyELIAFBJ2ohAQNAIAEgBUGYAWpBARARIAQgBSgCmAEiB0EHdiIINgJUIAQgB0H/AHFBAWoiBzYCTAJAIAAoAuABDQAgAC0AvAFBBHENACAHIAtGIAggCkZxDQAgBSAINgJUIAUgBzYCUCAFIAk2AkwgBSAKNgJIIAUgCzYCRCAFIAk2AkAgA0ECQcfuACAFQUBrEA8LIAFBAWogBUGYAWoiCEEBEBEgBCAFKAKYATYCNCABQQJqIAhBARARIAQgBSgCmAEiCDYCOCAEKAI0IgdBgAJrQYF+SQ0FIAhBgAJrQYB+TQ0FIAQoAkwiCEEgTw0EIAFBA2ohASAEQQA2AlggBCAAKAKgATYCXCAEQTRqIQQgCUEBaiIJIAYoAhBJDQALC0EAIQIgACgCXCIIRQ0EIAAoAmAiC0UNBCAAIAitIg1CAX0iDyAGKAIIIAAoAlQiB2utfCANgKciATYCaCAAIAutIg5CAX0iECAGKAIMIAAoAlgiCmutfCAOgKciBDYCbAJAAkAgAUUNACAERQ0AQf//AyAEbiABTw0BCyAFIAQ2AhQgBSABNgIQIANBAUG16QAgBUEQahAPDAULIAEgBGwhCQJAIAAtAERBAnEEQCAAIAAoAhwgB2sgCG42AhwgACAAKAIgIAprIAtuNgIgIAAgDyAAKAIkIAdrrXwgDYA+AiQgACAQIAAoAiggCmutfCAOgD4CKAwBCyAAIAQ2AiggACABNgIkIABCADcCHAsgACAJQYwsEBMiATYCnAEgAUUEQCADQQFBzR1BABAPDAULIAYoAhBBuAgQEyEBIAAoAgwgATYC0CsgACgCDCgC0CtFBEAgA0EBQc0dQQAQDwwFC0EKQRQQEyEBIAAoAgwgATYC8CsgACgCDCIBKALwK0UEQCADQQFBzR1BABAPDAULIAFBCjYC+CtBCkEUEBMhASAAKAIMIAE2AvwrIAAoAgwiASgC/CtFBEAgA0EBQc0dQQAQDwwFCyABQQo2AoQsAkAgBigCECIERQ0AIAYoAhghCEEAIQEgBEEBRwRAIARBfnEhCwNAIAggAUE0bGoiBygCIEUEQCAAKAIMKALQKyABQbgIbGpBASAHKAIYQQFrdDYCtAgLIAggAUEBciIHQTRsaiIKKAIgRQRAIAAoAgwoAtArIAdBuAhsakEBIAooAhhBAWt0NgK0CAsgAUECaiEBIAJBAmoiAiALRw0ACwsgBEEBcUUNACAIIAFBNGxqIgIoAiANACAAKAIMKALQKyABQbgIbGpBASACKAIYQQFrdDYCtAgLIAkEQCAAKAKcASEBQQAhAgNAIAEgBigCEEG4CBATIgQ2AtArIARFBEBBACECIANBAUHNHUEAEA8MBwsgAUGMLGohASACQQFqIgIgCUkNAAsLIABBBDYCCCAGKAIQIgMEQEF/IAAoAlgiASAAKAJgIgIgACgCbEEBa2xqIgQgAmoiAiACIARJGyICIAYoAgwiBCACIARJG60hEEF/IAAoAlQiAiAAKAJcIgQgACgCaEEBa2xqIgAgBGoiBCAAIARLGyIAIAYoAggiBCAAIARJG60hESABIAYoAgQiACAAIAFJG60hEiACIAYoAgAiACAAIAJJG60hEyAGKAIYIQBBACEBA0AgACAANQIEIg1CAX0iFCASfCANgCIVPgIUIAAgADUCACIOQgF9IhYgE3wgDoAiFz4CECAAQn8gADUCKCIPhkJ/hSIYIBAgFHwgDYAgFX1C/////w+DfCAPiD4CDCAAIBEgFnwgDoAgF31C/////w+DIBh8IA+IPgIIIABBNGohACABQQFqIgEgA0cNAAsLQQEhAgwECyAFIAI2ApABIANBAUH2OyAFQZABahAPQQAhAgwDC0EAIQIgBkEANgIQIANBAUHNHUEAEA8MAgsgBSAINgI0IAUgCTYCMCADQQFBt/MAIAVBMGoQDwwBCyAFIAg2AiggBSAHNgIkIAUgCTYCICADQQFBkesAIAVBIGoQDwsgBUGgAWokACACC54DAQd/IwBBEGsiBiQAAn8gAiACQQFBAiAAKAJIKAIQIghBgQJJGyIHQQF0QQVqIgRuIgUgBGxGIAIgBE9xRQRAIANBAUGKI0EAEA9BAAwBCwJ/IAAoAghBEEYEQCAAKAKcASAAKALMAUGMLGxqDAELIAAoAgwLIQRBACEAIAQtAIgsIgJBBHEEQCAEKAKkA0EBaiEACyAAIAVqIgVBIE8EQCAGIAU2AgAgA0EBQYs7IAYQD0EADAELIAQgAkEEcjoAiCwgACAFSQRAIAQgAEGUAWxqQagDaiECA0AgASACQQEQESABQQFqIgEgAkEEaiAHEBEgASAHaiIBIAJBCGpBAhARIAIgAigCCCIDIAQoAggiCSADIAlJGzYCCCABQQJqIAJBDGpBARARIAFBA2oiASACQRBqIAcQESABIAdqIgEgBkEMakEBEBEgAiAGKAIMNgIkIAIgAigCECIDIAggAyAISRs2AhAgAkGUAWohAiABQQFqIQEgAEEBaiIAIAVHDQALCyAEIAVBAWs2AqQDQQELIQogBkEQaiQAIAoL7AEBBH8jAEEQayIEJAACfwJAIAEgBEEIagJ/IAAoAkgoAhBBgAJNBEAgAgRAQX8hBUEBDAILIANBAUG+I0EAEA9BAAwDCyACQQFNDQFBfiEFQQILIgYQESAEIAIgBWo2AgwgBCgCCCICIAAoAkgoAhAiBU8EQCAEIAU2AgQgBCACNgIAIANBAUHGOiAEEA9BAAwCCyAAIAIgASAGaiAEQQxqIAMQQkUEQCADQQFBviNBABAPQQAMAgtBASAEKAIMRQ0BGiADQQFBviNBABAPQQAMAQsgA0EBQb4jQQAQD0EACyEHIARBEGokACAHC9kBAQR/IwBBEGsiBCQAIAQgAjYCDAJAAkAgAEEAIAEgBEEMaiADEEJFDQAgBCgCDA0AAn8gACgCCEEQRgRAIAAoApwBIAAoAswBQYwsbGoMAQsgACgCDAshB0EBIQUgACgCSCgCEEECSQ0BIAcoAtArIgJBHGohBkEBIQEgAiEDA0AgAyACKAIYNgLQCCADIAIoAqQGNgLcDiADQdQIaiAGQYgGEBIaIANBuAhqIQMgAUEBaiIBIAAoAkgoAhBJDQALDAELIANBAUHWIkEAEA8LIARBEGokACAFC9YBAQN/IwBBEGsiBCQAAkAgAkEBQQIgACgCSCgCECIGQYECSRsiBUECakcEQEEAIQAgA0EBQYogQQAQDwwBCwJ/IAAoAghBEEYEQCAAKAKcASAAKALMAUGMLGxqDAELIAAoAgwLIQIgASAEQQxqIAUQEUEBIQAgASAFaiIFIARBCGpBARARIAYgBCgCDCIBTQRAIAQgBjYCBCAEIAE2AgAgA0EBQdjvACAEEA9BACEADAELIAVBAWogAigC0CsgAUG4CGxqQagGakEBEBELIARBEGokACAAC4QCAQV/IwBBEGsiBCQAAn8gACgCCEEQRgRAIAAoApwBIAAoAswBQYwsbGoMAQsgACgCDAshBgJAIAJBAUECIAAoAkgiBygCEEGBAkkbIgVNBEBBACECIANBAUGkI0EAEA8MAQsgBCAFQX9zIAJqNgIMIAEgBEEIaiAFEBEgBCgCCCIIIAcoAhBPBEBBACECIANBAUGA6QBBABAPDAELQQEhAiABIAVqIgEgBigC0CsgCEG4CGxqQQEQESAAIAQoAgggAUEBaiAEQQxqIAMQQ0UEQEEAIQIgA0EBQaQjQQAQDwwBCyAEKAIMRQ0AQQAhAiADQQFBpCNBABAPCyAEQRBqJAAgAgusBgEHfyMAQRBrIgYkACAGIAI2AgwgACgCSCEJAn8gACgCCEEQRgRAIAAoApwBIAAoAswBQYwsbGoMAQsgACgCDAsiBCAELQCILEEBcjoAiCwCQCACQQRNBEAgA0EBQbwiQQAQDwwBCyABIARBARARIAQoAgBBCE8EQCADQQFBmiJBABAPDAELIAFBAWogBkEIakEBEBEgBCAGKAIIIgI2AgQgAkEFTgRAIANBAUHxIUEAEA8gBEF/NgIECyABQQJqIARBCGpBAhARIAQoAggiB0GAgARrQYCAfE0EQCAGIAc2AgAgA0EBQak9IAYQDwwBCyAEIAAoAqQBIgIgByACGzYCDCABQQRqIARBEGpBARARIAQoAhBBAk8EQCADQQFBhypBABAPDAELIAFBBWohAiAGIAYoAgxBBWs2AgwCQCAJKAIQIgdFDQAgBCgCAEEBcSEIIAQoAtArIQRBACEJIAdBCE8EQCAHQXhxIQEDQCAEIAVBuAhsaiAINgIAIAQgBUEBckG4CGxqIAg2AgAgBCAFQQJyQbgIbGogCDYCACAEIAVBA3JBuAhsaiAINgIAIAQgBUEEckG4CGxqIAg2AgAgBCAFQQVyQbgIbGogCDYCACAEIAVBBnJBuAhsaiAINgIAIAQgBUEHckG4CGxqIAg2AgAgBUEIaiEFIApBCGoiCiABRw0ACwsgB0EHcSIBRQ0AA0AgBCAFQbgIbGogCDYCACAFQQFqIQUgCUEBaiIJIAFHDQALC0EAIQUgAEEAIAIgBkEMaiADEENFBEAgA0EBQbwiQQAQDwwBCyAGKAIMBEAgA0EBQbwiQQAQDwwBCwJ/IAAoAghBEEYEQCAAKAKcASAAKALMAUGMLGxqDAELIAAoAgwLIQEgACgCSCgCEEECTwRAIAEoAtArIgEoAgRBAnQhByABQbAHaiEKIAFBrAZqIQNBASEJIAEhAgNAIAIgAf0AAgT9CwK8CCACIAEoAhQ2AswIIAJB5A5qIAMgBxASGiACQegPaiAKIAcQEhogAkG4CGohAiAJQQFqIgkgACgCSCgCEEkNAAsLQQEhBQsgBkEQaiQAIAUL7AkBBn8jAEHwAGsiBCQAIARBADYCaAJAIAJBCEcEQCADQQFBvR5BABAPIANBAUG9HkEAEA8MAQsgASAAQcwBakECEBEgAUECaiAEQewAakEEEBEgAUEGaiAEQeQAakEBEBEgAUEHaiAEQegAakEBEBEgACgCzAEiAiAAKAJoIgggACgCbGxPBEAgBCACNgJgIANBAUGdOyAEQeAAahAPDAELIAAoApwBIAJBjCxsaiEFIAIgCG4hByAEKAJkIQECQCAAKAIsIgZBAE4gAiAGR3ENACAFKALUK0EBaiIGIAFGDQAgBCAGNgJYIAQgATYCVCAEIAI2AlAgA0EBQbU7IARB0ABqEA9BACEFDAELIAUgATYC1CsCQAJAIAQoAmwiAUEBa0EMTQR/IAFBDEcNASAEQQw2AjAgA0ECQeXXACAEQTBqEA8gBCgCbAUgAQtFBEAgA0EEQbLPAEEAEA8gAEEBNgI4CwJAAkACQAJAIAUoAtgrIgEEQCAEKAJkIgYgAUkNASAEIAE2AiQgBCAGNgIgIANBAUGFJyAEQSBqEA8gAEEBNgI4QQAhBQwHCyAEKAJoIgYNAQwDCyAEKAJoIgZFDQELIAQgBiAALQBEQQR2QQFxaiIBNgJoIAQoAmQiBiAFKALYKyIJQQFrSwRAIAQgCTYCBCAEIAY2AgAgA0EBQaImIAQQDyAAQQE2AjhBACEFDAULIAEgBk0EQCAEIAE2AhQgBCAGNgIQIANBAUHpJyAEQRBqEA8gAEEBNgI4QQAhBQwFCyAFIAE2AtgrCyABIAQoAmRBAWpHDQAgACAALQBEQQFyOgBECyAEKAJsIQEgAEEQNgIIIABBACABQQxrIAAoAjgbNgIYAkAgACgCLCIBQX9GBEBBBCEFIAIgByAIbGsiASAAKAIcSQ0BIAEgACgCJE8NASAHIAAoAiBJDQEgByAAKAIoT0ECdCEFDAELIAAoAswBIAFHQQJ0IQULIAAgAC0AREH7AXEgBXI6AERBASEFIAAoAsgBIgFFDQIgASgCKCIGIAAoAswBIgJBKGxqIgcgAjYCACAHIAQoAmQiCDYCDCAEKAJoIgEEQCAHIAE2AgQgByAEKAJoIgE2AgggBygCECICRQRAIAFBGBATIQEgACgCyAEoAiggACgCzAFBKGxqIAE2AhAgAQ0EQQAhBSADQQFByTRBABAPDAQLIAIgAUEYbBAXIQEgACgCyAEoAiggACgCzAFBKGxqIQIgAUUEQCACKAIQEBBBACEFIAAoAsgBKAIoIAAoAswBQShsakEANgIQIANBAUHJNEEAEA8MBAsgAiABNgIQDAMLIAcoAhAiAUUEQCAHQQo2AghBCkEYEBMhASAAKALIASgCKCIGIAAoAswBIgJBKGxqIgcgATYCECABRQ0CIAQoAmQhCAsgCCAGIAJBKGxqIgIoAghJDQIgAiAIQQFqIgI2AgggASACQRhsEBchASAAKALIASgCKCAAKALMAUEobGohAiABRQRAIAIoAhAQEEEAIQUgACgCyAEoAiggACgCzAFBKGxqIgBBADYCCCAAQQA2AhAgA0EBQck0QQAQDwwDCyACIAE2AhAMAgsgBCABNgJAIANBAUHy2QAgBEFAaxAPQQAhBQwBC0EAIQUgB0EANgIIIANBAUHJNEEAEA8LIARB8ABqJAAgBQurBwEIfyMAQdAAayIEJAAgBEEBNgJMAkACQCAAKALIASIFKAIoIgMNACAFIAAoAmwgACgCaGwiAzYCJCADQSgQEyEDIAAoAsgBIgUgAzYCKCADRQRAQQAhBQwCCyAFKAIkRQ0AA0BBACEFIAMgBkEobCIHaiIDQQA2AhQgA0HkADYCHEHkAEEYEBMhCSAHIAAoAsgBIggoAigiA2ogCTYCGCAJRQ0CIAZBAWoiBiAIKAIkSQ0ACwsgACgCLCEJAkAgAygCEEUNAAJAIAMgCUEobGoiAygCBEUEQCABIAApAzBCAnwgAhA2DQFBACEFIAJBAUGnKUEAEA8MAwsgASADKAIQKQMAQgJ8IAIQNg0AQQAhBSACQQFBpylBABAPDAILIAAoAghBgAJHDQAgAEEINgIICwJAIAAoAmwgACgCaGwiB0UNACAAKAKcASEFQQAhAyAHQQhPBEAgB0F4cSEIQQAhBgNAIAUgA0GMLGxqQX82AtQrIAUgA0EBckGMLGxqQX82AtQrIAUgA0ECckGMLGxqQX82AtQrIAUgA0EDckGMLGxqQX82AtQrIAUgA0EEckGMLGxqQX82AtQrIAUgA0EFckGMLGxqQX82AtQrIAUgA0EGckGMLGxqQX82AtQrIAUgA0EHckGMLGxqQX82AtQrIANBCGohAyAGQQhqIgYgCEcNAAsLIAdBB3EiBkUNAANAIAUgA0GMLGxqQX82AtQrIANBAWohAyAKQQFqIgogBkcNAAsLQQAhBSAAIARByABqQQAgBEHEAGogBEFAayAEQTxqIARBOGogBEE0aiAEQcwAaiABIAIQJ0UNACAJQQFqIQcDQAJAIAQoAkxFDQAgACAEKAJIIgNBAEEAIAEgAhArRQ0CIAAoAmghCCAAKAJsIQogBCADQQFqIgY2AiAgBCAIIApsNgIkIAJBBEGg1wAgBEEgahAPIAAoAtABIAAoAkwoAhgQdEUNAiAAKAKcASADQYwsbGoiBSgC3CsiCARAIAgQECAFQgA3AtwrCyAEIAY2AhAgAkEEQeb8ACAEQRBqEA8gAyAJRgRAIAEgACgCyAEpAwhCAnwgAhA2DQFBACEFIAJBAUGnKUEAEA8MAwsgBCAHNgIEIAQgBjYCACACQQJB3eUAIAQQD0EAIQUgACAEQcgAakEAIARBxABqIARBQGsgBEE8aiAEQThqIARBNGogBEHMAGogASACECcNAQwCCwsgACACEHIhBQsgBEHQAGokACAFC8gGAgd/AX4jAEHQAGsiAyQAIANBATYCTAJAAkAgACgCaCIEQQFHDQAgACgCbEEBRw0AIAAoAlQNACAAKAJYDQAgACgCTCIFKAIADQAgBSgCBA0AIAUoAgggACgCXEcNACAFKAIMIAAoAmBHDQBBACEEIAAgA0HIAGpBACADQcQAaiADQUBrIANBPGogA0E4aiADQTRqIANBzABqIAEgAhAnRQ0BAkAgACADKAJIQQBBACABIAIQKwRAIAAoAkwiASgCEA0BQQEhBAwDCyACQQFBkcIAQQAQDwwCCyABKAIYIQFBACECA0AgASACQTRsIgRqKAIsEBAgACgCTCIFKAIYIgEgBGoiBiAAKALQASIHKAIUKAIAKAIUIAJBzABsaiIIKAIkNgIsIAYgBygCGCgCGCAEaigCJDYCJCAIQQA2AiRBASEEIAJBAWoiAiAFKAIQSQ0ACwwBCwNAAkACfwJAIARBAUcNACAAKAJsQQFHDQAgACgCnAEoAtwrRQ0AIANBADYCSCAAQQA2AswBIAAgACgCCEGAAXI2AghBAAwBC0EAIQQgACADQcgAakEAIANBxABqIANBQGsgA0E8aiADQThqIANBNGogA0HMAGogASACECdFDQMgAygCTEUNASADKAJICyIHQQFqIQQgACAHQQBBACABIAIQKyEJIAAoAmggACgCbGwhBSAJRQRAIAMgBTYCBCADIAQ2AgAgAkEBQZc5IAMQD0EAIQQMAwsgAyAFNgIkIAMgBDYCICACQQRBoNcAIANBIGoQDyAAKALQASAAKAJMKAIYEHRFBEBBACEEDAMLAkACQCAAKAJoQQFHDQAgACgCbEEBRw0AIAAoAkwiBSgCACAAKAJIIgYoAgBHDQEgBSgCBCAGKAIERw0BIAUoAgggBigCCEcNASAFKAIMIAYoAgxHDQELIAAoApwBIAdBjCxsaiIFKALcKyIGRQ0AIAYQECAFQgA3AtwrCyADIAQ2AhAgAkEEQeb8ACADQRBqEA8gASkDCCIKUAR+QgAFIAogASkDOH0LUARAIAAoAghBwABGDQELIAhBAWoiCCAAKAJoIgQgACgCbGxHDQELCyAAIAIQciEECyADQdAAaiQAIAQLtQYBDH8gACgCSCEJAkAgACgCaCAAKAJsbCIMBEAgCSgCECIBQbgIbCENIAEgAWxBAnQhCiAAKAIMIQQgACgCnAEhAwNAIAMoAtArIQsgAyAEQYwsEBIiAUEANgLoKyABQX82AtQrIAFBADYCsCggAUEANgKELCABQQA2AvArIAFCADcC+CsgASALNgLQKyABIAEtAIgsQfwBcToAiCwgBCgC6CsEQCABIAoQFCIDNgLoKyADRQRAQQAPCyADIAQoAugrIAoQEhoLIAEgBCgC+CtBFGwiBRAUIgM2AvArQQAhCCADRQ0CIAMgBCgC8CsgBRASGiAEKAL0KyIGBEAgBCgC8CshAyABKALwKyEFQQAhBwNAIAMoAgwEQCAFIAMoAhAQFCIGNgIMIAZFBEBBAA8LIAYgAygCDCADKAIQEBIaIAQoAvQrIQYLIAEgASgC+CtBAWo2AvgrIAVBFGohBSADQRRqIQMgB0EBaiIHIAZJDQALCyABIAQoAoQsQRRsIgUQFCIDNgL8KyADRQ0CIAMgBCgC/CsgBRASGiABIAQoAoQsIgg2AoQsIAgEQCAEKAL8KyEDIAEoAvwrIQVBACEHA0AgAygCCCIGBEAgBSABKALwKyAGIAQoAvAra2o2AggLIAMoAgwiBgRAIAUgASgC8CsgBiAEKALwK2tqNgIMCyAFQRRqIQUgA0EUaiEDIAdBAWoiByAIRw0ACwsgCyAEKALQKyANEBIaIAFBjCxqIQMgDkEBaiIOIAxHDQALC0EBIQggAAJ/QQBBAUHIABATIgFFDQAaIAEgAS0AKEH+AXFBAXI6ACggAUEBQQQQEyIENgIUIAEgBA0AGiABEBBBAAsiATYC0AEgAUUEQEEADwsgACgC1AEhBUEAIQQgASAAQdAAajYCHCABIAk2AhhBAUHQBhATIQMgASgCFCADNgIAAkAgA0UNACAJKAIQQcwAEBMhAyABKAIUKAIAIgcgAzYCFCADRQ0AIAcgCSgCEDYCECAAKAKkASEEIAEgBTYCLCABIAQ2AgBBASEECyAEDQAgACgC0AEQVUEAIQggAEEANgLQASACQQFBwhtBABAPCyAIC9USAwx/AX0BfiMAQTBrIggkACAAQQE2AggCfwJAAkAgASAIQShqIgVBAiACEBpBAkcNACAFIAhBLGpBAhARIAgoAixBz/4DRw0AIABBAjYCCCAAKALIASABKQM4QgJ9IhA3AwAgCCAQNwMQIAJBBEHu3gAgCEEQahAPIAAoAsgBIgMpAwAhECADKAIYIgdBAWoiBSADKAIgIgRNBEAgAygCHCEEDAILIAMCfyAEs0MAAMhCkiIPQwAAgE9dIA9DAAAAAGBxBEAgD6kMAQtBAAsiBTYCICADKAIcIAVBGGwQFyIEBEAgAyAENgIcIAMoAhgiB0EBaiEFDAILIAMoAhwQECADQQA2AiAgA0IANwMYIAJBAUGpHUEAEA8LIAJBAUG19QBBABAPQQAMAQsgBCAHQRhsaiIEQQI2AhAgBCAQxDcDCCAEQc/+AzsBACADIAU2AhggASAAKAIQQQIgAhAaQQJHBEAgAkEBQZYSQQAQD0EADAELIAAoAhAgCEEoakECEBECQAJAIAgoAigiBEGQ/wNHBEADQEHgvQEhByAEQf/9A00EQCAIIAQ2AgAgAkEBQcoQIAgQD0EADAULA0AgByIFKAIAIgMEQCAFQQxqIQcgAyAERw0BCwsCQAJAIAMNAEECIQYgAkECQfUcQQAQD0GWEiEHAkACQCABIAAoAhBBAiACEBpBAkcNAANAIAAoAhAgCEEsakECEBFB4L0BIQMgCCgCLCIEQYD+A08EQANAIAMiBSgCACIMBEAgA0EMaiEDIAQgDEcNAQsLIAUoAgQgACgCCHFFBEBB/CghBwwDCyAMBEAgDEGQ/wNGBEAgCEGQ/wM2AigMBwsgASkDOCEQIAAoAsgBIgMoAhgiBUEBaiIEIAMoAiAiB00EQCADKAIcIQcMBQsgAwJ/IAezQwAAyEKSIg9DAACAT10gD0MAAAAAYHEEQCAPqQwBC0EACyIFNgIgIAMoAhwgBUEYbBAXIgcEQCADIAc2AhwgAygCGCIFQQFqIQQMBQsgAygCHBAQIANBADYCICADQgA3AxhBqR0hBwwDCyAGQQJqIQYLIAEgACgCEEECIAIQGkECRg0ACwsgAkEBIAdBABAPIAJBAUH9yABBABAPQQAMBwsgByAFQRhsaiIFIAY2AhAgBSAQpyAGa6w3AwggBUEAOwEAIAMgBDYCGCAIIAw2AihB4L0BIQQDQCAEIgUoAgAiA0UNASAEQQxqIQQgAyAMRw0ACwsgBSgCBCAAKAIIcUUEQCACQQFB/ChBABAPQQAMBgsgASAAKAIQQQIgAhAaQQJHBEAgAkEBQZYSQQAQD0EADAYLIAAoAhAgCEEkakECEBEgCCgCJCIEQQFNBEAgAkEBQaEuQQAQD0EADAYLIAggBEECayIHNgIkIAAoAhAhBCAAKAIUIAdJBEAgBCAHEBciBEUEQCAAKAIQEBAgAEIANwMQIAJBAUHUJUEAEA9BAAwHCyAAIAQ2AhAgACAIKAIkIgc2AhQLIAEgBCAHIAIQGiIEIAgoAiRHBEAgAkEBQZYSQQAQD0EADAYLIAAgACgCECAEIAIgBSgCCBEBAEUEQCACQQFBqBJBABAPQQAMBgsgASkDOCEQIAgoAiQhDAJAIAAoAsgBIgUoAhgiBkEBaiIHIAUoAiAiBE0EQCAFKAIcIQQMAQsgBQJ/IASzQwAAyEKSIg9DAACAT10gD0MAAAAAYHEEQCAPqQwBC0EACyIENgIgIAUoAhwgBEEYbBAXIgRFDQUgBSAENgIcIAUoAhgiBkEBaiEHCyAEIAZBGGxqIgQgDEEEajYCECAEIBCnIAxrQQRrrDcDCCAEIAM7AQAgBSAHNgIYIAEgACgCEEECIAIQGkECRwRAIAJBAUGWEkEAEA9BAAwGC0EBIAogA0Hc/gNGGyEKQQEgCyADQdL+A0YbIQtBASANIANB0f4DRhshDSAAKAIQIAhBKGpBAhARIAgoAigiBEGQ/wNHDQELCyANDQELIAJBAUGYJEEAEA9BAAwCCyALRQRAIAJBAUHGJEEAEA9BAAwCCyAKRQRAIAJBAUH0JEEAEA9BAAwCC0EAIQNBACENIwBBEGsiBCQAQQEhBwJAIAAtALwBQQFxRQ0AAkAgACgCcCILRQ0AAkADQCAAKAJ0IA1BA3RqIgUoAgAiCgRAIAMgBSgCBCIGayIFQQAgAyAFTxshBSADIAZJBEAgBiADayELIAMgCmohCgNAIAtBBEkEQEGOKyEDDAULIAogBEEMakEEEBEgBCgCDCIDQX9zIAlJBEBB9CohAwwFCyADIAtBBGsiBmsgBSADIAZLIgwbIQUgAyAJaiEJIAYgA2shCyAKQQAgAyAMG2pBBGohCiADIAZJDQALIAAoAnAhCwsgBSEDCyANQQFqIg0gC0kNAAsgA0UNAUEAIQcgAkEBQekWQQAQDwwCC0EAIQcgAkEBIANBABAPDAELIAAgCRAUIgM2AogBIANFBEBBACEHIAJBAUG+IEEAEA8MAQsgACAJNgJ8IAAoAnQhBgJAIAAoAnAiCgRAQQAhCUEAIQNBACEFA0AgBiAFQQN0Ig1qIgwoAgAiCwRAIAAoAogBIANqIQoCfyAMKAIEIgYgCU0EQCAKIAsgBhASGiADIAZqIQMgCSAGawwBCyAKIAsgCRASGiADIAlqIQMgBiAJayIGBEAgCSALaiEJA0AgBkEESQ0GIAkgBEEIakEEEBEgCUEEaiEJIAAoAogBIANqIQogBkEEayIGIAQoAggiC0kEQCAKIAkgBhASGiADIAZqIQMgBCgCCCAGawwDCyAKIAkgCxASGiAEKAIIIgogA2ohAyAJIApqIQkgBiAKayIGDQALC0EACyEJIAAoAnQgDWooAgAQECAAKAJ0IgYgDWpCADcCACAAKAJwIQoLIAVBAWoiBSAKSQ0ACyAAKAJ8IQkgACgCiAEhAwsgACAJNgKQASAAIAM2AnggAEEANgJwIAYQECAAQQA2AnQMAQtBACEHIAJBAUGOK0EAEA8LIARBEGokACAHRQRAIAJBAUGPPUEAEA9BAAwCCyACQQRB99YAQQAQDyAAKALIASABKQM4Qv7///8PfEL/////D4M3AwggAEEINgIIQQEMAQsgBSgCHBAQIAVBADYCICAFQgA3AxggAkEBQakdQQAQD0EACyEOIAhBMGokACAOCxwAIAAoAghFIAAoAsABQQBHIAAoAsQBQQBHcXELBABBAAsPACAABEAgACABNgK4AQsLjwEBBH8gACgCGCIBBEAgACgCHCIDQTRuIQQgA0E0TwR/QQAhAwNAIAEoAgAiAgRAIAJBAWsQECABQQA2AgALIAEoAgQiAgRAIAIQECABQQA2AgQLIAEoAggiAgRAIAIQECABQQA2AggLIAFBNGohASADQQFqIgMgBEcNAAsgACgCGAUgAQsQECAAQQA2AhgLC4YBAQR/IAAoAhgiAQRAIAAoAhwiAkHAAE8EfyACQQZ2IQRBACECA0AgASgCACIDBEAgAxAQIAFBADYCAAsgASgCBCIDBEAgAxAQIAFBADYCBAsgASgCPBAQIAFBADYCPCABQUBrIQEgAkEBaiICIARHDQALIAAoAhgFIAELEBAgAEEANgIYCws/AQF/IAAEQCAAKAJ0IgEEQCABEBAgAEEANgJ0CyAAKAJ4IgEEQCABEBAgAEEANgJ4CyAAKAKUARAQIAAQEAsLwaYFBFx/AnsGfgF9IwBB4ABrIiMkACAAKAIIIRoCQAJAAkACQCAAKAIARQRAIBogGigCECAaKAIIayAaKAIUIBooAgxrbEECdCIGEBgiAzYCPCADRQRAIAAoAiQaIAAoAiBBAUHRPEEAEA8gACgCJBogAEEcaiEQDAMLIANBACAGEBUaDAELIBooAjwiA0UNACADEBAgGkEANgI8CyAAKAIQIjIoAhwgMigCGEGYAWxqIgNBmAFrKAIAITUgA0GQAWsoAgAhNiAAKAIUIS8gACgCDCEwIAAoAgQhNyAAKAIcKAIARQ0CIABBHGohEAJAAn9BACABKAIEIgNBAEwNABogASgCACEGAkADQCAGIAdBDGxqIgQoAgBFDQEgB0EBaiIHIANHDQALQQAMAQsgBCgCBAsiBA0AQQFBnAEQEyIERQRAIAAoAiBBAUGQMEEAEA8MAgsgBEEANgKMASABKAIEIgNB/////wdHBH8CfyABKAIAIQYgA0EASgRAA0AgBiAJQQxsaiIHKAIARQRAIAcoAggiAwR/IAcoAgQgAxECACABKAIABSAGCyAJQQxsaiIBQQ82AgggASAENgIEQQEMAwsgCUEBaiIJIANHDQALC0EAIAYgA0EMbEEMahAXIgNFDQAaIAEgAzYCACADIAEoAgQiBkEMbGoiA0EPNgIIIAMgBDYCBCADQQA2AgAgASAGQQFqNgIEQQELBUEACw0AIAAoAiBBAUGMP0EAEA8gBCgCdCIBBEAgARAQIARBADYCdAsgBCgCeCIBBEAgARAQIARBADYCeAsgBCgClAEQECAEEBAMAQsgBCAAKAIYNgKQASAAKAIoISsgACgCJCEhIAAoAiAhHSAvKAKoBiERIDAoAhAhAQJAAkAgLygCECIWQcAAcQRAIBYhCiMAQbACayIPJAACQCARBEAgIQRAQQAhByAdQQFBgRhBABAPDAILQQAhByAdQQFBgRhBABAPDAELIAQoAnQhBwJAAkAgGigCFCAaKAIMayIDIBooAhAgGigCCGsiBmwiASAEKAKEAUsEQCAHEBAgBCABQQJ0IhEQGCIHNgJ0IAdFBEBBACEHDAQLIAQgATYChAEMAQsgB0UNASABQQJ0IRELIAdBACAREBUaCyAEKAJ4IQcCQCAEKAKIAUHPFEsNACAHEBAgBEHA0gAQGCIHNgJ4IAcNAEEAIQcMAQsgBEHQFDYCiAEgB0EAQcDSABAVGiAEIAM2AoABIAQgBjYCfCAaKAIYIgJFBEBBASEHDAELIBooAhwhDUEBIQcCQAJAAkACQAJAIBooAjQiAwRAIBooAgQhCUEAIQdBACEBAkAgA0EETwRAIANBfHEhAQNAIAkgCEEDdGoiBkEcaiAGQRRqIAZBDGogBv0JAgT9VgIAAf1WAgAC/VYCAAMgXv2uASFeIAhBBGoiCCABRw0ACyBeIF4gXv0NCAkKCwwNDg8AAQIDAAECA/2uASJeIF4gXv0NBAUGBwABAgMAAQIDAAECA/2uAf0bACEHIAEgA0YNAQsDQCAJIAFBA3RqKAIEIAdqIQcgAUEBaiIBIANHDQALCyADQQFGBEAgBCgCkAFFDQULIAcgBCgCmAFNDQEgBCgClAEgBxAXIhENAkEAIQcMBgsgBCgCkAFFDQULIAQoApQBIhENAUEAIQcMBAsgBCAHNgKYASAEIBE2ApQBCyAaKAI0RQRAQQAhBwwCCyAaKAIEIQhBACEHQQAhAQNAIAcgEWogCCABQQN0IgNqIgYoAgAgBigCBBASGiAaKAIEIgggA2ooAgQgB2ohByABQQFqIgEgGigCNEkNAAsMAQsgGigCBCgCACERC0EAIQFBACEIAn9BACAaKAIoIgNFDQAaIBooAgAiBigCCCEIQQAgA0EBRg0AGiAGKAIgCyEDIAIgDWshRQJAIAMgCGoiCEUEQEEAIQkMAQtBASEBIBooAgAiAygCACEFQQAhCSAIQQFGBEBBACEBDAELIAMoAhghCQsgRUEBaiEWIAQoAnQhDiAEKAJ4IRQgGigCDCESIBooAhQhGCAaKAIIISQgGigCECErAkACQAJAAkACQAJAAkACQAJAIAFFDQAgCQ0AICFFDQEgHUECQaHQAEEAEA9BASEIDAILIAhBBEkNASAhBEAgDyAINgJwIB1BAUH8xgAgD0HwAGoQDwwICyAPIAg2AmAgHUEBQfzGACAPQeAAahAPQQAhBwwICyAdQQJBodAAQQAQDyAaKAIYIgFBHksNAUEBIQwgASAWTw0DDAULIBooAhgiAUEeTQ0BICFFDQAgDyABNgIgIB1BAUGb2wAgD0EgahAPDAULIA8gATYCACAdQQFBm9sAIA8QD0EAIQcMBQsgASAWSQ0BIAhBAkkEQCAIIQwMAQsgASAWRwRAIAghDAwBC0EBIQxBkMcBLQAADQAgIUUEQEGQxwFBAToAACAPIAg2AkAgHUECQabMACAPQUBrEA8MAQtBkMcBLQAARQRAQZDHAUEBOgAAIA8gCDYCUCAdQQJBpswAIA9B0ABqEA8LCwJAAkAgBUECSQ0AIAUgB0sNACAFIAlqIAdNDQELICEEQEEAIQcgHUEBQcLGAEEAEA8MBQtBACEHIB1BAUHCxgBBABAPDAQLAkACQCAFIBFqIhNBAWstAABBBHQgE0ECay0AAEEPcXIiBkECSQ0AIAUgBkgNACAGQfAfSQ0BCyAhBEBBACEHIB1BAUHW8gBBABAPDAULQQAhByAdQQFB1vIAQQAQDwwECyAaKAIcISYgD0EANgKQAiAPQQA2ApgCIA9CADcDiAIgD0IANwOoAiAPQgA3ApwCIA8gBkEBayIHNgKUAiAPIAUgEWogBmsiATYCgAJC/wEhYCAGQQJPBEAgATEAACFgC0EIIQMgD0EINgKQAiAPIAZBAmsiCDYClAIgDyBgQg+EIGAgB0EBRhsiYDcDiAIgDyABIAZBAUpqIgc2AoACIA8gYEL/AVEiDTYCmAICfwJAIAFBA3EiAkEDRg0AQv8BIWEgDQRAQQAgBy0AAEGPAUsNAhoLIAZBA04EQCAHMQAAIWELIA8gBkEDayINNgKUAiAPQQ9BECBgQv8BUSILGyIDNgKQAiAPIAcgBkECSmoiATYCgAIgDyBhQg+EIGEgCEEBRhsiYUL/AVE2ApgCIA8gYEIHQgggCxuGIGGEImA3A4gCIAJBAkYNACBhQv8BUQRAQQAgAS0AAEGPAUsNAhoLQv8BIWIgBkEETgRAIAExAAAhYgsgDyAGQQRrIgc2ApQCIA8gASAGQQNKaiIBNgKAAiAPIGJCD4QgYiANQQFGGyJiQv8BUTYCmAIgDyADQQdBCCBhQv8BUSIIG2oiAzYCkAIgDyBgQgdCCCAIG4YgYoQiYDcDiAIgAkEBRg0AQv8BIWEgYkL/AVEEQEEAIAEtAABBjwFLDQIaCyAGQQVOBEAgATEAACFhCyAPIAZBBWs2ApQCIA8gASAGQQRKajYCgAIgDyBhQg+EIGEgB0EBRhsiYUL/AVE2ApgCIA8gA0EHQQggYkL/AVEiARtqIgM2ApACIA8gYEIHQgggARuGIGGEImA3A4gCCyAPIGBBwAAgA2uthjcDiAJBAQtFBEAgIQRAQQAhByAdQQFBg9UAQQAQDwwFC0EAIQcgHUEBQYPVAEEAEA8MBAsgKyAkayEVIA8gBkECayILNgL0ASAPIAUgEWoiAkEDayIDNgLgASAPIAJBAmstAAAiGUGPAUsiDTYC+AEgDyAZQQR2rSJgNwPoASAPQQNBBCBgQgeDQgdRGyIBNgLwASADQQNxQQFqIgcgCyAHIAtIGyEIAkACQCAGQQJMBEAgDyALIAhrIgI2AvQBDAELIA8gAkEEayIHNgLgASAPIAMtAAAiF0GPAUsiDTYC+AEgDyAXrSJhIAGthiBghCJgNwPoASAPQQhBB0EIIGFC/wCDQv8AURsgGUGPAU0bIAFqIgE2AvABAkAgCEEBRgRAIAchAwwBCyAPIAJBBWsiAzYC4AEgDyAHLQAAIhlBjwFLIg02AvgBIA8gGa0iYSABrYYgYIQiYDcD6AEgD0EIQQdBCCBhQv8Ag0L/AFEbIBdBjwFNGyABaiIBNgLwASAIQQJGDQAgDyACQQZrIgc2AuABIA8gAy0AACIXQY8BSyINNgL4ASAPIBetImEgAa2GIGCEImA3A+gBIA9BCEEHQQggYUL/AINC/wBRGyAZQY8BTRsgAWoiATYC8AEgCEEDRgRAIAchAwwBCyAPIAJBB2siAzYC4AEgDyAHMQAAImFCjwFWIg02AvgBIA8gYSABrYYgYIQiYDcD6AEgD0EIQQdBCCBhQv8Ag0L/AFEbIBdBjwFNGyABaiIBNgLwAQsgDyALIAhrIgI2AvQBIAFBIEsNAQsCQCACQQROBEAgA0EDaygCACEHIA8gAkEEazYC9AEgDyADQQRrNgLgAQwBCyACQQBMBEBBACEHDAELIAJBAXEhRwJAIAJBAUYEQEEYIQhBACEHDAELIAJB/v///wdxIRdBGCEIQQAhB0EAIQsDQCAPIANBAWsiHzYC4AEgAy0AACFGIA8gA0ECayIDNgLgASAPIAJBAWs2AvQBIB8tAAAhHyAPIAJBAmsiAjYC9AEgRiAIdCAHciAfIAhBCGt0ciEHIAhBEGshCCALQQJqIgsgF0cNAAsLIEdFDQAgDyADQQFrNgLgASADLQAAIUggDyACQQFrNgL0ASBIIAh0IAdyIQcLIA8gB0H/AXEiA0GPAUs2AvgBIA9BB0EIIAdBgICA+AdxQYCAgPgHRhtBCCANGyICQQhBB0EIIAdBgID8A3FBgID8A0YbIAdB/////3hNG2oiCEEIQQdBCCAHQYD+AXFBgP4BRhsgB0EQdkH/AXEiDUGPAU0baiILQQhBB0EIIAdB/wBxQf8ARhsgB0EIdkH/AXEiGUGPAU0bIAFqajYC8AEgDyANIAJ0IAdBGHZyIBkgCHRyIAMgC3RyrSABrYYgYIQ3A+gBCyAPQcABaiARIAUgBmtB/wEQWwJ/QQAgDEECSQ0AGiAPQaABaiATIAlBABBbQQAgDEECRg0AGkIAIWBCACFiIA9BATYCmAEgD0EANgKQASAPQgA3A4gBIA8gCUEBayIGNgKUASAPIAUgEWogCWoiA0EBayIBNgKAASABQQNxIQUCQCAJQQBMBEAgASEDDAELIA8gA0ECayIDNgKAASABMQAAIWALIA8gYDcDiAEgDyBgQo8BViIRNgKYASAPQQdBCCBgQv8Ag0L/AFEbIg02ApABAkAgBUUNACAPIAlBAmsiAjYClAECQCAJQQJIBEAgAyEHDAELIA8gA0EBayIHNgKAASADMQAAIWILIA8gYkKPAVYiETYCmAEgDyBiIA2thiBghCJhNwOIASAPQQhBB0EIIGJC/wCDQv8AURsgYEKPAVgbIA1qIg02ApABIAVBAUYEQCAHIQMgYSFgIAYhCSACIQYMAQsgDyAJQQNrIgg2ApQBAkAgCUEDSARAIAchAQwBCyAPIAdBAWsiATYCgAEgBzEAACFjCyAPIGNCjwFWIhE2ApgBIA8gYyANrYYgYYQiYDcDiAEgD0EIQQdBCCBjQv8Ag0L/AFEbIGJCjwFYGyANaiINNgKQASAFQQJGBEAgASEDIAIhCSAIIQYMAQsgDyAJQQRrIgY2ApQBQgAhYgJAIAlBBEgEQCABIQMMAQsgDyABQQFrIgM2AoABIAExAAAhYgsgDyBiQo8BViIRNgKYASAPIGIgDa2GIGCEImA3A4gBIA9BCEEHQQggYkL/AINC/wBRGyBjQo8BWBsgDWoiDTYCkAEgCCEJCyANQSBNBEACQCAJQQVOBEAgA0EDaygCACEHIA8gCUEFazYClAEgDyADQQRrNgKAAQwBC0EAIQcgCUECSA0AQRghCQNAIA8gA0EBayIBNgKAASADLQAAIUkgDyAGQQFrIgI2ApQBIEkgCXQgB3IhByAGQQFLIUogASEDIAlBCGshCSACIQYgSg0ACwsgDyAHQf8BcSIBQY8BSzYCmAEgD0EHQQggB0GAgID4B3FBgICA+AdGG0EIIBEbIgNBCEEHQQggB0GAgPwDcUGAgPwDRhsgB0H/////eE0baiIGQQhBB0EIIAdBgP4BcUGA/gFGGyAHQRB2Qf8BcSIJQY8BTRtqIgJBCEEHQQggB0H/AHFB/wBGGyAHQQh2Qf8BcSIIQY8BTRsgDWpqNgKQASAPIAkgA3QgB0EYdnIgCCAGdHIgASACdHKtIA2thiBghDcDiAELQQELITEgGCASayEfIBZBAWohLCAUQQA6AMAQIBRBwBBqIQsgD0GAAmoQKCECIBVBAEoEQCAmQQFrIRMgFCEDIAshCEEAIREgDiEGQQAhDQNAIA0hBSARQQh0IA9B4AFqEC9B/wBxQQF0ckGg/QBqLwEAIQECQCARDQAgAUEAIAJBAmsiB0F/RhshASACQQFKBEAgByECDAELIA9BgAJqECghAgsgDykD6AEhZCAPKALwASFLIAMgAygCACABQQR2IhhBA3EgAUECdkEwcXIgInRyIhY2AgAgAUEFdkEHcSABQRBxIh5BBHZyIREgSyABQQdxIgdrIQ0gZCAHrYgiYKchCUEAIQcgFSAFQQJySgRAIBFBCHQgCUH/AHFBAXRyQaD9AGovAQAhBwJAIBENACAHQQAgAkECayIJQX9GGyEHIAJBAUoEQCAJIQIMAQsgD0GAAmoQKCECCyAHQQR2QQFxIAdBBXZBB3FyIREgDSAHQQdxIglrIQ0gYCAJrYgiYKchCQsgAyAHQQJ0QYAGcSAHQTBxciAiQQRqdCAWcjYCAAJAIAdBAnZBAnEgAUEDdkEBcXIiF0EDRw0AQQRBAyACQQJrIhZBf0YbIRcgAkEBSgRAIBYhAgwBCyAPQYACahAoIQILAn8gF0UEQCAPQoGAgIAQNwJ4QQAMAQsgF0ECTQRAIA9BASAJQQdxQdSdAWotAAAiFkEFdkF/IBZBAnZBB3EiGXRBf3MgCSAWQQNxIgl2cWpBAWoiFiAXQQFGIhcbNgJ8IA8gFkEBIBcbNgJ4IAkgGWoMAQsgCSAJQQdxQdSdAWotAAAiFkEDcSIZdiEJIBdBA0YEQCAWQQV2QQFqIRcgGUEDRgRAIA8gCUEBcUECcjYCfCAPIBdBfyAWQQJ2QQdxIhZ0QX9zIAlBAXZxajYCeCAWQQRqDAILIA8gFyAJIAlBB3FB1J0Bai0AACIJQQNxIhJ2IiBBfyAWQQJ2QQdxIhZ0QX9zcWo2AnggD0F/IAlBAnZBB3EiF3RBf3MgICAWdnEgCUEFdmpBAWo2AnwgFiAZaiASaiAXagwBCyAPIAkgCUEHcUHUnQFqLQAAIglBA3EiEnYiIEF/IBZBAnZBB3EiF3RBf3NxIBZBBXZqQQNqNgJ4IA9BfyAJQQJ2QQdxIhZ0QX9zICAgF3ZxIAlBBXZqQQNqNgJ8IBIgGWogF2ogFmoLIQkCQCAsIA8oAngiGU8EQCAPKAJ8IhIgLE0NAQsgIQRAQQAhByAdQQFBmfYAQQAQDwwHC0EAIQcgHUEBQZn2AEEAEA8MBgsgDyANIAlrNgLwASAPIGAgCa2INwPoASAHQfABcSAYQQ9xckH/AUH/ASAFQQRqIg0gFWtBAXR2IA0gFUwbIgkgCUHVAHEgH0EBShsiCUF/c3EEQCAhBEBBACEHIB1BAUGv2gBBABAPDAcLQQAhByAdQQFBr9oAQQAQDwwGCwJAAkAgHgRAIA9BwAFqEBshFyAPIA8oAtABIBkgAUETdEEfdWoiFms2AtABIA8gDykDyAEgFq2INwPIASAXQX8gFnRBf3NxIAFBCHZBAXEgFnRyQQFyQQJqIBN0IBdBH3RyIRYMAQtBACEWIAlBAXFFDQELIAYgFjYCAAsCQCABQSBxBEAgD0HAAWoQGyEXIA8gDygC0AEgGSABQRJ0QR91aiIWazYC0AEgDyAPKQPIASAWrYg3A8gBIAYgFUECdGogF0F/IBZ0QX9zcSABQQl2QQFxIBZ0ckEBciIWQQJqIBN0IBdBH3RyNgIAIAhBICAWZ2siFiAILQAAQf8AcSIXIBYgF0sbQYABcjoAAAwBCyAJQQJxRQ0AIAYgFUECdGpBADYCAAsgBkEEaiEXAkACQCABQcAAcQRAIA9BwAFqEBshGCAPIA8oAtABIBkgAUERdEEfdWoiFms2AtABIA8gDykDyAEgFq2INwPIASAYQX8gFnRBf3NxIAFBCnZBAXEgFnRyQQFyQQJqIBN0IBhBH3RyIRYMAQtBACEWIAlBBHFFDQELIBcgFjYCAAsgCEEAOgABAkAgAUGAAXEEQCAPQcABahAbIRggDyAPKALQASAZIAFBEHRBH3VqIhZrNgLQASAPIA8pA8gBIBatiDcDyAEgFyAVQQJ0aiAYQX8gFnRBf3NxIAFBC3ZBAXEgFnRyQQFyIgFBAmogE3QgGEEfdHI2AgAgCEGgfyABZ2s6AAEMAQsgCUEIcUUNACAXIBVBAnRqQQA2AgALIAZBCGohAQJAAkAgB0EQcQRAIA9BwAFqEBshGSAPIA8oAtABIBIgB0ETdEEfdWoiFms2AtABIA8gDykDyAEgFq2INwPIASAZQX8gFnRBf3NxIAdBCHZBAXEgFnRyQQFyQQJqIBN0IBlBH3RyIRcMAQtBACEXIAlBEHFFDQELIAEgFzYCAAsCQCAHQSBxBEAgD0HAAWoQGyEZIA8gDygC0AEgEiAHQRJ0QR91aiIWazYC0AEgDyAPKQPIASAWrYg3A8gBIAEgFUECdGogGUF/IBZ0QX9zcSAHQQl2QQFxIBZ0ckEBciIBQQJqIBN0IBlBH3RyNgIAIAhBICABZ2siASAILQABQf8AcSIWIAEgFksbQYABcjoAAQwBCyAJQSBxRQ0AIAEgFUECdGpBADYCAAsgBkEMaiEBAkACQCAHQcAAcQRAIA9BwAFqEBshGSAPIA8oAtABIBIgB0ERdEEfdWoiFms2AtABIA8gDykDyAEgFq2INwPIASAZQX8gFnRBf3NxIAdBCnZBAXEgFnRyQQFyQQJqIBN0IBlBH3RyIRcMAQtBACEXIAlBwABxRQ0BCyABIBc2AgALIAhBAmoiCEEAOgAAAkAgB0GAAXEEQCAPQcABahAbIRYgDyAPKALQASASIAdBEHRBH3VqIglrNgLQASAPIA8pA8gBIAmtiDcDyAEgASAVQQJ0aiAWQX8gCXRBf3NxIAdBC3ZBAXEgCXRyQQFyIgFBAmogE3QgFkEfdHI2AgAgCEGgfyABZ2s6AAAMAQsgCUGAAUkNACABIBVBAnRqQQA2AgALICJBEHMhIiADIAVBBHFqIQMgBkEQaiEGIA0gFUgNAAsLIApBCHEhOCAUQbAMaiEoIBRBoAhqISkgFEGQBGohJSAfQQNOBEAgFUEDbCE5IBVBAXQhOiAmQQFrISBBAyAmQQJrIgF0IS1BASABdCEuIBVBB2pBAXZB/P///wdxQQRqIT0gKyAkQX9zaiIBQQN2IgNBAnQiPkEEaiE7IANBAWoiP0H8////A3EiHEECdCE8IBxBA3QhEiABQRhJIUBBAiEZA0AgGSETIAstAAAhFiALQQA6AAAgIkFvcUECcyEiAkAgFUEATARAIBNBAmohGQwBCyAlIBQgE0EEcRshESATQQJqIRkgDiATIBVsQQJ0aiEIQQAhCiALIQZBACENA0AgDSEFIAYtAAFBBXZBBHEgCiAWQQd2cnIiA0EIdCAPQeABahAvQf8AcUEBdHJBoI0Bai8BACEBAkAgAw0AIAFBACACQQJrIgNBf0YbIQEgAkEBSgRAIAMhAgwBCyAPQYACahAoIQILIA8pA+gBIWUgDygC8AEhTCARIBEoAgAgAUEEdkEDcSABQQJ2QTBxciAidHIiCTYCACABQcAAcSIqQQV2IAFBgAFxIidBBnZyIQogTCABQQdxIgNrIRcgZSADrYgiYKchDUEAIRgCQCAVIAVBAnJMBEBBACEHDAELIAogBi0AAkEFdkEEcSAGLQABQQd2cnIiA0EIdCANQf8AcUEBdHJBoI0Bai8BACEHAkAgAw0AIAdBACACQQJrIgNBf0YbIQcgAkEBSgRAIAMhAgwBCyAPQYACahAoIQILIAdBBXYgB0EGdnJBAnEhCiAXIAdBB3EiA2shFyBgIAOtiCJgpyENCyARIAdBAnRBgAZxIAdBMHFyICJBBGp0IAlyNgIAQQEhCUEBIQMCQCAHQQJ2QQJxIAFBA3ZBAXFyIh5FDQAgDSANQQdxQdSdAWotAAAiA0EDcSINdiEJIB5BA0cEQEEBIAlBfyADQQJ2QQdxIhh0QX9zcSADQQV2akEBaiIDIB5BAUYiHhshCSADQQEgHhshAyANIBhqIRgMAQsgCUEHcUHUnQFqLQAAIh5BA3EiMyANIANBAnZBB3EiG2pqIB5BAnZBB3EiDWohGCAJIDN2IglBfyAbdEF/c3EgA0EFdmpBAWohA0F/IA10QX9zIAkgG3ZxIB5BBXZqQQFqIQkLIA8gFyAYazYC8AEgDyBgIBitiDcD6AEgAUHwAXEiDSANQQFrcQRAIAMgFkH/AHEiFiAGLQABQf8AcSIXIBYgF0sbIhZBAmsiF0EAIBYgF08baiEDCyAHQfABcSIXIBdBAWtxBEAgCSAGLQABQf8AcSIWIAYtAAJB/wBxIhggFiAYSxsiFkECa0EAIBZBAksbaiEJCyADICxNIAkgLE1xRQRAICEEQEEAIQcgHUEBQf32AEEAEA8MCQtBACEHIB1BAUH99gBBABAPDAgLIAYtAAIhFiAGQQA7AAEgFyANQQR2ckH/AUH/ASAFQQRqIg0gFWtBAXR2IA0gFUwbIhdB1QBxIBcgGSAfShsiGEF/c3EEQCAhBEBBACEHIB1BAUGv2gBBABAPDAkLQQAhByAdQQFBr9oAQQAQDwwICwJAAkAgAUEQcQRAIA9BwAFqEBshHiAPIA8oAtABIAMgAUETdEEfdWoiF2s2AtABIA8gDykDyAEgF62INwPIASAeQX8gF3RBf3NxIAFBCHZBAXEgF3RyQQFyQQJqICB0IB5BH3RyIRcMAQtBACEXIBhBAXFFDQELIAggFzYCAAsCQCABQSBxBEAgD0HAAWoQGyEeIA8gDygC0AEgAyABQRJ0QR91aiIXazYC0AEgDyAPKQPIASAXrYg3A8gBIAggFUECdGogHkF/IBd0QX9zcSABQQl2QQFxIBd0ckEBciIXQQJqICB0IB5BH3RyNgIAIAZBICAXZ2siFyAGLQAAQf8AcSIeIBcgHksbQYABcjoAAAwBCyAYQQJxRQ0AIAggFUECdGpBADYCAAsgCEEEaiEeAkACQCAqBEAgD0HAAWoQGyEbIA8gDygC0AEgAyABQRF0QR91aiIXazYC0AEgDyAPKQPIASAXrYg3A8gBIBtBfyAXdEF/c3EgAUEKdkEBcSAXdHJBAXJBAmogIHQgG0EfdHIhFwwBC0EAIRcgGEEEcUUNAQsgHiAXNgIACwJAICcEQCAPQcABahAbIRcgDyAPKALQASADIAFBEHRBH3VqIgNrNgLQASAPIA8pA8gBIAOtiDcDyAEgHiAVQQJ0aiAXQX8gA3RBf3NxIAFBC3ZBAXEgA3RyQQFyIgFBAmogIHQgF0EfdHI2AgAgBkGgfyABZ2s6AAEMAQsgGEEIcUUNACAeIBVBAnRqQQA2AgALIAhBCGohAQJAAkAgB0EQcQRAIA9BwAFqEBshFyAPIA8oAtABIAkgB0ETdEEfdWoiA2s2AtABIA8gDykDyAEgA62INwPIASAXQX8gA3RBf3NxIAdBCHZBAXEgA3RyQQFyQQJqICB0IBdBH3RyIQMMAQtBACEDIBhBEHFFDQELIAEgAzYCAAsCQCAHQSBxBEAgD0HAAWoQGyEXIA8gDygC0AEgCSAHQRJ0QR91aiIDazYC0AEgDyAPKQPIASADrYg3A8gBIAEgFUECdGogF0F/IAN0QX9zcSAHQQl2QQFxIAN0ckEBciIBQQJqICB0IBdBH3RyNgIAIAZBICABZ2siASAGLQABQf8AcSIDIAEgA0sbQYABcjoAAQwBCyAYQSBxRQ0AIAEgFUECdGpBADYCAAsgCEEMaiEBAkACQCAHQcAAcQRAIA9BwAFqEBshFyAPIA8oAtABIAkgB0ERdEEfdWoiA2s2AtABIA8gDykDyAEgA62INwPIASAXQX8gA3RBf3NxIAdBCnZBAXEgA3RyQQFyQQJqICB0IBdBH3RyIQMMAQtBACEDIBhBwABxRQ0BCyABIAM2AgALIAZBAmohBgJAIAdBgAFxBEAgD0HAAWoQGyEXIA8gDygC0AEgCSAHQRB0QR91aiIDazYC0AEgDyAPKQPIASADrYg3A8gBIAEgFUECdGogF0F/IAN0QX9zcSAHQQt2QQFxIAN0ckEBciIBQQJqICB0IBdBH3RyNgIAIAZBoH8gAWdrOgAADAELIBhBgAFJDQAgASAVQQJ0akEANgIACyAiQRBzISIgESAFQQRxaiERIAhBEGohCCANIBVIDQALCwJAIAxBAkkNACATQQJxRQ0AIBlBBHEhAwJAAn8CQAJAIDEEQCAUICUgAxshFkEAIRggFUEATA0BIA4gE0ECayAVbEECdGohEQNAIA9BgAFqEC8hB0EAIQEgFigCACIIBEAgESAYQQJ0aiEBQQAhCUEPIQYDQAJAIAYgCHFFDQAgBkGRosSIAXEiDSAIcQRAIAEgASgCACAHQX9zQQFxICB0cyAucjYCACAHQQF2IQcLIA1BAXQgCHEEQCABIBVBAnRqIgUgBSgCACAHQX9zQQFxICB0cyAucjYCACAHQQF2IQcLIA1BAnQgCHEEQCABIDpBAnRqIgUgBSgCACAHQX9zQQFxICB0cyAucjYCACAHQQF2IQcLIA1BA3QgCHFFDQAgASA5QQJ0aiINIA0oAgAgB0F/c0EBcSAgdHMgLnI2AgAgB0EBdiEHCyABQQRqIQEgBkEEdCEGIAlBAWoiCUEIRw0ACyAIaSEBCyAWQQRqIRYgDyAPKAKQASABazYCkAEgDyAPKQOIASABrYg3A4gBIBhBCGoiGCAVSA0ACwsgKSAoIAMbIQUgFCAlIAMbIRYgA0UhGCAVQQBMDQNBACEDIEANASAFIBYgO2pJIBYgBSA7aiIHSXENAUEAIAUiASAWIgYgPmpBCGpJIAZBBGogB0lxDQIaIAYgPGohBiABIDxqIQH9DAAAAAAAAAAAAAAAAAAAAAAhXkEAIQcDQCAFIAdBAnQiA2oiCSADIBZqIgP9AAIAIl9BBP2tASBfQQT9qwEgXiBf/Q0MDQ4PEBESExQVFhcYGRobQRz9rQH9UP1QIF/9UCJe/QsCACAJIF4gA/0AAgRBHP2rAf1QIl5BAf2tAf0Md3d3d3d3d3d3d3d3d3d3d/1OIF5BAf2rAf0M7u7u7u7u7u7u7u7u7u7u7v1O/VAgXv1QIF/9T/0LAgAgXyFeIAdBBGoiByAcRw0ACyAcID9GDQMgEiEDIF79GwMMAgsgA0UhGCApICggAxshBQwCCyAFIQEgFiEGQQALIQcDQCAHQRx2IQkgASAGKAIAIgdBBHYgCSAHQQR0cnIgB3IiCTYCACABIAkgBigCBEEcdHIiCUEBdkH37t27B3EgCUEBdEHu3bv3fnFyIAlyIAdBf3NxNgIAIAFBBGohASAGQQRqIQYgA0EIaiIDIBVIDQALCyATQQZJDQBBACEJQQAhESAWIQEgKSAoIBgbIhshByAUICUgGBsiFyEGAkAgFUEATCINDQADQCABQQRqIQMgBygCACEIIAEoAgAhASAHIDgEfyAIBSABQQR0IBFBHHZyIAFBBHZyIAMoAgBBHHRyIAFyQQN0QYiRosR4cSAIcgsgBigCAEF/c3E2AgAgBkEEaiEGIAdBBGohByABIREgAyEBIAlBCGoiCSAVSA0ACyANDQAgDiATQQZrIBVsQQJ0aiFBQQAhHiAXIREDQEEAIQMgGygCACIBBEAgFSAeayFCQQAhB0EAIQoDQCAHIU0gD0GgAWoQGyEHAkAgCiAKQQRqIgYgQiAGIB5qIBVIGyIzTiJDBEBBACEGDAELIBEoAgBBf3MhKiBBIAogHnJBAnRqIRhBACEGQQ8gCiIJQQJ0IkR0Ig0hCANAAkAgASAIcUUNACAIQZGixIgBcSInIAFxBEAgB0EBcQRAIAMgJ3IhA0EyIAlBAnR0ICpxIAFyIQELIAdBAXYhByAGQQFqIQYLIAEgJ0EBdCI0cQRAIAdBAXEEQCADIDRyIQMgAUH0ACAJQQJ0dCAqcXIhAQsgB0EBdiEHIAZBAWohBgsgASAnQQJ0IjRxBEAgB0EBcQRAIAMgNHIhAyABQegBIAlBAnR0ICpxciEBCyAHQQF2IQcgBkEBaiEGCyABICdBA3QiJ3FFDQAgB0EBcQRAIAMgJ3IhAyABQcABIAlBAnR0ICpxciEBCyAGQQFqIQYgB0EBdiEHCyAIQQR0IQggCUEBaiIJIDNIDQALIAMgRHZB//8DcUUNACBDDQADQAJAIAMgDXFFDQAgDUGRosSIAXEiCSADcQRAIBggGCgCACAHQR90ciAtcjYCACAHQQF2IQcgBkEBaiEGCyAJQQF0IANxBEAgGCAVQQJ0aiIIIAgoAgAgB0EfdHIgLXI2AgAgB0EBdiEHIAZBAWohBgsgCUECdCADcQRAIBggOkECdGoiCCAIKAIAIAdBH3RyIC1yNgIAIAdBAXYhByAGQQFqIQYLIAlBA3QgA3FFDQAgGCA5QQJ0aiIJIAkoAgAgB0EfdHIgLXI2AgAgBkEBaiEGIAdBAXYhBwsgDUEEdCENIBhBBGohGCAKQQFqIgogM0gNAAsLIA8gDygCsAEgBms2ArABIA8gDykDqAEgBq2INwOoAUEBIQdBBCEKIE1BAXFFDQALIBsgGygCBCADQRt2QQ5xIANBHXZyIANBHHZyIBEoAgRBf3NxcjYCBAsgESgCACADciIDQQN2QZGixIgBcSIBQQR2IAFBBHRyIAFyIQYgHgRAIAVBBGsiByAHKAIAIBZBBGsoAgBBf3MgAUEcdHFyNgIACyAFIAUoAgAgBiAWKAIAQX9zcXI2AgAgBSAFKAIEIBYoAgRBf3MgA0EfdnFyNgIEIBtBBGohGyARQQRqIREgBUEEaiEFIBZBBGohFiAeQQhqIh4gFUgNAAsLIBdBACA9EBUaCyAZIB9IDQALCwJAIAxBAkkNAAJAIB9BA3FBAWsiFkECSSAxcQRAIBVBAEwNAUEBICZBAmt0IQIgDiAfQfz//wdxIBVsQQJ0aiERICUgFCAfQQRxGyEFICZBAWshCEEAIQogFUEMbCEMIBVBA3QhCwNAIA9BgAFqEC8hB0EAIQEgBSgCACIDBEAgESAKQQJ0aiEBQQ8hBkEAIQkDQAJAIAMgBnFFDQAgBkGRosSIAXEiDSADcQRAIAEgASgCACAHQX9zQQFxIAh0cyACcjYCACAHQQF2IQcLIA1BAXQgA3EEQCABIBVBAnRqIh0gHSgCACAHQX9zQQFxIAh0cyACcjYCACAHQQF2IQcLIA1BAnQgA3EEQCABIAtqIh0gHSgCACAHQX9zQQFxIAh0cyACcjYCACAHQQF2IQcLIA1BA3QgA3FFDQAgASAMaiINIA0oAgAgB0F/c0EBcSAIdHMgAnI2AgAgB0EBdiEHCyABQQRqIQEgBkEEdCEGIAlBAWoiCUEIRw0ACyADaSEBCyAFQQRqIQUgDyAPKAKQASABazYCkAEgDyAPKQOIASABrYg3A4gBIApBCGoiCiAVSA0ACwsgFkEBSw0AIBVBAEwNACAlIBQgH0EEcSIBGyEJICggKSABGyECQQAhAwJ/AkAgKyAkQX9zaiIBQThJDQAgAiAJIAFBAXZB/P///wdxIgZBBGoiB2pJIAkgAiAHaiIHSXENACACIAYgCWpBCGpJIAlBBGogB0lxDQAgAUEDdkEBaiINQfz///8DcSIIQQN0IQMgCSAIQQJ0IgFqIQYgASACaiEB/QwAAAAAAAAAAAAAAAAAAAAAIV5BACEHA0AgAiAHQQJ0IhZqIhEgCSAWaiIW/QACACJfQQT9rQEgX0EE/asBIF4gX/0NDA0ODxAREhMUFRYXGBkaG0Ec/a0B/VD9UCBf/VAiXv0LAgAgESBeIBb9AAIEQRz9qwH9UCJeQQH9rQH9DHd3d3d3d3d3d3d3d3d3d3f9TiBeQQH9qwH9DO7u7u7u7u7u7u7u7u7u7u79Tv1QIF79UCBf/U/9CwIAIF8hXiAHQQRqIgcgCEcNAAsgCCANRg0CIF79GwMMAQsgAiEBIAkhBkEACyEHA0AgB0EcdiEJIAEgBigCACIHQQR2IAkgB0EEdHJyIAdyIgk2AgAgASAJIAYoAgRBHHRyIglBAXZB9+7duwdxIAlBAXRB7t27935xciAJciAHQX9zcTYCACABQQRqIQEgBkEEaiEGIANBCGoiAyAVSA0ACwsgHyAfQQFqQQNxa0EDa0EAIB9BBkobIhEgH04NAEEDICZBAmt0IRkgKyAkQX9zaiIBQQN2IgNBAnQiK0EEaiEdIANBAWoiA0H8////A3EiEkECdCEhIBJBA3QhFiAVQQxsISwgFUEDdCEtIAFBGEkhJiADIBJGIRsDQAJAAkACQAJAAn8CQCAfIBFrIgFBAWsiA0EDTwRAQX8hFyABQQVIDQUgFUEATA0GICUgFCARQQRxIgEbIQIgKCApIAEbIQkgOARAQQAhBiAmDQQgAiAJIB1qSSACIB1qIAlLcQ0EIAIgIWohASAJICFqIQcDQCAJIAZBAnQiA2oiCCAI/QACACACIANq/QACAP1P/QsCACAGQQRqIgYgEkcNAAsgFiEGIBsNBgwFCyAUICUgARshDUEAIQMgJg0BIAkgDSAdakkgDSAJIB1qIgFJcQ0BIAkgDSArakEIakkgDUEEaiABSXENASAJIAIgHWpJIAEgAktxDQEgAiAhaiEIIAkgIWohASANICFqIQf9DAAAAAAAAAAAAAAAAAAAAAAhXkEAIQYDQCAJIAZBAnQiA2oiBSADIA1qIgz9AAIAIl9BBP2tASBfQQT9qwEgXiBf/Q0MDQ4PEBESExQVFhcYGRobQRz9rQH9UP1QIAz9AAIEQRz9qwH9UCBf/VBBA/2rAf0MiIiIiIiIiIiIiIiIiIiIiP1OIAX9AAIA/VAgAiADav0AAgD9T/0LAgAgXyFeIAZBBGoiBiASRw0ACyAbDQUgFiEDIF79GwMMAgsgA0ECdEHcnQFqKAIAIRcMBAsgDSEHIAkhASACIQhBAAshBgNAIAZBHHYhCSABIAEoAgAgBygCACIGQQR2IAkgBkEEdHJyIAcoAgRBHHRyIAZyQQN0QYiRosR4cXIgCCgCAEF/c3E2AgAgCEEEaiEIIAFBBGohASAHQQRqIQcgA0EIaiIDIBVIDQALDAILIAkhByACIQELA0AgByAHKAIAIAEoAgBBf3NxNgIAIAFBBGohASAHQQRqIQcgBkEIaiIGIBVIDQALCyAVQQBMDQAgJSAUIBFBBHEiARshCiAoICkgARshAiAUICUgARshEyApICggARshHiAOIBEgFWxBAnRqIS5BACEFA0BBACEDIAIoAgAgF3EiAQRAIBUgBWshKkEAIQdBACENA0AgByFOIA9BoAFqEBshBwJAIA0gDUEEaiIGICogBSAGaiAVSBsiJE4iJwRAQQAhBgwBCyAXIAooAgBBf3NxIRggLiAFIA1yQQJ0aiELQQAhBkEPIA0iCUECdCIcdCIgIQgDQAJAIAEgCHFFDQAgCEGRosSIAXEiIiABcQRAIAdBAXEEQCADICJyIQNBMiAJQQJ0dCAYcSABciEBCyAHQQF2IQcgBkEBaiEGCyABICJBAXQiMXEEQCAHQQFxBEAgAyAxciEDIAFB9AAgCUECdHQgGHFyIQELIAdBAXYhByAGQQFqIQYLIAEgIkECdCIxcQRAIAdBAXEEQCADIDFyIQMgAUHoASAJQQJ0dCAYcXIhAQsgB0EBdiEHIAZBAWohBgsgASAiQQN0IiJxRQ0AIAdBAXEEQCADICJyIQMgAUHAASAJQQJ0dCAYcXIhAQsgBkEBaiEGIAdBAXYhBwsgCEEEdCEIIAlBAWoiCSAkSA0ACyADIBx2Qf//A3FFDQAgJw0AA0ACQCADICBxRQ0AICBBkaLEiAFxIgkgA3EEQCALIAsoAgAgB0EfdHIgGXI2AgAgB0EBdiEHIAZBAWohBgsgCUEBdCADcQRAIAsgFUECdGoiCCAIKAIAIAdBH3RyIBlyNgIAIAdBAXYhByAGQQFqIQYLIAlBAnQgA3EEQCALIC1qIgggCCgCACAHQR90ciAZcjYCACAHQQF2IQcgBkEBaiEGCyAJQQN0IANxRQ0AIAsgLGoiCSAJKAIAIAdBH3RyIBlyNgIAIAZBAWohBiAHQQF2IQcLICBBBHQhICALQQRqIQsgDUEBaiINICRIDQALCyAPIA8oArABIAZrNgKwASAPIA8pA6gBIAatiDcDqAFBASEHQQQhDSBOQQFxRQ0ACyACIAIoAgQgA0EbdkEOcSADQR12ciADQRx2ciAKKAIEQX9zcXI2AgQLIAooAgAgA3IiA0EDdkGRosSIAXEiAUEEdiABQQR0ciABciEGIAUEQCAeQQRrIgcgBygCACATQQRrKAIAQX9zIAFBHHRxcjYCAAsgHiAeKAIAIAYgEygCAEF/c3FyNgIAIB4gHigCBCATKAIEQX9zIANBH3ZxcjYCBCACQQRqIQIgCkEEaiEKIB5BBGohHiATQQRqIRMgBUEIaiIFIBVIDQALCyARQQRqIhEgH0gNAAsLQQEhByAfQQBMDQMgFUEATA0DIBVB/P///wdxIgZBAnQhAiAVQQRJIQhBACEJA0AgDiAJIBVsQQJ0aiEDAkACQCAIBEAgAyEHQQAhAQwBCyACIANqIQdBACEBA0AgAyABQQJ0aiINIA39AAIAIl79DP///3////9/////f////3/9TiJf/aEBIF8gXv0MAAAAAAAAAAAAAAAAAAAAAP05/VL9CwIAIAFBBGoiASAGRw0ACyAGIgEgFUYNAQsDQCAHQQAgBygCACIDQf////8HcSINayANIANBAEgbNgIAIAdBBGohByABQQFqIgEgFUcNAAsLQQEhByAJQQFqIgkgH0cNAAsMAwsgIUUNACAPIBooAhg2AjQgDyAWNgIwIB1BAUHcxwAgD0EwahAPDAELIA8gATYCFCAPIBY2AhAgHUEBQdzHACAPQRBqEA9BACEHDAELQQAhBwsgD0GwAmokACAHDQEMAwsgBCABQQl0QdCpAWo2AmwCfyAEKAJ0IQECQAJAIBooAhAgGigCCGsiBSAaKAIUIBooAgxrIglsIgMgBCgChAFLBEAgARAQIAQgA0ECdBAYIgE2AnRBACABRQ0DGiAEIAM2AoQBDAELIAFFDQELIAFBACADQQJ0EBUaCyAEKAJ4IQECQCAFQQJqIgYgCUEDakECdiIMQQJqbCIDIAQoAogBTQRAIANBAnQhCAwBCyABEBAgBCADQQJ0IggQGCIBNgJ4IAENAEEADAELIAQgAzYCiAEgAUEAIAgQFRoCQCAGRQ0AIAQoAngiByEBAkAgBkEETwRAIAcgBkF8cSINQQJ0aiEBQQAhCANAIAcgCEECdGr9DAAAIEkAACBJAAAgSQAAIEn9CwIAIAhBBGoiCCANRw0ACyAGIA1GDQELA0AgAUGAgIDJBDYCACABQQRqIQEgDUEBaiINIAZHDQALCyAHIAxBAWogBmxBAnRqIQNBACENAkACQCAGQQRJBEAgAyEBDAELIAMgBkF8cSINQQJ0aiEBQQAhCANAIAMgCEECdGr9DAAAIEkAACBJAAAgSQAAIEn9CwIAIAhBBGoiCCANRw0ACyAGIA1GDQELA0AgAUGAgIDJBDYCACABQQRqIQEgDUEBaiINIAZHDQALCyAJQQNxIgFFDQAgBkUNAEGAgIDIBEGAgIDABEGAgICABCABQQJGGyABQQFGGyELIAcgBiAMbEECdGohA0EAIQ0CQCAGQQRJBEAgAyEBDAELIAMgBkF8cSINQQJ0aiEBIAv9ESFfQQAhCANAIAMgCEECdGogX/0LAgAgCEEEaiIIIA1HDQALIAYgDUYNAQsDQCABIAs2AgAgAUEEaiEBIA1BAWoiDSAGRw0ACwsgBCAJNgKAASAEIAU2AnxBAQtFDQIgGigCHCARaiIZQR9OBEAgIUUNAiAjIBk2AhAgHUECQdXBACAjQRBqEA8MAwsgBBBaQQAhASAEQbCpATYCZCAEQdCeATYCYCAEQfCeATYCHAJAAkACQAJAIBooAjQiB0EBSw0AIAQoApABRQ0CIAcNAAwBCyAaKAIEIQMgB0EETwRAIAdBfHEhAkEAIQYDQCADIAZBA3RqIgFBHGogAUEUaiABQQxqIAH9CQIE/VYCAAH9VgIAAv1WAgADIF79rgEhXiAGQQRqIgYgAkcNAAsgXiBeIF79DQgJCgsMDQ4PAAECAwABAgP9rgEiXiBeIF79DQQFBgcAAQIDAAECAwABAgP9rgH9GwAhASACIAdGDQELA0AgAyACQQN0aigCBCABaiEBIAJBAWoiAiAHRw0ACwsgAUECaiIDIAQoApgBSwRAIAQoApQBIAMQFyIGRQ0FIAQgBjYClAEgASAGakEAOwAAIAQgAzYCmAEgGigCNCEHCyAEKAKUASEeIAdFDQEgGigCBCEGQQAhAkEAIQEDQCACIB5qIAYgAUEDdCIDaiIGKAIAIAYoAgQQEhogGigCBCIGIANqKAIEIAJqIQIgAUEBaiIBIBooAjRJDQALDAELIAdBAUcNASAaKAIEKAIAIR4LIBooAjwiAQRAIAQoAnQhLCAEIAE2AnQLIBooAiwEQCAWQQhxISUgBEEcaiEPIBZBAXEhLSAWQQJxRSEuQQIhHwNAIB4gKGohASAaKAIAIClBGGxqIiAoAgAhAwJAIC0gH0ECSSAZIBooAhxBBGtMcXEiIgRAIAQgATYCFCAEIAEgA2oiAzYCGCAEIAMvAAA7AXAgA0H/AToAACAEKAIYQf8BOgABIARBADYCCCAEQQA2AgAgBCABNgIQDAELIAQgATYCFCAEIAEgA2oiBjYCGCAEIAYvAAA7AXAgBkH/AToAACAEKAIYQf8BOgABIAQgBEEcajYCaCAEIAE2AhAgBEEANgIMIAQgAwR/IAEtAABBEHQFQYCA/AcLIgM2AgBBASEGIAFBAWohCSABLQABIQcCfyABLQAAQf8BRgRAIAdBkAFPBEAgBEEBNgIMIANBgP4DcgwCCyAEIAk2AhBBACEGIAdBCXQgA2oMAQsgBCAJNgIQIAdBCHQgA3ILIQEgBCAGNgIIIARBgIACNgIEIAQgAUEHdDYCAAsgICgCACEqAkAgGUEATA0AICAoAghFDQAgIiAuciEnQQAhJgNAAkACQAJAAkACQCAfQQFrDgIBAgALICIEQEEBIBl0IgFBAXYgAXIhESAEKAJ8IgVBAnQiDSAEKAJ4akEMaiEBIAQoAnQhBkEAIQggBCgCgAEiA0EETwRAIAVFDQUgBUEDbCECIAVBAXQhDEEAIBFrIQkDQCAMQQJ0IQtBACEDA0ACQCABIgcoAgAiAUUNAAJAIAFBkICAAXENACABQe8DcUUNACAEKAIAIQECQCAEKAIIIhANACABQf8BRiEKIAQoAhAiEC0AACEBAkAgCkUEQCAEIAE2AgAgBCAQQQFqNgIQDAELIAFBjwFNBEAgBCABNgIAIAQgEEEBajYCEEEHIRAMAgtB/wEhASAEQf8BNgIAC0EIIRALIAQgEEEBayIQNgIIAkAgASAQdkEBcUUNAAJAIBANACABQf8BRiEKIAQoAhAiEC0AACEBAkAgCkUEQCAEIAE2AgAgBCAQQQFqNgIQDAELIAFBjwFNBEAgBCABNgIAIAQgEEEBajYCEEEHIRAMAgtB/wEhASAEQf8BNgIAC0EIIRALIAQgEEEBayIQNgIIIAYgCSARIAEgEHZBAXEiEBs2AgAgBCgCfCEBIAdBBGsiCiAKKAIAQSByNgIAIAcgBygCBEEIcjYCBCAHIAcoAgAgEEETdHJBEHI2AgAgJQ0AIAdBfiABa0ECdGoiASABKAIEQYCAAnI2AgQgASABKAIAIBBBH3RyQYCABHI2AgAgAUEEayIBIAEoAgBBgIAIcjYCAAsgByAHKAIAQYCAgAFyIgE2AgALAkAgAUGAgYAIcQ0AIAFB+B5xRQ0AIAQoAgAhAQJAIAQoAggiEA0AIAFB/wFGIQogBCgCECIQLQAAIQECQCAKRQRAIAQgATYCACAEIBBBAWo2AhAMAQsgAUGPAU0EQCAEIAE2AgAgBCAQQQFqNgIQQQchEAwCC0H/ASEBIARB/wE2AgALQQghEAsgBCAQQQFrIhA2AgggBwJ/IAEgEHZBAXFFBEAgBygCAAwBCwJAIBANACABQf8BRiEKIAQoAhAiEC0AACEBAkAgCkUEQCAEIAE2AgAgBCAQQQFqNgIQDAELIAFBjwFNBEAgBCABNgIAIAQgEEEBajYCEEEHIRAMAgtB/wEhASAEQf8BNgIAC0EIIRALIAQgEEEBayIQNgIIIAYgDWogCSARIAEgEHZBAXEiARs2AgAgB0EEayIQIBAoAgBBgAJyNgIAIAcgBygCBEHAAHI2AgQgBygCACABQRZ0ckGAAXILQYCAgAhyIgE2AgALAkAgAUGAiIDAAHENACABQcD3AXFFDQAgBCgCACEBAkAgBCgCCCIQDQAgAUH/AUYhCiAEKAIQIhAtAAAhAQJAIApFBEAgBCABNgIAIAQgEEEBajYCEAwBCyABQY8BTQRAIAQgATYCACAEIBBBAWo2AhBBByEQDAILQf8BIQEgBEH/ATYCAAtBCCEQCyAEIBBBAWsiEDYCCCAHAn8gASAQdkEBcUUEQCAHKAIADAELAkAgEA0AIAFB/wFGIQogBCgCECIQLQAAIQECQCAKRQRAIAQgATYCACAEIBBBAWo2AhAMAQsgAUGPAU0EQCAEIAE2AgAgBCAQQQFqNgIQQQchEAwCC0H/ASEBIARB/wE2AgALQQghEAsgBCAQQQFrIhA2AgggBiALaiAJIBEgASAQdkEBcSIBGzYCACAHQQRrIhAgECgCAEGAEHI2AgAgByAHKAIEQYAEcjYCBCAHKAIAIAFBGXRyQYAIcgtBgICAwAByIgE2AgALIAFBgMCAgARxDQAgAUGAvA9xRQ0AIAQoAgAhAQJAIAQoAggiEA0AIAFB/wFGIQogBCgCECIQLQAAIQECQCAKRQRAIAQgATYCACAEIBBBAWo2AhAMAQsgAUGPAU0EQCAEIAE2AgAgBCAQQQFqNgIQQQchEAwCC0H/ASEBIARB/wE2AgALQQghEAsgBCAQQQFrIhA2AgggASAQdkEBcQRAIAYgAkECdGohTwJAIBANACABQf8BRiEUIAQoAhAiEC0AACEBAkAgFEUEQCAEIAE2AgAgBCAQQQFqNgIQDAELIAFBjwFNBEAgBCABNgIAIAQgEEEBajYCEEEHIRAMAgtB/wEhASAEQf8BNgIAC0EIIRALIAQgEEEBayIQNgIIIE8gCSARIAEgEHZBAXEiEBs2AgAgBCgCfCEBIAdBBGsiCiAKKAIAQYCAAXI2AgAgByAHKAIEQYAgcjYCBCAHIAcoAgAgEEEcdHJBgMAAcjYCACAHIAFBAnRqIgEgASgCBEEEcjYCBCABIAEoAgxBAXI2AgwgASABKAIIIBBBEnRyQQJyNgIICyAHIAcoAgBBgICAgARyNgIACyAGQQRqIQYgB0EEaiEBIANBAWoiAyAFRw0ACyAHQQxqIQEgBiACQQJ0aiEGIAhBBGoiCCAEKAKAASIDQXxxSQ0ACwsgAyAITQ0DIAVFDQNBACETQQAgEWshCyADIRADQAJAIAggEEYEQCAIIRAMAQsgAUEEayEMIAEoAgAhDUEAIQIDQAJAIA0gAkEDbCIHdiIJQZCAgAFxDQAgCUHvA3FFDQAgBCgCACEDAkAgBCgCCCIJDQAgA0H/AUchECAEKAIQIgktAAAhAwJAIBBFBEAgA0GQAU8EQEH/ASEDIARB/wE2AgAMAgsgBCADNgIAIAQgCUEBajYCEEEHIQkMAgsgBCADNgIAIAQgCUEBajYCEAtBCCEJCyAEIAlBAWsiCTYCCAJAIAMgCXZBAXFFDQAgBiACIAVsQQJ0aiFQAkAgCQ0AIANB/wFHIQ0gBCgCECIJLQAAIQMCQCANRQRAIANBkAFPBEBB/wEhAyAEQf8BNgIADAILIAQgAzYCACAEIAlBAWo2AhBBByEJDAILIAQgAzYCACAEIAlBAWo2AhALQQghCQsgBCAJQQFrIgk2AgggUCALIBEgAyAJdkEBcSIJGzYCACAEKAJ8IRAgDCAMKAIAQSAgB3RyNgIAIAEgASgCACAJQRN0QRByIAd0cjYCACABIAEoAgRBCCAHdHI2AgQgAiAlckUEQCABQX4gEGtBAnRqIgMgAygCBEGAgAJyNgIEIAMgAygCACAJQR90ckGAgARyNgIAIANBBGsiAyADKAIAQYCACHI2AgALIAJBA0cNACABIBBBAnRqIgMgAygCBEEEcjYCBCADIAMoAgxBAXI2AgwgAyADKAIIIAlBEnRyQQJyNgIICyABIAEoAgBBgICAASAHdHIiDTYCACAEKAKAASEDCyADIRAgAkEBaiICIAMgCGtJDQALCyAGQQRqIQYgAUEEaiEBIBNBAWoiEyAFRw0ACwwDC0EAIQdBACENQQAhFwJAAkACQAJAIAQoAnwiEEHAAEcNACAEKAKAAUHAAEcNAEEAQQEgGXQiAUEBdiABciIRayEFIARBHGohECAEKAJ4QYwCaiEGIAQoAgghCCAEKAIEIQMgBCgCACECIAQoAmghDCAEKAJ0IQEgFkEIcQ0BA0BBACEXA0AgASEJIAYiBygCACIGBEACQCAGQZCAgAFxDQAgBkHvA3EiAUUNACADIBAgBCgCbCABai0AAEECdGoiDCgCACILKAIAIgFrIQMCfyABIAJBEHZLBEAgCygCBCEKIAwgC0EIQQwgASADSyIUG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQMgCC0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIANBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCADQQh0IAJqIQILIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIAogCkUgFBsMAQsgAiABQRB0ayECIANBgIACcUUEQCALKAIEIQogDCALQQxBCCABIANLIhQbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhASAILQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgAUEJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIAFBCHQgAmohAgsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyAKRSAKIBQbDAELIAsoAgQLBH8gAyAQIAcoAgRBEXZBBHEgB0EEayIKKAIAQRN2QQFxIAZBDnZBEHEgBkEQdkHAAHEgBkGqAXFycnJyIhRB0LkBai0AAEECdGoiDCgCACILKAIAIgFrIQMgFEHQuwFqLQAAIRMgCSAFIBECfyABIAJBEHZLBEAgCygCBCEUIAwgC0EIQQwgASADSyIOG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQMgCC0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIANBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCADQQh0IAJqIQILIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIBQgFEUgDhsMAQsgAiABQRB0ayECIANBgIACcUUEQCALKAIEIRQgDCALQQxBCCABIANLIg4baigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhASAILQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgAUEJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIAFBCHQgAmohAgsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyAURSAUIA4bDAELIAsoAgQLIBNzIgEbNgIAIAogCigCAEEgcjYCACAHIAcoAgRBCHI2AgQgB0GMAmsiCyALKAIAQYCACHI2AgAgB0GEAmsiCyALKAIAQYCAAnI2AgAgB0GIAmsiCyALKAIAIAFBH3RyQYCABHI2AgAgBiABQRN0ckEQcgUgBgtBgICAAXIhBgsCQCAGQYCBgAhxDQAgBkH4HnFFDQAgAyAQIAQoAmwgBkEDdiIUQe8DcWotAABBAnRqIgwoAgAiCygCACIBayEDAn8gASACQRB2SwRAIAsoAgQhCiAMIAtBCEEMIAEgA0siExtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAKIApFIBMbDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEKIAwgC0EMQQggASADSyITG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgCkUgCiATGwwBCyALKAIECwR/IAMgECAHKAIEQRR2QQRxIAdBBGsiCigCAEEWdkEBcSAGQQ92QRBxIAZBE3ZBwABxIBRBqgFxcnJyciIUQdC5AWotAABBAnRqIgwoAgAiCygCACIBayEDIBRB0LsBai0AACETIAkgBSARAn8gASACQRB2SwRAIAsoAgQhFCAMIAtBCEEMIAEgA0siDhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAUIBRFIA4bDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEUIAwgC0EMQQggASADSyIOG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgFEUgFCAOGwwBCyALKAIECyATcyIBGzYCgAIgCiAKKAIAQYACcjYCACAHIAcoAgRBwAByNgIEIAYgAUEWdHJBgAFyBSAGC0GAgIAIciEGCwJAIAZBgIiAwABxDQAgBkHA9wFxRQ0AIAMgECAEKAJsIAZBBnYiFEHvA3FqLQAAQQJ0aiIMKAIAIgsoAgAiAWshAwJ/IAEgAkEQdksEQCALKAIEIQogDCALQQhBDCABIANLIhMbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhAyAILQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgA0EJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIANBCHQgAmohAgsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgCiAKRSATGwwBCyACIAFBEHRrIQIgA0GAgAJxRQRAIAsoAgQhCiAMIAtBDEEIIAEgA0siExtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEBIAgtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECABQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggAUEIdCACaiECCyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIApFIAogExsMAQsgCygCBAsEfyADIBAgBygCBEEXdkEEcSAHQQRrIgooAgBBGXZBAXEgBkESdkEQcSAGQRZ2QcAAcSAUQaoBcXJycnIiFEHQuQFqLQAAQQJ0aiIMKAIAIgsoAgAiAWshAyAUQdC7AWotAAAhEyAJIAUgEQJ/IAEgAkEQdksEQCALKAIEIRQgDCALQQhBDCABIANLIg4baigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhAyAILQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgA0EJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIANBCHQgAmohAgsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgFCAURSAOGwwBCyACIAFBEHRrIQIgA0GAgAJxRQRAIAsoAgQhFCAMIAtBDEEIIAEgA0siDhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEBIAgtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECABQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggAUEIdCACaiECCyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIBRFIBQgDhsMAQsgCygCBAsgE3MiARs2AoAEIAogCigCAEGAEHI2AgAgByAHKAIEQYAEcjYCBCAGIAFBGXRyQYAIcgUgBgtBgICAwAByIQYLAkAgBkGAwICABHENACAGQYC8D3FFDQAgAyAQIAQoAmwgBkEJdiIUQe8DcWotAABBAnRqIgwoAgAiCygCACIBayEDAn8gASACQRB2SwRAIAsoAgQhCiAMIAtBCEEMIAEgA0siExtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAKIApFIBMbDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEKIAwgC0EMQQggASADSyITG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgCkUgCiATGwwBCyALKAIECwR/IAMgECAHKAIEQRp2QQRxIAdBBGsiCigCAEEcdkEBcSAGQRV2QRBxIAZBGXZBwABxIBRBqgFxcnJyciIUQdC5AWotAABBAnRqIgwoAgAiCygCACIBayEDIBRB0LsBai0AACETIAkgBSARAn8gASACQRB2SwRAIAsoAgQhFCAMIAtBCEEMIAEgA0siDhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAUIBRFIA4bDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEUIAwgC0EMQQggASADSyIOG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgFEUgFCAOGwwBCyALKAIECyATcyIBGzYCgAYgCiAKKAIAQYCAAXI2AgAgByAHKAIEQYAgcjYCBCAHIAcoAoQCQQRyNgKEAiAHIAcoAowCQQFyNgKMAiAHIAcoAogCIAFBEnRyQQJyNgKIAiAGIAFBHHRyQYDAAHIFIAYLQYCAgIAEciEGCyAHIAY2AgALIAdBBGohBiAJQQRqIQEgF0EBaiIXQcAARw0ACyAHQQxqIQYgCUGEBmohASANQTxJIVEgDUEEaiENIFENAAsMAgtBASAZdCIBQQF2IAFyIQ0gBCgCeCIJIBBBAnRqQQxqIQYgBCgCgAEhASAEKAIIIQggBCgCBCEDIAQoAgAhAiAEKAJoIQwgBCgCdCERAkAgFkEIcQRAAkAgAUEESQ0AIBAEQEEAIA1rIRQgBEEcaiEFIBBBDGwhEyAQQQN0IRUDQEEAIQsDQCAGIgkoAgAiBgRAAkAgBkGQgIABcQ0AIAZB7wNxIgFFDQAgAyAFIAQoAmwgAWotAABBAnRqIgwoAgAiCigCACIBayEDAn8gASACQRB2TQRAIAIgAUEQdGshAiADQYCAAnEEQCAKKAIEDAILIAooAgQhDiAMIApBDEEIIAEgA0siEhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEBIAgtAABB/wFHBEAgBCAKNgIQQQghCCABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAo2AhAgAUEJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIA5FIA4gEhsMAQsgCigCBCEOIAwgCkEIQQwgASADSyISG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQMgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIANBCHQgAmohAgwBCyADQY8BTQRAIAQgCjYCECADQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIA4gDkUgEhsLBH8gAyAFIAkoAgRBEXZBBHEgCUEEayIOKAIAQRN2QQFxIAZBDnZBEHEgBkEQdkHAAHEgBkGqAXFycnJyIhJB0LkBai0AAEECdGoiDCgCACIKKAIAIgFrIQMgEkHQuwFqLQAAIRggESAUIA0CfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCESIAwgCkEMQQggASADSyIbG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgEkUgEiAbGwwBCyAKKAIEIRIgDCAKQQhBDCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgEiASRSAbGwsgGHMiARs2AgAgDiAOKAIAQSByNgIAIAkgCSgCBEEIcjYCBCAGIAFBE3RyQRByBSAGC0GAgIABciEGCwJAIAZBgIGACHENACAGQfgecUUNACADIAUgBCgCbCAGQQN2IhJB7wNxai0AAEECdGoiDCgCACIKKAIAIgFrIQMCfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCEOIAwgCkEMQQggASADSyIYG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgDkUgDiAYGwwBCyAKKAIEIQ4gDCAKQQhBDCABIANLIhgbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgDiAORSAYGwsEfyADIAUgCSgCBEEUdkEEcSAJQQRrIg4oAgBBFnZBAXEgBkEPdkEQcSAGQRN2QcAAcSASQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIMKAIAIgooAgAiAWshAyASQdC7AWotAAAhGCARIBBBAnRqIBQgDQJ/IAEgAkEQdk0EQCACIAFBEHRrIQIgA0GAgAJxBEAgCigCBAwCCyAKKAIEIRIgDCAKQQxBCCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhASAILQAAQf8BRwRAIAQgCjYCEEEIIQggAUEIdCACaiECDAELIAFBjwFNBEAgBCAKNgIQIAFBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyASRSASIBsbDAELIAooAgQhEiAMIApBCEEMIAEgA0siGxtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEDIAgtAABB/wFHBEAgBCAKNgIQQQghCCADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAo2AhAgA0EJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyASIBJFIBsbCyAYcyIBGzYCACAOIA4oAgBBgAJyNgIAIAkgCSgCBEHAAHI2AgQgBiABQRZ0ckGAAXIFIAYLQYCAgAhyIQYLAkAgBkGAiIDAAHENACAGQcD3AXFFDQAgAyAFIAQoAmwgBkEGdiISQe8DcWotAABBAnRqIgwoAgAiCigCACIBayEDAn8gASACQRB2TQRAIAIgAUEQdGshAiADQYCAAnEEQCAKKAIEDAILIAooAgQhDiAMIApBDEEIIAEgA0siGBtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEBIAgtAABB/wFHBEAgBCAKNgIQQQghCCABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAo2AhAgAUEJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIA5FIA4gGBsMAQsgCigCBCEOIAwgCkEIQQwgASADSyIYG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQMgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIANBCHQgAmohAgwBCyADQY8BTQRAIAQgCjYCECADQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIA4gDkUgGBsLBH8gAyAFIAkoAgRBF3ZBBHEgCUEEayIOKAIAQRl2QQFxIAZBEnZBEHEgBkEWdkHAAHEgEkGqAXFycnJyIhJB0LkBai0AAEECdGoiDCgCACIKKAIAIgFrIQMgEkHQuwFqLQAAIRggESAVaiAUIA0CfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCESIAwgCkEMQQggASADSyIbG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgEkUgEiAbGwwBCyAKKAIEIRIgDCAKQQhBDCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgEiASRSAbGwsgGHMiARs2AgAgDiAOKAIAQYAQcjYCACAJIAkoAgRBgARyNgIEIAYgAUEZdHJBgAhyBSAGC0GAgIDAAHIhBgsCQCAGQYDAgIAEcQ0AIAZBgLwPcUUNACADIAUgBCgCbCAGQQl2IhJB7wNxai0AAEECdGoiDCgCACIKKAIAIgFrIQMCfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCEOIAwgCkEMQQggASADSyIYG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgDkUgDiAYGwwBCyAKKAIEIQ4gDCAKQQhBDCABIANLIhgbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgDiAORSAYGwsEfyADIAUgCSgCBEEadkEEcSAJQQRrIg4oAgBBHHZBAXEgBkEVdkEQcSAGQRl2QcAAcSASQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIMKAIAIgooAgAiAWshAyASQdC7AWotAAAhGCARIBNqIBQgDQJ/IAEgAkEQdk0EQCACIAFBEHRrIQIgA0GAgAJxBEAgCigCBAwCCyAKKAIEIRIgDCAKQQxBCCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhASAILQAAQf8BRwRAIAQgCjYCEEEIIQggAUEIdCACaiECDAELIAFBjwFNBEAgBCAKNgIQIAFBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyASRSASIBsbDAELIAooAgQhEiAMIApBCEEMIAEgA0siGxtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEDIAgtAABB/wFHBEAgBCAKNgIQQQghCCADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAo2AhAgA0EJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyASIBJFIBsbCyAYcyIKGzYCACAOIA4oAgBBgIABcjYCACAJIAkoAgRBgCByNgIEIAQoAnxBAnQgCWoiASABKAIEQQRyNgIEIAEgASgCDEEBcjYCDCABIAEoAgggCkESdHJBAnI2AgggBiAKQRx0ckGAwAByBSAGC0GAgICABHIhBgsgCSAGNgIACyAJQQRqIQYgEUEEaiERIAtBAWoiCyAQRw0ACyAJQQxqIQYgESATaiERIAdBBGoiByAEKAKAASIBQXxxSQ0ACwwBC0EEIAFBfHEiBiAGQQRNG0EBayIGQXxxQQRqIQcgCSAGQQF0QXhxakEUaiEGCyAEIAg2AgggBCADNgIEIAQgAjYCACAEIAw2AmggEEUNASABIAdNDQEDQCABIAdGIVJBACEIIAchASBSRQRAA0AgBCAGIBEgCCAQbEECdGogDSAIIAQoAnxBAmpBARBZIAhBAWoiCCAEKAKAASIBIAdrSQ0ACwsgBkEEaiEGIBFBBGohESAXQQFqIhcgEEcNAAsMAQsCQCABQQRJDQAgEARAQQAgDWshFCAEQRxqIQUgEEEMbCETIBBBA3QhFQNAQQAhCwNAIAYiCSgCACIGBEACQCAGQZCAgAFxDQAgBkHvA3EiAUUNACADIAUgBCgCbCABai0AAEECdGoiDCgCACIKKAIAIgFrIQMCfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCEOIAwgCkEMQQggASADSyISG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgDkUgDiASGwwBCyAKKAIEIQ4gDCAKQQhBDCABIANLIhIbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgDiAORSASGwsEfyADIAUgCSgCBEERdkEEcSAJQQRrIg4oAgBBE3ZBAXEgBkEOdkEQcSAGQRB2QcAAcSAGQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIMKAIAIgooAgAiAWshAyASQdC7AWotAAAhGCARIBQgDQJ/IAEgAkEQdk0EQCACIAFBEHRrIQIgA0GAgAJxBEAgCigCBAwCCyAKKAIEIRIgDCAKQQxBCCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhASAILQAAQf8BRwRAIAQgCjYCEEEIIQggAUEIdCACaiECDAELIAFBjwFNBEAgBCAKNgIQIAFBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyASRSASIBsbDAELIAooAgQhEiAMIApBCEEMIAEgA0siGxtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEDIAgtAABB/wFHBEAgBCAKNgIQQQghCCADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAo2AhAgA0EJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyASIBJFIBsbCyAYcyIKGzYCACAOIA4oAgBBIHI2AgAgCSAJKAIEQQhyNgIEIAlBfiAEKAJ8a0ECdGoiASABKAIEQYCAAnI2AgQgASABKAIAIApBH3RyQYCABHI2AgAgAUEEayIBIAEoAgBBgIAIcjYCACAGIApBE3RyQRByBSAGC0GAgIABciEGCwJAIAZBgIGACHENACAGQfgecUUNACADIAUgBCgCbCAGQQN2IhJB7wNxai0AAEECdGoiDCgCACIKKAIAIgFrIQMCfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCEOIAwgCkEMQQggASADSyIYG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgDkUgDiAYGwwBCyAKKAIEIQ4gDCAKQQhBDCABIANLIhgbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgDiAORSAYGwsEfyADIAUgCSgCBEEUdkEEcSAJQQRrIg4oAgBBFnZBAXEgBkEPdkEQcSAGQRN2QcAAcSASQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIMKAIAIgooAgAiAWshAyASQdC7AWotAAAhGCARIBBBAnRqIBQgDQJ/IAEgAkEQdk0EQCACIAFBEHRrIQIgA0GAgAJxBEAgCigCBAwCCyAKKAIEIRIgDCAKQQxBCCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhASAILQAAQf8BRwRAIAQgCjYCEEEIIQggAUEIdCACaiECDAELIAFBjwFNBEAgBCAKNgIQIAFBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyASRSASIBsbDAELIAooAgQhEiAMIApBCEEMIAEgA0siGxtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEDIAgtAABB/wFHBEAgBCAKNgIQQQghCCADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAo2AhAgA0EJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyASIBJFIBsbCyAYcyIBGzYCACAOIA4oAgBBgAJyNgIAIAkgCSgCBEHAAHI2AgQgBiABQRZ0ckGAAXIFIAYLQYCAgAhyIQYLAkAgBkGAiIDAAHENACAGQcD3AXFFDQAgAyAFIAQoAmwgBkEGdiISQe8DcWotAABBAnRqIgwoAgAiCigCACIBayEDAn8gASACQRB2TQRAIAIgAUEQdGshAiADQYCAAnEEQCAKKAIEDAILIAooAgQhDiAMIApBDEEIIAEgA0siGBtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEBIAgtAABB/wFHBEAgBCAKNgIQQQghCCABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAo2AhAgAUEJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIA5FIA4gGBsMAQsgCigCBCEOIAwgCkEIQQwgASADSyIYG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQMgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIANBCHQgAmohAgwBCyADQY8BTQRAIAQgCjYCECADQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIA4gDkUgGBsLBH8gAyAFIAkoAgRBF3ZBBHEgCUEEayIOKAIAQRl2QQFxIAZBEnZBEHEgBkEWdkHAAHEgEkGqAXFycnJyIhJB0LkBai0AAEECdGoiDCgCACIKKAIAIgFrIQMgEkHQuwFqLQAAIRggESAVaiAUIA0CfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCESIAwgCkEMQQggASADSyIbG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgEkUgEiAbGwwBCyAKKAIEIRIgDCAKQQhBDCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgEiASRSAbGwsgGHMiARs2AgAgDiAOKAIAQYAQcjYCACAJIAkoAgRBgARyNgIEIAYgAUEZdHJBgAhyBSAGC0GAgIDAAHIhBgsCQCAGQYDAgIAEcQ0AIAZBgLwPcUUNACADIAUgBCgCbCAGQQl2IhJB7wNxai0AAEECdGoiDCgCACIKKAIAIgFrIQMCfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCEOIAwgCkEMQQggASADSyIYG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgDkUgDiAYGwwBCyAKKAIEIQ4gDCAKQQhBDCABIANLIhgbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgDiAORSAYGwsEfyADIAUgCSgCBEEadkEEcSAJQQRrIg4oAgBBHHZBAXEgBkEVdkEQcSAGQRl2QcAAcSASQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIMKAIAIgooAgAiAWshAyASQdC7AWotAAAhGCARIBNqIBQgDQJ/IAEgAkEQdk0EQCACIAFBEHRrIQIgA0GAgAJxBEAgCigCBAwCCyAKKAIEIRIgDCAKQQxBCCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhASAILQAAQf8BRwRAIAQgCjYCEEEIIQggAUEIdCACaiECDAELIAFBjwFNBEAgBCAKNgIQIAFBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyASRSASIBsbDAELIAooAgQhEiAMIApBCEEMIAEgA0siGxtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEDIAgtAABB/wFHBEAgBCAKNgIQQQghCCADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAo2AhAgA0EJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyASIBJFIBsbCyAYcyIKGzYCACAOIA4oAgBBgIABcjYCACAJIAkoAgRBgCByNgIEIAQoAnxBAnQgCWoiASABKAIEQQRyNgIEIAEgASgCDEEBcjYCDCABIAEoAgggCkESdHJBAnI2AgggBiAKQRx0ckGAwAByBSAGC0GAgICABHIhBgsgCSAGNgIACyAJQQRqIQYgEUEEaiERIAtBAWoiCyAQRw0ACyAJQQxqIQYgESATaiERIAdBBGoiByAEKAKAASIBQXxxSQ0ACwwBC0EEIAFBfHEiBiAGQQRNG0EBayIGQXxxQQRqIQcgCSAGQQF0QXhxakEUaiEGCyAEIAg2AgggBCADNgIEIAQgAjYCACAEIAw2AmggEEUNACABIAdNDQADQCABIAdGIVNBACEIIAchASBTRQRAA0AgBCAGIBEgCCAQbEECdGogDSAIIAQoAnxBAmpBABBZIAhBAWoiCCAEKAKAASIBIAdrSQ0ACwsgBkEEaiEGIBFBBGohESAXQQFqIhcgEEcNAAsLDAILA0BBACEXA0AgASEJIAYiBygCACIGBEACQCAGQZCAgAFxDQAgBkHvA3EiAUUNACADIBAgBCgCbCABai0AAEECdGoiDCgCACILKAIAIgFrIQMCfyABIAJBEHZLBEAgCygCBCEKIAwgC0EIQQwgASADSyIUG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQMgCC0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIANBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCADQQh0IAJqIQILIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIAogCkUgFBsMAQsgAiABQRB0ayECIANBgIACcUUEQCALKAIEIQogDCALQQxBCCABIANLIhQbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhASAILQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgAUEJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIAFBCHQgAmohAgsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyAKRSAKIBQbDAELIAsoAgQLBH8gAyAQIAcoAgRBEXZBBHEgB0EEayIKKAIAQRN2QQFxIAZBDnZBEHEgBkEQdkHAAHEgBkGqAXFycnJyIhRB0LkBai0AAEECdGoiDCgCACILKAIAIgFrIQMgFEHQuwFqLQAAIRMgCSAFIBECfyABIAJBEHZLBEAgCygCBCEUIAwgC0EIQQwgASADSyIOG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQMgCC0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIANBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCADQQh0IAJqIQILIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIBQgFEUgDhsMAQsgAiABQRB0ayECIANBgIACcUUEQCALKAIEIRQgDCALQQxBCCABIANLIg4baigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhASAILQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgAUEJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIAFBCHQgAmohAgsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyAURSAUIA4bDAELIAsoAgQLIBNzIgEbNgIAIAogCigCAEEgcjYCACAHIAcoAgRBCHI2AgQgBiABQRN0ckEQcgUgBgtBgICAAXIhBgsCQCAGQYCBgAhxDQAgBkH4HnFFDQAgAyAQIAQoAmwgBkEDdiIUQe8DcWotAABBAnRqIgwoAgAiCygCACIBayEDAn8gASACQRB2SwRAIAsoAgQhCiAMIAtBCEEMIAEgA0siExtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAKIApFIBMbDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEKIAwgC0EMQQggASADSyITG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgCkUgCiATGwwBCyALKAIECwR/IAMgECAHKAIEQRR2QQRxIAdBBGsiCigCAEEWdkEBcSAGQQ92QRBxIAZBE3ZBwABxIBRBqgFxcnJyciIUQdC5AWotAABBAnRqIgwoAgAiCygCACIBayEDIBRB0LsBai0AACETIAkgBSARAn8gASACQRB2SwRAIAsoAgQhFCAMIAtBCEEMIAEgA0siDhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAUIBRFIA4bDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEUIAwgC0EMQQggASADSyIOG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgFEUgFCAOGwwBCyALKAIECyATcyIBGzYCgAIgCiAKKAIAQYACcjYCACAHIAcoAgRBwAByNgIEIAYgAUEWdHJBgAFyBSAGC0GAgIAIciEGCwJAIAZBgIiAwABxDQAgBkHA9wFxRQ0AIAMgECAEKAJsIAZBBnYiFEHvA3FqLQAAQQJ0aiIMKAIAIgsoAgAiAWshAwJ/IAEgAkEQdksEQCALKAIEIQogDCALQQhBDCABIANLIhMbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhAyAILQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgA0EJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIANBCHQgAmohAgsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgCiAKRSATGwwBCyACIAFBEHRrIQIgA0GAgAJxRQRAIAsoAgQhCiAMIAtBDEEIIAEgA0siExtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEBIAgtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECABQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggAUEIdCACaiECCyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIApFIAogExsMAQsgCygCBAsEfyADIBAgBygCBEEXdkEEcSAHQQRrIgooAgBBGXZBAXEgBkESdkEQcSAGQRZ2QcAAcSAUQaoBcXJycnIiFEHQuQFqLQAAQQJ0aiIMKAIAIgsoAgAiAWshAyAUQdC7AWotAAAhEyAJIAUgEQJ/IAEgAkEQdksEQCALKAIEIRQgDCALQQhBDCABIANLIg4baigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhAyAILQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgA0EJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIANBCHQgAmohAgsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgFCAURSAOGwwBCyACIAFBEHRrIQIgA0GAgAJxRQRAIAsoAgQhFCAMIAtBDEEIIAEgA0siDhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEBIAgtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECABQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggAUEIdCACaiECCyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIBRFIBQgDhsMAQsgCygCBAsgE3MiARs2AoAEIAogCigCAEGAEHI2AgAgByAHKAIEQYAEcjYCBCAGIAFBGXRyQYAIcgUgBgtBgICAwAByIQYLAkAgBkGAwICABHENACAGQYC8D3FFDQAgAyAQIAQoAmwgBkEJdiIUQe8DcWotAABBAnRqIgwoAgAiCygCACIBayEDAn8gASACQRB2SwRAIAsoAgQhCiAMIAtBCEEMIAEgA0siExtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAKIApFIBMbDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEKIAwgC0EMQQggASADSyITG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgCkUgCiATGwwBCyALKAIECwR/IAMgECAHKAIEQRp2QQRxIAdBBGsiCigCAEEcdkEBcSAGQRV2QRBxIAZBGXZBwABxIBRBqgFxcnJyciIUQdC5AWotAABBAnRqIgwoAgAiCygCACIBayEDIBRB0LsBai0AACETIAkgBSARAn8gASACQRB2SwRAIAsoAgQhFCAMIAtBCEEMIAEgA0siDhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAUIBRFIA4bDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEUIAwgC0EMQQggASADSyIOG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgFEUgFCAOGwwBCyALKAIECyATcyIBGzYCgAYgCiAKKAIAQYCAAXI2AgAgByAHKAIEQYAgcjYCBCAHIAcoAoQCQQRyNgKEAiAHIAcoAowCQQFyNgKMAiAHIAcoAogCIAFBEnRyQQJyNgKIAiAGIAFBHHRyQYDAAHIFIAYLQYCAgIAEciEGCyAHIAY2AgALIAdBBGohBiAJQQRqIQEgF0EBaiIXQcAARw0ACyAHQQxqIQYgCUGEBmohASANQTxJIVQgDUEEaiENIFQNAAsLIAQgCDYCCCAEIAM2AgQgBCACNgIAIAQgDDYCaAsMAgsgIgRAQQEgGXRBAXYhCSAEKAJ8IhFBAnQiDCAEKAJ4akEMaiEBIAQoAnQhBkEAIQ0gBCgCgAEiA0EETwRAIBFFDQQgEUEDbCEFIBFBAXQhC0EAIAlrIQIDQCALQQJ0IQpBACEDA0ACQCABIgcoAgAiAUUNACABQZCAgAFxQRBGBEAgBCgCACEBAkAgBCgCCCIQDQAgAUH/AUYhECAEKAIQIggtAAAhAQJAIBBFBEAgBCABNgIAIAQgCEEBajYCEAwBCyABQY8BTQRAIAQgATYCACAEIAhBAWo2AhBBByEQDAILQf8BIQEgBEH/ATYCAAtBCCEQCyAEIBBBAWsiCDYCCCAGIAIgCSABIAh2QQFxIAYoAgAiAUEfdkYbIAFqNgIAIAcgBygCAEGAgMAAciIBNgIACyABQYCBgAhxQYABRgRAIAQoAgAhAQJAIAQoAggiEA0AIAFB/wFGIRAgBCgCECIILQAAIQECQCAQRQRAIAQgATYCACAEIAhBAWo2AhAMAQsgAUGPAU0EQCAEIAE2AgAgBCAIQQFqNgIQQQchEAwCC0H/ASEBIARB/wE2AgALQQghEAsgBCAQQQFrIgg2AgggBiAMaiIQIAIgCSABIAh2QQFxIBAoAgAiAUEfdkYbIAFqNgIAIAcgBygCAEGAgIAEciIBNgIACyABQYCIgMAAcUGACEYEQCAEKAIAIQECQCAEKAIIIhANACABQf8BRiEQIAQoAhAiCC0AACEBAkAgEEUEQCAEIAE2AgAgBCAIQQFqNgIQDAELIAFBjwFNBEAgBCABNgIAIAQgCEEBajYCEEEHIRAMAgtB/wEhASAEQf8BNgIAC0EIIRALIAQgEEEBayIINgIIIAYgCmoiECACIAkgASAIdkEBcSAQKAIAIgFBH3ZGGyABajYCACAHIAcoAgBBgICAIHIiATYCAAsgAUGAwICABHFBgMAARw0AIAYgBUECdGohECAEKAIAIQECQCAEKAIIIggNACABQf8BRiEUIAQoAhAiCC0AACEBAkAgFEUEQCAEIAE2AgAgBCAIQQFqNgIQDAELIAFBjwFNBEAgBCABNgIAIAQgCEEBajYCEEEHIQgMAgtB/wEhASAEQf8BNgIAC0EIIQgLIAQgCEEBayIINgIIIBAgAiAJIAEgCHZBAXEgECgCACIBQR92RhsgAWo2AgAgByAHKAIAQYCAgIACcjYCAAsgBkEEaiEGIAdBBGohASADQQFqIgMgEUcNAAsgB0EMaiEBIAYgBUECdGohBiANQQRqIg0gBCgCgAEiA0F8cUkNAAsLIAMgDU0NAiARRQ0CQQAhE0EAIAlrIQUgAyEHA0ACQCAHIA1GBEAgDSEHDAELIAEoAgAhEEEAIQIDQEGQgIABIAJBA2wiB3QgEHFBECAHdEYEQCAGIAIgEWxBAnRqIRAgBCgCACEDAkAgBCgCCCIIDQAgA0H/AUchDCAEKAIQIggtAAAhAwJAIAxFBEAgA0GQAU8EQEH/ASEDIARB/wE2AgAMAgsgBCADNgIAIAQgCEEBajYCEEEHIQgMAgsgBCADNgIAIAQgCEEBajYCEAtBCCEICyAEIAhBAWsiCDYCCCAQIAUgCSADIAh2QQFxIBAoAgAiA0EfdkYbIANqNgIAIAEgASgCAEGAgMAAIAd0ciIQNgIAIAQoAoABIQMLIAMhByACQQFqIgIgAyANa0kNAAsLIAZBBGohBiABQQRqIQEgE0EBaiITIBFHDQALDAILIAQoAnghCCAEKAJ0IQcgBCgCgAEhAwJAIAQoAnwiDEHAAEcNACADQcAARw0AIAhBjAJqIQNBACETQQBBASAZdEEBdiIFayEMIAQoAgghAiAEKAIEIQYgBCgCACEBIAQoAmghDQNAQQAhCANAIAchCSADIhAoAgAiBwRAIAMhVSAHQZCAgAFxQRBGBEAgBiAPQRBBD0EOIAdB7wNxGyAHQYCAwABxG0ECdGoiDSgCACIRKAIAIgNrIQYCfyADIAFBEHZLBEAgESgCBCELIA0gEUEIQQwgAyAGSyIKG2ooAgA2AgADQAJAIAINACAEKAIQIgJBAWohESACLQABIQYgAi0AAEH/AUYEQCAGQZABTwRAIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQIMAgsgBCARNgIQIAZBCXQgAWohAUEHIQIMAQsgBCARNgIQQQghAiAGQQh0IAFqIQELIAJBAWshAiABQQF0IQEgA0EBdCIDQYCAAkkNAAsgAyEGIAsgC0UgChsMAQsgASADQRB0ayEBIAZBgIACcUUEQCARKAIEIQsgDSARQQxBCCADIAZLIgobaigCADYCAANAAkAgAg0AIAQoAhAiAkEBaiERIAItAAEhAyACLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAFBgP4DaiEBQQghAgwCCyAEIBE2AhAgA0EJdCABaiEBQQchAgwBCyAEIBE2AhBBCCECIANBCHQgAWohAQsgAkEBayECIAFBAXQhASAGQQF0IgZBgIACSQ0ACyALRSALIAobDAELIBEoAgQLIQMgCSAMIAUgAyAJKAIAIhFBH3ZGGyARajYCACAHQYCAwAByIQcLIAdBgIGACHFBgAFGBEAgBiAPQRBBD0EOIAdB+B5xGyAHQYCAgARxG0ECdGoiDSgCACIRKAIAIgNrIQYCfyADIAFBEHZLBEAgESgCBCELIA0gEUEIQQwgAyAGSyIKG2ooAgA2AgADQAJAIAINACAEKAIQIgJBAWohESACLQABIQYgAi0AAEH/AUYEQCAGQZABTwRAIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQIMAgsgBCARNgIQIAZBCXQgAWohAUEHIQIMAQsgBCARNgIQQQghAiAGQQh0IAFqIQELIAJBAWshAiABQQF0IQEgA0EBdCIDQYCAAkkNAAsgAyEGIAsgC0UgChsMAQsgASADQRB0ayEBIAZBgIACcUUEQCARKAIEIQsgDSARQQxBCCADIAZLIgobaigCADYCAANAAkAgAg0AIAQoAhAiAkEBaiERIAItAAEhAyACLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAFBgP4DaiEBQQghAgwCCyAEIBE2AhAgA0EJdCABaiEBQQchAgwBCyAEIBE2AhBBCCECIANBCHQgAWohAQsgAkEBayECIAFBAXQhASAGQQF0IgZBgIACSQ0ACyALRSALIAobDAELIBEoAgQLIQMgCSAMIAUgAyAJKAKAAiIRQR92RhsgEWo2AoACIAdBgICABHIhBwsgB0GAiIDAAHFBgAhGBEAgBiAPQRBBD0EOIAdBwPcBcRsgB0GAgIAgcRtBAnRqIg0oAgAiESgCACIDayEGAn8gAyABQRB2SwRAIBEoAgQhCyANIBFBCEEMIAMgBksiChtqKAIANgIAA0ACQCACDQAgBCgCECICQQFqIREgAi0AASEGIAItAABB/wFGBEAgBkGQAU8EQCAEIAQoAgxBAWo2AgwgAUGA/gNqIQFBCCECDAILIAQgETYCECAGQQl0IAFqIQFBByECDAELIAQgETYCEEEIIQIgBkEIdCABaiEBCyACQQFrIQIgAUEBdCEBIANBAXQiA0GAgAJJDQALIAMhBiALIAtFIAobDAELIAEgA0EQdGshASAGQYCAAnFFBEAgESgCBCELIA0gEUEMQQggAyAGSyIKG2ooAgA2AgADQAJAIAINACAEKAIQIgJBAWohESACLQABIQMgAi0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQIMAgsgBCARNgIQIANBCXQgAWohAUEHIQIMAQsgBCARNgIQQQghAiADQQh0IAFqIQELIAJBAWshAiABQQF0IQEgBkEBdCIGQYCAAkkNAAsgC0UgCyAKGwwBCyARKAIECyEDIAkgDCAFIAMgCSgCgAQiEUEfdkYbIBFqNgKABCAHQYCAgCByIQcLIFUgB0GAwICABHFBgMAARgR/IAYgD0EQQQ9BDiAHQYC8D3EbIAdBgICAgAJxG0ECdGoiDSgCACIRKAIAIgNrIQYCfyADIAFBEHZLBEAgESgCBCELIA0gEUEIQQwgAyAGSyIKG2ooAgA2AgADQAJAIAINACAEKAIQIgJBAWohESACLQABIQYgAi0AAEH/AUYEQCAGQZABTwRAIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQIMAgsgBCARNgIQIAZBCXQgAWohAUEHIQIMAQsgBCARNgIQQQghAiAGQQh0IAFqIQELIAJBAWshAiABQQF0IQEgA0EBdCIDQYCAAkkNAAsgAyEGIAsgC0UgChsMAQsgASADQRB0ayEBIAZBgIACcUUEQCARKAIEIQsgDSARQQxBCCADIAZLIgobaigCADYCAANAAkAgAg0AIAQoAhAiAkEBaiERIAItAAEhAyACLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAFBgP4DaiEBQQghAgwCCyAEIBE2AhAgA0EJdCABaiEBQQchAgwBCyAEIBE2AhBBCCECIANBCHQgAWohAQsgAkEBayECIAFBAXQhASAGQQF0IgZBgIACSQ0ACyALRSALIAobDAELIBEoAgQLIQMgCSAMIAUgAyAJKAKABiIRQR92RhsgEWo2AoAGIAdBgICAgAJyBSAHCzYCAAsgEEEEaiEDIAlBBGohByAIQQFqIghBwABHDQALIBBBDGohAyAJQYQGaiEHIBNBPEkhViATQQRqIRMgVg0ACyAEIAI2AgggBCAGNgIEIAQgATYCACAEIA02AmgMAgtBASAZdEEBdiELIAggDEECdCIOakEMaiEJIAQoAgghAiAEKAIEIQYgBCgCACEBIAQoAmghDUEAIRECQCADQQRJDQAgDARAIAxBA2whFCAMQQF0IRdBACALayEKA0AgF0ECdCESQQAhCANAIAkiBSgCACIQBEAgEEGQgIABcUEQRgRAIAYgD0EQQQ9BDiAQQe8DcRsgEEGAgMAAcRtBAnRqIg0oAgAiCSgCACIDayEGAn8gAyABQRB2TQRAIAEgA0EQdGshASAGQYCAAnEEQCAJKAIEDAILIAkoAgQhEyANIAlBDEEIIAMgBksiFRtqKAIANgIAA0ACQCACDQAgBCgCECIJQQFqIQIgCS0AASEDIAktAABB/wFHBEAgBCACNgIQQQghAiADQQh0IAFqIQEMAQsgA0GPAU0EQCAEIAI2AhAgA0EJdCABaiEBQQchAgwBCyAEIAQoAgxBAWo2AgwgAUGA/gNqIQFBCCECCyACQQFrIQIgAUEBdCEBIAZBAXQiBkGAgAJJDQALIBNFIBMgFRsMAQsgCSgCBCETIA0gCUEIQQwgAyAGSyIVG2ooAgA2AgADQAJAIAINACAEKAIQIglBAWohAiAJLQABIQYgCS0AAEH/AUcEQCAEIAI2AhBBCCECIAZBCHQgAWohAQwBCyAGQY8BTQRAIAQgAjYCECAGQQl0IAFqIQFBByECDAELIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQILIAJBAWshAiABQQF0IQEgA0EBdCIDQYCAAkkNAAsgAyEGIBMgE0UgFRsLIQMgByAKIAsgAyAHKAIAIglBH3ZGGyAJajYCACAQQYCAwAByIRALIBBBgIGACHFBgAFGBEAgBiAPQRBBD0EOIBBB+B5xGyAQQYCAgARxG0ECdGoiDSgCACIJKAIAIgNrIQYCfyADIAFBEHZNBEAgASADQRB0ayEBIAZBgIACcQRAIAkoAgQMAgsgCSgCBCETIA0gCUEMQQggAyAGSyIVG2ooAgA2AgADQAJAIAINACAEKAIQIglBAWohAiAJLQABIQMgCS0AAEH/AUcEQCAEIAI2AhBBCCECIANBCHQgAWohAQwBCyADQY8BTQRAIAQgAjYCECADQQl0IAFqIQFBByECDAELIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQILIAJBAWshAiABQQF0IQEgBkEBdCIGQYCAAkkNAAsgE0UgEyAVGwwBCyAJKAIEIRMgDSAJQQhBDCADIAZLIhUbaigCADYCAANAAkAgAg0AIAQoAhAiCUEBaiECIAktAAEhBiAJLQAAQf8BRwRAIAQgAjYCEEEIIQIgBkEIdCABaiEBDAELIAZBjwFNBEAgBCACNgIQIAZBCXQgAWohAUEHIQIMAQsgBCAEKAIMQQFqNgIMIAFBgP4DaiEBQQghAgsgAkEBayECIAFBAXQhASADQQF0IgNBgIACSQ0ACyADIQYgEyATRSAVGwshAyAHIA5qIgkgCiALIAMgCSgCACIJQR92RhsgCWo2AgAgEEGAgIAEciEQCyAQQYCIgMAAcUGACEYEQCAGIA9BEEEPQQ4gEEHA9wFxGyAQQYCAgCBxG0ECdGoiDSgCACIJKAIAIgNrIQYCfyADIAFBEHZNBEAgASADQRB0ayEBIAZBgIACcQRAIAkoAgQMAgsgCSgCBCETIA0gCUEMQQggAyAGSyIVG2ooAgA2AgADQAJAIAINACAEKAIQIglBAWohAiAJLQABIQMgCS0AAEH/AUcEQCAEIAI2AhBBCCECIANBCHQgAWohAQwBCyADQY8BTQRAIAQgAjYCECADQQl0IAFqIQFBByECDAELIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQILIAJBAWshAiABQQF0IQEgBkEBdCIGQYCAAkkNAAsgE0UgEyAVGwwBCyAJKAIEIRMgDSAJQQhBDCADIAZLIhUbaigCADYCAANAAkAgAg0AIAQoAhAiCUEBaiECIAktAAEhBiAJLQAAQf8BRwRAIAQgAjYCEEEIIQIgBkEIdCABaiEBDAELIAZBjwFNBEAgBCACNgIQIAZBCXQgAWohAUEHIQIMAQsgBCAEKAIMQQFqNgIMIAFBgP4DaiEBQQghAgsgAkEBayECIAFBAXQhASADQQF0IgNBgIACSQ0ACyADIQYgEyATRSAVGwshAyAHIBJqIgkgCiALIAMgCSgCACIJQR92RhsgCWo2AgAgEEGAgIAgciEQCyAFIBBBgMCAgARxQYDAAEYEfyAGIA9BEEEPQQ4gEEGAvA9xGyAQQYCAgIACcRtBAnRqIg0oAgAiCSgCACIDayEGAn8gAyABQRB2TQRAIAEgA0EQdGshASAGQYCAAnEEQCAJKAIEDAILIAkoAgQhEyANIAlBDEEIIAMgBksiFRtqKAIANgIAA0ACQCACDQAgBCgCECIJQQFqIQIgCS0AASEDIAktAABB/wFHBEAgBCACNgIQQQghAiADQQh0IAFqIQEMAQsgA0GPAU0EQCAEIAI2AhAgA0EJdCABaiEBQQchAgwBCyAEIAQoAgxBAWo2AgwgAUGA/gNqIQFBCCECCyACQQFrIQIgAUEBdCEBIAZBAXQiBkGAgAJJDQALIBNFIBMgFRsMAQsgCSgCBCETIA0gCUEIQQwgAyAGSyIVG2ooAgA2AgADQAJAIAINACAEKAIQIglBAWohAiAJLQABIQYgCS0AAEH/AUcEQCAEIAI2AhBBCCECIAZBCHQgAWohAQwBCyAGQY8BTQRAIAQgAjYCECAGQQl0IAFqIQFBByECDAELIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQILIAJBAWshAiABQQF0IQEgA0EBdCIDQYCAAkkNAAsgAyEGIBMgE0UgFRsLIQMgByAUQQJ0aiIJIAogCyADIAkoAgAiCUEfdkYbIAlqNgIAIBBBgICAgAJyBSAQCzYCAAsgBUEEaiEJIAdBBGohByAIQQFqIgggDEcNAAsgBUEMaiEJIAcgFEECdGohByARQQRqIhEgBCgCgAEiA0F8cUkNAAsMAQtBBCADQXxxIgkgCUEETRtBAWsiCUF8cUEEaiERIAggCUEBdEF4cWpBFGohCQsgBCACNgIIIAQgBjYCBCAEIAE2AgAgBCANNgJoIAxFDQEgAyARTQ0BQQAhE0EAIAtrIRQgAyEBA0ACQCABIBFGBEAgESEBDAELIAkoAgAhAkEAIRADQEGQgIABIBBBA2wiCHQgAnFBECAIdEYEQCAHIAwgEGxBAnRqIQUgBCAPQRBBD0EOIAIgCHYiAUHvA3EbIAFBgIDAAHEbQQJ0aiINNgJoIAQgBCgCBCANKAIAIgIoAgAiAWsiAzYCBAJ/IAEgBCgCACIGQRB2SwRAIAIoAgQhCiAEIAE2AgQgDSACQQhBDCABIANLIg4baigCADYCACAEKAIIIQIDQAJAIAINACAEKAIQIgJBAWohDSACLQABIQMgAi0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAGQYD+A2ohBkEIIQIMAgsgBCANNgIQIANBCXQgBmohBkEHIQIMAQsgBCANNgIQQQghAiADQQh0IAZqIQYLIAQgAkEBayICNgIIIAQgBkEBdCIGNgIAIAQgAUEBdCIBNgIEIAFBgIACSQ0ACyAKIApFIA4bDAELIAQgBiABQRB0ayIGNgIAIANBgIACcUUEQCACKAIEIQogDSACQQxBCCABIANLIg4baigCADYCACAEKAIIIQIDQAJAIAINACAEKAIQIgJBAWohDSACLQABIQEgAi0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCAGQYD+A2ohBkEIIQIMAgsgBCANNgIQIAFBCXQgBmohBkEHIQIMAQsgBCANNgIQQQghAiABQQh0IAZqIQYLIAQgAkEBayICNgIIIAQgBkEBdCIGNgIAIAQgA0EBdCIDNgIEIANBgIACSQ0ACyAKRSAKIA4bDAELIAIoAgQLIQEgBSAUIAsgASAFKAIAIgNBH3ZGGyADajYCACAJIAkoAgBBgIDAACAIdHIiAjYCACAEKAKAASEDCyAQQQFqIhAgAyIBIBFrSQ0ACwsgCUEEaiEJIAdBBGohByATQQFqIhMgDEcNAAsMAQtBACERQQAhFwJAAkACQAJAIAQoAnwiFEHAAEcNACAEKAKAAUHAAEcNAEEAQQEgGXQiAUEBdiABciIUayETIARB5ABqIQggBEHgAGohECAEQRxqIQsgBCgCeEGMAmohBiAEKAIIIQUgBCgCBCEBIAQoAgAhAiAEKAJoIQkgBCgCdCEDIBZBCHENAQNAQQAhDANAIAMhEQJAAkACfwJAAkAgBiINKAIAIgZFBEAgASAQKAIAIgMoAgAiBmshAQJ/IAYgAkEQdksEQCADKAIEIQcgECADQQhBDCABIAZJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiA0EBaiEJIAMtAAEhASADLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgAUEJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgByAHRSAKGwwBCyACIAZBEHRrIQIgAUGAgAJxRQRAIAMoAgQhByAQIANBDEEIIAEgBkkiChtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgCTYCECADQQl0IAJqIQJBByEFDAELIAQgCTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgChsMAQsgAygCBAtFBEAgECEJDAYLIAEgCCgCACIDKAIAIgZrIQECfyAGIAJBEHZLBEAgAygCBCEHIAggA0EIQQwgASAGSSIKG2ooAgAiAzYCAANAAkAgBQ0AIAQoAhAiCUEBaiEFIAktAAEhASAJLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgByAHRSAKGwwBCyACIAZBEHRrIQIgAUGAgAJxRQRAIAMoAgQhByAIIANBDEEIIAEgBkkiChtqKAIAIgM2AgADQAJAIAUNACAEKAIQIglBAWohBSAJLQABIQYgCS0AAEH/AUYEQCAGQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAZBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSAGQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgB0UgByAKGwwBCyADKAIECyEKIAEgAygCACIGayEBAn8gBiACQRB2SwRAIAMoAgQhByAIIANBCEEMIAEgBkkiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIDQQFqIQkgAy0AASEBIAMtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgCTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAHIAdFIA4bDAELIAIgBkEQdGshAiABQYCAAnFFBEAgAygCBCEHIAggA0EMQQggASAGSSIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQMgBi0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAJNgIQIANBCXQgAmohAkEHIQUMAQsgBCAJNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgB0UgByAOGwwBCyADKAIECyEDQQAhBiAIIQkCQAJAAkACfwJAAkAgAyAKQQF0cg4EAAEDBQoLIAEgCyANKAIEQRF2QQRxIA1BBGsiBygCAEETdkEBcXIiDkHQuQFqLQAAQQJ0aiIJKAIAIgMoAgAiBmshAQJ/IAYgAkEQdksEQCADKAIEIQogCSADQQhBDCABIAZJIhIbaigCADYCAANAAkAgBQ0AIAQoAhAiA0EBaiEJIAMtAAEhASADLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgAUEJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgCiAKRSASGwwBCyACIAZBEHRrIQIgAUGAgAJxRQRAIAMoAgQhCiAJIANBDEEIIAEgBkkiEhtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgCTYCECADQQl0IAJqIQJBByEFDAELIAQgCTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogEhsMAQsgAygCBAshAyARIBMgFCADIA5B0LsBai0AAHMiAxs2AgAgByAHKAIAQSByNgIAIA0gDSgCBEEIcjYCBCANQYwCayIGIAYoAgBBgIAIcjYCACANQYQCayIGIAYoAgBBgIACcjYCACANQYgCayIGIAYoAgAgA0EfdHJBgIAEcjYCACADQRN0IVcgASALIAQoAmwtAAJBAnRqIgcoAgAiAygCACIGayEBAn8gBiACQRB2SwRAIAMoAgQhCSAHIANBCEEMIAEgBkkiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIDQQFqIQcgAy0AASEBIAMtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBzYCECABQQl0IAJqIQJBByEFDAELIAQgBzYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAJIAlFIA4bDAELIAIgBkEQdGshAiABQYCAAnFFBEAgAygCBCEJIAcgA0EMQQggASAGSSIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohByAGLQABIQMgBi0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAHNgIQIANBCXQgAmohAkEHIQUMAQsgBCAHNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgCUUgCSAOGwwBCyADKAIECyEDIFdBEHIiBiADRQ0BGgsgASALIA0oAgRBFHZBBHEgDUEEayIJKAIAQRZ2QQFxIAZBD3ZBEHEgBkETdkHAAHEgBkEDdkGqAXFycnJyIhJB0LkBai0AAEECdGoiCigCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEOIAogB0EIQQwgASADSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIA4gDkUgChsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQ4gCiAHQQxBCCABIANJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAORSAOIAobDAELIAcoAgQLIQMgESATIBQgAyASQdC7AWotAABzIgMbNgKAAiAJIAkoAgBBgAJyNgIAIA0gDSgCBEHAAHI2AgQgBiADQRZ0ckGAAXILIQYgASALIAQoAmwgBkEGdkHvA3FqLQAAQQJ0aiIJKAIAIgcoAgAiA2shAQJ/IAMgAkEQdksEQCAHKAIEIQogCSAHQQhBDCABIANJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEJIActAAEhASAHLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgAUEJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQEgCiAKRSAOGwwBCyACIANBEHRrIQIgAUGAgAJxRQRAIAcoAgQhCiAJIAdBDEEIIAEgA0kiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQkgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgCTYCECADQQl0IAJqIQJBByEFDAELIAQgCTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogDhsMAQsgBygCBAtFDQELIAEgCyANKAIEQRd2QQRxIA1BBGsiCSgCAEEZdkEBcSAGQRJ2QRBxIAZBFnZBwABxIAZBBnZBqgFxcnJyciISQdC5AWotAABBAnRqIgooAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhDiAKIAdBCEEMIAEgA0kiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAOIA5FIAobDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEOIAogB0EMQQggASADSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgDkUgDiAKGwwBCyAHKAIECyEDIBEgEyAUIAMgEkHQuwFqLQAAcyIDGzYCgAQgCSAJKAIAQYAQcjYCACANIA0oAgRBgARyNgIEIAYgA0EZdHJBgAhyIQYLIAEgCyAEKAJsIAZBCXZB7wNxai0AAEECdGoiCSgCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEKIAkgB0EIQQwgASADSSIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAogCkUgDhsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQogCSAHQQxBCCABIANJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIA4bDAELIAcoAgQLRQ0FCyABIAsgDSgCBEEadkEEcSANQQRrIg4oAgBBHHZBAXEgBkEVdkEQcSAGQRl2QcAAcSAGQQl2QaoBcXJycnIiCkHQuQFqLQAAQQJ0aiIJKAIAIgcoAgAiA2shASADIAJBEHZLBEAgBygCBCESIAkgB0EIQQwgASADSSIVG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIBIgEkUgFRsMBAsgAiADQRB0ayECIAFBgIACcQ0BIAcoAgQhEiAJIAdBDEEIIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIBJFIBIgFRsMAwsCQCAGQZCAgAFxDQAgASALIAQoAmwgBkHvA3FqLQAAQQJ0aiIJKAIAIgcoAgAiA2shAQJ/IAMgAkEQdksEQCAHKAIEIQogCSAHQQhBDCABIANJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhASAHLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQEgCiAKRSAOGwwBCyACIANBEHRrIQIgAUGAgAJxRQRAIAcoAgQhCiAJIAdBDEEIIAEgA0kiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogDhsMAQsgBygCBAtFDQAgASALIA0oAgRBEXZBBHEgDUEEayIKKAIAQRN2QQFxIAZBDnZBEHEgBkEQdkHAAHEgBkGqAXFycnJyIhJB0LkBai0AAEECdGoiCSgCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEOIAkgB0EIQQwgASADSSIVG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIA4gDkUgFRsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQ4gCSAHQQxBCCABIANJIhUbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAORSAOIBUbDAELIAcoAgQLIQMgESATIBQgAyASQdC7AWotAABzIgMbNgIAIAogCigCAEEgcjYCACANIA0oAgRBCHI2AgQgDUGMAmsiByAHKAIAQYCACHI2AgAgDUGEAmsiByAHKAIAQYCAAnI2AgAgDUGIAmsiByAHKAIAIANBH3RyQYCABHI2AgAgBiADQRN0ckEQciEGCwJAIAZBgIGACHENACABIAsgBCgCbCAGQQN2Ig5B7wNxai0AAEECdGoiCSgCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEKIAkgB0EIQQwgASADSSISG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAogCkUgEhsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQogCSAHQQxBCCABIANJIhIbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIBIbDAELIAcoAgQLRQ0AIAEgCyANKAIEQRR2QQRxIA1BBGsiCigCAEEWdkEBcSAGQQ92QRBxIAZBE3ZBwABxIA5BqgFxcnJyciISQdC5AWotAABBAnRqIgkoAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhDiAJIAdBCEEMIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAOIA5FIBUbDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEOIAkgB0EMQQggASADSSIVG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgDkUgDiAVGwwBCyAHKAIECyEDIBEgEyAUIAMgEkHQuwFqLQAAcyIDGzYCgAIgCiAKKAIAQYACcjYCACANIA0oAgRBwAByNgIEIAYgA0EWdHJBgAFyIQYLAkAgBkGAiIDAAHENACABIAsgBCgCbCAGQQZ2Ig5B7wNxai0AAEECdGoiCSgCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEKIAkgB0EIQQwgASADSSISG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAogCkUgEhsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQogCSAHQQxBCCABIANJIhIbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIBIbDAELIAcoAgQLRQ0AIAEgCyANKAIEQRd2QQRxIA1BBGsiCigCAEEZdkEBcSAGQRJ2QRBxIAZBFnZBwABxIA5BqgFxcnJyciISQdC5AWotAABBAnRqIgkoAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhDiAJIAdBCEEMIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAOIA5FIBUbDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEOIAkgB0EMQQggASADSSIVG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgDkUgDiAVGwwBCyAHKAIECyEDIBEgEyAUIAMgEkHQuwFqLQAAcyIDGzYCgAQgCiAKKAIAQYAQcjYCACANIA0oAgRBgARyNgIEIAYgA0EZdHJBgAhyIQYLIAZBgMCAgARxDQMgASALIAQoAmwgBkEJdiISQe8DcWotAABBAnRqIgkoAgAiASgCACIDayEHAn8gAyACQRB2SwRAIAEoAgQhCiAJIAFBCEEMIAMgB0siDhtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhByAKIApFIA4bDAELIAIgA0EQdGshAiAHQYCAAnFFBEAgASgCBCEKIAkgAUEMQQggAyAHSyIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgNBAWohBSADLQABIQEgAy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgB0EBdCIHQYCAAkkNAAsgCkUgCiAOGwwBCyABKAIEC0UEQCAHIQEMBAsgByALIA0oAgRBGnZBBHEgDUEEayIOKAIAQRx2QQFxIAZBFXZBEHEgBkEZdkHAAHEgEkGqAXFycnJyIgpB0LkBai0AAEECdGoiCSgCACIHKAIAIgFrIQMgASACQRB2SwRAIAcoAgQhEiAJIAdBCEEMIAEgA0siFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIBIgEkUgFRsMAwsgAiABQRB0ayECIANBgIACcUUNASADIQELIAcoAgQMAQsgBygCBCESIAkgB0EMQQggASADSyIVG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIBJFIBIgFRsLIQMgESATIBQgAyAKQdC7AWotAABzIgMbNgKABiAOIA4oAgBBgIABcjYCACANIA0oAgRBgCByNgIEIA0gDSgChAJBBHI2AoQCIA0gDSgCjAJBAXI2AowCIA0gDSgCiAIgA0ESdHJBAnI2AogCIAYgA0EcdHJBgMAAciEGCyANIAZB////tntxNgIACyANQQRqIQYgEUEEaiEDIAxBAWoiDEHAAEcNAAsgDUEMaiEGIBFBhAZqIQMgF0E8SSFYIBdBBGohFyBYDQALDAILQQEgGXQiAUEBdiABciEOIAQoAngiByAUQQJ0akEMaiEDIAQoAoABIQYgBCgCCCEFIAQoAgQhASAEKAIAIQIgBCgCaCEJIAQoAnQhCwJAAkAgFkEIcQRAIAZBBEkNAiAURQ0BIARB5ABqIRAgBEHgAGohDSAUQQNsIRsgFEEBdCEkQQAgDmshFSAEQRxqIRIDQEEAIRgDQAJAAkACfwJAIAMiCCgCACIDBEACQCADQZCAgAFxDQAgASASIAQoAmwgA0HvA3FqLQAAQQJ0aiIJKAIAIgcoAgAiBmshAQJ/IAYgAkEQdk0EQCACIAZBEHRrIQIgAUGAgAJxBEAgBygCBAwCCyAHKAIEIQwgCSAHQQxBCCABIAZJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhBiAHLQAAQf8BRwRAIAQgBTYCEEEIIQUgBkEIdCACaiECDAELIAZBjwFNBEAgBCAFNgIQIAZBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAMRSAMIAobDAELIAcoAgQhDCAJIAdBCEEMIAEgBkkiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAMIAxFIAobC0UNACABIBIgCCgCBEERdkEEcSAIQQRrIgwoAgBBE3ZBAXEgA0EOdkEQcSADQRB2QcAAcSADQaoBcXJycnIiE0HQuQFqLQAAQQJ0aiIJKAIAIgcoAgAiBmshAQJ/IAYgAkEQdk0EQCACIAZBEHRrIQIgAUGAgAJxBEAgBygCBAwCCyAHKAIEIQogCSAHQQxBCCABIAZJIhwbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhBiAHLQAAQf8BRwRAIAQgBTYCEEEIIQUgBkEIdCACaiECDAELIAZBjwFNBEAgBCAFNgIQIAZBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIBwbDAELIAcoAgQhCiAJIAdBCEEMIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAKIApFIBwbCyEGIAsgFSAOIAYgE0HQuwFqLQAAcyIGGzYCACAMIAwoAgBBIHI2AgAgCCAIKAIEQQhyNgIEIAMgBkETdHJBEHIhAwsCQCADQYCBgAhxDQAgASASIAQoAmwgA0EDdiIKQe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiExtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgExsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSITG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgExsLRQ0AIAEgEiAIKAIEQRR2QQRxIAhBBGsiDCgCAEEWdkEBcSADQQ92QRBxIANBE3ZBwABxIApBqgFxcnJyciITQdC5AWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAJIAdBDEEIIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogHBsMAQsgBygCBCEKIAkgB0EIQQwgASAGSSIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgHBsLIQYgCyAUQQJ0aiAVIA4gBiATQdC7AWotAABzIgYbNgIAIAwgDCgCAEGAAnI2AgAgCCAIKAIEQcAAcjYCBCADIAZBFnRyQYABciEDCwJAIANBgIiAwABxDQAgASASIAQoAmwgA0EGdiIKQe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiExtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgExsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSITG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgExsLRQ0AIAEgEiAIKAIEQRd2QQRxIAhBBGsiDCgCAEEZdkEBcSADQRJ2QRBxIANBFnZBwABxIApBqgFxcnJyciITQdC5AWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAJIAdBDEEIIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogHBsMAQsgBygCBCEKIAkgB0EIQQwgASAGSSIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgHBsLIQYgCyAkQQJ0aiAVIA4gBiATQdC7AWotAABzIgYbNgIAIAwgDCgCAEGAEHI2AgAgCCAIKAIEQYAEcjYCBCADIAZBGXRyQYAIciEDCyADQYDAgIAEcQ0DIAEgEiAEKAJsIANBCXYiCkHvA3FqLQAAQQJ0aiIJKAIAIgEoAgAiBmshBwJ/IAYgAkEQdk0EQCACIAZBEHRrIQIgB0GAgAJxBEAgASgCBAwCCyABKAIEIQwgCSABQQxBCCAGIAdLIhMbaigCADYCAANAAkAgBQ0AIAQoAhAiBkEBaiEFIAYtAAEhASAGLQAAQf8BRwRAIAQgBTYCEEEIIQUgAUEIdCACaiECDAELIAFBjwFNBEAgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiAHQQF0IgdBgIACSQ0ACyAMRSAMIBMbDAELIAEoAgQhDCAJIAFBCEEMIAYgB0siExtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhByAMIAxFIBMbC0UEQCAHIQEMBAsgByASIAgoAgRBGnZBBHEgCEEEayIMKAIAQRx2QQFxIANBFXZBEHEgA0EZdkHAAHEgCkGqAXFycnJyIhNB0LkBai0AAEECdGoiCSgCACIKKAIAIgFrIQYgASACQRB2TQRAIAIgAUEQdGshAiAGQYCAAnEEQCAGIQEMAwsgCigCBCEHIAkgCkEMQQggASAGSyIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgVBAWohCiAFLQABIQEgBS0AAEH/AUcEQCAEIAo2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAdFIAcgHBsMAwsgCigCBCEHIAkgCkEIQQwgASAGSyIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgVBAWohCiAFLQABIQYgBS0AAEH/AUcEQCAEIAo2AhBBCCEFIAZBCHQgAmohAgwBCyAGQY8BTQRAIAQgCjYCECAGQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgByAHRSAcGwwCCyABIA0oAgAiBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhByANIAZBDEEIIAEgA0kiDBtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFHBEAgBCAJNgIQQQghBSADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgDBsMAQsgBigCBCEHIA0gBkEIQQwgASADSSIMG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQEgBi0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAcgB0UgDBsLRQRAIA0hCQwECyABIBAoAgAiBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhByAQIAZBDEEIIAEgA0kiDBtqKAIAIgY2AgADQAJAIAUNACAEKAIQIglBAWohBSAJLQABIQMgCS0AAEH/AUcEQCAEIAU2AhBBCCEFIANBCHQgAmohAgwBCyADQY8BTQRAIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgB0UgByAMGwwBCyAGKAIEIQcgECAGQQhBDCABIANJIgwbaigCACIGNgIAA0ACQCAFDQAgBCgCECIJQQFqIQUgCS0AASEBIAktAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAHIAdFIAwbCyEMIAEgBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhByAQIAZBDEEIIAEgA0kiChtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFHBEAgBCAJNgIQQQghBSADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgChsMAQsgBigCBCEHIBAgBkEIQQwgASADSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQEgBi0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAcgB0UgChsLIQZBACEDIBAhCQJAAkACQAJ/AkACQCAGIAxBAXRyDgQAAQMFCAsgASASIAgoAgRBEXZBBHEgCEEEayIHKAIAQRN2QQFxciIKQdC5AWotAABBAnRqIgkoAgAiBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhDCAJIAZBDEEIIAEgA0kiExtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFHBEAgBCAJNgIQQQghBSADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgExsMAQsgBigCBCEMIAkgBkEIQQwgASADSSITG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQEgBi0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAwgDEUgExsLIQMgCyAVIA4gAyAKQdC7AWotAABzIgMbNgIAIAcgBygCAEEgcjYCACAIIAgoAgRBCHI2AgQgA0ETdCFZIAEgEiAEKAJsLQACQQJ0aiIHKAIAIgYoAgAiA2shAQJ/IAMgAkEQdk0EQCACIANBEHRrIQIgAUGAgAJxBEAgBigCBAwCCyAGKAIEIQkgByAGQQxBCCABIANJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiBkEBaiEHIAYtAAEhAyAGLQAAQf8BRwRAIAQgBzYCEEEIIQUgA0EIdCACaiECDAELIANBjwFNBEAgBCAHNgIQIANBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAJRSAJIAobDAELIAYoAgQhCSAHIAZBCEEMIAEgA0kiChtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQcgBi0AASEBIAYtAABB/wFHBEAgBCAHNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAc2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAJIAlFIAobCyEGIFlBEHIiAyAGRQ0BGgsgASASIAgoAgRBFHZBBHEgCEEEayIJKAIAQRZ2QQFxIANBD3ZBEHEgA0ETdkHAAHEgA0EDdkGqAXFycnJyIhNB0LkBai0AAEECdGoiDCgCACIHKAIAIgZrIQECfyAGIAJBEHZNBEAgAiAGQRB0ayECIAFBgIACcQRAIAcoAgQMAgsgBygCBCEKIAwgB0EMQQggASAGSSIMG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQYgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAZBCHQgAmohAgwBCyAGQY8BTQRAIAQgBTYCECAGQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgCkUgCiAMGwwBCyAHKAIEIQogDCAHQQhBDCABIAZJIgwbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhASAHLQAAQf8BRwRAIAQgBTYCEEEIIQUgAUEIdCACaiECDAELIAFBjwFNBEAgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgCiAKRSAMGwshBiALIBRBAnRqIBUgDiAGIBNB0LsBai0AAHMiBhs2AgAgCSAJKAIAQYACcjYCACAIIAgoAgRBwAByNgIEIAMgBkEWdHJBgAFyCyEDIAEgEiAEKAJsIANBBnZB7wNxai0AAEECdGoiCSgCACIHKAIAIgZrIQECfyAGIAJBEHZNBEAgAiAGQRB0ayECIAFBgIACcQRAIAcoAgQMAgsgBygCBCEMIAkgB0EMQQggASAGSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohCSAHLQABIQYgBy0AAEH/AUcEQCAEIAk2AhBBCCEFIAZBCHQgAmohAgwBCyAGQY8BTQRAIAQgCTYCECAGQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgDEUgDCAKGwwBCyAHKAIEIQwgCSAHQQhBDCABIAZJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEJIActAAEhASAHLQAAQf8BRwRAIAQgCTYCEEEIIQUgAUEIdCACaiECDAELIAFBjwFNBEAgBCAJNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgDCAMRSAKGwtFDQELIAEgEiAIKAIEQRd2QQRxIAhBBGsiCSgCAEEZdkEBcSADQRJ2QRBxIANBFnZBwABxIANBBnZBqgFxcnJyciITQdC5AWotAABBAnRqIgwoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAMIAdBDEEIIAEgBkkiDBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogDBsMAQsgBygCBCEKIAwgB0EIQQwgASAGSSIMG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgDBsLIQYgCyAkQQJ0aiAVIA4gBiATQdC7AWotAABzIgYbNgIAIAkgCSgCAEGAEHI2AgAgCCAIKAIEQYAEcjYCBCADIAZBGXRyQYAIciEDCyABIBIgBCgCbCADQQl2Qe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgChsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgChsLRQ0DCyABIBIgCCgCBEEadkEEcSAIQQRrIgwoAgBBHHZBAXEgA0EVdkEQcSADQRl2QcAAcSADQQl2QaoBcXJycnIiE0HQuQFqLQAAQQJ0aiIJKAIAIgooAgAiBmshASAGIAJBEHZNBEAgAiAGQRB0ayECIAFBgIACcQ0BIAooAgQhByAJIApBDEEIIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIFQQFqIQogBS0AASEGIAUtAABB/wFHBEAgBCAKNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAo2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgHBsMAgsgCigCBCEHIAkgCkEIQQwgASAGSSIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgVBAWohCiAFLQABIQEgBS0AAEH/AUcEQCAEIAo2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAcgB0UgHBsMAQsgCigCBAshBiALIBtBAnRqIBUgDiAGIBNB0LsBai0AAHMiBxs2AgAgDCAMKAIAQYCAAXI2AgAgCCAIKAIEQYAgcjYCBCAEKAJ8QQJ0IAhqIgYgBigCBEEEcjYCBCAGIAYoAgxBAXI2AgwgBiAGKAIIIAdBEnRyQQJyNgIIIAMgB0EcdHJBgMAAciEDCyAIIANB////tntxNgIACyAIQQRqIQMgC0EEaiELIBhBAWoiGCAURw0ACyAIQQxqIQMgCyAbQQJ0aiELIBFBBGoiESAEKAKAASIGQXxxSQ0ACwwCCwJAIAZBBEkNACAUBEAgBEHkAGohECAEQeAAaiENIBRBA2whGyAUQQF0ISRBACAOayEVIARBHGohEgNAQQAhGANAAkACQAJ/AkAgAyIIKAIAIgMEQAJAIANBkICAAXENACABIBIgBCgCbCADQe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgChsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgChsLRQ0AIAEgEiAIKAIEQRF2QQRxIAhBBGsiDCgCAEETdkEBcSADQQ52QRBxIANBEHZBwABxIANBqgFxcnJyciITQdC5AWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAJIAdBDEEIIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogHBsMAQsgBygCBCEKIAkgB0EIQQwgASAGSSIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgHBsLIQYgCyAVIA4gBiATQdC7AWotAABzIgcbNgIAIAwgDCgCAEEgcjYCACAIIAgoAgRBCHI2AgQgCEF+IAQoAnxrQQJ0aiIGIAYoAgRBgIACcjYCBCAGIAYoAgAgB0EfdHJBgIAEcjYCACAGQQRrIgYgBigCAEGAgAhyNgIAIAMgB0ETdHJBEHIhAwsCQCADQYCBgAhxDQAgASASIAQoAmwgA0EDdiIKQe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiExtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgExsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSITG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgExsLRQ0AIAEgEiAIKAIEQRR2QQRxIAhBBGsiDCgCAEEWdkEBcSADQQ92QRBxIANBE3ZBwABxIApBqgFxcnJyciITQdC5AWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAJIAdBDEEIIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogHBsMAQsgBygCBCEKIAkgB0EIQQwgASAGSSIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgHBsLIQYgCyAUQQJ0aiAVIA4gBiATQdC7AWotAABzIgYbNgIAIAwgDCgCAEGAAnI2AgAgCCAIKAIEQcAAcjYCBCADIAZBFnRyQYABciEDCwJAIANBgIiAwABxDQAgASASIAQoAmwgA0EGdiIKQe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiExtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgExsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSITG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgExsLRQ0AIAEgEiAIKAIEQRd2QQRxIAhBBGsiDCgCAEEZdkEBcSADQRJ2QRBxIANBFnZBwABxIApBqgFxcnJyciITQdC5AWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAJIAdBDEEIIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogHBsMAQsgBygCBCEKIAkgB0EIQQwgASAGSSIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgHBsLIQYgCyAkQQJ0aiAVIA4gBiATQdC7AWotAABzIgYbNgIAIAwgDCgCAEGAEHI2AgAgCCAIKAIEQYAEcjYCBCADIAZBGXRyQYAIciEDCyADQYDAgIAEcQ0DIAEgEiAEKAJsIANBCXYiCkHvA3FqLQAAQQJ0aiIJKAIAIgEoAgAiBmshBwJ/IAYgAkEQdk0EQCACIAZBEHRrIQIgB0GAgAJxBEAgASgCBAwCCyABKAIEIQwgCSABQQxBCCAGIAdLIhMbaigCADYCAANAAkAgBQ0AIAQoAhAiBkEBaiEFIAYtAAEhASAGLQAAQf8BRwRAIAQgBTYCEEEIIQUgAUEIdCACaiECDAELIAFBjwFNBEAgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiAHQQF0IgdBgIACSQ0ACyAMRSAMIBMbDAELIAEoAgQhDCAJIAFBCEEMIAYgB0siExtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhByAMIAxFIBMbC0UEQCAHIQEMBAsgByASIAgoAgRBGnZBBHEgCEEEayIMKAIAQRx2QQFxIANBFXZBEHEgA0EZdkHAAHEgCkGqAXFycnJyIhNB0LkBai0AAEECdGoiCSgCACIKKAIAIgFrIQYgASACQRB2TQRAIAIgAUEQdGshAiAGQYCAAnEEQCAGIQEMAwsgCigCBCEHIAkgCkEMQQggASAGSyIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgVBAWohCiAFLQABIQEgBS0AAEH/AUcEQCAEIAo2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAdFIAcgHBsMAwsgCigCBCEHIAkgCkEIQQwgASAGSyIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgVBAWohCiAFLQABIQYgBS0AAEH/AUcEQCAEIAo2AhBBCCEFIAZBCHQgAmohAgwBCyAGQY8BTQRAIAQgCjYCECAGQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgByAHRSAcGwwCCyABIA0oAgAiBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhByANIAZBDEEIIAEgA0kiDBtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFHBEAgBCAJNgIQQQghBSADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgDBsMAQsgBigCBCEHIA0gBkEIQQwgASADSSIMG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQEgBi0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAcgB0UgDBsLRQRAIA0hCQwECyABIBAoAgAiBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhByAQIAZBDEEIIAEgA0kiDBtqKAIAIgY2AgADQAJAIAUNACAEKAIQIglBAWohBSAJLQABIQMgCS0AAEH/AUcEQCAEIAU2AhBBCCEFIANBCHQgAmohAgwBCyADQY8BTQRAIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgB0UgByAMGwwBCyAGKAIEIQcgECAGQQhBDCABIANJIgwbaigCACIGNgIAA0ACQCAFDQAgBCgCECIJQQFqIQUgCS0AASEBIAktAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAHIAdFIAwbCyEMIAEgBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhByAQIAZBDEEIIAEgA0kiChtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFHBEAgBCAJNgIQQQghBSADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgChsMAQsgBigCBCEHIBAgBkEIQQwgASADSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQEgBi0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAcgB0UgChsLIQZBACEDIBAhCQJAAkACQAJ/AkACQCAGIAxBAXRyDgQAAQMFCAsgASASIAgoAgRBEXZBBHEgCEEEayIHKAIAQRN2QQFxciIKQdC5AWotAABBAnRqIgkoAgAiBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhDCAJIAZBDEEIIAEgA0kiExtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFHBEAgBCAJNgIQQQghBSADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgExsMAQsgBigCBCEMIAkgBkEIQQwgASADSSITG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQEgBi0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAwgDEUgExsLIQMgCyAVIA4gAyAKQdC7AWotAABzIgYbNgIAIAcgBygCAEEgcjYCACAIIAgoAgRBCHI2AgQgCEF+IAQoAnxrQQJ0aiIDIAMoAgRBgIACcjYCBCADIAMoAgAgBkEfdHJBgIAEcjYCACADQQRrIgMgAygCAEGAgAhyNgIAIAZBE3QhWiABIBIgBCgCbC0AAkECdGoiBygCACIGKAIAIgNrIQECfyADIAJBEHZNBEAgAiADQRB0ayECIAFBgIACcQRAIAYoAgQMAgsgBigCBCEJIAcgBkEMQQggASADSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohByAGLQABIQMgBi0AAEH/AUcEQCAEIAc2AhBBCCEFIANBCHQgAmohAgwBCyADQY8BTQRAIAQgBzYCECADQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgCUUgCSAKGwwBCyAGKAIEIQkgByAGQQhBDCABIANJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiBkEBaiEHIAYtAAEhASAGLQAAQf8BRwRAIAQgBzYCEEEIIQUgAUEIdCACaiECDAELIAFBjwFNBEAgBCAHNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQEgCSAJRSAKGwshBiBaQRByIgMgBkUNARoLIAEgEiAIKAIEQRR2QQRxIAhBBGsiCSgCAEEWdkEBcSADQQ92QRBxIANBE3ZBwABxIANBA3ZBqgFxcnJyciITQdC5AWotAABBAnRqIgwoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAMIAdBDEEIIAEgBkkiDBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogDBsMAQsgBygCBCEKIAwgB0EIQQwgASAGSSIMG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgDBsLIQYgCyAUQQJ0aiAVIA4gBiATQdC7AWotAABzIgYbNgIAIAkgCSgCAEGAAnI2AgAgCCAIKAIEQcAAcjYCBCADIAZBFnRyQYABcgshAyABIBIgBCgCbCADQQZ2Qe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQkgBy0AASEGIActAABB/wFHBEAgBCAJNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAk2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgChsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohCSAHLQABIQEgBy0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgChsLRQ0BCyABIBIgCCgCBEEXdkEEcSAIQQRrIgkoAgBBGXZBAXEgA0ESdkEQcSADQRZ2QcAAcSADQQZ2QaoBcXJycnIiE0HQuQFqLQAAQQJ0aiIMKAIAIgcoAgAiBmshAQJ/IAYgAkEQdk0EQCACIAZBEHRrIQIgAUGAgAJxBEAgBygCBAwCCyAHKAIEIQogDCAHQQxBCCABIAZJIgwbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhBiAHLQAAQf8BRwRAIAQgBTYCEEEIIQUgBkEIdCACaiECDAELIAZBjwFNBEAgBCAFNgIQIAZBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIAwbDAELIAcoAgQhCiAMIAdBCEEMIAEgBkkiDBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAKIApFIAwbCyEGIAsgJEECdGogFSAOIAYgE0HQuwFqLQAAcyIGGzYCACAJIAkoAgBBgBByNgIAIAggCCgCBEGABHI2AgQgAyAGQRl0ckGACHIhAwsgASASIAQoAmwgA0EJdkHvA3FqLQAAQQJ0aiIJKAIAIgcoAgAiBmshAQJ/IAYgAkEQdk0EQCACIAZBEHRrIQIgAUGAgAJxBEAgBygCBAwCCyAHKAIEIQwgCSAHQQxBCCABIAZJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhBiAHLQAAQf8BRwRAIAQgBTYCEEEIIQUgBkEIdCACaiECDAELIAZBjwFNBEAgBCAFNgIQIAZBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAMRSAMIAobDAELIAcoAgQhDCAJIAdBCEEMIAEgBkkiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAMIAxFIAobC0UNAwsgASASIAgoAgRBGnZBBHEgCEEEayIMKAIAQRx2QQFxIANBFXZBEHEgA0EZdkHAAHEgA0EJdkGqAXFycnJyIhNB0LkBai0AAEECdGoiCSgCACIKKAIAIgZrIQEgBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnENASAKKAIEIQcgCSAKQQxBCCABIAZJIhwbaigCADYCAANAAkAgBQ0AIAQoAhAiBUEBaiEKIAUtAAEhBiAFLQAAQf8BRwRAIAQgCjYCEEEIIQUgBkEIdCACaiECDAELIAZBjwFNBEAgBCAKNgIQIAZBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAHRSAHIBwbDAILIAooAgQhByAJIApBCEEMIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIFQQFqIQogBS0AASEBIAUtAABB/wFHBEAgBCAKNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAo2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAHIAdFIBwbDAELIAooAgQLIQYgCyAbQQJ0aiAVIA4gBiATQdC7AWotAABzIgcbNgIAIAwgDCgCAEGAgAFyNgIAIAggCCgCBEGAIHI2AgQgBCgCfEECdCAIaiIGIAYoAgRBBHI2AgQgBiAGKAIMQQFyNgIMIAYgBigCCCAHQRJ0ckECcjYCCCADIAdBHHRyQYDAAHIhAwsgCCADQf///7Z7cTYCAAsgCEEEaiEDIAtBBGohCyAYQQFqIhggFEcNAAsgCEEMaiEDIAsgG0ECdGohCyARQQRqIhEgBCgCgAEiBkF8cUkNAAsMAQtBBCAGQXxxIgMgA0EETRtBAWsiA0F8cUEEaiERIAcgA0EBdEF4cWpBFGohAwsgBCAFNgIIIAQgATYCBCAEIAI2AgAgBCAJNgJoIBRFDQQgBiARTQ0EA0BBACEFIBEgBCgCgAFHBEADQCAEIAMgCyAFIBRsQQJ0aiAOIAVBABBYIAVBAWoiBSAEKAKAASARa0kNAAsLIAMgAygCAEH///+2e3E2AgAgC0EEaiELIANBBGohAyAXQQFqIhcgFEcNAAsMBAtBBCAGQXxxIgMgA0EETRtBAWsiA0F8cUEEaiERIAcgA0EBdEF4cWpBFGohAwsgBCAFNgIIIAQgATYCBCAEIAI2AgAgBCAJNgJoIBRFDQIgBiARTQ0CA0BBACEFIBEgBCgCgAFHBEADQCAEIAMgCyAFIBRsQQJ0aiAOIAVBARBYIAVBAWoiBSAEKAKAASARa0kNAAsLIAMgAygCAEH///+2e3E2AgAgC0EEaiELIANBBGohAyAXQQFqIhcgFEcNAAsMAgsDQEEAIQwDQCADIRECQAJAAn8CQAJAIAYiDSgCACIGRQRAIAEgECgCACIDKAIAIgZrIQECfyAGIAJBEHZLBEAgAygCBCEHIBAgA0EIQQwgASAGSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgNBAWohCSADLQABIQEgAy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAJNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAJNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAcgB0UgChsMAQsgAiAGQRB0ayECIAFBgIACcUUEQCADKAIEIQcgECADQQxBCCABIAZJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiBkEBaiEJIAYtAAEhAyAGLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAHRSAHIAobDAELIAMoAgQLRQRAIBAhCQwGCyABIAgoAgAiAygCACIGayEBAn8gBiACQRB2SwRAIAMoAgQhByAIIANBCEEMIAEgBkkiChtqKAIAIgM2AgADQAJAIAUNACAEKAIQIglBAWohBSAJLQABIQEgCS0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAcgB0UgChsMAQsgAiAGQRB0ayECIAFBgIACcUUEQCADKAIEIQcgCCADQQxBCCABIAZJIgobaigCACIDNgIAA0ACQCAFDQAgBCgCECIJQQFqIQUgCS0AASEGIAktAABB/wFGBEAgBkGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECAGQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgBkEIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgChsMAQsgAygCBAshCiABIAMoAgAiBmshAQJ/IAYgAkEQdksEQCADKAIEIQcgCCADQQhBDCABIAZJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiA0EBaiEJIAMtAAEhASADLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgAUEJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgByAHRSAOGwwBCyACIAZBEHRrIQIgAUGAgAJxRQRAIAMoAgQhByAIIANBDEEIIAEgBkkiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgCTYCECADQQl0IAJqIQJBByEFDAELIAQgCTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgDhsMAQsgAygCBAshA0EAIQYgCCEJAkACQAJAAn8CQAJAIAMgCkEBdHIOBAABAwUKCyABIAsgDSgCBEERdkEEcSANQQRrIgcoAgBBE3ZBAXFyIg5B0LkBai0AAEECdGoiCSgCACIDKAIAIgZrIQECfyAGIAJBEHZLBEAgAygCBCEKIAkgA0EIQQwgASAGSSISG2ooAgA2AgADQAJAIAUNACAEKAIQIgNBAWohCSADLQABIQEgAy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAJNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAJNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgEhsMAQsgAiAGQRB0ayECIAFBgIACcUUEQCADKAIEIQogCSADQQxBCCABIAZJIhIbaigCADYCAANAAkAgBQ0AIAQoAhAiBkEBaiEJIAYtAAEhAyAGLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIBIbDAELIAMoAgQLIQMgESATIBQgAyAOQdC7AWotAABzIgMbNgIAIAcgBygCAEEgcjYCACANIA0oAgRBCHI2AgQgA0ETdCFbIAEgCyAEKAJsLQACQQJ0aiIHKAIAIgMoAgAiBmshAQJ/IAYgAkEQdksEQCADKAIEIQkgByADQQhBDCABIAZJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiA0EBaiEHIAMtAAEhASADLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAc2AhAgAUEJdCACaiECQQchBQwBCyAEIAc2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgCSAJRSAOGwwBCyACIAZBEHRrIQIgAUGAgAJxRQRAIAMoAgQhCSAHIANBDEEIIAEgBkkiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQcgBi0AASEDIAYtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBzYCECADQQl0IAJqIQJBByEFDAELIAQgBzYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAlFIAkgDhsMAQsgAygCBAshAyBbQRByIgYgA0UNARoLIAEgCyANKAIEQRR2QQRxIA1BBGsiCSgCAEEWdkEBcSAGQQ92QRBxIAZBE3ZBwABxIAZBA3ZBqgFxcnJyciISQdC5AWotAABBAnRqIgooAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhDiAKIAdBCEEMIAEgA0kiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAOIA5FIAobDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEOIAogB0EMQQggASADSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgDkUgDiAKGwwBCyAHKAIECyEDIBEgEyAUIAMgEkHQuwFqLQAAcyIDGzYCgAIgCSAJKAIAQYACcjYCACANIA0oAgRBwAByNgIEIAYgA0EWdHJBgAFyCyEGIAEgCyAEKAJsIAZBBnZB7wNxai0AAEECdGoiCSgCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEKIAkgB0EIQQwgASADSSIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohCSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAJNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAJNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAogCkUgDhsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQogCSAHQQxBCCABIANJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEJIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIA4bDAELIAcoAgQLRQ0BCyABIAsgDSgCBEEXdkEEcSANQQRrIgkoAgBBGXZBAXEgBkESdkEQcSAGQRZ2QcAAcSAGQQZ2QaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIKKAIAIgcoAgAiA2shAQJ/IAMgAkEQdksEQCAHKAIEIQ4gCiAHQQhBDCABIANJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhASAHLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQEgDiAORSAKGwwBCyACIANBEHRrIQIgAUGAgAJxRQRAIAcoAgQhDiAKIAdBDEEIIAEgA0kiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIA5FIA4gChsMAQsgBygCBAshAyARIBMgFCADIBJB0LsBai0AAHMiAxs2AoAEIAkgCSgCAEGAEHI2AgAgDSANKAIEQYAEcjYCBCAGIANBGXRyQYAIciEGCyABIAsgBCgCbCAGQQl2Qe8DcWotAABBAnRqIgkoAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhCiAJIAdBCEEMIAEgA0kiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAKIApFIA4bDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEKIAkgB0EMQQggASADSSIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgCkUgCiAOGwwBCyAHKAIEC0UNBQsgASALIA0oAgRBGnZBBHEgDUEEayIOKAIAQRx2QQFxIAZBFXZBEHEgBkEZdkHAAHEgBkEJdkGqAXFycnJyIgpB0LkBai0AAEECdGoiCSgCACIHKAIAIgNrIQEgAyACQRB2SwRAIAcoAgQhEiAJIAdBCEEMIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASASIBJFIBUbDAQLIAIgA0EQdGshAiABQYCAAnENASAHKAIEIRIgCSAHQQxBCCABIANJIhUbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyASRSASIBUbDAMLAkAgBkGQgIABcQ0AIAEgCyAEKAJsIAZB7wNxai0AAEECdGoiCSgCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEKIAkgB0EIQQwgASADSSIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAogCkUgDhsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQogCSAHQQxBCCABIANJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIA4bDAELIAcoAgQLRQ0AIAEgCyANKAIEQRF2QQRxIA1BBGsiCigCAEETdkEBcSAGQQ52QRBxIAZBEHZBwABxIAZBqgFxcnJyciISQdC5AWotAABBAnRqIgkoAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhDiAJIAdBCEEMIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAOIA5FIBUbDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEOIAkgB0EMQQggASADSSIVG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgDkUgDiAVGwwBCyAHKAIECyEDIBEgEyAUIAMgEkHQuwFqLQAAcyIDGzYCACAKIAooAgBBIHI2AgAgDSANKAIEQQhyNgIEIAYgA0ETdHJBEHIhBgsCQCAGQYCBgAhxDQAgASALIAQoAmwgBkEDdiIOQe8DcWotAABBAnRqIgkoAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhCiAJIAdBCEEMIAEgA0kiEhtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAKIApFIBIbDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEKIAkgB0EMQQggASADSSISG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgCkUgCiASGwwBCyAHKAIEC0UNACABIAsgDSgCBEEUdkEEcSANQQRrIgooAgBBFnZBAXEgBkEPdkEQcSAGQRN2QcAAcSAOQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIJKAIAIgcoAgAiA2shAQJ/IAMgAkEQdksEQCAHKAIEIQ4gCSAHQQhBDCABIANJIhUbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhASAHLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQEgDiAORSAVGwwBCyACIANBEHRrIQIgAUGAgAJxRQRAIAcoAgQhDiAJIAdBDEEIIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIA5FIA4gFRsMAQsgBygCBAshAyARIBMgFCADIBJB0LsBai0AAHMiAxs2AoACIAogCigCAEGAAnI2AgAgDSANKAIEQcAAcjYCBCAGIANBFnRyQYABciEGCwJAIAZBgIiAwABxDQAgASALIAQoAmwgBkEGdiIOQe8DcWotAABBAnRqIgkoAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhCiAJIAdBCEEMIAEgA0kiEhtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAKIApFIBIbDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEKIAkgB0EMQQggASADSSISG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgCkUgCiASGwwBCyAHKAIEC0UNACABIAsgDSgCBEEXdkEEcSANQQRrIgooAgBBGXZBAXEgBkESdkEQcSAGQRZ2QcAAcSAOQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIJKAIAIgcoAgAiA2shAQJ/IAMgAkEQdksEQCAHKAIEIQ4gCSAHQQhBDCABIANJIhUbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhASAHLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQEgDiAORSAVGwwBCyACIANBEHRrIQIgAUGAgAJxRQRAIAcoAgQhDiAJIAdBDEEIIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIA5FIA4gFRsMAQsgBygCBAshAyARIBMgFCADIBJB0LsBai0AAHMiAxs2AoAEIAogCigCAEGAEHI2AgAgDSANKAIEQYAEcjYCBCAGIANBGXRyQYAIciEGCyAGQYDAgIAEcQ0DIAEgCyAEKAJsIAZBCXYiEkHvA3FqLQAAQQJ0aiIJKAIAIgEoAgAiA2shBwJ/IAMgAkEQdksEQCABKAIEIQogCSABQQhBDCADIAdLIg4baigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhASAHLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQcgCiAKRSAOGwwBCyACIANBEHRrIQIgB0GAgAJxRQRAIAEoAgQhCiAJIAFBDEEIIAMgB0siDhtqKAIANgIAA0ACQCAFDQAgBCgCECIDQQFqIQUgAy0AASEBIAMtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIAdBAXQiB0GAgAJJDQALIApFIAogDhsMAQsgASgCBAtFBEAgByEBDAQLIAcgCyANKAIEQRp2QQRxIA1BBGsiDigCAEEcdkEBcSAGQRV2QRBxIAZBGXZBwABxIBJBqgFxcnJyciIKQdC5AWotAABBAnRqIgkoAgAiBygCACIBayEDIAEgAkEQdksEQCAHKAIEIRIgCSAHQQhBDCABIANLIhUbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyASIBJFIBUbDAMLIAIgAUEQdGshAiADQYCAAnFFDQEgAyEBCyAHKAIEDAELIAcoAgQhEiAJIAdBDEEIIAEgA0siFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASASRSASIBUbCyEDIBEgEyAUIAMgCkHQuwFqLQAAcyIDGzYCgAYgDiAOKAIAQYCAAXI2AgAgDSANKAIEQYAgcjYCBCANIA0oAoQCQQRyNgKEAiANIA0oAowCQQFyNgKMAiANIA0oAogCIANBEnRyQQJyNgKIAiAGIANBHHRyQYDAAHIhBgsgDSAGQf///7Z7cTYCAAsgDUEEaiEGIBFBBGohAyAMQQFqIgxBwABHDQALIA1BDGohBiARQYQGaiEDIBdBPEkhXCAXQQRqIRcgXA0ACwsgBCAFNgIIIAQgATYCBCAEIAI2AgAgBCAJNgJoCwJAIBZBIHFFDQAgBCAEQeQAajYCaCAEIAQoAgQgBCgCZCIGKAIAIgFrIgI2AgQCQCABIAQoAgAiBUEQdksEQCAEIAE2AgQgBCAGQQhBDCABIAJLG2ooAgAiBjYCZCAEKAIIIQIDQAJAIAINACAEKAIQIgdBAWohCSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAFQYD+A2ohBUEIIQIMAgsgBCAJNgIQIANBCXQgBWohBUEHIQIMAQsgBCAJNgIQQQghAiADQQh0IAVqIQULIAQgAkEBayICNgIIIAQgBUEBdCIFNgIAIAQgAUEBdCIBNgIEIAFBgIACSQ0ACyABIQIMAQsgBCAFIAFBEHRrIgU2AgAgAkGAgAJxDQAgBCAGQQxBCCABIAJLG2ooAgAiBjYCZCAEKAIIIQEDQAJAIAENACAEKAIQIgFBAWohByABLQABIQMgAS0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAFQYD+A2ohBUEIIQEMAgsgBCAHNgIQIANBCXQgBWohBUEHIQEMAQsgBCAHNgIQQQghASADQQh0IAVqIQULIAQgAUEBayIBNgIIIAQgBUEBdCIFNgIAIAQgAkEBdCICNgIEIAJBgIACSQ0ACwsgBCACIAYoAgAiAWsiAjYCBAJAIAEgBUEQdksEQCAEIAE2AgQgBCAGQQhBDCABIAJLG2ooAgAiBjYCZCAEKAIIIQIDQAJAIAINACAEKAIQIgdBAWohCSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAFQYD+A2ohBUEIIQIMAgsgBCAJNgIQIANBCXQgBWohBUEHIQIMAQsgBCAJNgIQQQghAiADQQh0IAVqIQULIAQgAkEBayICNgIIIAQgBUEBdCIFNgIAIAQgAUEBdCIBNgIEIAFBgIACSQ0ACyABIQIMAQsgBCAFIAFBEHRrIgU2AgAgAkGAgAJxDQAgBCAGQQxBCCABIAJLG2ooAgAiBjYCZCAEKAIIIQEDQAJAIAENACAEKAIQIgFBAWohByABLQABIQMgAS0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAFQYD+A2ohBUEIIQEMAgsgBCAHNgIQIANBCXQgBWohBUEHIQEMAQsgBCAHNgIQQQghASADQQh0IAVqIQULIAQgAUEBayIBNgIIIAQgBUEBdCIFNgIAIAQgAkEBdCICNgIEIAJBgIACSQ0ACwsgBCACIAYoAgAiAWsiAjYCBAJAIAEgBUEQdksEQCAEIAE2AgQgBCAGQQhBDCABIAJLG2ooAgAiBjYCZCAEKAIIIQIDQAJAIAINACAEKAIQIgdBAWohCSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAFQYD+A2ohBUEIIQIMAgsgBCAJNgIQIANBCXQgBWohBUEHIQIMAQsgBCAJNgIQQQghAiADQQh0IAVqIQULIAQgAkEBayICNgIIIAQgBUEBdCIFNgIAIAQgAUEBdCIBNgIEIAFBgIACSQ0ACyABIQIMAQsgBCAFIAFBEHRrIgU2AgAgAkGAgAJxDQAgBCAGQQxBCCABIAJLG2ooAgAiBjYCZCAEKAIIIQEDQAJAIAENACAEKAIQIgFBAWohByABLQABIQMgAS0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAFQYD+A2ohBUEIIQEMAgsgBCAHNgIQIANBCXQgBWohBUEHIQEMAQsgBCAHNgIQQQghASADQQh0IAVqIQULIAQgAUEBayIBNgIIIAQgBUEBdCIFNgIAIAQgAkEBdCICNgIEIAJBgIACSQ0ACwsgBCACIAYoAgAiAWsiAjYCBCABIAVBEHZLBEAgBCABNgIEIAQgBkEIQQwgASACSxtqKAIANgJkIAQoAgghAgNAAkAgAg0AIAQoAhAiBkEBaiEHIAYtAAEhAyAGLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAVBgP4DaiEFQQghAgwCCyAEIAc2AhAgA0EJdCAFaiEFQQchAgwBCyAEIAc2AhBBCCECIANBCHQgBWohBQsgBCACQQFrIgI2AgggBCAFQQF0IgU2AgAgBCABQQF0IgE2AgQgAUGAgAJJDQALDAELIAQgBSABQRB0ayIHNgIAIAJBgIACcQ0AIAQgBkEMQQggASACSxtqKAIANgJkIAQoAgghBQNAAkAgBQ0AIAQoAhAiA0EBaiEGIAMtAAEhASADLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAdBgP4DaiEHQQghBQwCCyAEIAY2AhAgAUEJdCAHaiEHQQchBQwBCyAEIAY2AhBBCCEFIAFBCHQgB2ohBwsgBCAFQQFrIgU2AgggBCAHQQF0Igc2AgAgBCACQQF0IgI2AgQgAkGAgAJJDQALCwsgJw0AIAQQWiAEQbCpATYCZCAEQdCeATYCYCAEQfCeATYCHAtBACAfQQFqIgEgAUEDRiIBGyEfIBkgAWshGSAmQQFqIiYgICgCCE8NASAZQQBKDQALCyAoICpqISggBCgCGCAELwFwOwAAIClBAWoiKSAaKAIsSQ0ACwsCQCArRQ0AAkAgBCgCGCIBIAQoAhAiA0ECaksEQCAhRQ0BICMgASAEKAIUIgZrNgI4ICMgAyAGazYCNCAjIAEgA2tBAms2AjAgHUECQZDyACAjQTBqEA8MAgsgBCgCDCIBQQNJDQEgIQRAICMgATYCUCAdQQJB6TUgI0HQAGoQDwwCCyAjIAE2AkAgHUECQek1ICNBQGsQDwwBCyAjIAEgBCgCFCIGazYCKCAjIAMgBms2AiQgIyABIANrQQJrNgIgIB1BAkGQ8gAgI0EgahAPCyAaKAI8RQ0AIAQgLDYCdAsgMCgCBCEBIBooAgwhXSAaKAIIIDAoAgBrIQggMCgCECIGQQFxBEAgMigCHCA3QZgBbGoiB0GQAWsoAgAgCGogB0GYAWsoAgBrIQgLIF0gAWshAyAGQQJxBEAgMigCHCA3QZgBbGoiAUGMAWsoAgAgA2ogAUGUAWsoAgBrIQMLIBooAjwiBiECIAZFBEAgBCgCdCECCyAEKAKAASEWIAQoAnwhDQJAIC8oAqgGIgdFDQAgFkUgDUVyIQEgB0EeTARAIAENAUEAIRADQCANIBBsIQRBACEBA0AgAiABIARqQQJ0aiIRKAIAIgkgCUEfdSIFcyAFayIFIAd2BEAgEUEAIAUgLygCqAZ2IhFrIBEgCUEASBs2AgALIAFBAWoiASANRw0ACyAQQQFqIhAgFkcNAAsMAQsgAQ0AIAJBACANIBZsQQJ0EBUaCyAGBEAgDSAWbCEGIC8oAhRBAUYEQCAGRQ0FQQAhASAGQQRPBEAgBkF8cSEBQQAhBANAIAIgBEECdGoiAyAD/QACACJe/RsAQQJt/REgXv0bAUECbf0cASBe/RsCQQJt/RwCIF79GwNBAm39HAP9CwIAIARBBGoiBCABRw0ACyABIAZGDQYLA0AgAiABQQJ0aiIDIAMoAgBBAm02AgAgAUEBaiIBIAZHDQALDAULIAZFDQQgMCoCIEMAAAA/lCFmQQAhBAJAIAZBBEkEQCACIQEMAQsgAiAGQXxxIgRBAnRqIQEgZv0TIV5BACEDA0AgAiADQQJ0aiIHIF4gB/0AAgD9+gH95gH9CwIAIANBBGoiAyAERw0ACyAEIAZGDQULA0AgASBmIAEoAgCylDgCACABQQRqIQEgBEEBaiIEIAZHDQALDAQLIDYgNWshESAvKAIUQQFHDQIgFkUNAyAyKAIkIgYgAyARbCIDQQJ0aiAIQQJ0aiEJIA1BfHEiDEEBayIBQQRxIQsgNiANIDVqa0ECdCEaIAFBAnZBAWpB/v///wdxIR0gAyAIakECdCAGaiACayEKQQAhCCABQQNHIRQDQEEAIQECQCAMRQ0AIAggDWwhAyAJIAggEWxBAnRqIQZBACEHIBQEQANAIAYgAUECdGogAiABIANqQQJ0av0AAgAiXv0bAEECbf0RIF79GwFBAm39HAEgXv0bAkECbf0cAiBe/RsDQQJt/RwD/QsCACAGIAFBBHIiBEECdGogAiADIARqQQJ0av0AAgAiXv0bAEECbf0RIF79GwFBAm39HAEgXv0bAkECbf0cAiBe/RsDQQJt/RwD/QsCACABQQhqIQEgB0ECaiIHIB1HDQALCyALDQAgBiABQQJ0aiACIAEgA2pBAnRq/QACACJe/RsAQQJt/REgXv0bAUECbf0cASBe/RsCQQJt/RwCIF79GwNBAm39HAP9CwIAIAFBBGohAQsCQCABIA1PDQAgCCANbCEDIAkgCCARbEECdGohBwJAIA0gAWsiEEEESQRAIAEhBAwBCyAKIAggGmxqQRBJBEAgASEEDAELIAEgEEF8cSIFaiEEQQAhBgNAIAcgASAGaiIhQQJ0aiACIAMgIWpBAnRq/QACACJe/RsAQQJt/REgXv0bAUECbf0cASBe/RsCQQJt/RwCIF79GwNBAm39HAP9CwIAIAZBBGoiBiAFRw0ACyAFIBBGDQELIARBAWohASANIARrQQFxBEAgByAEQQJ0aiACIAMgBGpBAnRqKAIAQQJtNgIAIAEhBAsgASANRg0AA0AgByAEQQJ0aiACIAMgBGpBAnRqKAIAQQJtNgIAIAcgBEEBaiIBQQJ0aiACIAEgA2pBAnRqKAIAQQJtNgIAIARBAmoiBCANRw0ACwsgCEEBaiIIIBZHDQALDAMLICMgGTYCACAdQQJB1cEAICMQDwsgECgCAEEANgIADAELIBZFDQAgDUUNACAyKAIkIAMgEWxBAnRqIAhBAnRqIQcgDUF8cSIDQQJ0IQYgMCoCIEMAAAA/lCJm/RMhXkEAIRAgDUEESSEIA0ACQAJAIAgEQCACIQkgByEBQQAhBAwBCyAGIAdqIQEgAiAGaiEJQQAhBANAIAcgBEECdCIFaiBeIAIgBWr9AAIA/foB/eYB/QsCACAEQQRqIgQgA0cNAAsgCSECIAMiBCANRg0BCyAJIQIDQCABIGYgAigCALKUOAIAIAFBBGohASACQQRqIQIgBEEBaiIEIA1HDQALCyAHIBFBAnRqIQcgEEEBaiIQIBZHDQALCyAAEBAgI0HgAGokAAvWBAEJfyAAKAIsQQhPBEAgACgCKCEFQQghCgNAIAAoAgxBBXQhCCAAKAIAIQQgACgCJCEDAkAgACgCFCIGIAAoAhAiAU0NACAEIAhqIQcgAUEBaiECIAYgAWtBAXEEQCAHIAFBBnRqIgkgBSABIANsQQJ0aiIB/QACAP0LAgAgCSAB/QACEP0LAhAgAiEBCyACIAZGDQADQCAHIAFBBnRqIgIgBSABIANsQQJ0aiIJ/QACAP0LAgAgAiAJ/QACEP0LAhAgByABQQFqIgJBBnRqIgkgBSACIANsQQJ0aiIC/QACEP0LAhAgCSAC/QACAP0LAgAgAUECaiIBIAZHDQALCwJAIAAoAhwiBiAAKAIYIgFNDQAgBCAIa0EgaiEHIAUgACgCCCADbEECdGohCCABQQFqIQIgBiABa0EBcQRAIAcgAUEGdGoiBCAIIAEgA2xBAnRqIgH9AAIA/QsCACAEIAH9AAIQ/QsCECACIQELIAIgBkYNAANAIAcgAUEGdGoiAiAIIAEgA2xBAnRqIgT9AAIA/QsCACACIAT9AAIQ/QsCECAHIAFBAWoiAkEGdGoiBCAIIAIgA2xBAnRqIgL9AAIQ/QsCECAEIAL9AAIA/QsCACABQQJqIgEgBkcNAAsLIAAQIkEAIQEgACgCIARAA0AgBSAAKAIkIAFsQQJ0aiICIAAoAgAgAUEFdGoiA/0AAgD9CwIAIAIgA/0AAhD9CwIQIAFBAWoiASAAKAIgSQ0ACwsgBUEgaiEFIApBCGoiCiAAKAIsTQ0ACwsgACgCABAQIAAQEAv3DQElfyAAKAIsQQhPBEAgACgCJCIKQQV0IR4gCkEHbCEWIApBBmwhFyAKQQVsIRggCkEDbCEZIApBAXQhGiAAKAIoIgEgCkEcbGohHyABIApBGGxqISAgASAKQRRsaiEhIAEgCkEEdGohIiABIApBDGxqISMgASAKQQN0IiRqISUgASAKQQJ0IhtqISZBCCEcA0AgACABIAAoAiRBCBA7IAAQIgJAIAAoAiAiC0UNACAdIB5sIQggACgCACEGQQAhBAJAAkAgC0HoAkkNACAGQQxqIg4gC0EBayICQQV0IgNqIA5JDQAgBkEIaiIPIANqIA9JDQAgAyAGaiAGSQ0AIAZBBGoiECADaiAQSQ0AIAJB////P0sNACABIAggJmoiAyALQQJ0IgVqIgxJIAMgASAFaiIHSXENACABIAggJWoiAiAFaiINSSACIAdJcQ0AIAEgBSAIICNqIglqIgVJIAcgCUtxDQAgBiAHSSABIAYgC0EFdGoiEUEcayISSXENACABIBFBGGsiE0kgByAQS3ENACABIBFBFGsiFEkgByAPS3ENACAHIA5LIAEgEUEQayIHSXENACADIA1JIAIgDElxDQAgAyAFSSAJIAxJcQ0AIAMgEkkgBiAMSXENACADIBNJIAwgEEtxDQAgAyAUSSAMIA9LcQ0AIAMgB0kgDCAOS3ENACACIAVJIAkgDUlxDQAgAiASSSAGIA1JcQ0AIAIgE0kgDSAQS3ENACACIBRJIA0gD0txDQAgAiAHSSANIA5LcQ0AIAkgEkkgBSAGS3ENACAJIBNJIAUgEEtxDQAgCSAUSSAFIA9LcQ0AIAcgCUsgBSAOS3ENACALQfz///8AcSEEQQAhAwNAIAEgA0ECdGogBiADQQV0aiIC/QkCACACKgIg/SABIAJBQGsqAgD9IAIgAioCYP0gA/0LAgAgASADIApqQQJ0aiAC/QkCBCACKgIk/SABIAIqAkT9IAIgAioCZP0gA/0LAgAgASADIBpqQQJ0aiAC/QkCCCACKgIo/SABIAIqAkj9IAIgAioCaP0gA/0LAgAgASADIBlqQQJ0aiAC/QkCDCACKgIs/SABIAIqAkz9IAIgAioCbP0gA/0LAgAgA0EEaiIDIARHDQALIAQgC0YNAQsDQCABIARBAnRqIAYgBEEFdGoiAyoCADgCACABIAQgCmpBAnRqIAMqAgQ4AgAgASAEIBpqQQJ0aiADKgIIOAIAIAEgBCAZakECdGogAyoCDDgCACAEQQFqIgQgC0cNAAsLIAAoAgAhBkEAIQQCQCALQdwASQ0AIAZBHGoiDyALQQFrIgJBBXQiA2ogD0kNACAGQRhqIhAgA2ogEEkNACAGQRBqIhEgA2ogEUkNACAGQRRqIhIgA2ogEkkNACACQf///z9LDQAgCCAiaiIDIAggIWoiAiALQQJ0IgVqIgxJIAIgAyAFaiIHSXENACADIAggIGoiCSAFaiINSSAHIAlLcQ0AIAMgCCAfaiIIIAVqIgVJIAcgCEtxDQAgAyAGIAtBBXRqIg5BDGsiE0kgByARS3ENACADIA5BCGsiFEkgByASS3ENACADIA5BBGsiFUkgByAQS3ENACADIA5JIAcgD0txDQAgAiANSSAJIAxJcQ0AIAIgBUkgCCAMSXENACACIBNJIAwgEUtxDQAgAiAUSSAMIBJLcQ0AIAIgFUkgDCAQS3ENACACIA5JIAwgD0txDQAgCCANSSAFIAlLcQ0AIAkgE0kgDSARS3ENACAJIBRJIA0gEktxDQAgCSAVSSANIBBLcQ0AIAkgDkkgDSAPS3ENACAIIBNJIAUgEUtxDQAgCCAUSSAFIBJLcQ0AIAggFUkgBSAQS3ENACAIIA5JIAUgD0txDQAgC0H8////AHEhBEEAIQMDQCABIAMgG2pBAnRqIAYgA0EFdGoiAv0JAhAgAioCMP0gASACKgJQ/SACIAIqAnD9IAP9CwIAIAEgAyAYakECdGogAv0JAhQgAioCNP0gASACKgJU/SACIAIqAnT9IAP9CwIAIAEgAyAXakECdGogAv0JAhggAioCOP0gASACKgJY/SACIAIqAnj9IAP9CwIAIAEgAyAWakECdGogAv0JAhwgAioCPP0gASACKgJc/SACIAIqAnz9IAP9CwIAIANBBGoiAyAERw0ACyAEIAtGDQELA0AgASAEIBtqQQJ0aiAGIARBBXRqIgMqAhA4AgAgASAEIBhqQQJ0aiADKgIUOAIAIAEgBCAXakECdGogAyoCGDgCACABIAQgFmpBAnRqIAMqAhw4AgAgBEEBaiIEIAtHDQALCyAdQQFqIR0gASAkQQJ0aiEBIBxBCGoiHCAAKAIsTQ0ACwsgACgCABAQIAAQEAtzAQJ/IAAoAhwiAUEIaiIDIAAoAiAiAk0EQANAIAAgACgCGCABQQJ0aiAAKAIUQQgQMCADIgFBCGoiAyAAKAIgIgJNDQALCyABIAJJBEAgACAAKAIYIAFBAnRqIAAoAhQgAiABaxAwCyAAKAIAEBAgABAQC0QAIAAoAhwiASAAKAIgSQRAA0AgACAAKAIYIAAoAhQgAWxBAnRqEF0gAUEBaiIBIAAoAiBJDQALCyAAKAIAEBAgABAQC6gBAQV/IAAoAlQiAygCACEFIAMoAgQiBCAAKAIUIAAoAhwiB2siBiAEIAZJGyIGBEAgBSAHIAYQEhogAyADKAIAIAZqIgU2AgAgAyADKAIEIAZrIgQ2AgQLIAQgAiACIARLGyIEBEAgBSABIAQQEhogAyADKAIAIARqIgU2AgAgAyADKAIEIARrNgIECyAFQQA6AAAgACAAKAIsIgE2AhwgACABNgIUIAILngUCBn4EfyABIAEoAgBBB2pBeHEiAUEQajYCACAAIQsgASkDACEDIAEpAwghByMAQSBrIggkACAHQv///////z+DIQQCfiAHQjCIQv//AYMiBaciCkGB+ABrQf0PTQRAIARCBIYgA0I8iIQhAiAKQYD4AGutIQUCQCADQv//////////D4MiA0KBgICAgICAgAhaBEAgAkIBfCECDAELIANCgICAgICAgIAIUg0AIAJCAYMgAnwhAgtCACACIAJC/////////wdWIgAbIQIgAK0gBXwMAQsCQCADIASEUA0AIAVC//8BUg0AIARCBIYgA0I8iIRCgICAgICAgASEIQJC/w8MAQtC/w8gCkH+hwFLDQAaQgBBgPgAQYH4ACAFUCIBGyIAIAprIglB8ABKDQAaIAMhAiAEIARCgICAgICAwACEIAEbIgYhBAJAQYABIAlrIgFBwABxBEAgAyABQUBqrYYhBEIAIQIMAQsgAUUNACAEIAGtIgWGIAJBwAAgAWutiIQhBCACIAWGIQILIAggAjcDECAIIAQ3AxgCQCAJQcAAcQRAIAYgCUFAaq2IIQNCACEGDAELIAlFDQAgBkHAACAJa62GIAMgCa0iAoiEIQMgBiACiCEGCyAIIAM3AwAgCCAGNwMIIAgpAwhCBIYgCCkDACICQjyIhCEDAkAgACAKRyAIKQMQIAgpAxiEQgBSca0gAkL//////////w+DhCICQoGAgICAgICACFoEQCADQgF8IQMMAQsgAkKAgICAgICAgAhSDQAgA0IBgyADfCEDCyADQoCAgICAgIAIhSADIANC/////////wdWIgAbIQIgAK0LIQMgCEEgaiQAIAsgB0KAgICAgICAgIB/gyADQjSGhCAChL85AwALhhgDE38BfAN+IwBBsARrIgwkACAMQQA2AiwCQCABvSIaQgBTBEBBASERQboIIRMgAZoiAb0hGgwBCyAEQYAQcQRAQQEhEUG9CCETDAELQcAIQbsIIARBAXEiERshEyARRSEVCwJAIBpCgICAgICAgPj/AINCgICAgICAgPj/AFEEQCAAQSAgAiARQQNqIgMgBEH//3txEBwgACATIBEQGSAAQZIJQfYKIAVBIHEiBRtB+wlB+gogBRsgASABYhtBAxAZIABBICACIAMgBEGAwABzEBwgAyACIAIgA0gbIQoMAQsgDEEQaiESAkACfwJAIAEgDEEsahBlIgEgAaAiAUQAAAAAAAAAAGIEQCAMIAwoAiwiBkEBazYCLCAFQSByIg5B4QBHDQEMAwsgBUEgciIOQeEARg0CIAwoAiwhCUEGIAMgA0EASBsMAQsgDCAGQR1rIgk2AiwgAUQAAAAAAACwQaIhAUEGIAMgA0EASBsLIQsgDEEwakGgAkEAIAlBAE4baiINIQcDQCAHAn8gAUQAAAAAAADwQWMgAUQAAAAAAAAAAGZxBEAgAasMAQtBAAsiAzYCACAHQQRqIQcgASADuKFEAAAAAGXNzUGiIgFEAAAAAAAAAABiDQALAkAgCUEATARAIAkhAyAHIQYgDSEIDAELIA0hCCAJIQMDQEEdIAMgA0EdTxshAwJAIAdBBGsiBiAISQ0AIAOtIRxCACEaA0AgBiAaQv////8PgyAGNQIAIByGfCIbQoCU69wDgCIaQoDslKMMfiAbfD4CACAGQQRrIgYgCE8NAAsgG0KAlOvcA1QNACAIQQRrIgggGj4CAAsDQCAIIAciBkkEQCAGQQRrIgcoAgBFDQELCyAMIAwoAiwgA2siAzYCLCAGIQcgA0EASg0ACwsgA0EASARAIAtBGWpBCW5BAWohDyAOQeYARiEQA0BBCUEAIANrIgMgA0EJTxshCgJAIAYgCE0EQCAIKAIARUECdCEHDAELQYCU69wDIAp2IRRBfyAKdEF/cyEWQQAhAyAIIQcDQCAHIAMgBygCACIXIAp2ajYCACAWIBdxIBRsIQMgB0EEaiIHIAZJDQALIAgoAgBFQQJ0IQcgA0UNACAGIAM2AgAgBkEEaiEGCyAMIAwoAiwgCmoiAzYCLCANIAcgCGoiCCAQGyIHIA9BAnRqIAYgBiAHa0ECdSAPShshBiADQQBIDQALC0EAIQMCQCAGIAhNDQAgDSAIa0ECdUEJbCEDQQohByAIKAIAIgpBCkkNAANAIANBAWohAyAKIAdBCmwiB08NAAsLIAsgA0EAIA5B5gBHG2sgDkHnAEYgC0EAR3FrIgcgBiANa0ECdUEJbEEJa0gEQCAMQTBqQYRgQaRiIAlBAEgbaiAHQYDIAGoiCkEJbSIPQQJ0aiEJQQohByAPQXdsIApqIgpBB0wEQANAIAdBCmwhByAKQQFqIgpBCEcNAAsLAkAgCSgCACIQIBAgB24iDyAHbCIKRiAJQQRqIhQgBkZxDQAgECAKayEQAkAgD0EBcUUEQEQAAAAAAABAQyEBIAdBgJTr3ANHDQEgCCAJTw0BIAlBBGstAABBAXFFDQELRAEAAAAAAEBDIQELRAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IAYgFEYbRAAAAAAAAPg/IBAgB0EBdiIURhsgECAUSRshGQJAIBUNACATLQAAQS1HDQAgGZohGSABmiEBCyAJIAo2AgAgASAZoCABYQ0AIAkgByAKaiIDNgIAIANBgJTr3ANPBEADQCAJQQA2AgAgCCAJQQRrIglLBEAgCEEEayIIQQA2AgALIAkgCSgCAEEBaiIDNgIAIANB/5Pr3ANLDQALCyANIAhrQQJ1QQlsIQNBCiEHIAgoAgAiCkEKSQ0AA0AgA0EBaiEDIAogB0EKbCIHTw0ACwsgCUEEaiIHIAYgBiAHSxshBgsDQCAGIgcgCE0iCkUEQCAGQQRrIgYoAgBFDQELCwJAIA5B5wBHBEAgBEEIcSEJDAELIANBf3NBfyALQQEgCxsiBiADSiADQXtKcSIJGyAGaiELQX9BfiAJGyAFaiEFIARBCHEiCQ0AQXchBgJAIAoNACAHQQRrKAIAIg5FDQBBCiEKQQAhBiAOQQpwDQADQCAGIglBAWohBiAOIApBCmwiCnBFDQALIAlBf3MhBgsgByANa0ECdUEJbCEKIAVBX3FBxgBGBEBBACEJIAsgBiAKakEJayIGQQAgBkEAShsiBiAGIAtKGyELDAELQQAhCSALIAMgCmogBmpBCWsiBkEAIAZBAEobIgYgBiALShshCwtBfyEKIAtB/f///wdB/v///wcgCSALciIQG0oNASALIBBBAEdqQQFqIQ4CQCAFQV9xIhVBxgBGBEAgAyAOQf////8Hc0oNAyADQQAgA0EAShshBgwBCyASIAMgA0EfdSIGcyAGa60gEhAqIgZrQQFMBEADQCAGQQFrIgZBMDoAACASIAZrQQJIDQALCyAGQQJrIg8gBToAACAGQQFrQS1BKyADQQBIGzoAACASIA9rIgYgDkH/////B3NKDQILIAYgDmoiAyARQf////8Hc0oNASAAQSAgAiADIBFqIgMgBBAcIAAgEyAREBkgAEEwIAIgAyAEQYCABHMQHAJAAkACQCAVQcYARgRAIAxBEGpBCXIhBSANIAggCCANSxsiCSEIA0AgCDUCACAFECohBgJAIAggCUcEQCAGIAxBEGpNDQEDQCAGQQFrIgZBMDoAACAGIAxBEGpLDQALDAELIAUgBkcNACAGQQFrIgZBMDoAAAsgACAGIAUgBmsQGSAIQQRqIgggDU0NAAsgEARAIABBggxBARAZCyAHIAhNDQEgC0EATA0BA0AgCDUCACAFECoiBiAMQRBqSwRAA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwsgACAGQQkgCyALQQlOGxAZIAtBCWshBiAIQQRqIgggB08NAyALQQlKIRggBiELIBgNAAsMAgsCQCALQQBIDQAgByAIQQRqIAcgCEsbIQ0gDEEQakEJciEFIAghBwNAIAUgBzUCACAFECoiBkYEQCAGQQFrIgZBMDoAAAsCQCAHIAhHBEAgBiAMQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwwBCyAAIAZBARAZIAZBAWohBiAJIAtyRQ0AIABBggxBARAZCyAAIAYgBSAGayIGIAsgBiALSBsQGSALIAZrIQsgB0EEaiIHIA1PDQEgC0EATg0ACwsgAEEwIAtBEmpBEkEAEBwgACAPIBIgD2sQGQwCCyALIQYLIABBMCAGQQlqQQlBABAcCyAAQSAgAiADIARBgMAAcxAcIAMgAiACIANIGyEKDAELIBMgBUEadEEfdUEJcWohCAJAIANBC0sNAEEMIANrIQZEAAAAAAAAMEAhGQNAIBlEAAAAAAAAMECiIRkgBkEBayIGDQALIAgtAABBLUYEQCAZIAGaIBmhoJohAQwBCyABIBmgIBmhIQELIBIgDCgCLCIHIAdBH3UiBnMgBmutIBIQKiIGRgRAIAZBAWsiBkEwOgAACyARQQJyIQsgBUEgcSENIAZBAmsiCSAFQQ9qOgAAIAZBAWtBLUErIAdBAEgbOgAAIARBCHEhBiAMQRBqIQcDQCAHIgUCfyABmUQAAAAAAADgQWMEQCABqgwBC0GAgICAeAsiB0HQxAFqLQAAIA1yOgAAIAEgB7ehRAAAAAAAADBAoiEBAkAgBUEBaiIHIAxBEGprQQFHDQACQCAGDQAgA0EASg0AIAFEAAAAAAAAAABhDQELIAVBLjoAASAFQQJqIQcLIAFEAAAAAAAAAABiDQALQX8hCkH9////ByALIBIgCWsiBmoiDWsgA0gNACAAQSAgAiANIANBAmogByAMQRBqIgdrIgUgBUECayADSBsgBSADGyIKaiIDIAQQHCAAIAggCxAZIABBMCACIAMgBEGAgARzEBwgACAHIAUQGSAAQTAgCiAFa0EAQQAQHCAAIAkgBhAZIABBICACIAMgBEGAwABzEBwgAyACIAIgA0gbIQoLIAxBsARqJAAgCgsEAEIACwQAQQALnwMBCX9B5gohAAJAA0AgAC0AACIBRQ0BIAFBPUYNASAAQQFqIgBBA3ENAAsCQAJAQYCChAggACgCACICayACckGAgYKEeHFBgIGChHhHDQADQEGAgoQIIAJBvfr06QNzIgFrIAFyQYCBgoR4cUGAgYKEeEcNASAAKAIEIQIgAEEEaiIBIQAgAkGAgoQIIAJrckGAgYKEeHFBgIGChHhGDQALDAELIAAhAQsDQCABIgAtAAAiAkUNASAAQQFqIQEgAkE9Rw0ACwsgACIBQeYKRgRAQQAPCwJAIAFB5gprIgBB5gpqLQAADQBBsM8BKAIAIgRFDQAgBCgCACIFRQ0AA0ACQAJ/IAUhAkHmCiEGQQAgACIBRQ0AGkHmCi0AACIDBH8CQANAIAMgAi0AACIHRw0BIAdFDQEgAUEBayIBRQ0BIAJBAWohAiAGLQABIQMgBkEBaiEGIAMNAAtBACEDCyADBUEACyACLQAAawtFBEAgACAFaiIBLQAAQT1GDQELIAQoAgQhBSAEQQRqIQQgBQ0BDAILCyABQQFqIQgLIAgLCQAgACgCPBANC84CAQh/IwBBIGsiAyQAIAMgACgCHCIENgIQIAAoAhQhBSADIAI2AhwgAyABNgIYIAMgBSAEayIBNgIUIAEgAmohBUECIQYgA0EQaiEBAn8DQAJAAkACQCAAKAI8IAEgBiADQQxqEAEiBAR/QZTHASAENgIAQX8FQQALRQRAIAUgAygCDCIHRg0BIAdBAE4NAgwDCyAFQX9HDQILIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhAgAgwDCyABIAcgASgCBCIISyIJQQN0aiIEIAcgCEEAIAkbayIIIAQoAgBqNgIAIAFBDEEEIAkbaiIBIAEoAgAgCGs2AgAgBSAHayEFIAYgCWshBiAEIQEMAQsLIABBADYCHCAAQgA3AxAgACAAKAIAQSByNgIAQQAgBkECRg0AGiACIAEoAgRrCyEKIANBIGokACAKC1YBAn8gACgCPCEEIwBBEGsiACQAIAQgAacgAUIgiKcgAkH/AXEgAEEIahAJIgIEf0GUxwEgAjYCAEF/BUEACyECIAApAwghASAAQRBqJABCfyABIAIbCwYAIAAQAAsGACAAEAML8n4FAnw2fwh7A34GfSMAQeDAAGsiGCQAIBhBADYCIEECIQwCQAJAIAAoAgAiB0GNlJzUAEYNACAHQf+f/Y8FRwRAAkAgB0GAgIDgAEcNACAAKAIEQeqggYECRw0AIAAoAghBjZSc1ABGDQILQc0IEABBASEMDAILQQAhDAsCf0EAQQFB4AAQEyIHRQ0AGiAHQQE2AkwCQAJAAkACQCAMDgMAAwEDCyAHQcMANgJYIAdBxAA2AlQgB0HFADYCUCAHQcYANgIQIAdBxwA2AgQgB0HIADYCHCAHQckANgIYIAdBygA2AhQgB0HLADYCACAHQcwANgJcIAdBzQA2AiwgB0HOADYCKCAHQc8ANgIkIAdB0AA2AiAgB0HRADYCDCAHQdIANgIIIAcQTSIINgIwIAgNAQwCCyAHQdMANgJYIAdB1AA2AlQgB0HVADYCUCAHQdYANgIQIAdB1wA2AgQgB0HYADYCXCAHQdkANgIsIAdB2gA2AiggB0HbADYCJCAHQdwANgIgIAdB3QA2AhwgB0HeADYCGCAHQd8ANgIUIAdB4AA2AgwgB0HhADYCCCAHQeIANgIAIAcCf0EBQYgBEBMiCARAIAgQTSIONgIAAkAgDkUNACAI/QwAAAAAAAAAAAAAAAAAAAAA/QsCbCAIQQA6AHwgCBAzIg42AgQgDkUNACAIEDMiDjYCCCAORQ0AIAgMAgsgCBBwC0EACyIINgIwIAhFDQELIAdBATYCSCAHQQE2AkAgB0EANgI8IAdCADcCNCAHQQE2AkQgBwwBCyAHEBBBAAsiCARAIAhBADYCPCAIQeMANgJICyAIBEAgCEEANgI4IAhB5AA2AkQLIAgEQCAIQQA2AjQgCEHlADYCQAsgGEEkaiIHBEAgB0EAQbjAABAVIgdBADYCuEAgB0J/NwKIQAsgAwRAIBggGCgC3EBBAXI2AtxACyAYIAE2AhwgGCAANgIYIBggADYCFEEBIQxBACEBAkAgGEEUaiIHRQ0AQQFByAAQEyIABH8CfyAAQYCAwAA2AkAgAEGAgMAAEBQiDjYCICAORQRAIAAQEEEADAELIAAgDjYCJCAAQQI2AhwgAEEDNgIYIABBBDYCFCAAQQU2AhAgAEEGNgIsIABBCDYCKCAAIAAoAkRBAnI2AkQgAAsFQQALIgBFDQAgAARAIABBADYCBCAAIAc2AgALIAc1AgghRSAABEAgACBFNwMICwJAIABFDQAgAC0AREECcUUNACAAQT82AhALIAAEQCAAQcEANgIYCyAABEAgAEHCADYCHAsgACEBCyABIQACfyAYQSRqIQECQCAIRQ0AIAFFDQAgCCgCTEUEQCAIQTRqQQFBtMkAQQAQD0EADAILIAgoAjAgASAIKAIYEQMAQQEhCwsgCwtFBEBB3AgQACAAEDQgCBA1DAELAn8gGEEgaiEBQQAhBwJAIABFDQAgCEUNACAIKAJMRQRAIAhBNGpBAUGFygBBABAPQQAMAgsgACAIKAIwIAEgCEE0aiAIKAIAEQEAIQcLIAcLRQRAQfgIEAAgABA0IAgQNSAYKAIgECEMAQsgGCgCICEBQQAhBwJAIAhFDQAgAEUNACAIKAJMRQ0AIAgoAjAgACABIAhBNGogCCgCBBEBACEHCwJAIAcEQEEAIQcCQCAIRQ0AIABFDQAgCCgCTEUNACAIKAIwIAAgCEE0aiAIKAIQEQAAIQcLIAcNAQtB/wkQACAIEDUgABA0IBgoAiAQIQwBCyAAEDQgCBA1IBgoAiAiDSgCHCIABEAgABAQIBgoAiAiDUIANwIcCyANKAIQISECQAJAIAJFBEACQCAERQ0AICFBBEcNAEEBIRlBBCEhDAMLAkACQCANKAIUIgFBA0YNACAhQQNHDQAgDSgCGCIAKAIAIAAoAgRHDQEgACgCNEEBRg0BIA1BAzYCFAwDCyAhQQJLDQAgDUECNgIUDAMLAkACQCABQQNrDgMDAQAECyMAQRBrIg4kAAJAAkACQCANKAIQQQRJDQAgDSgCGCIAKAIAIgEgACgCNEcNACABIAAoAmhHDQAgASAAKAKcAUcNACAAKAIEIgEgACgCOEcNACABIAAoAmxHDQAgASAAKAKgAUYNAQsgDkGHCDYCBCAOQbgKNgIAQejEAUHtPSAOEBYMAQsCQCAAKAIMIAAoAghsIghFBEAgACgCyAEhAQwBC0MAAIA/QX8gACgCtAF0QX9zs5UhSEMAAIA/QX8gACgCgAF0QX9zs5UhSkMAAIA/QX8gACgCTHRBf3OzlSFLQwAAgD9BfyAAKAIYdEF/c7OVIUkgACgCyAEhASAAKAKUASECIAAoAmAhCiAAKAIsIQdBACEAAkAgCEEISQ0AIAcgCiAIQQJ0IgtqIg9JIAogByALaiIXSXENACACIBdJIAcgAiALaiIJSXENACABIBdJIAcgASALaiILSXENACACIA9JIAkgCktxDQAgASAPSSAKIAtJcQ0AIAEgCUkgAiALSXENACAIQXxxIQAgSP0TIT0gSv0TIT4gS/0TIUMgSf0TIUBBACELA0AgAiALQQJ0Ig9qIhf9AAIAIUEgCiAPaiIJ/QACACFCIAcgD2oiEP0MAACAPwAAgD8AAIA/AACAPyBAIBD9AAIA/foB/eYB/eUB/QwAAH9DAAB/QwAAf0MAAH9D/eYB/QwAAIA/AACAPwAAgD8AAIA/ID0gASAPav0AAgD9+gH95gH95QEiP/3mAf34Af0LAgAgCf0MAACAPwAAgD8AAIA/AACAPyBDIEL9+gH95gH95QH9DAAAf0MAAH9DAAB/QwAAf0P95gEgP/3mAf34Af0LAgAgF/0MAACAPwAAgD8AAIA/AACAPyA+IEH9+gH95gH95QH9DAAAf0MAAH9DAAB/QwAAf0P95gEgP/3mAf34Af0LAgAgC0EEaiILIABHDQALIAAgCEYNAQsDQAJ/QwAAgD8gSSAHIABBAnQiC2oiDygCALKUk0MAAH9DlEMAAIA/IEggASALaigCALKUkyJMlCJNi0MAAABPXQRAIE2oDAELQYCAgIB4CyEXIAIgC2oiCSgCACEQIAogC2oiCygCACEMIA8gFzYCACALAn9DAACAPyBLIAyylJNDAAB/Q5QgTJQiTYtDAAAAT10EQCBNqAwBC0GAgICAeAs2AgAgCQJ/QwAAgD8gSiAQspSTQwAAf0OUIEyUIkyLQwAAAE9dBEAgTKgMAQtBgICAgHgLNgIAIABBAWoiACAIRw0ACwsgARAQIA0oAhgiAEEINgKAASAAQQg2AkwgAEEINgIYIABBADYCyAEgDUEBNgIUIA0gDSgCEEEBayIANgIQIABBBEkNAEEDIQADQCANKAIYIABBNGxqIgEgASgCZDYCMCABIAH9AAJU/QsCICABIAH9AAJE/QsCECABIAH9AAI0/QsCACAAQQFqIgAgDSgCEEkNAAsLIA5BEGokAAwDCyMAQRBrIgskAAJAAkACQCANKAIQQQNJDQAgDSgCGCIAKAIAIgEgACgCNEcNACABIAAoAmhHDQAgACgCBCIBIAAoAjhHDQAgASAAKAJsRg0BCyALQcUINgIEIAtBuAo2AgBB6MQBQZc+IAsQFgwBCwJAIAAoAgwgACgCCGwiAkUNAEF/IAAoAhgiCnRBf3MhAUEAQQEgCkEBa3QiCiAAKAKIARshD0EAIAogACgCVBshFyAAKAKUASEKIAAoAmAhByAAKAIsIQ5BACEAAkAgAkEESQ0AIA4gByACQQJ0IghqIglJIAcgCCAOaiIQSXENACAKIBBJIA4gCCAKaiIISXENACAHIAhJIAkgCktxDQAgAkF8cSEAIAH9ESE/IA/9ESFAIBf9ESFBQQAhCANAIA4gCEECdCIJaiIQID8gCSAKaiIM/QACACBA/bEB/foBIj39DGl0sz9pdLM/aXSzP2l0sz/95gEgByAJaiIJ/QACACBB/bEB/foBIj79DLNZGrizWRq4s1kauLNZGrj95gEgEP0AAgD9+gEiQ/3kAf3kAf0MAAAAPwAAAD8AAAA/AAAAP/3kAf34ASJC/QwAAAAAAAAAAAAAAAAAAAAA/bgBID8gQv05/VL9CwIAIAkgPyA9/QwZ0Da/GdA2vxnQNr8Z0Da//eYBIEP9DNUJgD/VCYA/1QmAP9UJgD/95gEgPv0MJzGwvicxsL4nMbC+JzGwvv3mAf3kAf3kAf0MAAAAPwAAAD8AAAA/AAAAP/3kAf34ASJC/QwAAAAAAAAAAAAAAAAAAAAA/bgBID8gQv05/VL9CwIAIAwgPyA9/Qy9Nwa3vTcGt703Bre9Nwa3/eYBIEP9DGb0fz9m9H8/ZvR/P2b0fz/95gEgPv0MNdLiPzXS4j810uI/NdLiP/3mAf3kAf3kAf0MAAAAPwAAAD8AAAA/AAAAP/3kAf34ASI9/QwAAAAAAAAAAAAAAAAAAAAA/bgBID8gPf05/VL9CwIAIAhBBGoiCCAARw0ACyAAIAJGDQELA0ACfyAKIABBAnQiCGoiCSgCACAPa7IiSENpdLM/lCAHIAhqIhAoAgAgF2uyIkpDs1kauJQgCCAOaiIMKAIAsiJLkpJDAAAAP5IiSYtDAAAAT10EQCBJqAwBC0GAgICAeAshCCAMIAEgCEEAIAhBAEobIAEgCEgbNgIAIBAgAQJ/IEhDGdA2v5QgS0PVCYA/lCBKQycxsL6UkpJDAAAAP5IiSYtDAAAAT10EQCBJqAwBC0GAgICAeAsiCEEAIAhBAEobIAEgCEgbNgIAIAkgAQJ/IEhDvTcGt5QgS0Nm9H8/lCBKQzXS4j+UkpJDAAAAP5IiSItDAAAAT10EQCBIqAwBC0GAgICAeAsiCEEAIAhBAEobIAEgCEgbNgIAIABBAWoiACACRw0ACwsgDUEBNgIUCyALQRBqJAAMAgsgISACIAIgIUsbISFBASEZDAELAkACQAJ/AkACQCANKAIYIgEoAgBBAUcNAAJAAkAgASgCNEEBaw4CAQACCyABKAJoQQJHDQECQCABKAIEQQFHDQAgASgCOEECRw0AIAEoAmxBAkcNAEEAIQsgDSIXKAIYIgAoAhghASAAKAKUASERIAAoAmAhCiAAKAIsIRAgACgCCCINIAAoAgwiAmxBAnQiABAYIQcgABAYIQggABAYIQ4CQAJAAkACQAJAAkAgB0UNACAIRQ0AIA5FDQBBfyABdEF/cyEJQQEgAUEBa3QhDCACIBcoAgRBAXEiAGshHiAXKAIAQQFxIRsgAEUNAyANRQ0DAn9BACAMa7K7IgVEarx0kxgE1j+iIAVEDAIrhxbZ5j+ioCIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAshFAJ/IAVEJzEIrBxa/D+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyEaIA1BCEkhOAJ/IAVEO99PjZdu9j+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyEdIDgNASAIIAdrQRBJDQEgDiAHa0EQSQ0BIAcgEGtBEEkNASAOIAhrQRBJDQEgCCAQa0EQSQ0BIA4gEGtBEEkNASAOIA1BfHEiC0ECdCICaiEBIAIgB2ohACAa/REhPiAU/REhQyAJ/REhPyAd/REhQANAIAcgD0ECdCITav0MAAAAAAAAAAAAAAAAAAAAACAQIBNq/QACACI9IED9rgEiQSA//bYBIEH9DAAAAAAAAAAAAAAAAAAAAAD9Of1S/QsCACAIIBNq/QwAAAAAAAAAAAAAAAAAAAAAID0gQ/2xASJBID/9tgEgQf0MAAAAAAAAAAAAAAAAAAAAAP05/VL9CwIAIA4gE2r9DAAAAAAAAAAAAAAAAAAAAAAgPSA+/a4BIj0gP/22ASA9/QwAAAAAAAAAAAAAAAAAAAAA/Tn9Uv0LAgAgD0EEaiIPIAtHDQALIAIgEGohECACIAhqIQIgCyANRg0EDAILIAcQECAIEBAgDhAQDAQLIAchACAIIQIgDiEBCwNAIAAgECgCACIPIB1qIhMgCSAJIBNKG0EAIBNBAE4bNgIAIAIgDyAUayITIAkgCSATShtBACATQQBOGzYCACABIA8gGmoiDyAJIAkgD0obQQAgD0EAThs2AgAgAUEEaiEBIAJBBGohAiAAQQRqIQAgEEEEaiEQIAtBAWoiCyANRw0ACwwBCyAOIQEgCCECIAchAAsgDSAbayEaAkAgHkF+cSIdBH8Cf0EAIAxrsrsiBURqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyEiIBpBfnEiHEEBayE5An8gBUQnMQisHFr8P6IiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLISMgOUF+cSE6An8gBUQ730+Nl272P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLISQgHUEBayElIDpBAmohJiANQQJ0IQ0DQCABIA1qIQ8gAiANaiETIAAgDWohCyANIBBqIRQgGwRAIAAgECgCACIVICRqIhIgCSAJIBJKG0EAIBJBAE4bNgIAIAIgFSAiayISIAkgCSASShtBACASQQBOGzYCACABIBUgI2oiFSAJIAkgFUobQQAgFUEAThs2AgAgCigCACEWIAsCfyARKAIAIAxrsrsiBUQ730+Nl272P6IiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLIBQoAgAiFWoiEiAJIAkgEkobQQAgEkEAThs2AgAgEyAVAn8gFiAMa7K7IgZEarx0kxgE1j+iIAVEDAIrhxbZ5j+ioCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAtrIhIgCSAJIBJKG0EAIBJBAE4bNgIAIA8CfyAGRCcxCKwcWvw/oiIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAsgFWoiFSAJIAkgFUobQQAgFUEAThs2AgAgD0EEaiEPIBNBBGohEyALQQRqIQsgFEEEaiEUIAJBBGohAiAQQQRqIRAgAUEEaiEBIABBBGohAAtBACEVIBwEfwNAIAooAgAhHyAAAn8gESgCACAMa7K7IgVEO99PjZdu9j+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyAQKAIAIhJqIhYgCSAJIBZKG0EAIBZBAE4bNgIAIAIgEgJ/IB8gDGuyuyIGRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLayIWIAkgCSAWShtBACAWQQBOGzYCACABAn8gBkQnMQisHFr8P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIBJqIhIgCSAJIBJKG0EAIBJBAE4bNgIAIAooAgAhHyAAAn8gESgCACAMa7K7IgVEO99PjZdu9j+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyAQKAIEIhJqIhYgCSAJIBZKG0EAIBZBAE4bNgIEIAIgEgJ/IB8gDGuyuyIGRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLayIWIAkgCSAWShtBACAWQQBOGzYCBCABAn8gBkQnMQisHFr8P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIBJqIhIgCSAJIBJKG0EAIBJBAE4bNgIEIAooAgAhHyALAn8gESgCACAMa7K7IgVEO99PjZdu9j+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyAUKAIAIhJqIhYgCSAJIBZKG0EAIBZBAE4bNgIAIBMgEgJ/IB8gDGuyuyIGRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLayIWIAkgCSAWShtBACAWQQBOGzYCACAPAn8gBkQnMQisHFr8P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIBJqIhIgCSAJIBJKG0EAIBJBAE4bNgIAIAooAgAhHyALAn8gESgCACAMa7K7IgVEO99PjZdu9j+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyAUKAIEIhJqIhYgCSAJIBZKG0EAIBZBAE4bNgIEIBMgEgJ/IB8gDGuyuyIGRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLayIWIAkgCSAWShtBACAWQQBOGzYCBCAPAn8gBkQnMQisHFr8P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIBJqIhIgCSAJIBJKG0EAIBJBAE4bNgIEIBFBBGohESAKQQRqIQogD0EIaiEPIBNBCGohEyALQQhqIQsgFEEIaiEUIAFBCGohASACQQhqIQIgAEEIaiEAIBBBCGohECAVQQJqIhUgHEkNAAsgJgVBAAsgGkkEfyAKKAIAIRYgAAJ/IBEoAgAgDGuyuyIFRDvfT42XbvY/oiIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAsgECgCACIVaiISIAkgCSASShtBACASQQBOGzYCACACIBUCfyAWIAxrsrsiBkRqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C2siEiAJIAkgEkobQQAgEkEAThs2AgAgAQJ/IAZEJzEIrBxa/D+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyAVaiIVIAkgCSAVShtBACAVQQBOGzYCACAKKAIAIRUgCwJ/IBEoAgAgDGuyuyIFRDvfT42XbvY/oiIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAsgFCgCACILaiIUIAkgCSAUShtBACAUQQBOGzYCACATIAsCfyAVIAxrsrsiBkRqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C2siEyAJIAkgE0obQQAgE0EAThs2AgAgDwJ/IAZEJzEIrBxa/D+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyALaiILIAkgCSALShtBACALQQBOGzYCACARQQRqIREgCkEEaiEKIAJBBGohAiAQQQRqIRAgAEEEaiEAIAFBBGoFIAELIA1qIQEgAiANaiECIAAgDWohACANIBBqIRAgIEECaiIgIB1JDQALICVBfnFBAmoFQQALIB5PDQAgGwRAIAACf0EAIAxrsrsiBUQ730+Nl272P6IiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLIBAoAgAiC2oiDSAJIAkgDUobQQAgDUEAThs2AgAgAiALAn8gBURqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4C2siDSAJIAkgDUobQQAgDUEAThs2AgAgAQJ/IAVEJzEIrBxa/D+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyALaiILIAkgCSALShtBACALQQBOGzYCACACQQRqIQIgEEEEaiEQIAFBBGohASAAQQRqIQALIBpBfnEiIAR/ICBBAWsiC0F+cSE7AkACf0EAICBBD0kNABpBACAAIAIgC0EBdiIUQQN0QQhqIhNqIgtJIAIgACATaiINSXENABpBACABIA1JIAAgASATaiIPSXENABpBACAAIBAgE2oiE0kgDSAQS3ENABpBACAKIA1JIAAgCiAUQQJ0QQRqIh5qIhtJcQ0AGkEAIA0gEUsgACARIB5qIg1JcQ0AGkEAIAIgD0kgASALSXENABpBACACIBNJIAsgEEtxDQAaQQAgCiALSSACIBtJcQ0AGkEAIAIgDUkgCyARS3ENABpBACABIBNJIA8gEEtxDQAaQQAgCiAPSSABIBtJcQ0AGkEAIAEgDUkgDyARS3ENABogCiAUQQFqIhZB/P///wdxIhtBAnQiImohCyABIBtBA3QiHmohDSAAIB5qIQ8gCf0RIT8gDP0RIUNBACETA0AgECATQQN0IhRBGHIiHWoiIyAQIBRBEHIiHGoiJCAQIBRBCHIiFWoiJSAQIBRqIib9CQIA/VYCAAH9VgIAAv1WAgADIT0CfyARIBNBAnQiH2r9AAIAIEP9sQH9+gEiPv1fIkD9DDvfT42XbvY/O99PjZdu9j/98gEiQf0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAshJyAKIB9q/QACACFCIAAgFGoiH/0MAAAAAAAAAAAAAAAAAAAAACA9An8gQf0hACIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9ESAn/RwBAn8gPiA+/Q0ICQoLDA0ODwABAgMAAQID/V8iQf0MO99PjZdu9j8730+Nl272P/3yASI+/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0cAgJ/ID79IQEiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwDIkT9rgEiPiA//bYBID79DAAAAAAAAAAAAAAAAAAAAAD9Of1SIj79WgIAACAAIBVqIicgPv1aAgABIAAgHGoiKSA+/VoCAAIgACAdaiIqID79WgIAAwJ/IEIgQ/2xAf36ASI+/V8iQv0Marx0kxgE1j9qvHSTGATWP/3yASBA/QwMAiuHFtnmPwwCK4cW2eY//fIB/fABIkD9IQEiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLISggAiAUaiIr/QwAAAAAAAAAAAAAAAAAAAAAID0CfyBA/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0RICj9HAECfyA+/QwAAAAAAAAAAAAAAAAAAAAA/Q0ICQoLDA0ODwABAgMAAQID/V8iQP0Marx0kxgE1j9qvHSTGATWP/3yASBB/QwMAiuHFtnmPwwCK4cW2eY//fIB/fABIj79IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwCAn8gPv0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAMiQf2xASI+ID/9tgEgPv0MAAAAAAAAAAAAAAAAAAAAAP05/VIiPv1aAgAAIAIgFWoiKCA+/VoCAAEgAiAcaiIsID79WgIAAiACIB1qIi0gPv1aAgADAn8gQv0MJzEIrBxa/D8nMQisHFr8P/3yASI+/SEBIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyEuIAEgFGoiFP0MAAAAAAAAAAAAAAAAAAAAACA9An8gPv0hACIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9ESAu/RwBAn8gQP0MJzEIrBxa/D8nMQisHFr8P/3yASI9/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0cAgJ/ID39IQEiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwDIkD9rgEiPSA//bYBID39DAAAAAAAAAAAAAAAAAAAAAD9Of1SIj39WgIAACABIBVqIhUgPf1aAgABIAEgHGoiHCA9/VoCAAIgASAdaiIdID39WgIAAyAf/QwAAAAAAAAAAAAAAAAAAAAAICNBBGogJEEEaiAlQQRqICb9CQIE/VYCAAH9VgIAAv1WAgADIj4gRP2uASI9ID/9tgEgPf0MAAAAAAAAAAAAAAAAAAAAAP05/VIiPf1aAgQAICcgPf1aAgQBICkgPf1aAgQCICogPf1aAgQDICv9DAAAAAAAAAAAAAAAAAAAAAAgPiBB/bEBIj0gP/22ASA9/QwAAAAAAAAAAAAAAAAAAAAA/Tn9UiI9/VoCBAAgKCA9/VoCBAEgLCA9/VoCBAIgLSA9/VoCBAMgFP0MAAAAAAAAAAAAAAAAAAAAACA+IED9rgEiPSA//bYBID39DAAAAAAAAAAAAAAAAAAAAAD9Of1SIj39WgIEACAVID39WgIEASAcID39WgIEAiAdID39WgIEAyATQQRqIhMgG0cNAAsgESAiaiERIBAgHmohECACIB5qIQIgFiAbRgRAIA8hACANIQEgCyEKDAILIA8hACANIQEgCyEKIBtBAXQLIQsDQCAKKAIAIRMgAAJ/IBEoAgAgDGuyuyIFRDvfT42XbvY/oiIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAsgECgCACINaiIPIAkgCSAPShtBACAPQQBOGzYCACACIA0CfyATIAxrsrsiBkRqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C2siDyAJIAkgD0obQQAgD0EAThs2AgAgAQJ/IAZEJzEIrBxa/D+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyANaiINIAkgCSANShtBACANQQBOGzYCACAKKAIAIRMgAAJ/IBEoAgAgDGuyuyIFRDvfT42XbvY/oiIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAsgECgCBCINaiIPIAkgCSAPShtBACAPQQBOGzYCBCACIA0CfyATIAxrsrsiBkRqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C2siDyAJIAkgD0obQQAgD0EAThs2AgQgAQJ/IAZEJzEIrBxa/D+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyANaiINIAkgCSANShtBACANQQBOGzYCBCARQQRqIREgCkEEaiEKIAFBCGohASACQQhqIQIgAEEIaiEAIBBBCGohECALQQJqIgsgIEkNAAsLIDtBAmoFQQALIBpPDQAgCigCACELIAACfyARKAIAIAxrsrsiBUQ730+Nl272P6IiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLIBAoAgAiAGoiCiAJIAkgCkobQQAgCkEAThs2AgAgAiAAAn8gCyAMa7K7IgZEarx0kxgE1j+iIAVEDAIrhxbZ5j+ioCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAtrIgIgCSACIAlIG0EAIAJBAE4bNgIAIAECfyAGRCcxCKwcWvw/oiIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAsgAGoiACAJIAAgCUgbQQAgAEEAThs2AgALIBcoAhgoAiwQECAXKAIYIgAgBzYCLCAAKAJgEBAgFygCGCIAIAg2AmAgACgClAEQECAXKAIYIgAgDjYClAEgACAA/QACACI//QsCaCAAID/9CwI0IBdBATYCFAsMBwsgASgCBEEBRw0BIAEoAjhBAUcNASABKAJsQQFHDQEgASgCGCEAIAEoApQBIQIgASgCYCEHIAEoAiwhDCABKAIIIgogASgCDCIWbEECdCIBEBghDyABEBghFyABEBghCSAPRQ0FIBdFDQUgCUUNBSAWBEAgCiANKAIAQQFxIh9rISICf0EAQQEgAEEBa3QiFGuyuyIFRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLISdBfyAAdCE8ICJBfnEiHUEBayIKQQF2IgBBAWohIwJ/IAVEJzEIrBxa/D+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyEpIApBfnEhCiAAQQJ0IQggAEEDdCEAICNBfHEhGyA8QX9zIRECfyAFRDvfT42XbvY/oiIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAshKiAKQQJqISQgCEEEaiElIABBCGohICAbQQJ0ISYgG0EDdCEeIBtBAXQhECAR/REhPyAU/REhQyAdQQdJISggDyEKIBchACAJIQ4DQCAfBEAgCiAMKAIAIgEgKmoiCCARIAggEUgbQQAgCEEAThs2AgAgACABICdrIgggESAIIBFIG0EAIAhBAE4bNgIAIA4gASApaiIBIBEgASARSBtBACABQQBOGzYCACAOQQRqIQ4gCkEEaiEKIAxBBGohDCAAQQRqIQALAn8CfyAdRQRAIAchASAOIQsgCiEIQQAMAQtBACEZAkACQCAoDQAgCiAAICBqIgFJIAAgCiAgaiIISXENACAKIA4gIGoiC0kgCCAOS3ENACAKIAwgIGoiGkkgCCAMS3ENACAHIAhJIAogByAlaiIcSXENACACIAhJIAogAiAlaiIISXENACAAIAtJIAEgDktxDQAgACAaSSABIAxLcQ0AIAAgHEkgASAHS3ENACAAIAhJIAEgAktxDQAgDiAaSSALIAxLcQ0AIA4gHEkgByALSXENACACIAtJIAggDktxDQAgByAmaiEBIA4gHmohCyAKIB5qIQgDQCAMIBlBA3QiGkEYciIcaiIrIAwgGkEQciIVaiIsIAwgGkEIciISaiItIAwgGmoiLv0JAgD9VgIAAf1WAgAC/VYCAAMhPQJ/IAIgGUECdCIvav0AAgAgQ/2xAf36ASI+/V8iQP0MO99PjZdu9j8730+Nl272P/3yASJB/SEBIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyEwIAcgL2r9AAIAIUIgCiAaaiIv/QwAAAAAAAAAAAAAAAAAAAAAID0CfyBB/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0RIDD9HAECfyA+ID79DQgJCgsMDQ4PAAECAwABAgP9XyJB/Qw730+Nl272PzvfT42XbvY//fIBIj79IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwCAn8gPv0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAMiRP2uASI+ID/9tgEgPv0MAAAAAAAAAAAAAAAAAAAAAP05/VIiPv1aAgAAIAogEmoiMCA+/VoCAAEgCiAVaiIyID79WgIAAiAKIBxqIjMgPv1aAgADAn8gQiBD/bEB/foBIj79XyJC/QxqvHSTGATWP2q8dJMYBNY//fIBIED9DAwCK4cW2eY/DAIrhxbZ5j/98gH98AEiQP0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAshMSAAIBpqIjT9DAAAAAAAAAAAAAAAAAAAAAAgPQJ/IED9IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/REgMf0cAQJ/ID79DAAAAAAAAAAAAAAAAAAAAAD9DQgJCgsMDQ4PAAECAwABAgP9XyJA/QxqvHSTGATWP2q8dJMYBNY//fIBIEH9DAwCK4cW2eY/DAIrhxbZ5j/98gH98AEiPv0hACIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAICfyA+/SEBIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0cAyJB/bEBIj4gP/22ASA+/QwAAAAAAAAAAAAAAAAAAAAA/Tn9UiI+/VoCAAAgACASaiIxID79WgIAASAAIBVqIjUgPv1aAgACIAAgHGoiNiA+/VoCAAMCfyBC/QwnMQisHFr8PycxCKwcWvw//fIBIj79IQEiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLITcgDiAaaiIa/QwAAAAAAAAAAAAAAAAAAAAAID0CfyA+/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0RIDf9HAECfyBA/QwnMQisHFr8PycxCKwcWvw//fIBIj39IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwCAn8gPf0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAMiQP2uASI9ID/9tgEgPf0MAAAAAAAAAAAAAAAAAAAAAP05/VIiPf1aAgAAIA4gEmoiEiA9/VoCAAEgDiAVaiIVID39WgIAAiAOIBxqIhwgPf1aAgADIC/9DAAAAAAAAAAAAAAAAAAAAAAgK0EEaiAsQQRqIC1BBGogLv0JAgT9VgIAAf1WAgAC/VYCAAMiPiBE/a4BIj0gP/22ASA9/QwAAAAAAAAAAAAAAAAAAAAA/Tn9UiI9/VoCBAAgMCA9/VoCBAEgMiA9/VoCBAIgMyA9/VoCBAMgNP0MAAAAAAAAAAAAAAAAAAAAACA+IEH9sQEiPSA//bYBID39DAAAAAAAAAAAAAAAAAAAAAD9Of1SIj39WgIEACAxID39WgIEASA1ID39WgIEAiA2ID39WgIEAyAa/QwAAAAAAAAAAAAAAAAAAAAAID4gQP2uASI9ID/9tgEgPf0MAAAAAAAAAAAAAAAAAAAAAP05/VIiPf1aAgQAIBIgPf1aAgQBIBUgPf1aAgQCIBwgPf1aAgQDIBlBBGoiGSAbRw0ACyACICZqIQIgDCAeaiEMIAAgHmohACAQIRkgJCAbICNGDQIaDAELIAohCCAOIQsgByEBCwNAIAEoAgAhDiAIAn8gAigCACAUa7K7IgVEO99PjZdu9j+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyAMKAIAIgpqIgcgESAHIBFIG0EAIAdBAE4bNgIAIAAgCgJ/IA4gFGuyuyIGRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLayIHIBEgByARSBtBACAHQQBOGzYCACALAn8gBkQnMQisHFr8P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIApqIgogESAKIBFIG0EAIApBAE4bNgIAIAEoAgAhDiAIAn8gAigCACAUa7K7IgVEO99PjZdu9j+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyAMKAIEIgpqIgcgESAHIBFIG0EAIAdBAE4bNgIEIAAgCgJ/IA4gFGuyuyIGRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLayIHIBEgByARSBtBACAHQQBOGzYCBCALAn8gBkQnMQisHFr8P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIApqIgogESAKIBFIG0EAIApBAE4bNgIEIAJBBGohAiABQQRqIQEgC0EIaiELIABBCGohACAIQQhqIQggDEEIaiEMIBlBAmoiGSAdSQ0ACyAkCyAiTwRAIAEhByAIIQogCwwBCyABKAIAIQ4gCAJ/IAIoAgAgFGuyuyIFRDvfT42XbvY/oiIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAsgDCgCACIKaiIHIBEgByARSBtBACAHQQBOGzYCACAAIAoCfyAOIBRrsrsiBkRqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C2siByARIAcgEUgbQQAgB0EAThs2AgAgCwJ/IAZEJzEIrBxa/D+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyAKaiIKIBEgCiARSBtBACAKQQBOGzYCACACQQRqIQIgAUEEaiEHIABBBGohACAIQQRqIQogDEEEaiEMIAtBBGoLIQ4gE0EBaiITIBZHDQALCyANKAIYKAIsEBAgDSgCGCIAIA82AiwgACgCYBAQIA0oAhgiACAXNgJgIAAoApQBEBAgDSgCGCIAIAk2ApQBIAAgAP0AAgAiP/0LAmggACA//QsCNCANQQE2AhRBACEZDAYLIAEoAmhBAUcNACABKAIEQQFHDQAgASgCOEEBRw0AIAEoAmxBAUcNACABKAIYIQIgASgClAEhCCABKAJgIQwgASgCLCEAIAEoAgwgASgCCGwiF0ECdCIBEBghByABEBghDyABEBghDgJAIAdFDQAgD0UNACAORQ0AIBdFDQRBfyACdEF/cyEZQQEgAkEBa3QhESAXQQhJDQIgDyAHa0EQSQ0CIA4gB2tBEEkNAiAHIABrQRBJDQIgByAMa0EQSQ0CIAcgCGtBEEkNAiAOIA9rQRBJDQIgDyAAa0EQSQ0CIA8gDGtBEEkNAiAPIAhrQRBJDQIgDiAAa0EQSQ0CIA4gDGtBEEkNAiAOIAhrQRBJDQIgCCAXQXxxIgpBAnQiCWohCyAJIA5qIQEgByAJaiECIBn9ESE/IBH9ESE9A0ACfyAIIBNBAnQiEGr9AAIAID39sQH9+gEiPv1fIkD9DDvfT42XbvY/O99PjZdu9j/98gEiQf0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAshFCAMIBBq/QACACFCIAcgEGr9DAAAAAAAAAAAAAAAAAAAAAAgACAQav0AAgAiQwJ/IEH9IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/REgFP0cAQJ/ID4gPv0NCAkKCwwNDg8AAQIDAAECA/1fIj79DDvfT42XbvY/O99PjZdu9j/98gEiQf0hACIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAICfyBB/SEBIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0cA/2uASJBID/9tgEgQf0MAAAAAAAAAAAAAAAAAAAAAP05/VL9CwIAAn8gQiA9/bEB/foBIkH9XyJC/QxqvHSTGATWP2q8dJMYBNY//fIBIED9DAwCK4cW2eY/DAIrhxbZ5j/98gH98AEiQP0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAshFCAPIBBq/QwAAAAAAAAAAAAAAAAAAAAAIEMCfyBA/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0RIBT9HAECfyBB/QwAAAAAAAAAAAAAAAAAAAAA/Q0ICQoLDA0ODwABAgMAAQID/V8iQP0Marx0kxgE1j9qvHSTGATWP/3yASA+/QwMAiuHFtnmPwwCK4cW2eY//fIB/fABIj79IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwCAn8gPv0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAP9sQEiPiA//bYBID79DAAAAAAAAAAAAAAAAAAAAAD9Of1S/QsCAAJ/IEL9DCcxCKwcWvw/JzEIrBxa/D/98gEiPv0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAshFCAOIBBq/QwAAAAAAAAAAAAAAAAAAAAAIEMCfyA+/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0RIBT9HAECfyBA/QwnMQisHFr8PycxCKwcWvw//fIBIj79IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwCAn8gPv0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAP9rgEiPiA//bYBID79DAAAAAAAAAAAAAAAAAAAAAD9Of1S/QsCACATQQRqIhMgCkcNAAsgCiAXRg0EIAkgDGohDCAAIAlqIQAgCSAPagwDCyAHEBAgDxAQIA4QEAwFCyAYQbkDNgIEIBhBuAo2AgBB6MQBQcI+IBgQFgwECyAHIQIgDiEBIAghCyAPCyEIA0AgDCgCACETIAICfyALKAIAIBFrsrsiBUQ730+Nl272P6IiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLIAAoAgAiCWoiECAZIBAgGUgbQQAgEEEAThs2AgAgCCAJAn8gEyARa7K7IgZEarx0kxgE1j+iIAVEDAIrhxbZ5j+ioCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAtrIhAgGSAQIBlIG0EAIBBBAE4bNgIAIAECfyAGRCcxCKwcWvw/oiIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAsgCWoiCSAZIAkgGUgbQQAgCUEAThs2AgAgAUEEaiEBIAhBBGohCCACQQRqIQIgC0EEaiELIAxBBGohDCAAQQRqIQAgCkEBaiIKIBdHDQALCyANKAIYKAIsEBAgDSgCGCIAIAc2AiwgACgCYBAQIA0oAhgiACAPNgJgIAAoApQBEBAgDSgCGCAONgKUASANQQE2AhRBACEZDAELIA8QECAXEBAgCRAQCyAYKAIgIQACQCADDQAgIUUNACAAKAIYIQ5BACETA0AgDiATQTRsaiIDKAIYIgJBCEcEQAJAIAJBB00EQCADKAIMIAMoAghsIQEgAygCLCEKIAMoAiAEQCABRQ0CQQEgAkEBa3StIUVBACEHIAFBBE8EQCABQXxxIQcgRf0SIT9BACEMA0AgCiAMQQJ0aiICIAL9AAIAIj39xwFBB/3LASI+/R0AID/9HQAiRn/9EiA+/R0BID/9HQEiR3/9HgEgPSA//Q0ICQoLDA0ODwABAgMAAQID/ccBQQf9ywEiPf0dACBGf/0SID39HQEgR3/9HgH9DQABAgMICQoLEBESExgZGhv9CwIAIAxBBGoiDCAHRw0ACyABIAdGDQMLA0AgCiAHQQJ0aiICIAI0AgBCB4YgRX8+AgAgB0EBaiIHIAFHDQALDAILIAFFDQFBfyACdEF/c60hRUEAIQcgAUEETwRAIAFBfHEhByBF/RIhP0EAIQwDQCAKIAxBAnRqIgIgAv0AAgAiPf3JAf0M/wAAAAAAAAD/AAAAAAAAAP3VASI+/R0AID/9HQAiRoD9EiA+/R0BID/9HQEiR4D9HgEgPSA//Q0ICQoLDA0ODwABAgMAAQID/ckB/Qz/AAAAAAAAAP8AAAAAAAAA/dUBIj39HQAgRoD9EiA9/R0BIEeA/R4B/Q0AAQIDCAkKCxAREhMYGRob/QsCACAMQQRqIgwgB0cNAAsgASAHRg0CCwNAIAogB0ECdGoiAiACNQIAQv8BfiBFgD4CACAHQQFqIgcgAUcNAAsMAQsgAkEIayEKIAMoAgwgAygCCGwhASADKAIsIQggAygCIARAIAFFDQFBACEHIAFBBE8EQCABQXxxIQdBACECA0AgCCACQQJ0aiILIAv9AAIAIAr9rAH9CwIAIAJBBGoiAiAHRw0ACyABIAdGDQILA0AgCCAHQQJ0aiICIAIoAgAgCnU2AgAgB0EBaiIHIAFHDQALDAELIAFFDQBBACEHIAFBBE8EQCABQXxxIQdBACECA0AgCCACQQJ0aiILIAv9AAIAIAr9rQH9CwIAIAJBBGoiAiAHRw0ACyABIAdGDQELA0AgCCAHQQJ0aiICIAIoAgAgCnY2AgAgB0EBaiIHIAFHDQALCyADQQg2AhgLIBNBAWoiEyAhRw0ACwsgACgCDCAAKAIIbCEBAkAgGUUEQCAAKAIUQQJGBEAgACgCEEEBRgRAIAAoAhgoAiwgARAODAMLIARFDQIgACgCGCIAKAIsIAAoAmAgARAIDAILIAAoAhgiACgCLCAAKAJgIAAoApQBIAEQBwwBCwJAAkACQCAhQQFrDgQAAwECAwsgACgCGCgCLCABEAYMAgsgACgCGCIAKAIsIAAoAmAgACgClAEgARAFDAELIAAoAhgiACgCLCAAKAJgIAAoApQBIAAoAsgBIAEQBAsgGCgCIBAhQQAhDAsgGEHgwABqJAAgDAsIAEEIIAAQJQurAgICfgJ/Qn8hAyAALQBEQQhxRQRAIAAgACgCICIGNgIkAkACQAJAIAAgACgCMCIFBH8DQCAGIAUgACgCACAAKAIUEQAAIgVBf0YNAiAAIAAoAiQgBWoiBjYCJCAAIAAoAjAgBWsiBTYCMCAFDQALIAAoAiAFIAYLNgIkIAFCAFUNAUIAIQMMAgsgACAAKAJEQQhyNgJEIAJBBEGB9QBBABAPIABBADYCMCAAIAAoAkRBCHI2AkRCfw8LQgAhAwNAIAEgACgCACAAKAIYEQsAIgRCf1EEQCACQQRB8vQAQQAQDyAAIAAoAkRBCHI2AkQgACAAKQM4IAN8NwM4Qn8gAyADUBsPCyADIAR8IQMgASAEfSIBQgBVDQALCyAAIAApAzggA3w3AzgLIAMLIwEBfyABIAEoAgAgASgCCCIBIACnIgIgASACSRtqNgIEQQELPAICfwF+IAEoAgAgASgCCGoiAyABKAIEIgJGBEBCfw8LIAEgAiAAp2o2AgQgAyACa6wiBCAAIAAgBFUbC5gDAgJ+An8gACgCMCIFIAGnIgZPBEAgACAFIAZrNgIwIAAgACgCJCAGajYCJCAAIAApAzggAXw3AzggAQ8LIAAtAERBBHEEQCAAQQA2AjAgACAAKAIkIAVqNgIkIAAgBa0iASAAKQM4fDcDOCABQn8gBRsPCwJAIAVFBEAMAQsgAEEANgIwIAAgACgCIDYCJCABIAWtIgN9IQELIAFCAFUEQANAIAApAwggACkDOCABIAN8fFQEQCACQQRBm/UAQQAQDyAAQQA2AjAgACAAKAIgNgIkIAAgACkDOCADfCIDNwM4IAApAwgiASADfSEEIAEgACgCACAAKAIcEQoAIQUgACgCRCECIAAgBQR/IAAgATcDOCACQXtxBSACC0EEcjYCREJ/IAQgASADURsPCyABIAAoAgAgACgCGBELACIEQn9RBEAgAkEEQZv1AEEAEA8gACAAKAJEQQRyNgJEIAAgACkDOCADfDcDOEJ/IAMgA1AbDwsgAyAEfCEDIAEgBH0iAUIAVQ0ACwsgACAAKQM4IAN8NwM4IAMLmwEBBX9BASACKAIIIgcgB0EBTRshBCACKAIEIgMgAigCAGshBgNAIAQiBUEBdCEEIAUgBmsgAUkNAAsgBSAHRwRAIAUQFCIDRQRAQX8PCyACKAIAIgQEQCADIAQgBhASGiACKAIAEBALIAIgBTYCCCACIAM2AgAgAiADIAZqIgM2AgQLIAMgACABEBIaIAIgAigCBCABajYCBCABC0YBAn8gAigCACACKAIIaiIEIAIoAgQiA0YEQEF/DwsgACADIAQgA2siACABIAAgAUkbIgAQEhogAiACKAIEIABqNgIEIAALqgIBBH8jAEEQayIEJAACQCAAKAJ0DQAgAkEBTQRAIANBAUH7wgBBABAPDAELIAEgBEEMakECEBEgBCgCDCIGQf//A3EiB0UEQCADQQFBnMMAQQAQDwwBCyACIAdBBmxBAmpJBEAgA0EBQfvCAEEAEA8MAQsgBkEGbBAUIgNFDQAgAEEIEBQiAjYCdCACRQRAIAMQEAwBCyACIAM2AgAgAiAELwEMIgI7AQQgAkUEQEEBIQUMAQtBACECA0AgAUECaiAEQQxqIgVBAhARIAMgAkEGbGoiBiAEKAIMOwEAIAFBBGogBUECEBEgBiAEKAIMOwECIAFBBmoiASAFQQIQESAGIAQoAgw7AQRBASEFIAJBAWoiAiAAKAJ0LwEESQ0ACwsgBEEQaiQAIAUL8AEBBX8jAEEQayIEJAACfyAAKAJ4IgVFBEAgA0EBQc3CAEEAEA9BAAwBCyAFKAIMBEAgA0EBQdvVAEEAEA9BAAwBCyACIAUtABIiBUECdCIGSQRAIANBAUGswgBBABAPQQAMAQtBACAGEBQiAkUNABogBQRAQQAhAwNAIAEgBEEMaiIHQQIQESACIANBAnRqIgYgBCgCDDsBACABQQJqIAdBARARIAYgBCgCDDoAAiABQQNqIAdBARARIAYgBCgCDDoAAyABQQRqIQEgA0EBaiIDIAVHDQALCyAAKAJ4IAI2AgxBAQshCCAEQRBqJAAgCAvwAwEJfyMAQRBrIgUkAAJAIAJBA0kNACAAKAJ4DQAgASAFQQxqQQIQESAFLwEMIglBgQhrQf93TQRAIAUgCTYCACADQQFBtBogBRAPDAELIAFBAmogBUEMakEBEBEgBS8BDCIIRQRAIANBAUHUF0EAEA8MAQsgCEEDaiACSw0AIAggCWxBAnQQFCIHRQ0AIAgQFCIKRQRAIAcQEAwBCyAIEBQiC0UEQCAHEBAgChAQDAELQRQQFCIGRQRAIAcQECAKEBAgCxAQDAELIAFBA2ohAyAGIAo2AgggBiALNgIEIAYgCTsBECAGIAc2AgAgBSgCDCEMIAZBADYCDCAGIAw6ABIgACAGNgJ4A0AgAyAFQQxqQQEQESAEIApqIAUtAAxB/wBxQQFqOgAAIAQgC2ogBSgCDEGAAXFBB3Y6AAAgA0EBaiEDIARBAWoiBCAIRw0ACyAJRQRAQQEhBAwBC0EAIQYDQEEAIQRBACEAA0AgAkEEIAQgCmotAABBB2pBA3YiBCAEQQRPGyIEIAMgAWtqSARAQQAhBAwDCyADIAVBDGogBBARIAcgBSgCDDYCACAHQQRqIQcgAyAEaiEDIABBAWoiAEH//wNxIgQgCEkNAAtBASEEIAZBAWoiBkH//wNxIAlJDQALCyAFQRBqJAAgBAuYAQECfyMAQRBrIgUkACAAKAIYIgRB/wFHBEAgBSAENgIAIANBAkHkEyAFEA8LAkACQCACIAAoAhRGBEAgAg0BQQEhBAwCC0EAIQQgA0EBQbvsAEEAEA8MAQtBACECA0BBASEEIAEgACgCSCACQQxsakEIakEBEBEgAUEBaiEBIAJBAWoiAiAAKAIUSQ0ACwsgBUEQaiQAIAQLjgYBBn8jAEHQAGsiBCQAAkAgAkECTQRAIANBAUGb7ABBABAPDAELIAAtAHwEQCADQQRB7tIAQQAQD0EBIQYMAQtBASEGIAEgAEEoakEBEBEgAUEBaiAAQTRqQQEQESABQQJqIABBLGpBARARIAFBA2ohBQJAAkACQAJAAkAgACgCKCIHQQFrDgIAAQILIAJBBk0EQCAEIAI2AhAgA0EBQcDxACAEQRBqEA9BACEGDAULAkAgAkEHRg0AIAAoAjBBDkYNACAEIAI2AjAgA0ECQcDxACAEQTBqEA8LIAUgAEEwakEEEBEgACgCMEEORw0DQSQQFCIFRQRAQQAhBiADQQFBszxBABAPDAULIAVBDjYCACAEQQA2AkAgBEEANgI4IARBADYCSCAEQQA2AjwgBEEANgJEIARBADYCTEGw6pACIQYgBEGw6pACNgI0IAVBgIyVogQ2AgQCfyACQQdHBEAgAkEjRgRAIAFBB2ogBEHMAGpBBBARIAFBC2ogBEHIAGpBBBARIAFBD2ogBEHEAGpBBBARIAFBE2ogBEFAa0EEEBEgAUEXaiAEQTxqQQQQESABQRtqIARBOGpBBBARIAFBH2ogBEE0akEEEBEgBUEANgIEIAQoAjQhBiAEKAI4IQIgBCgCQCEDIAQoAjwhByAEKAJEIQggBCgCTCEJIAQoAkgMAgsgBCACNgIgIANBAkHk8QAgBEEgahAPC0EAIQJBACEDQQAhB0EACyEBIAUgBzYCGCAFIAg2AhAgBSAJNgIIIAUgBjYCICAFIAI2AhwgBSADNgIUIAUgATYCDCAAQQA2AnAgACAFNgJsDAMLIAAgAkEDayIBNgJwIABBASABEBMiAzYCbCADRQ0BIAJBA0wNAkEAIQIDQCAFIARBzABqQQEQESAAKAJsIAJqIAQoAkw6AAAgBUEBaiEFIAJBAWoiAiABRw0ACwwCCyAHQQNJDQIgBCAHNgIAIANBBEHb9wAgBBAPDAILQQAhBiAAQQA2AnAMAQtBASEGIABBAToAfAsgBEHQAGokACAGC7QDAQN/IwBBIGsiBCQAAkAgACgCSARAIANBAkGNNUEAEA9BASECDAELIAJBDkcEQEEAIQIgA0EBQfrrAEEAEA8MAQsgASAAQRBqQQQQESABQQRqIABBDGpBBBARIAFBCGogAEEUakECEBEgACgCDCEFAkAgBAJ/IAAoAhAiBkUEQCAAKAIUDAELIAAoAhQiAiAFRQ0AGiACDQFBAAs2AgggBCAGNgIEIAQgBTYCACADQQFB3uoAIAQQD0EAIQIMAQsgAkGBgAFrQf//fk0EQEEAIQIgA0EBQYjqAEEAEA8MAQsgACACQQwQEyICNgJIIAJFBEBBACECIANBAUGt6gBBABAPDAELQQEhAiABQQpqIABBGGpBARARIAFBC2ogAEEcakEBEBEgACgCHCIFQQdHBEAgBCAFNgIQIANBBEGd+gAgBEEQahAPCyABQQxqIABBIGpBARARIAFBDWogAEEkakEBEBEgACgCACIBIAEtALwBQfsBcSAAKAIYQf8BRkECdHI6ALwBIAAoAgAiASAAKAIMNgLYASABIAAoAhA2AtwBIABBAToAhQELIARBIGokACACC7oEAQZ/IwBBEGsiBiQAAn8gAC0AZEECcUUEQCADQQFBkdQAQQAQD0EADAELIABBADYCaAJAAkACQCACBEADQCACQQdNBEAgA0EBQbkZQQAQDwwFCyABIAZBDGoiBUEEEBEgBigCDCEEIAFBBGogBUEEEBFBCCEHIAYoAgwhBQJAAkACQAJAIAQOAgEAAwsgAkEQSQRAQeEZIQQMBwsgAUEIaiAGQQhqQQQQESAGKAIIBEBByj8hBAwHCyABQQxqIAZBDGpBBBARIAYoAgwiBA0BQbIYIQQMBgsgA0EBQbIYQQAQDwwGC0EQIQcLIAQgB0kEQCADQQFBhcUAQQAQDwwFCyACIARJBEAgA0EBQb3EAEEAEA9BAAwGCwJAAkAgACABIAdqIAQgB2sgAwJ/AkACQAJAIAVB8di9mwZMBEAgBUHjxsGTBkYNASAFQebKkZsGRg0DIAVB8MK1mwZHDQVB4MABDAQLIAVB8tiNgwdGDQFBwMABIAVB8sihywZGDQMaIAVB8ti9mwZHDQRByMABDAMLQdDAAQwCC0HYwAEMAQtB6MABCygCBBEBAA0BQQAMBwsgACAAKAJoQf////8HcjYCaAtBASAIIAVB8sihywZGGyEIIAEgBGohASACIARrIgINAAsgCA0BCyADQQFB2cMAQQAQD0EADAMLIABBAToAhAEgACAAKAJkQQRyNgJkQQEMAgsgA0EBIARBABAPCyADQQFBng5BABAPQQALIQkgBkEQaiQAIAkL4gEBAX8gACgCZEEBRwRAIANBAUG+1ABBABAPQQAPCwJAIAJBB00EQAwBCyABIABBOGpBBBARIAFBBGogAEE8akEEEBEgAkEDcQRADAELIAAgAkEIayICQQJ2IgQ2AkACQCACRQ0AIAAgBEEEEBMiAjYCRCACRQRAIANBAUGpEEEAEA9BAA8LIAAoAkBFDQAgAUEIaiEDQQAhAgNAIAMgACgCRCACQQJ0akEEEBEgA0EEaiEDIAJBAWoiAiAAKAJASQ0ACwsgACAAKAJkQQJyNgJkQQEPCyADQQFBqi1BABAPQQALxAEBAn8gACAAKAIgIgQ2AiQCQCAAKAIwIgMEQANAIAQgAyAAKAIAIAAoAhQRAAAiA0F/Rg0CIAAgACgCJCADaiIENgIkIAAgACgCMCADayIDNgIwIAMNAAsgACgCICEECyAAQQA2AjAgACAENgIkIAEgACgCACAAKAIcEQoARQRAIAAgACgCREEIcjYCREEADwsgACABNwM4QQEPCyAAIAAoAkRBCHI2AkQgAkEEQYH1AEEAEA8gACAAKAJEQQhyNgJEQQALggEBAn8jAEEQayIEJAACfyAAKAJkBEAgA0EBQdvTAEEAEA9BAAwBCyACQQRHBEAgA0EBQc4tQQAQD0EADAELIAEgBEEMakEEEBEgBCgCDEGKjqroAEcEQCADQQFB9iVBABAPQQAMAQsgACAAKAJkQQFyNgJkQQELIQUgBEEQaiQAIAULDQAgACgCACABIAIQRQsJACAAKAIAEEoLCQAgACgCABBJCw0AIAAoAgAgASACEEwLQQEBfyACBH8gA0ECQdvLAEEAEA8gACgCACABIAIgAyAEEEZFBEAgA0EBQakvQQAQD0EADwsgACACIAMQcQVBAAsLFQAgACgCACABIAIgAyAEIAUgBhBOCw8AIAAoAgAgASACIAMQTwsTACAAKAIAIAEgAiADIAQgBRArCx0AIAAoAgAgASACIAMgBCAFIAYgByAIIAkgChAnC+oEAQd/AkAgASgCCEE1IAMQJEUNACABKAIEIgcoAgAhBSAHKAIIIQQCQCAFBEBBASEGIAVBAUcEQCAFQX5xIQoDQAJ/QQAgBkUNABpBACABIAAgAyAEKAIAEQAARQ0AGiABIAAgAyAEKAIEEQAAQQBHCyEGIARBCGohBCAJQQJqIgkgCkcNAAsLAkAgBUEBcQRAIAZFDQEgASAAIAMgBCgCABEAAEEARyEGCyAHQQA2AgAgBkUNAwwCCyAHQQA2AgBBAA8LIAdBADYCAAsgASgCCCIHKAIAIQUgBygCCCEEAkACQAJ/AkAgBQRAQQEhBiAFQQFxIQggBUEBRw0BQQAMAgsgB0EANgIADAILIAVBfnEhBUEAIQkDQAJ/QQAgBkUNABpBACABIAAgAyAEKAIAEQAARQ0AGiABIAAgAyAEKAIEEQAAQQBHCyEGIARBCGohBCAJQQJqIgkgBUcNAAsgBkULIQUgCARAIAUNAiABIAAgAyAEKAIAEQAAQQBHIQYLIAdBADYCAEEAIQggBkUNAgsgAS0AhAFFBEAgA0EBQb3WAEEAEA9BAA8LIAEtAIUBRQRAIANBAUGg1gBBABAPQQAPCyAAIAEoAgAgAiADEFAhCCACRQ0BIAIoAgAiAEUNAUEBIQQCQAJAAkACQAJAAkAgASgCMEEMaw4NAwQEBAUAAQQEBAQEAgQLQQIhBAwEC0EDIQQMAwtBBCEEDAILQQUhBAwBC0F/IQQLIAAgBDYCFCABKAJsIgNFDQEgACADNgIcIAIoAgAgASgCcDYCICABQQA2AmwgCA8LIAdBADYCAEEAIQgLIAgL5AkCCn8BfiMAQfAAayIDJABBgAghCAJ/AkBBAUGACBATIgYEQCADQdwAaiELIANB7ABqIQkDQAJAAkACQCABIANB6ABqIgRBCCACEBpBCEcNACAEIANB2ABqQQQQESAJIAtBBBARQQghBQJAAkACQAJAAkAgAygCWA4CAAEECyABKQMIIg1QBH5CAAUgDSABKQM4fQsiDUL4////D1MNASACQQFByj9BABAPDAQLIAEgA0HoAGoiBEEIIAIQGkEIRw0DIAQgA0HkAGpBBBARIAMoAmRFDQEgAkEBQco/QQAQDwwDCyADIA2nQQhqNgJYDAELIAkgA0HYAGpBBBARQRAhBQsgAygCXCIEQePkwNMGRgRAIAAoAmQiAUEEcQRAIAAgAUEIcjYCZAwCCyACQQFBrStBABAPIAYQEEEADAcLIAMoAlgiB0UEQCACQQFBshhBABAPIAYQEEEADAcLIAUgB0sEQCADIAQ2AgQgAyAHNgIAIAJBAUH65wAgAxAPDAYLAkACfwJ/AkACfwJAAkACQAJAAkAgBEHx2L2bBkwEQCAEQePGwZMGRg0CIARB5sqRmwZGDQQgBEHwwrWbBkcNAUHgwAEMBgsgBEGfwMDSBkwEQCAEQfLYvZsGRg0FQcDAASAEQfLIocsGRg0GGiAEQfDy0bMGRw0BQajAAQwICyAEQfLYjYMHRg0CIARBoMDA0gZGDQZBsMABIARB6OTA0wZGDQcaCyAAKAJkIgRBAXENCCACQQFB/A5BABAPIAYQEEEADA8LQdDAAQwDC0HYwAEMAgtB6MABDAELQcjAAQshCiADIARB/wFxNgJMIAMgBEEYdjYCQCADIARBCHZB/wFxNgJIIAMgBEEQdkH/AXE2AkQgAkECQckOIANBQGsQDyAHIAVrIgUgAC0AZEEEcQ0CGiADIAMoAlwiBEEYdjYCMCADIARB/wFxNgI8IAMgBEEQdkH/AXE2AjQgAyAEQQh2Qf8BcTYCOCACQQJB2jMgA0EwahAPIAAgACgCZEH/////B3I2AmQgASAFrSINIAIgASgCKBEIACANUQ0HIAJBAUGSHEEAEA8gBhAQQQAMCgtBoMABCyEKIAcgBWsLIQUgASkDCCINUAR+QgAFIA0gASkDOH0LIAWtUwRAIAMoAlghBCADKAJcIQAgAyABKQMIIg1QBH5CAAUgDSABKQM4fQs+AiggAyAFNgIkIAMgAEH/AXE2AiAgAyAAQRh2NgIUIAMgBDYCECADIABBCHZB/wFxNgIcIAMgAEEQdkH/AXE2AhggAkEBQc31ACADQRBqEA8MBwsgBSAITQRAIAYhBAwECyAFIQggBiAFEBciBA0DIAYQECACQQFB/w9BABAPQQAMBwsgBEECcUUEQCACQQFBwg9BABAPIAYQEEEADAcLIAAgBEH/////B3I2AmQgASAHIAVrrSINIAIgASgCKBEIACANUQ0DIAAtAGRBCHFFDQEgAkECQZIcQQAQDwsgBhAQQQEMBQsgAkEBQZIcQQAQDyAGEBBBAAwECyABIAQgBSACEBogBUcEQCACQQFBxBxBABAPIAQQEEEADAQLIAAgBCIGIAUgAiAKKAIEEQEADQALIAQQEEEADAILIAJBAUGiJUEAEA9BAAwBCyAGEBBBAAshDCADQfAAaiQAIAwL5gEBBn8gACgCCEE1IAIQJARAAkAgACgCCCIGKAIAIQMgBigCCCEFAkACQAJ/AkAgAwRAQQEhBCADQQFxIQcgA0EBRw0BQQAMAgsgBkEANgIADAILIANBfnEhAwNAAn9BACAERQ0AGkEAIAAgASACIAUoAgARAABFDQAaIAAgASACIAUoAgQRAABBAEcLIQQgBUEIaiEFIAhBAmoiCCADRw0ACyAERQshAyAHBEAgAw0CIAAgASACIAUoAgARAABBAEchBAsgBkEANgIAIARFDQILIAAoAgAaQQEPCyAGQQA2AgALC0EACwoAIAAoAgAaQQALFAAgACgCACIABEAgACABNgK4AQsLIQAgACgCACABEFMgAEEAOgB8IAAgASgCuEBBAXE2AoABCzIAIAJFBEBBAA8LIAAoAgAgASACIAMQSEUEQCADQQFBqS9BABAPQQAPCyAAIAIgAxBxC2kCAn8BfCMAQRBrIgMkACACBEADQCAAIANBCGoQRCABAn8gAysDCCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAs2AgAgAUEEaiEBIABBCGohACAEQQFqIgQgAkcNAAsLIANBEGokAAuEAQICfwF9IwBBEGsiAyQAIAIEQANAIAMgAC0AADoADyADIAAtAAE6AA4gAyAALQACOgANIAMgAC0AAzoADCABAn8gAyoCDCIFi0MAAABPXQRAIAWoDAELQYCAgIB4CzYCACABQQRqIQEgAEEEaiEAIARBAWoiBCACRw0ACwsgA0EQaiQAC0sBAn8jAEEQayIDJAAgAgRAA0AgACADQQxqQQQQESABIAMoAgw2AgAgAUEEaiEBIABBBGohACAEQQFqIgQgAkcNAAsLIANBEGokAAtLAQJ/IwBBEGsiAyQAIAIEQANAIAAgA0EMakECEBEgASADKAIMNgIAIAFBBGohASAAQQJqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALSgECfyMAQRBrIgMkACACBEADQCAAIANBCGoQRCABIAMrAwi2OAIAIAFBBGohASAAQQhqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALaAECfyMAQRBrIgMkACACBEADQCADIAAtAAA6AA8gAyAALQABOgAOIAMgAC0AAjoADSADIAAtAAM6AAwgASADKgIMOAIAIAFBBGohASAAQQRqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALTAECfyMAQRBrIgMkACACBEADQCAAIANBDGpBBBARIAEgAygCDLM4AgAgAUEEaiEBIABBBGohACAEQQFqIgQgAkcNAAsLIANBEGokAAtMAQJ/IwBBEGsiAyQAIAIEQANAIAAgA0EMakECEBEgASADKAIMszgCACABQQRqIQEgAEECaiEAIARBAWoiBCACRw0ACwsgA0EQaiQAC6oIAg1/AXsjAEEQayIIJAACfyAAKAIIQRBGBEAgACgCnAEgACgCzAFBjCxsagwBCyAAKAIMCyEJAkAgAkUEQCADQQFB8B9BABAPDAELIAAoAkghBkEBIQQgASAIQQhqQQEQESAIKAIIIgVBAk8EQCADQQJBxsgAQQAQDwwBCyACIAVBAWpHBEBBACEEIANBAkHwH0EAEA8MAQsCQCAGKAIQIgNFDQAgCSgC0CshBCADQQhPBEAgA0F4cSEGQQAhAgNAIARBADYCvEMgBEEANgKEOyAEQQA2AswyIARBADYClCogBEEANgLcISAEQQA2AqQZIARBADYC7BAgBEEANgK0CCAEQcDDAGohBCACQQhqIgIgBkcNAAsLIANBB3EiA0UNAEEAIQIDQCAEQQA2ArQIIARBuAhqIQQgAkEBaiICIANHDQALCyAJKALoKyICBH8gAhAQIAlBADYC6CsgCCgCCAUgBQtFBEBBASEEDAELA0AgAUEBaiIBIAhBDGpBARARAkAgCSgCgCxF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KT0ALgAobnVsbCkAKCVkLCVkKSAAJXN9CgAJCSB9CgBbREVWXSBEdW1wIGFuIGltYWdlX2NvbXBfaGVhZGVyIHN0cnVjdCB7CgBbREVWXSBEdW1wIGFuIGltYWdlX2hlYWRlciBzdHJ1Y3QgewoASW1hZ2UgaW5mbyB7CgAJIGRlZmF1bHQgdGlsZSB7CgAlcwkgY29tcG9uZW50ICVkIHsKAAkJIGNvbXAgJWQgewoACSBUaWxlIGluZGV4OiB7CgAJIE1hcmtlciBsaXN0OiB7CgBDb2Rlc3RyZWFtIGluZGV4IGZyb20gbWFpbiBoZWFkZXI6IHsKAENvZGVzdHJlYW0gaW5mbyBmcm9tIG1haW4gaGVhZGVyOiB7CgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveAoARm91bmQgYSBtaXNwbGFjZWQgJyVjJWMlYyVjJyBib3ggb3V0c2lkZSBqcDJoIGJveAoATWFsZm9ybWVkIEpQMiBmaWxlIGZvcm1hdDogZmlyc3QgYm94IG11c3QgYmUgSlBFRyAyMDAwIHNpZ25hdHVyZSBib3gKAE1hbGZvcm1lZCBKUDIgZmlsZSBmb3JtYXQ6IHNlY29uZCBib3ggbXVzdCBiZSBmaWxlIHR5cGUgYm94CgBOb3QgZW5vdWdoIG1lbW9yeSB0byBoYW5kbGUganBlZzIwMDAgYm94CgBOb3QgZW5vdWdoIG1lbW9yeSB3aXRoIEZUWVAgQm94CgBBIG1hcmtlciBJRCB3YXMgZXhwZWN0ZWQgKDB4ZmYtLSkgaW5zdGVhZCBvZiAlLjh4CgAJCSBtY3Q9JXgKAAkJCSBjYmxrc3R5PSUjeAoACQkJIGNzdHk9JSN4CgAJCSBwcmc9JSN4CgBJbnRlZ2VyIG92ZXJmbG93CgAJIHRkeD0ldSwgdGR5PSV1CgAJIHR3PSV1LCB0aD0ldQoACSB0eDA9JXUsIHR5MD0ldQoASW52YWxpZCBjb21wb25lbnQgaW5kZXg6ICV1CgBTdHJlYW0gdG9vIHNob3J0CgBNYXJrZXIgaGFuZGxlciBmdW5jdGlvbiBmYWlsZWQgdG8gcmVhZCB0aGUgbWFya2VyIHNlZ21lbnQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjdXJyZW50IHByZWNpbmN0IGNvZGVibG9jayBlbGVtZW50CgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQKAEVycm9yIHJlYWRpbmcgU1FjZCBvciBTUWNjIGVsZW1lbnQKAEEgQlBDQyBoZWFkZXIgYm94IGlzIGF2YWlsYWJsZSBhbHRob3VnaCBCUEMgZ2l2ZW4gYnkgdGhlIElIRFIgYm94ICglZCkgaW5kaWNhdGUgY29tcG9uZW50cyBiaXQgZGVwdGggaXMgY29uc3RhbnQKAEVycm9yIHdpdGggU0laIG1hcmtlcjogaWxsZWdhbCB0aWxlIG9mZnNldAoASW52YWxpZCBwcmVjaW5jdAoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGJhbmQgcHJlY2ludHMKAEZhaWxlZCB0byBkZWNvZGUgYWxsIHVzZWQgY29tcG9uZW50cwoAU2l6ZSBvZiBjb2RlIGJsb2NrIGRhdGEgZXhjZWVkcyBzeXN0ZW0gbGltaXRzCgBTaXplIG9mIHRpbGUgZGF0YSBleGNlZWRzIHN5c3RlbSBsaW1pdHMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtdWx0aXBsZSBNQ1QgbWFya2VycwoAQ29ycnVwdGVkIFBQTSBtYXJrZXJzCgBOb3QgZW5vdWdoIG1lbW9yeSBmb3IgdGlsZSByZXNvbHV0aW9ucwoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIGNvbGxlY3Rpb25zCgBJbnZhbGlkIFBDTFIgYm94LiBSZXBvcnRzIDAgcGFsZXR0ZSBjb2x1bW5zCgBXZSBkbyBub3Qgc3VwcG9ydCBST0kgaW4gZGVjb2RpbmcgSFQgY29kZWJsb2NrcwoAQ2Fubm90IGhhbmRsZSBib3ggb2YgdW5kZWZpbmVkIHNpemVzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgd2l0aG91dCBzYW1lIG51bWJlciBvZiBpbmRpeGVzCgBJbnZhbGlkIHRpbGVjLT53aW5feHh4IHZhbHVlcwoAQ2Fubm90IGhhbmRsZSBib3ggb2YgbGVzcyB0aGFuIDggYnl0ZXMKAENhbm5vdCBoYW5kbGUgWEwgYm94IG9mIGxlc3MgdGhhbiAxNiBieXRlcwoAQ29tcG9uZW50IGluZGV4ICV1IHVzZWQgc2V2ZXJhbCB0aW1lcwoASW52YWxpZCBQQ0xSIGJveC4gUmVwb3J0cyAlZCBlbnRyaWVzCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBjcmVhdGUgVGFnLXRyZWUgbm9kZXMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtY3QgZGF0YSB3aXRoaW4gbXVsdGlwbGUgTUNUIHJlY29yZHMKAENhbm5vdCBkZWNvZGUgdGlsZSwgbWVtb3J5IGVycm9yCgBvcGpfajJrX2FwcGx5X25iX3RpbGVfcGFydHNfY29ycmVjdGlvbiBlcnJvcgoAUHJvYmxlbSB3aXRoIHNraXBwaW5nIEpQRUcyMDAwIGJveCwgc3RyZWFtIGVycm9yCgBQcm9ibGVtIHdpdGggcmVhZGluZyBKUEVHMjAwMCBib3gsIHN0cmVhbSBlcnJvcgoAVW5rbm93biBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCB0bCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCBtaCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHRha2UgaW4gY2hhcmdlIFNJWiBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUFBUIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBQUFQgbWFya2VyCgBFcnJvciByZWFkaW5nIFNPVCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUExUIG1hcmtlcgoARXJyb3IgcmVhZGluZyBNQ1QgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIE1DVCBtYXJrZXIKAE5vdCBlbm91Z2ggc3BhY2UgZm9yIGV4cGVjdGVkIFNPUCBtYXJrZXIKAEV4cGVjdGVkIFNPUCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgTUNPIG1hcmtlcgoARXJyb3IgcmVhZGluZyBSR04gbWFya2VyCgBFcnJvciByZWFkaW5nIFBQTSBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgUFBNIG1hcmtlcgoARXJyb3IgcmVhZGluZyBUTE0gbWFya2VyCgBFcnJvciByZWFkaW5nIFBMTSBtYXJrZXIKAE5vdCBlbm91Z2ggc3BhY2UgZm9yIGV4cGVjdGVkIEVQSCBtYXJrZXIKAEV4cGVjdGVkIEVQSCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgQ1JHIG1hcmtlcgoAVW5rbm93biBwcm9ncmVzc2lvbiBvcmRlciBpbiBDT0QgbWFya2VyCgBVbmtub3duIFNjb2QgdmFsdWUgaW4gQ09EIG1hcmtlcgoARXJyb3IgcmVhZGluZyBDT0QgbWFya2VyCgBFcnJvciByZWFkaW5nIFFDRCBtYXJrZXIKAENycm9yIHJlYWRpbmcgQ0JEIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQT0MgbWFya2VyCgBFcnJvciByZWFkaW5nIENPQyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUUNDIG1hcmtlcgoARXJyb3IgcmVhZGluZyBNQ0MgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIE1DQyBtYXJrZXIKAHJlcXVpcmVkIFNJWiBtYXJrZXIgbm90IGZvdW5kIGluIG1haW4gaGVhZGVyCgByZXF1aXJlZCBDT0QgbWFya2VyIG5vdCBmb3VuZCBpbiBtYWluIGhlYWRlcgoAcmVxdWlyZWQgUUNEIG1hcmtlciBub3QgZm91bmQgaW4gbWFpbiBoZWFkZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGhhbmRsZSBqcGVnMjAwMCBmaWxlIGhlYWRlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBoZWFkZXIKAEVycm9yIHdpdGggSlAgU2lnbmF0dXJlIDogYmFkIG1hZ2ljIG51bWJlcgoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgY3VycmVudCBudW1iZXIgb2YgdGlsZS1wYXJ0ICglZCksIGdpdmluZyB1cAoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgcHJldmlvdXMgbnVtYmVyIG9mIHRpbGUtcGFydCAoJWQpLCBnaXZpbmcgdXAKAEluIFNPVCBtYXJrZXIsIFRQU290ICglZCkgaXMgbm90IHZhbGlkIHJlZ2FyZHMgdG8gdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHRpbGUtcGFydCAoaGVhZGVyKSAoJWQpLCBnaXZpbmcgdXAKAHRpbGVzIHJlcXVpcmUgYXQgbGVhc3Qgb25lIHJlc29sdXRpb24KAE1hcmtlciBpcyBub3QgY29tcGxpYW50IHdpdGggaXRzIHBvc2l0aW9uCgBQcm9ibGVtIHdpdGggc2VlayBmdW5jdGlvbgoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50LCBJbnZhbGlkIGNibGt3L2NibGtoIGNvbWJpbmF0aW9uCgBJbnZhbGlkIG11bHRpcGxlIGNvbXBvbmVudCB0cmFuc2Zvcm1hdGlvbgoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIGNvbGxlY3Rpb25zIG90aGVyIHRoYW4gYXJyYXkgZGVjb3JyZWxhdGlvbgoAVG9vIGxhcmdlIHZhbHVlIGZvciBOcHBtCgBOb3QgZW5vdWdoIGJ5dGVzIHRvIHJlYWQgTnBwbQoAYmFkIHBsYWNlZCBqcGVnIGNvZGVzdHJlYW0KAAkgTWFpbiBoZWFkZXIgc3RhcnQgcG9zaXRpb249JWxsaQoJIE1haW4gaGVhZGVyIGVuZCBwb3NpdGlvbj0lbGxpCgBNYXJrZXIgc2l6ZSBpbmNvbnNpc3RlbnQgd2l0aCBzdHJlYW0gbGVuZ3RoCgBUaWxlIHBhcnQgbGVuZ3RoIHNpemUgaW5jb25zaXN0ZW50IHdpdGggc3RyZWFtIGxlbmd0aAoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIGRhdGEgc3Bhbm5pbmcKAFdyb25nIGZsYWcKAEVycm9yIHdpdGggRlRZUCBzaWduYXR1cmUgQm94IHNpemUKAEVycm9yIHdpdGggSlAgc2lnbmF0dXJlIEJveCBzaXplCgBJbnZhbGlkIHByZWNpbmN0IHNpemUKAEluY29uc2lzdGVudCBtYXJrZXIgc2l6ZQoASW52YWxpZCBtYXJrZXIgc2l6ZQoARXJyb3Igd2l0aCBTSVogbWFya2VyIHNpemUKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCBhIG5ldyB2YWxpZGF0aW9uIHByb2NlZHVyZQoATm90IGVub3VnaCBtZW1vcnkgdG8gZGVjb2RlIHRpbGUKAEZhaWxlZCB0byBkZWNvZGUgdGhlIGNvZGVzdHJlYW0gaW4gdGhlIEpQMiBmaWxlCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgd2l0aCBpbmRpeCBzaHVmZmxlCgBDYW5ub3QgYWxsb2NhdGUgVGllciAxIGhhbmRsZQoATm8gZGVjb2RlZCBhcmVhIHBhcmFtZXRlcnMsIHNldCB0aGUgZGVjb2RlZCBhcmVhIHRvIHRoZSB3aG9sZSBpbWFnZQoATm90IGVub3VnaCBtZW1vcnkgdG8gY3JlYXRlIFRhZy10cmVlCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWluaXRpYWxpemUgdGhlIHRhZyB0cmVlCgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQsIEludmFsaWQgdHJhbnNmb3JtYXRpb24gZm91bmQKAEVycm9yIHJlYWRpbmcgU1BDb2QgU1BDb2MgZWxlbWVudC4gVW5zdXBwb3J0ZWQgTWl4ZWQgSFQgY29kZS1ibG9jayBzdHlsZSBmb3VuZAoAVGlsZSBZIGNvb3JkaW5hdGVzIGFyZSBub3Qgc3VwcG9ydGVkCgBUaWxlIFggY29vcmRpbmF0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQKAEltYWdlIGNvb3JkaW5hdGVzIGFib3ZlIElOVF9NQVggYXJlIG5vdCBzdXBwb3J0ZWQKAEpQRUcyMDAwIEhlYWRlciBib3ggbm90IHJlYWQgeWV0LCAnJWMlYyVjJWMnIGJveCB3aWxsIGJlIGlnbm9yZWQKAG9wal9qMmtfbWVyZ2VfcHB0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgU09UIG1hcmtlci4gVGlsZSBpbmRleCBhbGxvY2F0aW9uIGZhaWxlZAoASWdub3JpbmcgaWhkciBib3guIEZpcnN0IGloZHIgYm94IGFscmVhZHkgcmVhZAoAWnBwdCAldSBhbHJlYWR5IHJlYWQKAFpwcG0gJXUgYWxyZWFkeSByZWFkCgBQVEVSTSBjaGVjayBmYWlsdXJlOiAlZCBzeW50aGV0aXplZCAweEZGIG1hcmtlcnMgcmVhZAoACQkJIGNibGt3PTJeJWQKAAkJCSBjYmxraD0yXiVkCgAJCQkgcW50c3R5PSVkCgAlcyBkeD0lZCwgZHk9JWQKAAkJCSByb2lzaGlmdD0lZAoACQkJIG51bWdiaXRzPSVkCgAJCSBudW1sYXllcnM9JWQKACVzIG51bWNvbXBzPSVkCgBvcGpfanAyX2FwcGx5X2NkZWY6IGFjbj0lZCwgbnVtY29tcHM9JWQKAG9wal9qcDJfYXBwbHlfY2RlZjogY249JWQsIG51bWNvbXBzPSVkCgAJCQkgbnVtcmVzb2x1dGlvbnM9JWQKAAkJIHR5cGU9JSN4LCBwb3M9JWxsaSwgbGVuPSVkCgAlcyBzZ25kPSVkCgAJCQkgcW1mYmlkPSVkCgAlcyBwcmVjPSVkCgAJCSBuYiBvZiB0aWxlLXBhcnQgaW4gdGlsZSBbJWRdPSVkCgAlcyB4MT0lZCwgeTE9JWQKACVzIHgwPSVkLCB5MD0lZAoARmFpbGVkIHRvIGRlY29kZSB0aWxlICVkLyVkCgBTZXR0aW5nIGRlY29kaW5nIGFyZWEgdG8gJWQsJWQsJWQsJWQKAEZhaWxlZCB0byBkZWNvZGUgY29tcG9uZW50ICVkCgBJbnZhbGlkIHZhbHVlIGZvciBudW1yZXNvbHV0aW9ucyA6ICVkLCBtYXggdmFsdWUgaXMgc2V0IGluIG9wZW5qcGVnLmggYXQgJWQKAEludmFsaWQgY29tcG9uZW50IG51bWJlcjogJWQsIHJlZ2FyZGluZyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgJWQKAFRvbyBtYW55IFBPQ3MgJWQKAEludmFsaWQgdGlsZSBudW1iZXIgJWQKAEludmFsaWQgdGlsZSBwYXJ0IGluZGV4IGZvciB0aWxlIG51bWJlciAlZC4gR290ICVkLCBleHBlY3RlZCAlZAoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBudW1iZXIgb2YgY29tcG9uZW50IGlzIGlsbGVnYWwgLT4gJWQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjaWVsYWIKAENhbm5vdCBhbGxvY2F0ZSBjYmxrLT5kZWNvZGVkX2RhdGEKAEZhaWxlZCB0byBtZXJnZSBQUFQgZGF0YQoARmFpbGVkIHRvIG1lcmdlIFBQTSBkYXRhCgBJbnZhbGlkIG51bWJlciBvZiBsYXllcnMgaW4gQ09EIG1hcmtlciA6ICVkIG5vdCBpbiByYW5nZSBbMS02NTUzNV0KACVzOiVkOmNvbG9yX2NteWtfdG9fcmdiCglDQU4gTk9UIENPTlZFUlQKACVzOiVkOmNvbG9yX2VzeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgAlczolZDpjb2xvcl9zeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgBTdHJlYW0gdG9vIHNob3J0LCBleHBlY3RlZCBTT1QKAFVuYWJsZSB0byBzZXQgdDEgaGFuZGxlIGFzIFRMUwoAU3RyZWFtIGRvZXMgbm90IGVuZCB3aXRoIEVPQwoAQ2Fubm90IGhhbmRsZSBib3ggc2l6ZXMgaGlnaGVyIHRoYW4gMl4zMgoAb3BqX3BpX25leHRfbHJjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcmxjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfY3BybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcGNybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcnBjbCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3QxX2RlY29kZV9jYmxrKCk6IHVuc3VwcG9ydGVkIGJwbm9fcGx1c19vbmUgPSAlZCA+PSAzMQoARmFpbGVkIHRvIGRlY29kZSB0aWxlIDEvMQoASW5zdWZmaWNpZW50IGRhdGEgZm9yIENNQVAgYm94LgoATmVlZCB0byByZWFkIGEgUENMUiBib3ggYmVmb3JlIHRoZSBDTUFQIGJveC4KAEluc3VmZmljaWVudCBkYXRhIGZvciBDREVGIGJveC4KAE51bWJlciBvZiBjaGFubmVsIGRlc2NyaXB0aW9uIGlzIGVxdWFsIHRvIHplcm8gaW4gQ0RFRiBib3guCgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveDogbm8gJ2loZHInIGJveC4KAE5vbiBjb25mb3JtYW50IGNvZGVzdHJlYW0gVFBzb3Q9PVROc290LgoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3g6IGJveCBsZW5ndGggaXMgaW5jb25zaXN0ZW50LgoAQm94IGxlbmd0aCBpcyBpbmNvbnNpc3RlbnQuCgBSZXNvbHV0aW9uIGZhY3RvciBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcmVzb2x1dGlvbiBpbiB0aGUgY29tcG9uZW50LgoAQ29tcG9uZW50IG1hcHBpbmcgc2VlbXMgd3JvbmcuIFRyeWluZyB0byBjb3JyZWN0LgoASW5jb21wbGV0ZSBjaGFubmVsIGRlZmluaXRpb25zLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW52YWxpZCBjb2RlYmxvY2sgbGVuZ3RoIHZhbHVlcy4KAFdlIGRvIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiAzIGNvZGluZyBwYXNzZXMgaW4gYW4gSFQgY29kZWJsb2NrOyBUaGlzIGNvZGVibG9ja3MgaGFzICVkIHBhc3Nlcy4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFRoZXJlIGFyZSAlZCB6ZXJvIGJpdHBsYW5lcyBpbiAlZCBiaXRwbGFuZXMuCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgdHJhbnNmb3JtYXRpb24gc3RhZ2VzLgoAVW5rbm93biBtYXJrZXIgaGFzIGJlZW4gZGV0ZWN0ZWQgYW5kIGdlbmVyYXRlZCBlcnJvci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfc2V0dXBfZGVjb2RlciBmdW5jdGlvbiBpcyBub3QgYSBkZWNvbXByZXNzb3IgaGFuZGxlci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfcmVhZF9oZWFkZXIgZnVuY3Rpb24gaXMgbm90IGEgZGVjb21wcmVzc29yIGhhbmRsZXIuCgBUaWxlcyBkb24ndCBhbGwgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24uIFNraXAgdGhlIE1DVCBzdGVwLgoATnVtYmVyIG9mIGNvbXBvbmVudHMgKCVkKSBpcyBpbmNvbnNpc3RlbnQgd2l0aCBhIE1DVC4gU2tpcCB0aGUgTUNUIHN0ZXAuCgBKUDIgYm94IHdoaWNoIGFyZSBhZnRlciB0aGUgY29kZXN0cmVhbSB3aWxsIG5vdCBiZSByZWFkIGJ5IHRoaXMgZnVuY3Rpb24uCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBXaGVuIHRoZSBudW1iZXIgb2YgemVybyBwbGFuZXMgYml0cGxhbmVzIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgYml0cGxhbmVzLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3MgbWFrZXMgc2Vuc2UsIGJ1dCB3ZSBoYXZlICVkIHBhc3NlcyBpbiB0aGlzIGNvZGVibG9jay4gVGhlcmVmb3JlLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3Mgd2lsbCBiZSBkZWNvZGVkLiBUaGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgZGlzcGxheWVkIGFnYWluLgoASW1hZ2UgaGFzIGxlc3MgY29tcG9uZW50cyB0aGFuIGNvZGVzdHJlYW0uCgBOZWVkIHRvIGRlY29kZSB0aGUgbWFpbiBoZWFkZXIgYmVmb3JlIGJlZ2luIHRvIGRlY29kZSB0aGUgcmVtYWluaW5nIGNvZGVzdHJlYW0uCgBQc290IHZhbHVlIG9mIHRoZSBjdXJyZW50IHRpbGUtcGFydCBpcyBlcXVhbCB0byB6ZXJvLCB3ZSBhc3N1bWluZyBpdCBpcyB0aGUgbGFzdCB0aWxlLXBhcnQgb2YgdGhlIGNvZGVzdHJlYW0uCgBBIG1hbGZvcm1lZCBjb2RlYmxvY2sgdGhhdCBoYXMgbW9yZSB0aGFuIG9uZSBjb2RpbmcgcGFzcywgYnV0IHplcm8gbGVuZ3RoIGZvciAybmQgYW5kIHBvdGVudGlhbGx5IHRoZSAzcmQgcGFzcyBpbiBhbiBIVCBjb2RlYmxvY2suCgAJCQkgdGlsZS1wYXJ0WyVkXTogc3Rhcl9wb3M9JWxsaSwgZW5kX2hlYWRlcj0lbGxpLCBlbmRfcG9zPSVsbGkuCgBUaWxlICV1IGhhcyBUUHNvdCA9PSAwIGFuZCBUTnNvdCA9PSAwLCBidXQgbm8gb3RoZXIgdGlsZS1wYXJ0cyB3ZXJlIGZvdW5kLiBFT0MgaXMgYWxzbyBtaXNzaW5nLgoAQ29tcG9uZW50ICVkIGRvZXNuJ3QgaGF2ZSBhIG1hcHBpbmcuCgBBIGNvbmZvcm1pbmcgSlAyIHJlYWRlciBzaGFsbCBpZ25vcmUgYWxsIENvbG91ciBTcGVjaWZpY2F0aW9uIGJveGVzIGFmdGVyIHRoZSBmaXJzdCwgc28gd2UgaWdub3JlIHRoaXMgb25lLgoAVGhlIHNpZ25hdHVyZSBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlICBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlIGZ0eXAgYm94IG11c3QgYmUgdGhlIHNlY29uZCBib3ggaW4gdGhlIGZpbGUuCgBGYWlsZWQgdG8gZGVjb2RlLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW5jb3JyZWN0IE1FTCBzZWdtZW50IHNlcXVlbmNlLgoAQ29tcG9uZW50ICVkIGlzIG1hcHBlZCB0d2ljZS4KAE9ubHkgb25lIENNQVAgYm94IGlzIGFsbG93ZWQuCgBXZSBuZWVkIGFuIGltYWdlIHByZXZpb3VzbHkgY3JlYXRlZC4KAElIRFIgYm94X21pc3NpbmcuIFJlcXVpcmVkLgoASlAySCBib3ggbWlzc2luZy4gUmVxdWlyZWQuCgBOb3Qgc3VyZSBob3cgdGhhdCBoYXBwZW5lZC4KAE1haW4gaGVhZGVyIGhhcyBiZWVuIGNvcnJlY3RseSBkZWNvZGVkLgoAVGlsZSAlZC8lZCBoYXMgYmVlbiBkZWNvZGVkLgoASGVhZGVyIG9mIHRpbGUgJWQgLyAlZCBoYXMgYmVlbiByZWFkLgoARW1wdHkgU09UIG1hcmtlciBkZXRlY3RlZDogUHNvdD0lZC4KAERpcmVjdCB1c2UgYXQgIyVkIGhvd2V2ZXIgcGNvbD0lZC4KAEltcGxlbWVudGF0aW9uIGxpbWl0YXRpb246IGZvciBwYWxldHRlIG1hcHBpbmcsIHBjb2xbJWRdIHNob3VsZCBiZSBlcXVhbCB0byAlZCwgYnV0IGlzIGVxdWFsIHRvICVkLgoASW52YWxpZCBjb21wb25lbnQvcGFsZXR0ZSBpbmRleCBmb3IgZGlyZWN0IG1hcHBpbmcgJWQuCgBJbnZhbGlkIHZhbHVlIGZvciBjbWFwWyVkXS5tdHlwID0gJWQuCgBQc290IHZhbHVlIGlzIG5vdCBjb3JyZWN0IHJlZ2FyZHMgdG8gdGhlIEpQRUcyMDAwIG5vcm06ICVkLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gVkxDIGNvZGUgcHJvZHVjZXMgc2lnbmlmaWNhbnQgc2FtcGxlcyBvdXRzaWRlIHRoZSBjb2RlYmxvY2sgYXJlYS4KAFVuZXhwZWN0ZWQgT09NLgoAMzIgYml0cyBhcmUgbm90IGVub3VnaCB0byBkZWNvZGUgdGhpcyBjb2RlYmxvY2ssIHNpbmNlIHRoZSBudW1iZXIgb2YgYml0cGxhbmUsICVkLCBpcyBsYXJnZXIgdGhhbiAzMC4KAEJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTE9JWQpIHNob3VsZCBiZSA+IDAuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIHNob3VsZCBiZSA+IDAuCgBVcCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTA9JWQpIHNob3VsZCBiZSA+PSAwLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIHNob3VsZCBiZSA+PSAwLgoARXJyb3IgcmVhZGluZyBQUFQgbWFya2VyOiBwYWNrZXQgaGVhZGVyIGhhdmUgYmVlbiBwcmV2aW91c2x5IGZvdW5kIGluIHRoZSBtYWluIGhlYWRlciAoUFBNIG1hcmtlcikuCgBTdGFydCB0byByZWFkIGoyayBtYWluIGhlYWRlciAoJWxsZCkuCgBCb3R0b20gcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kxPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZc2l6PSVkKS4KAFVwIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MD0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWXNpej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoAQm90dG9tIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWU9zaXo9JWQpLgoAVXAgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZT3Npej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhPc2l6PSVkKS4KAExlZnQgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3gwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChYT3Npej0lZCkuCgBTaXplIHggb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0udz0lZCkuCgBTaXplIHkgb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0uaD0lZCkuCgBUaWxlIHJlYWQsIGRlY29kZWQgYW5kIHVwZGF0ZWQgaXMgbm90IHRoZSBkZXNpcmVkIG9uZSAoJWQgdnMgJWQpLgoASW52YWxpZCBjb21wb25lbnQgaW5kZXggJWQgKD49ICVkKS4KAG9wal9yZWFkX2hlYWRlcigpIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIG9wal9zZXRfZGVjb2RlZF9jb21wb25lbnRzKCkuCgBNZW1vcnkgYWxsb2NhdGlvbiBmYWlsdXJlIGluIG9wal9qcDJfYXBwbHlfcGNscigpLgoAaW1hZ2UtPmNvbXBzWyVkXS5kYXRhID09IE5VTEwgaW4gb3BqX2pwMl9hcHBseV9wY2xyKCkuCgBpbnZhbGlkIGJveCBzaXplICVkICgleCkKAEZhaWwgdG8gcmVhZCB0aGUgY3VycmVudCBtYXJrZXIgc2VnbWVudCAoJSN4KQoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBJSERSIHcoJXUpIGgoJXUpIHZzLiBTSVogdygldSkgaCgldSkKAEVycm9yIHJlYWRpbmcgQ09DIG1hcmtlciAoYmFkIG51bWJlciBvZiBjb21wb25lbnRzKQoASW52YWxpZCBudW1iZXIgb2YgdGlsZXMgOiAldSB4ICV1IChtYXhpbXVtIGZpeGVkIGJ5IGpwZWcyMDAwIG5vcm0gaXMgNjU1MzUgdGlsZXMpCgBJbnZhbGlkIG51bWJlciBvZiBjb21wb25lbnRzIChpaGRyKQoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGltYWdlIGhlYWRlciAoaWhkcikKAFdyb25nIHZhbHVlcyBmb3I6IHcoJWQpIGgoJWQpIG51bWNvbXBzKCVkKSAoaWhkcikKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBkeD0ldSBkeT0ldSAoc2hvdWxkIGJlIGJldHdlZW4gMSBhbmQgMjU1IGFjY29yZGluZyB0byB0aGUgSlBFRzIwMDAgbm9ybSkKAEJhZCBpbWFnZSBoZWFkZXIgYm94IChiYWQgc2l6ZSkKAEJhZCBDT0xSIGhlYWRlciBib3ggKGJhZCBzaXplKQoAQmFkIEJQQ0MgaGVhZGVyIGJveCAoYmFkIHNpemUpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG5lZ2F0aXZlIG9yIHplcm8gaW1hZ2Ugc2l6ZSAoJWxsZCB4ICVsbGQpCgBza2lwOiBzZWdtZW50IHRvbyBsb25nICglZCkgd2l0aCBtYXggKCVkKSBmb3IgY29kZWJsb2NrICVkIChwPSVkLCBiPSVkLCByPSVkLCBjPSVkKQoAcmVhZDogc2VnbWVudCB0b28gbG9uZyAoJWQpIHdpdGggbWF4ICglZCkgZm9yIGNvZGVibG9jayAlZCAocD0lZCwgYj0lZCwgcj0lZCwgYz0lZCkKAERlc3BpdGUgSlAyIEJQQyE9MjU1LCBwcmVjaXNpb24gYW5kL29yIHNnbmQgdmFsdWVzIGZvciBjb21wWyVkXSBpcyBkaWZmZXJlbnQgdGhhbiBjb21wWzBdOgogICAgICAgIFswXSBwcmVjKCVkKSBzZ25kKCVkKSBbJWRdIHByZWMoJWQpIHNnbmQoJWQpCgBiYWQgY29tcG9uZW50IG51bWJlciBpbiBSR04gKCVkIHdoZW4gdGhlcmUgYXJlIG9ubHkgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG51bWJlciBvZiBjb21wb25lbnQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgcmVtYWluaW5nIG51bWJlciBvZiBwYXJhbWV0ZXJzICggJWQgdnMgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IGludmFsaWQgdGlsZSBzaXplICh0ZHg6ICVkLCB0ZHk6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoYmFkIHNpemU6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoQ0lFTGFiLCBiYWQgc2l6ZTogJWQpCgBQVEVSTSBjaGVjayBmYWlsdXJlOiAlZCByZW1haW5pbmcgYnl0ZXMgaW4gY29kZSBibG9jayAoJWQgdXNlZCAvICVkKQoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gT25lIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQ6IDIgPD0gU2N1cCA8PSBtaW4oTGN1cCwgNDA3OSkKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBwcmVjPSV1IChzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAzOCBhY2NvcmRpbmcgdG8gdGhlIEpQRUcyMDAwIG5vcm0uIE9wZW5KcGVnIG9ubHkgc3VwcG9ydHMgdXAgdG8gMzEpCgBJbnZhbGlkIGJpdCBudW1iZXIgJWQgaW4gb3BqX3QyX3JlYWRfcGFja2V0X2hlYWRlcigpCgBTdHJlYW0gZXJyb3IhCgBFcnJvciBvbiB3cml0aW5nIHN0cmVhbSEKAFN0cmVhbSByZWFjaGVkIGl0cyBlbmQgIQoARXhwZWN0ZWQgYSBTT0MgbWFya2VyIAoASW52YWxpZCBib3ggc2l6ZSAlZCBmb3IgYm94ICclYyVjJWMlYycuIE5lZWQgJWQgYnl0ZXMsICVkIGJ5dGVzIHJlbWFpbmluZyAKAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFVfcSBpcyBsYXJnZXIgdGhhbiB6ZXJvIGJpdHBsYW5lcyArIDEgCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBEZWNvZGluZyB0aGlzIGNvZGVibG9jayBpcyBzdG9wcGVkLiBVX3EgaXNsYXJnZXIgdGhhbiBiaXRwbGFuZXMgKyAxIAoAQ09MUiBCT1ggbWV0aCB2YWx1ZSBpcyBub3QgYSByZWd1bGFyIHZhbHVlICglZCksIHNvIHdlIHdpbGwgaWdub3JlIHRoZSBlbnRpcmUgQ29sb3VyIFNwZWNpZmljYXRpb24gYm94LiAKAFdoaWxlIHJlYWRpbmcgQ0NQX1FOVFNUWSBlbGVtZW50IGluc2lkZSBRQ0Qgb3IgUUNDIG1hcmtlciBzZWdtZW50LCBudW1iZXIgb2Ygc3ViYmFuZHMgKCVkKSBpcyBncmVhdGVyIHRvIE9QSl9KMktfTUFYQkFORFMgKCVkKS4gU28gd2UgbGltaXQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzdG9yZWQgdG8gT1BKX0oyS19NQVhCQU5EUyAoJWQpIGFuZCBza2lwIHRoZSByZXN0LiAKAEpQMiBJSERSIGJveDogY29tcHJlc3Npb24gdHlwZSBpbmRpY2F0ZSB0aGF0IHRoZSBmaWxlIGlzIG5vdCBhIGNvbmZvcm1pbmcgSlAyIGZpbGUgKCVkKSAKAFRpbGUgaW5kZXggcHJvdmlkZWQgYnkgdGhlIHVzZXIgaXMgaW5jb3JyZWN0ICVkIChtYXggPSAlZCkgCgBFcnJvciBkZWNvZGluZyBjb21wb25lbnQgJWQuClRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgdG8gcmVtb3ZlICglZCkgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgb2YgdGhpcyBjb21wb25lbnQg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AAABVAAAAQAAAABQAADAUAAAAUgAAAAAAAAQUAAAsFAAAAFIAAABAAAAIFAAAMBQAAABOAAAAAAAADBQAACwUAAAATgAAAEAAABAUAAAwFAAAAEwAAAAAAAAUFAAABBRAAABMAAAAQAAAGBQAAAgUQAAASQAAAAAAABwUAAAMFEAAAEkAAABAAAAgFAAAEBRAAABHAAAAAAAAJBQAABwUQAAARwAAAEAAACgUAAAgFEAAAEWAAAAAAAAkFIAAJBRAAABFgAAAQAAAKBSAACgUQAAAVYAAAAAAADQUAAAwFAAAAFWAAABAAAA4FAAALBQAAABVAAAAAAAAPBQAACwUAAAAVQAAAEAAAAAUQAAwFAAAAFRAAAAAAAAEFEAANBQAAABUQAAAQAAACBRAADgUAAAAUgAAAAAAAAwUQAA8FAAAAFIAAABAAAAQFEAAABRAAABOAAAAAAAAFBRAAAQUQAAATgAAAEAAABgUQAAIFEAAAE0AAAAAAAAcFEAADBRAAABNAAAAQAAAIBRAABAUQAAATAAAAAAAACQUQAAUFEAAAEwAAABAAAAoFEAAGBRAAABKAAAAAAAALBRAABQUQAAASgAAAEAAADAUQAAYFEAAAEkAAAAAAAA0FEAAHBRAAABJAAAAQAAAOBRAACAUQAAASIAAAAAAADwUQAAkFEAAAEiAAABAAAAAFIAAKBRAAABHAAAAAAAABBSAACwUQAAARwAAAEAAAAgUgAAwFEAAAEYAAAAAAAAMFIAANBRAAABGAAAAQAAAEBSAADgUQAAARYAAAAAAABQUgAA8FEAAAEWAAABAAAAYFIAAABSAAABFAAAAAAAAHBSAAAQUgAAARQAAAEAAACAUgAAIFIAAAESAAAAAAAAkFIAADBSAAABEgAAAQAAAKBSAABAUgAAAREAAAAAAACwUgAAUFIAAAERAAABAAAAwFIAAGBSAADBCgAAAAAAANBSAABwUgAAwQoAAAEAAADgUgAAgFIAAMEJAAAAAAAA8FIAAJBSAADBCQAAAQAAAABTAACgUgAAoQgAAAAAAAAQUwAAsFIAAKEIAAABAAAAIFMAAMBSAAAhBQAAAAAAADBTAADQUgAAIQUAAAEAAABAUwAA4FIAAEEEAAAAAAAAUFMAAPBSAABBBAAAAQAAAGBTAAAAUwAAoQIAAAAAAABwUwAAEFMAAKECAAABAAAAgFMAACBTAAAhAgAAAAAAAJBTAAAwUwAAIQIAAAEAAACgUwAAQFMAAEEBAAAAAAAAsFMAAFBTAABBAQAAAQAAAMBTAABgUwAAEQEAAAAAAADQUwAAcFMAABEBAAABAAAA4FMAAIBTAACFAAAAAAAAAPBTAACQUwAAhQAAAAEAAAAAVAAAoFMAAEkAAAAAAAAAEFQAALBTAABJAAAAAQAAACBUAADAUwAAJQAAAAAAAAAwVAAA0FMAACUAAAABAAAAQFQAAOBTAAAVAAAAAAAAAFBUAADwUwAAFQAAAAEAAABgVAAAAFQAAAkAAAAAAAAAcFQAABBUAAAJAAAAAQAAAIBUAAAgVAAABQAAAAAAAACQVAAAMFQAAAUAAAABAAAAoFQAAEBUAAABAAAAAAAAAJBUAABQVAAAAQAAAAEAAACgVAAAYFQAAAFWAAAAAAAAsFQAALBUAAABVgAAAQAAAMBUAADAVAAAAAEDAwECAwMFBgcHBgYHBwABAwMBAgMDBQYHBwYGBwcFBgcHBgYHBwgICAgICAgIBQYHBwYGBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgCAgMDAgIDAwYGBwcGBgcHAgIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgAAQUGAQIGBgMDBwcDAwcHAAEFBgECBgYDAwcHAwMHBwMDBwcDAwcHBAQHBwQEBwcDAwcHAwMHBwQEBwcEBAcHAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwUGCAgGBggIBwcICAcHCAgFBggIBgYICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwICBgYCAgYGAwMHBwMDBwcCAgYGAgIGBgMDBwcDAwcHAwMHBwMDBwcEBAcHBAQHBwMDBwcDAwcHBAQHBwQEBwcGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAABAwMBAgMDBQYHBwYGBwcAAQMDAQIDAwUGBwcGBgcHBQYHBwYGBwcICAgICAgICAUGBwcGBgcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAgIDAwICAwMGBgcHBgYHBwICAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAAMBBAMGBAcBBAIFBAcFBwADAQQDBgQHAQQCBQQHBQcBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwIFAgUFBwUHAgUCBQUHBQcCBQIFBQcFBwIFAgUFBwUHBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgGCAcICAgICAcIBwgICAgIBggHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgJCQoKCQkKCgwMDQsMDA0LCQkKCgkJCgoMDAsNDAwLDQwMDQ0MDAsLDAkNCgkMCgsMDAsLDAwNDQwJCwoJDAoNCQkKCgkJCgoMDA0LDAwNCwkJCgoJCQoKDAwLDQwMCw0MDA0NDAwLCwwJDQoJDAoLDAwLCwwMDQ0MCQsKCQwKDQoKCgoKCgoKDQsNCw0LDQsKCgkJCgoJCQ0LDAwNCwwMDQ0NDQsLCwsNCg0KCgsKCw0NDAwLCwwMDQoMCQoLCQwKCgkJCgoJCQsNDAwLDQwMCgoKCgoKCgoLDQsNCw0LDQsLDAwNDQwMCwoMCQoNCQwLCwsLDQ0NDQsKCwoKDQoNAEHZuwELNwEAAQABAAEAAAEBAAABAQABAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAQABAQEAQZm8AQs3AQABAAEAAQAAAQEAAAEBAAEAAQABAAEAAAAAAQEBAQAAAAAAAQABAAAAAAEBAQEAAAABAAEBAQBB2bwBCwcBAAEAAQABAEHpvAELlQIBAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAAABAAEBAQAAAQEAAAABAAEAAQABAQEBAQEBAQEAAQABAAEAAQAAAAABAQEBAAEAAAEBAAEAAAAAAQEBAQABAAEBAQEBAgAAAAQAAAAEAAAACAAAAJD/AAAMAAAAGAAAAFL/AAAUAAAAGQAAAFP/AAAUAAAAGgAAAF7/AAAUAAAAGwAAAFz/AAAUAAAAHAAAAF3/AAAUAAAAHQAAAF//AAAUAAAAHgAAAFH/AAACAAAAHwAAAFX/AAAEAAAAIAAAAFf/AAAEAAAAIQAAAFj/AAAQAAAAIgAAAGD/AAAEAAAAIwAAAGH/AAAQAAAAJAAAAJH/AEGIvwELZWP/AAAEAAAAJQAAAGT/AAAUAAAAJgAAAHT/AAAUAAAAJwAAAHj/AAAEAAAAKAAAAFD/AAAEAAAAKQAAAFn/AAAEAAAAKgAAAHX/AAAUAAAAKwAAAHf/AAAUAAAALAAAAAAAAAAUAEGAwAELNS0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAAICBQajYAAABweXRmNwAAAGgycGo4AEHAwAELMnJkaGk5AAAAcmxvYzoAAABjY3BiOwAAAHJsY3A8AAAAcGFtYz0AAABmZWRjPgAAAPhiAEGAwQELQRkACwAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQAKChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHRwQELIQ4AAAAAAAAAABkACw0ZGRkADQAAAgAJDgAAAAkADgAADgBBi8IBCwEMAEGXwgELFRMAAAAAEwAAAAAJDAAAAAAADAAADABBxcIBCwEQAEHRwgELFQ8AAAAEDwAAAAAJEAAAAAAAEAAAEABB/8IBCwESAEGLwwELHhEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgBBwsMBCw4aAAAAGhoaAAAAAAAACQBB88MBCwEUAEH/wwELFRcAAAAAFwAAAAAJFAAAAAAAFAAAFABBrcQBCwEWAEG5xAELJxUAAAAAFQAAAAAJFgAAAAAAFgAAFgAAMDEyMzQ1Njc4OUFCQ0RFRgBB4MQBCwmQbAEAAAAAAAUAQfTEAQsBaQBBjMUBCwpqAAAAawAAAHhoAEGkxQELAQIAQbTFAQsI//////////8AQfjFAQsBBQBBhMYBCwFsAEGcxgELDmoAAABtAAAAiGgAAAAEAEG0xgELAQEAQcTGAQsF/////wo=");
    return receiveInstance(instantiateSync(u2, e3)[0]);
  }();
  N2.q, a2._malloc = N2.r, a2._free = N2.s, a2._jp2_decode = N2.u;
  w2 = function runCaller() {
    b2 || run();
    b2 || (w2 = runCaller);
  };
  function run() {
    if (!(m2 > 0)) {
      !function preRun() {
        if (a2.preRun) {
          "function" == typeof a2.preRun && (a2.preRun = [a2.preRun]);
          for (; a2.preRun.length; )
            e3 = a2.preRun.shift(), d2.unshift(e3);
        }
        var e3;
        callRuntimeCallbacks(d2);
      }();
      if (!(m2 > 0))
        if (a2.setStatus) {
          a2.setStatus("Running...");
          setTimeout(function() {
            setTimeout(function() {
              a2.setStatus("");
            }, 1);
            doRun();
          }, 1);
        } else
          doRun();
    }
    function doRun() {
      if (!b2) {
        b2 = true;
        a2.calledRun = true;
        !function initRuntime() {
          callRuntimeCallbacks(f2);
        }();
        t2(a2);
        a2.onRuntimeInitialized && a2.onRuntimeInitialized();
        !function postRun() {
          if (a2.postRun) {
            "function" == typeof a2.postRun && (a2.postRun = [a2.postRun]);
            for (; a2.postRun.length; )
              e3 = a2.postRun.shift(), p2.unshift(e3);
          }
          var e3;
          callRuntimeCallbacks(p2);
        }();
      }
    }
  }
  if (a2.preInit) {
    "function" == typeof a2.preInit && (a2.preInit = [a2.preInit]);
    for (; a2.preInit.length > 0; )
      a2.preInit.pop()();
  }
  run();
  return a2;
});
var hi = Ci;
var JpxError = class extends ot {
  constructor(e2) {
    super(e2, "JpxError");
  }
};
var _y;
var JpxImage = class {
  static decode(e2, t2) {
    t2 || (t2 = {});
    __privateGet(this, _y) || __privateSet(this, _y, hi({ warn }));
    const i2 = __privateGet(this, _y).decode(e2, t2);
    if ("string" == typeof i2)
      throw new JpxError(i2);
    return i2;
  }
  static cleanup() {
    __privateSet(this, _y, null);
  }
  static parseImageProperties(e2) {
    let t2 = e2.getByte();
    for (; t2 >= 0; ) {
      const i2 = t2;
      t2 = e2.getByte();
      if (65361 === (i2 << 8 | t2)) {
        e2.skip(4);
        const t3 = e2.getInt32() >>> 0, i3 = e2.getInt32() >>> 0, a2 = e2.getInt32() >>> 0, s2 = e2.getInt32() >>> 0;
        e2.skip(16);
        return { width: t3 - a2, height: i3 - s2, bitsPerComponent: 8, componentsCount: e2.getUint16() };
      }
    }
    throw new JpxError("No size marker found in JPX stream");
  }
};
_y = new WeakMap();
__privateAdd(JpxImage, _y, null);
var JpxStream = class extends DecodeStream {
  constructor(e2, t2, i2) {
    super(t2);
    this.stream = e2;
    this.dict = e2.dict;
    this.maybeLength = t2;
    this.params = i2;
  }
  get bytes() {
    return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(e2) {
  }
  readBlock(e2) {
    this.decodeImage(null, e2);
  }
  decodeImage(e2, t2) {
    if (this.eof)
      return this.buffer;
    e2 || (e2 = this.bytes);
    this.buffer = JpxImage.decode(e2, t2);
    this.bufferLength = this.buffer.length;
    this.eof = true;
    return this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
};
var LZWStream = class extends DecodeStream {
  constructor(e2, t2, i2) {
    super(t2);
    this.str = e2;
    this.dict = e2.dict;
    this.cachedData = 0;
    this.bitsCached = 0;
    const a2 = 4096, s2 = { earlyChange: i2, codeLength: 9, nextCode: 258, dictionaryValues: new Uint8Array(a2), dictionaryLengths: new Uint16Array(a2), dictionaryPrevCodes: new Uint16Array(a2), currentSequence: new Uint8Array(a2), currentSequenceLength: 0 };
    for (let e3 = 0; e3 < 256; ++e3) {
      s2.dictionaryValues[e3] = e3;
      s2.dictionaryLengths[e3] = 1;
    }
    this.lzwState = s2;
  }
  readBits(e2) {
    let t2 = this.bitsCached, i2 = this.cachedData;
    for (; t2 < e2; ) {
      const e3 = this.str.getByte();
      if (-1 === e3) {
        this.eof = true;
        return null;
      }
      i2 = i2 << 8 | e3;
      t2 += 8;
    }
    this.bitsCached = t2 -= e2;
    this.cachedData = i2;
    this.lastCode = null;
    return i2 >>> t2 & (1 << e2) - 1;
  }
  readBlock() {
    let e2, t2, i2, a2 = 1024;
    const s2 = this.lzwState;
    if (!s2)
      return;
    const r2 = s2.earlyChange;
    let n2 = s2.nextCode;
    const g2 = s2.dictionaryValues, o2 = s2.dictionaryLengths, c2 = s2.dictionaryPrevCodes;
    let C2 = s2.codeLength, h2 = s2.prevCode;
    const l2 = s2.currentSequence;
    let Q2 = s2.currentSequenceLength, E2 = 0, u2 = this.bufferLength, d2 = this.ensureBuffer(this.bufferLength + a2);
    for (e2 = 0; e2 < 512; e2++) {
      const e3 = this.readBits(C2), s3 = Q2 > 0;
      if (e3 < 256) {
        l2[0] = e3;
        Q2 = 1;
      } else {
        if (!(e3 >= 258)) {
          if (256 === e3) {
            C2 = 9;
            n2 = 258;
            Q2 = 0;
            continue;
          }
          this.eof = true;
          delete this.lzwState;
          break;
        }
        if (e3 < n2) {
          Q2 = o2[e3];
          for (t2 = Q2 - 1, i2 = e3; t2 >= 0; t2--) {
            l2[t2] = g2[i2];
            i2 = c2[i2];
          }
        } else
          l2[Q2++] = l2[0];
      }
      if (s3) {
        c2[n2] = h2;
        o2[n2] = o2[h2] + 1;
        g2[n2] = l2[0];
        n2++;
        C2 = n2 + r2 & n2 + r2 - 1 ? C2 : 0 | Math.min(Math.log(n2 + r2) / 0.6931471805599453 + 1, 12);
      }
      h2 = e3;
      E2 += Q2;
      if (a2 < E2) {
        do {
          a2 += 512;
        } while (a2 < E2);
        d2 = this.ensureBuffer(this.bufferLength + a2);
      }
      for (t2 = 0; t2 < Q2; t2++)
        d2[u2++] = l2[t2];
    }
    s2.nextCode = n2;
    s2.codeLength = C2;
    s2.prevCode = h2;
    s2.currentSequenceLength = Q2;
    this.bufferLength = u2;
  }
};
var PredictorStream = class extends DecodeStream {
  constructor(e2, t2, i2) {
    super(t2);
    if (!(i2 instanceof Dict))
      return e2;
    const a2 = this.predictor = i2.get("Predictor") || 1;
    if (a2 <= 1)
      return e2;
    if (2 !== a2 && (a2 < 10 || a2 > 15))
      throw new FormatError(`Unsupported predictor: ${a2}`);
    this.readBlock = 2 === a2 ? this.readBlockTiff : this.readBlockPng;
    this.str = e2;
    this.dict = e2.dict;
    const s2 = this.colors = i2.get("Colors") || 1, r2 = this.bits = i2.get("BPC", "BitsPerComponent") || 8, n2 = this.columns = i2.get("Columns") || 1;
    this.pixBytes = s2 * r2 + 7 >> 3;
    this.rowBytes = n2 * s2 * r2 + 7 >> 3;
    return this;
  }
  readBlockTiff() {
    const e2 = this.rowBytes, t2 = this.bufferLength, i2 = this.ensureBuffer(t2 + e2), a2 = this.bits, s2 = this.colors, r2 = this.str.getBytes(e2);
    this.eof = !r2.length;
    if (this.eof)
      return;
    let n2, g2 = 0, o2 = 0, c2 = 0, C2 = 0, h2 = t2;
    if (1 === a2 && 1 === s2)
      for (n2 = 0; n2 < e2; ++n2) {
        let e3 = r2[n2] ^ g2;
        e3 ^= e3 >> 1;
        e3 ^= e3 >> 2;
        e3 ^= e3 >> 4;
        g2 = (1 & e3) << 7;
        i2[h2++] = e3;
      }
    else if (8 === a2) {
      for (n2 = 0; n2 < s2; ++n2)
        i2[h2++] = r2[n2];
      for (; n2 < e2; ++n2) {
        i2[h2] = i2[h2 - s2] + r2[n2];
        h2++;
      }
    } else if (16 === a2) {
      const t3 = 2 * s2;
      for (n2 = 0; n2 < t3; ++n2)
        i2[h2++] = r2[n2];
      for (; n2 < e2; n2 += 2) {
        const e3 = ((255 & r2[n2]) << 8) + (255 & r2[n2 + 1]) + ((255 & i2[h2 - t3]) << 8) + (255 & i2[h2 - t3 + 1]);
        i2[h2++] = e3 >> 8 & 255;
        i2[h2++] = 255 & e3;
      }
    } else {
      const e3 = new Uint8Array(s2 + 1), h3 = (1 << a2) - 1;
      let l2 = 0, Q2 = t2;
      const E2 = this.columns;
      for (n2 = 0; n2 < E2; ++n2)
        for (let t3 = 0; t3 < s2; ++t3) {
          if (c2 < a2) {
            g2 = g2 << 8 | 255 & r2[l2++];
            c2 += 8;
          }
          e3[t3] = e3[t3] + (g2 >> c2 - a2) & h3;
          c2 -= a2;
          o2 = o2 << a2 | e3[t3];
          C2 += a2;
          if (C2 >= 8) {
            i2[Q2++] = o2 >> C2 - 8 & 255;
            C2 -= 8;
          }
        }
      C2 > 0 && (i2[Q2++] = (o2 << 8 - C2) + (g2 & (1 << 8 - C2) - 1));
    }
    this.bufferLength += e2;
  }
  readBlockPng() {
    const e2 = this.rowBytes, t2 = this.pixBytes, i2 = this.str.getByte(), a2 = this.str.getBytes(e2);
    this.eof = !a2.length;
    if (this.eof)
      return;
    const s2 = this.bufferLength, r2 = this.ensureBuffer(s2 + e2);
    let n2 = r2.subarray(s2 - e2, s2);
    0 === n2.length && (n2 = new Uint8Array(e2));
    let g2, o2, c2, C2 = s2;
    switch (i2) {
      case 0:
        for (g2 = 0; g2 < e2; ++g2)
          r2[C2++] = a2[g2];
        break;
      case 1:
        for (g2 = 0; g2 < t2; ++g2)
          r2[C2++] = a2[g2];
        for (; g2 < e2; ++g2) {
          r2[C2] = r2[C2 - t2] + a2[g2] & 255;
          C2++;
        }
        break;
      case 2:
        for (g2 = 0; g2 < e2; ++g2)
          r2[C2++] = n2[g2] + a2[g2] & 255;
        break;
      case 3:
        for (g2 = 0; g2 < t2; ++g2)
          r2[C2++] = (n2[g2] >> 1) + a2[g2];
        for (; g2 < e2; ++g2) {
          r2[C2] = (n2[g2] + r2[C2 - t2] >> 1) + a2[g2] & 255;
          C2++;
        }
        break;
      case 4:
        for (g2 = 0; g2 < t2; ++g2) {
          o2 = n2[g2];
          c2 = a2[g2];
          r2[C2++] = o2 + c2;
        }
        for (; g2 < e2; ++g2) {
          o2 = n2[g2];
          const e3 = n2[g2 - t2], i3 = r2[C2 - t2], s3 = i3 + o2 - e3;
          let h2 = s3 - i3;
          h2 < 0 && (h2 = -h2);
          let l2 = s3 - o2;
          l2 < 0 && (l2 = -l2);
          let Q2 = s3 - e3;
          Q2 < 0 && (Q2 = -Q2);
          c2 = a2[g2];
          r2[C2++] = h2 <= l2 && h2 <= Q2 ? i3 + c2 : l2 <= Q2 ? o2 + c2 : e3 + c2;
        }
        break;
      default:
        throw new FormatError(`Unsupported predictor: ${i2}`);
    }
    this.bufferLength += e2;
  }
};
var RunLengthStream = class extends DecodeStream {
  constructor(e2, t2) {
    super(t2);
    this.str = e2;
    this.dict = e2.dict;
  }
  readBlock() {
    const e2 = this.str.getBytes(2);
    if (!e2 || e2.length < 2 || 128 === e2[0]) {
      this.eof = true;
      return;
    }
    let t2, i2 = this.bufferLength, a2 = e2[0];
    if (a2 < 128) {
      t2 = this.ensureBuffer(i2 + a2 + 1);
      t2[i2++] = e2[1];
      if (a2 > 0) {
        const e3 = this.str.getBytes(a2);
        t2.set(e3, i2);
        i2 += a2;
      }
    } else {
      a2 = 257 - a2;
      const s2 = e2[1];
      t2 = this.ensureBuffer(i2 + a2 + 1);
      for (let e3 = 0; e3 < a2; e3++)
        t2[i2++] = s2;
    }
    this.bufferLength = i2;
  }
};
var _w, w_fn;
var Parser = class {
  constructor({ lexer: e2, xref: t2, allowStreams: i2 = false, recoveryMode: a2 = false }) {
    __privateAdd(this, _w);
    this.lexer = e2;
    this.xref = t2;
    this.allowStreams = i2;
    this.recoveryMode = a2;
    this.imageCache = /* @__PURE__ */ Object.create(null);
    this._imageId = 0;
    this.refill();
  }
  refill() {
    this.buf1 = this.lexer.getObj();
    this.buf2 = this.lexer.getObj();
  }
  shift() {
    if (this.buf2 instanceof Cmd && "ID" === this.buf2.cmd) {
      this.buf1 = this.buf2;
      this.buf2 = null;
    } else {
      this.buf1 = this.buf2;
      this.buf2 = this.lexer.getObj();
    }
  }
  tryShift() {
    try {
      this.shift();
      return true;
    } catch (e2) {
      if (e2 instanceof MissingDataException)
        throw e2;
      return false;
    }
  }
  getObj(e2 = null) {
    const t2 = this.buf1;
    this.shift();
    if (t2 instanceof Cmd)
      switch (t2.cmd) {
        case "BI":
          return this.makeInlineImage(e2);
        case "[":
          const i2 = [];
          for (; !isCmd(this.buf1, "]") && this.buf1 !== wt; )
            i2.push(this.getObj(e2));
          if (this.buf1 === wt) {
            if (this.recoveryMode)
              return i2;
            throw new ParserEOFException("End of file inside array.");
          }
          this.shift();
          return i2;
        case "<<":
          const a2 = new Dict(this.xref);
          for (; !isCmd(this.buf1, ">>") && this.buf1 !== wt; ) {
            if (!(this.buf1 instanceof Name)) {
              info("Malformed dictionary: key must be a name object");
              this.shift();
              continue;
            }
            const t3 = this.buf1.name;
            this.shift();
            if (this.buf1 === wt)
              break;
            a2.set(t3, this.getObj(e2));
          }
          if (this.buf1 === wt) {
            if (this.recoveryMode)
              return a2;
            throw new ParserEOFException("End of file inside dictionary.");
          }
          if (isCmd(this.buf2, "stream"))
            return this.allowStreams ? this.makeStream(a2, e2) : a2;
          this.shift();
          return a2;
        default:
          return t2;
      }
    if (Number.isInteger(t2)) {
      if (Number.isInteger(this.buf1) && isCmd(this.buf2, "R")) {
        const e3 = Ref.get(t2, this.buf1);
        this.shift();
        this.shift();
        return e3;
      }
      return t2;
    }
    return "string" == typeof t2 && e2 ? e2.decryptString(t2) : t2;
  }
  findDefaultInlineStreamEnd(e2) {
    const { knownCommands: t2 } = this.lexer, i2 = e2.pos;
    let a2, s2, r2 = 0;
    for (; -1 !== (a2 = e2.getByte()); )
      if (0 === r2)
        r2 = 69 === a2 ? 1 : 0;
      else if (1 === r2)
        r2 = 73 === a2 ? 2 : 0;
      else if (32 === a2 || 10 === a2 || 13 === a2) {
        s2 = e2.pos;
        const i3 = e2.peekBytes(15), n3 = i3.length;
        if (0 === n3)
          break;
        for (let e3 = 0; e3 < n3; e3++) {
          a2 = i3[e3];
          if ((0 !== a2 || 0 === i3[e3 + 1]) && (10 !== a2 && 13 !== a2 && (a2 < 32 || a2 > 127))) {
            r2 = 0;
            break;
          }
        }
        if (2 !== r2)
          continue;
        if (!t2) {
          warn("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
          continue;
        }
        const g2 = new Lexer(new Stream(i3.slice()), t2);
        g2._hexStringWarn = () => {
        };
        let o2 = 0;
        for (; ; ) {
          const e3 = g2.getObj();
          if (e3 === wt) {
            r2 = 0;
            break;
          }
          if (e3 instanceof Cmd) {
            const i4 = t2[e3.cmd];
            if (!i4) {
              r2 = 0;
              break;
            }
            if (i4.variableArgs ? o2 <= i4.numArgs : o2 === i4.numArgs)
              break;
            o2 = 0;
          } else
            o2++;
        }
        if (2 === r2)
          break;
      } else
        r2 = 0;
    if (-1 === a2) {
      warn("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
      if (s2) {
        warn('... trying to recover by using the last "EI" occurrence.');
        e2.skip(-(e2.pos - s2));
      }
    }
    let n2 = 4;
    e2.skip(-n2);
    a2 = e2.peekByte();
    e2.skip(n2);
    isWhiteSpace(a2) || n2--;
    return e2.pos - n2 - i2;
  }
  findDCTDecodeInlineStreamEnd(e2) {
    const t2 = e2.pos;
    let i2, a2, s2 = false;
    for (; -1 !== (i2 = e2.getByte()); )
      if (255 === i2) {
        switch (e2.getByte()) {
          case 0:
            break;
          case 255:
            e2.skip(-1);
            break;
          case 217:
            s2 = true;
            break;
          case 192:
          case 193:
          case 194:
          case 195:
          case 197:
          case 198:
          case 199:
          case 201:
          case 202:
          case 203:
          case 205:
          case 206:
          case 207:
          case 196:
          case 204:
          case 218:
          case 219:
          case 220:
          case 221:
          case 222:
          case 223:
          case 224:
          case 225:
          case 226:
          case 227:
          case 228:
          case 229:
          case 230:
          case 231:
          case 232:
          case 233:
          case 234:
          case 235:
          case 236:
          case 237:
          case 238:
          case 239:
          case 254:
            a2 = e2.getUint16();
            a2 > 2 ? e2.skip(a2 - 2) : e2.skip(-2);
        }
        if (s2)
          break;
      }
    const r2 = e2.pos - t2;
    if (-1 === i2) {
      warn("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
      e2.skip(-r2);
      return this.findDefaultInlineStreamEnd(e2);
    }
    this.inlineStreamSkipEI(e2);
    return r2;
  }
  findASCII85DecodeInlineStreamEnd(e2) {
    const t2 = e2.pos;
    let i2;
    for (; -1 !== (i2 = e2.getByte()); )
      if (126 === i2) {
        const t3 = e2.pos;
        i2 = e2.peekByte();
        for (; isWhiteSpace(i2); ) {
          e2.skip();
          i2 = e2.peekByte();
        }
        if (62 === i2) {
          e2.skip();
          break;
        }
        if (e2.pos > t3) {
          const t4 = e2.peekBytes(2);
          if (69 === t4[0] && 73 === t4[1])
            break;
        }
      }
    const a2 = e2.pos - t2;
    if (-1 === i2) {
      warn("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
      e2.skip(-a2);
      return this.findDefaultInlineStreamEnd(e2);
    }
    this.inlineStreamSkipEI(e2);
    return a2;
  }
  findASCIIHexDecodeInlineStreamEnd(e2) {
    const t2 = e2.pos;
    let i2;
    for (; -1 !== (i2 = e2.getByte()) && 62 !== i2; )
      ;
    const a2 = e2.pos - t2;
    if (-1 === i2) {
      warn("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
      e2.skip(-a2);
      return this.findDefaultInlineStreamEnd(e2);
    }
    this.inlineStreamSkipEI(e2);
    return a2;
  }
  inlineStreamSkipEI(e2) {
    let t2, i2 = 0;
    for (; -1 !== (t2 = e2.getByte()); )
      if (0 === i2)
        i2 = 69 === t2 ? 1 : 0;
      else if (1 === i2)
        i2 = 73 === t2 ? 2 : 0;
      else if (2 === i2)
        break;
  }
  makeInlineImage(e2) {
    const t2 = this.lexer, i2 = t2.stream, a2 = /* @__PURE__ */ Object.create(null);
    let s2;
    for (; !isCmd(this.buf1, "ID") && this.buf1 !== wt; ) {
      if (!(this.buf1 instanceof Name))
        throw new FormatError("Dictionary key must be a name object");
      const t3 = this.buf1.name;
      this.shift();
      if (this.buf1 === wt)
        break;
      a2[t3] = this.getObj(e2);
    }
    -1 !== t2.beginInlineImagePos && (s2 = i2.pos - t2.beginInlineImagePos);
    const r2 = this.xref.fetchIfRef(a2.F || a2.Filter);
    let n2;
    if (r2 instanceof Name)
      n2 = r2.name;
    else if (Array.isArray(r2)) {
      const e3 = this.xref.fetchIfRef(r2[0]);
      e3 instanceof Name && (n2 = e3.name);
    }
    const g2 = i2.pos;
    let o2, c2;
    switch (n2) {
      case "DCT":
      case "DCTDecode":
        o2 = this.findDCTDecodeInlineStreamEnd(i2);
        break;
      case "A85":
      case "ASCII85Decode":
        o2 = this.findASCII85DecodeInlineStreamEnd(i2);
        break;
      case "AHx":
      case "ASCIIHexDecode":
        o2 = this.findASCIIHexDecodeInlineStreamEnd(i2);
        break;
      default:
        o2 = this.findDefaultInlineStreamEnd(i2);
    }
    if (o2 < 1e3 && s2 > 0) {
      const e3 = i2.pos;
      i2.pos = t2.beginInlineImagePos;
      c2 = function getInlineImageCacheKey(e4) {
        const t3 = [], i3 = e4.length;
        let a4 = 0;
        for (; a4 < i3 - 1; )
          t3.push(e4[a4++] << 8 | e4[a4++]);
        a4 < i3 && t3.push(e4[a4]);
        return i3 + "_" + String.fromCharCode.apply(null, t3);
      }(i2.getBytes(s2 + o2));
      i2.pos = e3;
      const a3 = this.imageCache[c2];
      if (void 0 !== a3) {
        this.buf2 = Cmd.get("EI");
        this.shift();
        a3.reset();
        return a3;
      }
    }
    const C2 = new Dict(this.xref);
    for (const e3 in a2)
      C2.set(e3, a2[e3]);
    let h2 = i2.makeSubStream(g2, o2, C2);
    e2 && (h2 = e2.createStream(h2, o2));
    h2 = this.filter(h2, C2, o2);
    h2.dict = C2;
    if (void 0 !== c2) {
      h2.cacheKey = "inline_img_" + ++this._imageId;
      this.imageCache[c2] = h2;
    }
    this.buf2 = Cmd.get("EI");
    this.shift();
    return h2;
  }
  makeStream(e2, t2) {
    const i2 = this.lexer;
    let a2 = i2.stream;
    i2.skipToNextLine();
    const s2 = a2.pos - 1;
    let r2 = e2.get("Length");
    if (!Number.isInteger(r2)) {
      info(`Bad length "${r2 && r2.toString()}" in stream.`);
      r2 = 0;
    }
    a2.pos = s2 + r2;
    i2.nextChar();
    if (this.tryShift() && isCmd(this.buf2, "endstream"))
      this.shift();
    else {
      r2 = __privateMethod(this, _w, w_fn).call(this, s2);
      if (r2 < 0)
        throw new FormatError("Missing endstream command.");
      i2.nextChar();
      this.shift();
      this.shift();
    }
    this.shift();
    a2 = a2.makeSubStream(s2, r2, e2);
    t2 && (a2 = t2.createStream(a2, r2));
    a2 = this.filter(a2, e2, r2);
    a2.dict = e2;
    return a2;
  }
  filter(e2, t2, i2) {
    let a2 = t2.get("F", "Filter"), s2 = t2.get("DP", "DecodeParms");
    if (a2 instanceof Name) {
      Array.isArray(s2) && warn("/DecodeParms should not be an Array, when /Filter is a Name.");
      return this.makeFilter(e2, a2.name, i2, s2);
    }
    let r2 = i2;
    if (Array.isArray(a2)) {
      const t3 = a2, i3 = s2;
      for (let n2 = 0, g2 = t3.length; n2 < g2; ++n2) {
        a2 = this.xref.fetchIfRef(t3[n2]);
        if (!(a2 instanceof Name))
          throw new FormatError(`Bad filter name "${a2}"`);
        s2 = null;
        Array.isArray(i3) && n2 in i3 && (s2 = this.xref.fetchIfRef(i3[n2]));
        e2 = this.makeFilter(e2, a2.name, r2, s2);
        r2 = null;
      }
    }
    return e2;
  }
  makeFilter(e2, t2, i2, a2) {
    if (0 === i2) {
      warn(`Empty "${t2}" stream.`);
      return new NullStream();
    }
    try {
      switch (t2) {
        case "Fl":
        case "FlateDecode":
          return a2 ? new PredictorStream(new FlateStream(e2, i2), i2, a2) : new FlateStream(e2, i2);
        case "LZW":
        case "LZWDecode":
          let t3 = 1;
          if (a2) {
            a2.has("EarlyChange") && (t3 = a2.get("EarlyChange"));
            return new PredictorStream(new LZWStream(e2, i2, t3), i2, a2);
          }
          return new LZWStream(e2, i2, t3);
        case "DCT":
        case "DCTDecode":
          return new JpegStream(e2, i2, a2);
        case "JPX":
        case "JPXDecode":
          return new JpxStream(e2, i2, a2);
        case "A85":
        case "ASCII85Decode":
          return new Ascii85Stream(e2, i2);
        case "AHx":
        case "ASCIIHexDecode":
          return new AsciiHexStream(e2, i2);
        case "CCF":
        case "CCITTFaxDecode":
          return new CCITTFaxStream(e2, i2, a2);
        case "RL":
        case "RunLengthDecode":
          return new RunLengthStream(e2, i2);
        case "JBIG2Decode":
          return new Jbig2Stream(e2, i2, a2);
      }
      warn(`Filter "${t2}" is not supported.`);
      return e2;
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      warn(`Invalid stream: "${e3}"`);
      return new NullStream();
    }
  }
};
_w = new WeakSet();
w_fn = function(e2) {
  const { stream: t2 } = this.lexer;
  t2.pos = e2;
  const i2 = new Uint8Array([101, 110, 100]), a2 = i2.length, s2 = [new Uint8Array([115, 116, 114, 101, 97, 109]), new Uint8Array([115, 116, 101, 97, 109]), new Uint8Array([115, 116, 114, 101, 97])], r2 = 9 - a2;
  for (; t2.pos < t2.end; ) {
    const n2 = t2.peekBytes(2048), g2 = n2.length - 9;
    if (g2 <= 0)
      break;
    let o2 = 0;
    for (; o2 < g2; ) {
      let g3 = 0;
      for (; g3 < a2 && n2[o2 + g3] === i2[g3]; )
        g3++;
      if (g3 >= a2) {
        let a3 = false;
        for (const e3 of s2) {
          const t3 = e3.length;
          let s3 = 0;
          for (; s3 < t3 && n2[o2 + g3 + s3] === e3[s3]; )
            s3++;
          if (s3 >= r2) {
            a3 = true;
            break;
          }
          if (s3 >= t3) {
            if (isWhiteSpace(n2[o2 + g3 + s3])) {
              info(`Found "${bytesToString([...i2, ...e3])}" when searching for endstream command.`);
              a3 = true;
            }
            break;
          }
        }
        if (a3) {
          t2.pos += o2;
          return t2.pos - e2;
        }
      }
      o2++;
    }
    t2.pos += g2;
  }
  return -1;
};
var Bi = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
function toHexDigit(e2) {
  return e2 >= 48 && e2 <= 57 ? 15 & e2 : e2 >= 65 && e2 <= 70 || e2 >= 97 && e2 <= 102 ? 9 + (15 & e2) : -1;
}
var Lexer = class {
  constructor(e2, t2 = null) {
    this.stream = e2;
    this.nextChar();
    this.strBuf = [];
    this.knownCommands = t2;
    this._hexStringNumWarn = 0;
    this.beginInlineImagePos = -1;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  peekChar() {
    return this.stream.peekByte();
  }
  getNumber() {
    let e2 = this.currentChar, t2 = false, i2 = 0, a2 = 1;
    if (45 === e2) {
      a2 = -1;
      e2 = this.nextChar();
      45 === e2 && (e2 = this.nextChar());
    } else
      43 === e2 && (e2 = this.nextChar());
    if (10 === e2 || 13 === e2)
      do {
        e2 = this.nextChar();
      } while (10 === e2 || 13 === e2);
    if (46 === e2) {
      i2 = 10;
      e2 = this.nextChar();
    }
    if (e2 < 48 || e2 > 57) {
      const t3 = `Invalid number: ${String.fromCharCode(e2)} (charCode ${e2})`;
      if (isWhiteSpace(e2) || -1 === e2) {
        info(`Lexer.getNumber - "${t3}".`);
        return 0;
      }
      throw new FormatError(t3);
    }
    let s2 = e2 - 48, r2 = 0, n2 = 1;
    for (; (e2 = this.nextChar()) >= 0; )
      if (e2 >= 48 && e2 <= 57) {
        const a3 = e2 - 48;
        if (t2)
          r2 = 10 * r2 + a3;
        else {
          0 !== i2 && (i2 *= 10);
          s2 = 10 * s2 + a3;
        }
      } else if (46 === e2) {
        if (0 !== i2)
          break;
        i2 = 1;
      } else if (45 === e2)
        warn("Badly formatted number: minus sign in the middle");
      else {
        if (69 !== e2 && 101 !== e2)
          break;
        e2 = this.peekChar();
        if (43 === e2 || 45 === e2) {
          n2 = 45 === e2 ? -1 : 1;
          this.nextChar();
        } else if (e2 < 48 || e2 > 57)
          break;
        t2 = true;
      }
    0 !== i2 && (s2 /= i2);
    t2 && (s2 *= 10 ** (n2 * r2));
    return a2 * s2;
  }
  getString() {
    let e2 = 1, t2 = false;
    const i2 = this.strBuf;
    i2.length = 0;
    let a2 = this.nextChar();
    for (; ; ) {
      let s2 = false;
      switch (0 | a2) {
        case -1:
          warn("Unterminated string");
          t2 = true;
          break;
        case 40:
          ++e2;
          i2.push("(");
          break;
        case 41:
          if (0 == --e2) {
            this.nextChar();
            t2 = true;
          } else
            i2.push(")");
          break;
        case 92:
          a2 = this.nextChar();
          switch (a2) {
            case -1:
              warn("Unterminated string");
              t2 = true;
              break;
            case 110:
              i2.push("\n");
              break;
            case 114:
              i2.push("\r");
              break;
            case 116:
              i2.push("	");
              break;
            case 98:
              i2.push("\b");
              break;
            case 102:
              i2.push("\f");
              break;
            case 92:
            case 40:
            case 41:
              i2.push(String.fromCharCode(a2));
              break;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
              let e3 = 15 & a2;
              a2 = this.nextChar();
              s2 = true;
              if (a2 >= 48 && a2 <= 55) {
                e3 = (e3 << 3) + (15 & a2);
                a2 = this.nextChar();
                if (a2 >= 48 && a2 <= 55) {
                  s2 = false;
                  e3 = (e3 << 3) + (15 & a2);
                }
              }
              i2.push(String.fromCharCode(e3));
              break;
            case 13:
              10 === this.peekChar() && this.nextChar();
              break;
            case 10:
              break;
            default:
              i2.push(String.fromCharCode(a2));
          }
          break;
        default:
          i2.push(String.fromCharCode(a2));
      }
      if (t2)
        break;
      s2 || (a2 = this.nextChar());
    }
    return i2.join("");
  }
  getName() {
    let e2, t2;
    const i2 = this.strBuf;
    i2.length = 0;
    for (; (e2 = this.nextChar()) >= 0 && !Bi[e2]; )
      if (35 === e2) {
        e2 = this.nextChar();
        if (Bi[e2]) {
          warn("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
          i2.push("#");
          break;
        }
        const a2 = toHexDigit(e2);
        if (-1 !== a2) {
          t2 = e2;
          e2 = this.nextChar();
          const s2 = toHexDigit(e2);
          if (-1 === s2) {
            warn(`Lexer_getName: Illegal digit (${String.fromCharCode(e2)}) in hexadecimal number.`);
            i2.push("#", String.fromCharCode(t2));
            if (Bi[e2])
              break;
            i2.push(String.fromCharCode(e2));
            continue;
          }
          i2.push(String.fromCharCode(a2 << 4 | s2));
        } else
          i2.push("#", String.fromCharCode(e2));
      } else
        i2.push(String.fromCharCode(e2));
    i2.length > 127 && warn(`Name token is longer than allowed by the spec: ${i2.length}`);
    return Name.get(i2.join(""));
  }
  _hexStringWarn(e2) {
    5 != this._hexStringNumWarn++ ? this._hexStringNumWarn > 5 || warn(`getHexString - ignoring invalid character: ${e2}`) : warn("getHexString - ignoring additional invalid characters.");
  }
  getHexString() {
    const e2 = this.strBuf;
    e2.length = 0;
    let t2, i2, a2 = this.currentChar, s2 = true;
    this._hexStringNumWarn = 0;
    for (; ; ) {
      if (a2 < 0) {
        warn("Unterminated hex string");
        break;
      }
      if (62 === a2) {
        this.nextChar();
        break;
      }
      if (1 !== Bi[a2]) {
        if (s2) {
          t2 = toHexDigit(a2);
          if (-1 === t2) {
            this._hexStringWarn(a2);
            a2 = this.nextChar();
            continue;
          }
        } else {
          i2 = toHexDigit(a2);
          if (-1 === i2) {
            this._hexStringWarn(a2);
            a2 = this.nextChar();
            continue;
          }
          e2.push(String.fromCharCode(t2 << 4 | i2));
        }
        s2 = !s2;
        a2 = this.nextChar();
      } else
        a2 = this.nextChar();
    }
    return e2.join("");
  }
  getObj() {
    let e2 = false, t2 = this.currentChar;
    for (; ; ) {
      if (t2 < 0)
        return wt;
      if (e2)
        10 !== t2 && 13 !== t2 || (e2 = false);
      else if (37 === t2)
        e2 = true;
      else if (1 !== Bi[t2])
        break;
      t2 = this.nextChar();
    }
    switch (0 | t2) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return this.getNumber();
      case 40:
        return this.getString();
      case 47:
        return this.getName();
      case 91:
        this.nextChar();
        return Cmd.get("[");
      case 93:
        this.nextChar();
        return Cmd.get("]");
      case 60:
        t2 = this.nextChar();
        if (60 === t2) {
          this.nextChar();
          return Cmd.get("<<");
        }
        return this.getHexString();
      case 62:
        t2 = this.nextChar();
        if (62 === t2) {
          this.nextChar();
          return Cmd.get(">>");
        }
        return Cmd.get(">");
      case 123:
        this.nextChar();
        return Cmd.get("{");
      case 125:
        this.nextChar();
        return Cmd.get("}");
      case 41:
        this.nextChar();
        throw new FormatError(`Illegal character: ${t2}`);
    }
    let i2 = String.fromCharCode(t2);
    if (t2 < 32 || t2 > 127) {
      const e3 = this.peekChar();
      if (e3 >= 32 && e3 <= 127) {
        this.nextChar();
        return Cmd.get(i2);
      }
    }
    const a2 = this.knownCommands;
    let s2 = void 0 !== (a2 == null ? void 0 : a2[i2]);
    for (; (t2 = this.nextChar()) >= 0 && !Bi[t2]; ) {
      const e3 = i2 + String.fromCharCode(t2);
      if (s2 && void 0 === a2[e3])
        break;
      if (128 === i2.length)
        throw new FormatError(`Command token too long: ${i2.length}`);
      i2 = e3;
      s2 = void 0 !== (a2 == null ? void 0 : a2[i2]);
    }
    if ("true" === i2)
      return true;
    if ("false" === i2)
      return false;
    if ("null" === i2)
      return null;
    "BI" === i2 && (this.beginInlineImagePos = this.stream.pos);
    return Cmd.get(i2);
  }
  skipToNextLine() {
    let e2 = this.currentChar;
    for (; e2 >= 0; ) {
      if (13 === e2) {
        e2 = this.nextChar();
        10 === e2 && this.nextChar();
        break;
      }
      if (10 === e2) {
        this.nextChar();
        break;
      }
      e2 = this.nextChar();
    }
  }
};
var Linearization = class {
  static create(e2) {
    function getInt(e3, t3, i3 = false) {
      const a3 = e3.get(t3);
      if (Number.isInteger(a3) && (i3 ? a3 >= 0 : a3 > 0))
        return a3;
      throw new Error(`The "${t3}" parameter in the linearization dictionary is invalid.`);
    }
    const t2 = new Parser({ lexer: new Lexer(e2), xref: null }), i2 = t2.getObj(), a2 = t2.getObj(), s2 = t2.getObj(), r2 = t2.getObj();
    let n2, g2;
    if (!(Number.isInteger(i2) && Number.isInteger(a2) && isCmd(s2, "obj") && r2 instanceof Dict && "number" == typeof (n2 = r2.get("Linearized")) && n2 > 0))
      return null;
    if ((g2 = getInt(r2, "L")) !== e2.length)
      throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
    return { length: g2, hints: function getHints(e3) {
      const t3 = e3.get("H");
      let i3;
      if (Array.isArray(t3) && (2 === (i3 = t3.length) || 4 === i3)) {
        for (let e4 = 0; e4 < i3; e4++) {
          const i4 = t3[e4];
          if (!(Number.isInteger(i4) && i4 > 0))
            throw new Error(`Hint (${e4}) in the linearization dictionary is invalid.`);
        }
        return t3;
      }
      throw new Error("Hint array in the linearization dictionary is invalid.");
    }(r2), objectNumberFirst: getInt(r2, "O"), endFirst: getInt(r2, "E"), numPages: getInt(r2, "N"), mainXRefEntriesOffset: getInt(r2, "T"), pageFirst: r2.has("P") ? getInt(r2, "P", true) : 0 };
  }
};
var li = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
var Qi = 2 ** 24 - 1;
var CMap = class {
  constructor(e2 = false) {
    this.codespaceRanges = [[], [], [], []];
    this.numCodespaceRanges = 0;
    this._map = [];
    this.name = "";
    this.vertical = false;
    this.useCMap = null;
    this.builtInCMap = e2;
  }
  addCodespaceRange(e2, t2, i2) {
    this.codespaceRanges[e2 - 1].push(t2, i2);
    this.numCodespaceRanges++;
  }
  mapCidRange(e2, t2, i2) {
    if (t2 - e2 > Qi)
      throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
    for (; e2 <= t2; )
      this._map[e2++] = i2++;
  }
  mapBfRange(e2, t2, i2) {
    if (t2 - e2 > Qi)
      throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
    const a2 = i2.length - 1;
    for (; e2 <= t2; ) {
      this._map[e2++] = i2;
      const t3 = i2.charCodeAt(a2) + 1;
      t3 > 255 ? i2 = i2.substring(0, a2 - 1) + String.fromCharCode(i2.charCodeAt(a2 - 1) + 1) + "\0" : i2 = i2.substring(0, a2) + String.fromCharCode(t3);
    }
  }
  mapBfRangeToArray(e2, t2, i2) {
    if (t2 - e2 > Qi)
      throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
    const a2 = i2.length;
    let s2 = 0;
    for (; e2 <= t2 && s2 < a2; ) {
      this._map[e2] = i2[s2++];
      ++e2;
    }
  }
  mapOne(e2, t2) {
    this._map[e2] = t2;
  }
  lookup(e2) {
    return this._map[e2];
  }
  contains(e2) {
    return void 0 !== this._map[e2];
  }
  forEach(e2) {
    const t2 = this._map, i2 = t2.length;
    if (i2 <= 65536)
      for (let a2 = 0; a2 < i2; a2++)
        void 0 !== t2[a2] && e2(a2, t2[a2]);
    else
      for (const i3 in t2)
        e2(i3, t2[i3]);
  }
  charCodeOf(e2) {
    const t2 = this._map;
    if (t2.length <= 65536)
      return t2.indexOf(e2);
    for (const i2 in t2)
      if (t2[i2] === e2)
        return 0 | i2;
    return -1;
  }
  getMap() {
    return this._map;
  }
  readCharCode(e2, t2, i2) {
    let a2 = 0;
    const s2 = this.codespaceRanges;
    for (let r2 = 0, n2 = s2.length; r2 < n2; r2++) {
      a2 = (a2 << 8 | e2.charCodeAt(t2 + r2)) >>> 0;
      const n3 = s2[r2];
      for (let e3 = 0, t3 = n3.length; e3 < t3; ) {
        const t4 = n3[e3++], s3 = n3[e3++];
        if (a2 >= t4 && a2 <= s3) {
          i2.charcode = a2;
          i2.length = r2 + 1;
          return;
        }
      }
    }
    i2.charcode = 0;
    i2.length = 1;
  }
  getCharCodeLength(e2) {
    const t2 = this.codespaceRanges;
    for (let i2 = 0, a2 = t2.length; i2 < a2; i2++) {
      const a3 = t2[i2];
      for (let t3 = 0, s2 = a3.length; t3 < s2; ) {
        const s3 = a3[t3++], r2 = a3[t3++];
        if (e2 >= s3 && e2 <= r2)
          return i2 + 1;
      }
    }
    return 1;
  }
  get length() {
    return this._map.length;
  }
  get isIdentityCMap() {
    if ("Identity-H" !== this.name && "Identity-V" !== this.name)
      return false;
    if (65536 !== this._map.length)
      return false;
    for (let e2 = 0; e2 < 65536; e2++)
      if (this._map[e2] !== e2)
        return false;
    return true;
  }
};
var IdentityCMap = class extends CMap {
  constructor(e2, t2) {
    super();
    this.vertical = e2;
    this.addCodespaceRange(t2, 0, 65535);
  }
  mapCidRange(e2, t2, i2) {
    unreachable("should not call mapCidRange");
  }
  mapBfRange(e2, t2, i2) {
    unreachable("should not call mapBfRange");
  }
  mapBfRangeToArray(e2, t2, i2) {
    unreachable("should not call mapBfRangeToArray");
  }
  mapOne(e2, t2) {
    unreachable("should not call mapCidOne");
  }
  lookup(e2) {
    return Number.isInteger(e2) && e2 <= 65535 ? e2 : void 0;
  }
  contains(e2) {
    return Number.isInteger(e2) && e2 <= 65535;
  }
  forEach(e2) {
    for (let t2 = 0; t2 <= 65535; t2++)
      e2(t2, t2);
  }
  charCodeOf(e2) {
    return Number.isInteger(e2) && e2 <= 65535 ? e2 : -1;
  }
  getMap() {
    const e2 = new Array(65536);
    for (let t2 = 0; t2 <= 65535; t2++)
      e2[t2] = t2;
    return e2;
  }
  get length() {
    return 65536;
  }
  get isIdentityCMap() {
    unreachable("should not access .isIdentityCMap");
  }
};
function strToInt(e2) {
  let t2 = 0;
  for (let i2 = 0; i2 < e2.length; i2++)
    t2 = t2 << 8 | e2.charCodeAt(i2);
  return t2 >>> 0;
}
function expectString(e2) {
  if ("string" != typeof e2)
    throw new FormatError("Malformed CMap: expected string.");
}
function expectInt(e2) {
  if (!Number.isInteger(e2))
    throw new FormatError("Malformed CMap: expected int.");
}
function parseBfChar(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === wt)
      break;
    if (isCmd(i2, "endbfchar"))
      return;
    expectString(i2);
    const a2 = strToInt(i2);
    i2 = t2.getObj();
    expectString(i2);
    const s2 = i2;
    e2.mapOne(a2, s2);
  }
}
function parseBfRange(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === wt)
      break;
    if (isCmd(i2, "endbfrange"))
      return;
    expectString(i2);
    const a2 = strToInt(i2);
    i2 = t2.getObj();
    expectString(i2);
    const s2 = strToInt(i2);
    i2 = t2.getObj();
    if (Number.isInteger(i2) || "string" == typeof i2) {
      const t3 = Number.isInteger(i2) ? String.fromCharCode(i2) : i2;
      e2.mapBfRange(a2, s2, t3);
    } else {
      if (!isCmd(i2, "["))
        break;
      {
        i2 = t2.getObj();
        const r2 = [];
        for (; !isCmd(i2, "]") && i2 !== wt; ) {
          r2.push(i2);
          i2 = t2.getObj();
        }
        e2.mapBfRangeToArray(a2, s2, r2);
      }
    }
  }
  throw new FormatError("Invalid bf range.");
}
function parseCidChar(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === wt)
      break;
    if (isCmd(i2, "endcidchar"))
      return;
    expectString(i2);
    const a2 = strToInt(i2);
    i2 = t2.getObj();
    expectInt(i2);
    const s2 = i2;
    e2.mapOne(a2, s2);
  }
}
function parseCidRange(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === wt)
      break;
    if (isCmd(i2, "endcidrange"))
      return;
    expectString(i2);
    const a2 = strToInt(i2);
    i2 = t2.getObj();
    expectString(i2);
    const s2 = strToInt(i2);
    i2 = t2.getObj();
    expectInt(i2);
    const r2 = i2;
    e2.mapCidRange(a2, s2, r2);
  }
}
function parseCodespaceRange(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === wt)
      break;
    if (isCmd(i2, "endcodespacerange"))
      return;
    if ("string" != typeof i2)
      break;
    const a2 = strToInt(i2);
    i2 = t2.getObj();
    if ("string" != typeof i2)
      break;
    const s2 = strToInt(i2);
    e2.addCodespaceRange(i2.length, a2, s2);
  }
  throw new FormatError("Invalid codespace range.");
}
function parseWMode(e2, t2) {
  const i2 = t2.getObj();
  Number.isInteger(i2) && (e2.vertical = !!i2);
}
function parseCMapName(e2, t2) {
  const i2 = t2.getObj();
  i2 instanceof Name && (e2.name = i2.name);
}
async function parseCMap(e2, t2, i2, a2) {
  let s2, r2;
  A:
    for (; ; )
      try {
        const i3 = t2.getObj();
        if (i3 === wt)
          break;
        if (i3 instanceof Name) {
          "WMode" === i3.name ? parseWMode(e2, t2) : "CMapName" === i3.name && parseCMapName(e2, t2);
          s2 = i3;
        } else if (i3 instanceof Cmd)
          switch (i3.cmd) {
            case "endcmap":
              break A;
            case "usecmap":
              s2 instanceof Name && (r2 = s2.name);
              break;
            case "begincodespacerange":
              parseCodespaceRange(e2, t2);
              break;
            case "beginbfchar":
              parseBfChar(e2, t2);
              break;
            case "begincidchar":
              parseCidChar(e2, t2);
              break;
            case "beginbfrange":
              parseBfRange(e2, t2);
              break;
            case "begincidrange":
              parseCidRange(e2, t2);
          }
      } catch (e3) {
        if (e3 instanceof MissingDataException)
          throw e3;
        warn("Invalid cMap data: " + e3);
        continue;
      }
  !a2 && r2 && (a2 = r2);
  return a2 ? extendCMap(e2, i2, a2) : e2;
}
async function extendCMap(e2, t2, i2) {
  e2.useCMap = await createBuiltInCMap(i2, t2);
  if (0 === e2.numCodespaceRanges) {
    const t3 = e2.useCMap.codespaceRanges;
    for (let i3 = 0; i3 < t3.length; i3++)
      e2.codespaceRanges[i3] = t3[i3].slice();
    e2.numCodespaceRanges = e2.useCMap.numCodespaceRanges;
  }
  e2.useCMap.forEach(function(t3, i3) {
    e2.contains(t3) || e2.mapOne(t3, e2.useCMap.lookup(t3));
  });
  return e2;
}
async function createBuiltInCMap(e2, t2) {
  if ("Identity-H" === e2)
    return new IdentityCMap(false, 2);
  if ("Identity-V" === e2)
    return new IdentityCMap(true, 2);
  if (!li.includes(e2))
    throw new Error("Unknown CMap name: " + e2);
  if (!t2)
    throw new Error("Built-in CMap parameters are not provided.");
  const { cMapData: i2, compressionType: a2 } = await t2(e2), s2 = new CMap(true);
  if (a2 === yA.BINARY)
    return new BinaryCMapReader().process(i2, s2, (e3) => extendCMap(s2, t2, e3));
  if (a2 === yA.NONE) {
    const e3 = new Lexer(new Stream(i2));
    return parseCMap(s2, e3, t2, null);
  }
  throw new Error(`Invalid CMap "compressionType" value: ${a2}`);
}
var CMapFactory = class {
  static async create({ encoding: e2, fetchBuiltInCMap: t2, useCMap: i2 }) {
    if (e2 instanceof Name)
      return createBuiltInCMap(e2.name, t2);
    if (e2 instanceof BaseStream) {
      const a2 = await parseCMap(new CMap(), new Lexer(e2), t2, i2);
      return a2.isIdentityCMap ? createBuiltInCMap(a2.name, t2) : a2;
    }
    throw new Error("Encoding required.");
  }
};
var Ei = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
var ui = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
var di = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
var fi = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
var pi = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
var mi = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
var yi = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
var wi = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
var Di = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
var bi = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
function getEncoding(e2) {
  switch (e2) {
    case "WinAnsiEncoding":
      return wi;
    case "StandardEncoding":
      return yi;
    case "MacRomanEncoding":
      return mi;
    case "SymbolSetEncoding":
      return Di;
    case "ZapfDingbatsEncoding":
      return bi;
    case "ExpertEncoding":
      return fi;
    case "MacExpertEncoding":
      return pi;
    default:
      return null;
  }
}
var Fi = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
var Si = 391;
var ki = [null, { id: "hstem", min: 2, stackClearing: true, stem: true }, null, { id: "vstem", min: 2, stackClearing: true, stem: true }, { id: "vmoveto", min: 1, stackClearing: true }, { id: "rlineto", min: 2, resetStack: true }, { id: "hlineto", min: 1, resetStack: true }, { id: "vlineto", min: 1, resetStack: true }, { id: "rrcurveto", min: 6, resetStack: true }, null, { id: "callsubr", min: 1, undefStack: true }, { id: "return", min: 0, undefStack: true }, null, null, { id: "endchar", min: 0, stackClearing: true }, null, null, null, { id: "hstemhm", min: 2, stackClearing: true, stem: true }, { id: "hintmask", min: 0, stackClearing: true }, { id: "cntrmask", min: 0, stackClearing: true }, { id: "rmoveto", min: 2, stackClearing: true }, { id: "hmoveto", min: 1, stackClearing: true }, { id: "vstemhm", min: 2, stackClearing: true, stem: true }, { id: "rcurveline", min: 8, resetStack: true }, { id: "rlinecurve", min: 8, resetStack: true }, { id: "vvcurveto", min: 4, resetStack: true }, { id: "hhcurveto", min: 4, resetStack: true }, null, { id: "callgsubr", min: 1, undefStack: true }, { id: "vhcurveto", min: 4, resetStack: true }, { id: "hvcurveto", min: 4, resetStack: true }];
var Ri = [null, null, null, { id: "and", min: 2, stackDelta: -1 }, { id: "or", min: 2, stackDelta: -1 }, { id: "not", min: 1, stackDelta: 0 }, null, null, null, { id: "abs", min: 1, stackDelta: 0 }, { id: "add", min: 2, stackDelta: -1, stackFn(e2, t2) {
  e2[t2 - 2] = e2[t2 - 2] + e2[t2 - 1];
} }, { id: "sub", min: 2, stackDelta: -1, stackFn(e2, t2) {
  e2[t2 - 2] = e2[t2 - 2] - e2[t2 - 1];
} }, { id: "div", min: 2, stackDelta: -1, stackFn(e2, t2) {
  e2[t2 - 2] = e2[t2 - 2] / e2[t2 - 1];
} }, null, { id: "neg", min: 1, stackDelta: 0, stackFn(e2, t2) {
  e2[t2 - 1] = -e2[t2 - 1];
} }, { id: "eq", min: 2, stackDelta: -1 }, null, null, { id: "drop", min: 1, stackDelta: -1 }, null, { id: "put", min: 2, stackDelta: -2 }, { id: "get", min: 1, stackDelta: 0 }, { id: "ifelse", min: 4, stackDelta: -3 }, { id: "random", min: 0, stackDelta: 1 }, { id: "mul", min: 2, stackDelta: -1, stackFn(e2, t2) {
  e2[t2 - 2] = e2[t2 - 2] * e2[t2 - 1];
} }, null, { id: "sqrt", min: 1, stackDelta: 0 }, { id: "dup", min: 1, stackDelta: 1 }, { id: "exch", min: 2, stackDelta: 0 }, { id: "index", min: 2, stackDelta: 0 }, { id: "roll", min: 3, stackDelta: -2 }, null, null, null, { id: "hflex", min: 7, resetStack: true }, { id: "flex", min: 13, resetStack: true }, { id: "hflex1", min: 9, resetStack: true }, { id: "flex1", min: 11, resetStack: true }];
var CFFParser = class {
  constructor(e2, t2, i2) {
    this.bytes = e2.getBytes();
    this.properties = t2;
    this.seacAnalysisEnabled = !!i2;
  }
  parse() {
    const e2 = this.properties, t2 = new CFF();
    this.cff = t2;
    const i2 = this.parseHeader(), a2 = this.parseIndex(i2.endPos), s2 = this.parseIndex(a2.endPos), r2 = this.parseIndex(s2.endPos), n2 = this.parseIndex(r2.endPos), g2 = this.parseDict(s2.obj.get(0)), o2 = this.createDict(CFFTopDict, g2, t2.strings);
    t2.header = i2.obj;
    t2.names = this.parseNameIndex(a2.obj);
    t2.strings = this.parseStringIndex(r2.obj);
    t2.topDict = o2;
    t2.globalSubrIndex = n2.obj;
    this.parsePrivateDict(t2.topDict);
    t2.isCIDFont = o2.hasName("ROS");
    const c2 = o2.getByName("CharStrings"), C2 = this.parseIndex(c2).obj, h2 = o2.getByName("FontMatrix");
    h2 && (e2.fontMatrix = h2);
    const l2 = o2.getByName("FontBBox");
    if (l2) {
      e2.ascent = Math.max(l2[3], l2[1]);
      e2.descent = Math.min(l2[1], l2[3]);
      e2.ascentScaled = true;
    }
    let Q2, E2;
    if (t2.isCIDFont) {
      const e3 = this.parseIndex(o2.getByName("FDArray")).obj;
      for (let i3 = 0, a3 = e3.count; i3 < a3; ++i3) {
        const a4 = e3.get(i3), s3 = this.createDict(CFFTopDict, this.parseDict(a4), t2.strings);
        this.parsePrivateDict(s3);
        t2.fdArray.push(s3);
      }
      E2 = null;
      Q2 = this.parseCharsets(o2.getByName("charset"), C2.count, t2.strings, true);
      t2.fdSelect = this.parseFDSelect(o2.getByName("FDSelect"), C2.count);
    } else {
      Q2 = this.parseCharsets(o2.getByName("charset"), C2.count, t2.strings, false);
      E2 = this.parseEncoding(o2.getByName("Encoding"), e2, t2.strings, Q2.charset);
    }
    t2.charset = Q2;
    t2.encoding = E2;
    const u2 = this.parseCharStrings({ charStrings: C2, localSubrIndex: o2.privateDict.subrsIndex, globalSubrIndex: n2.obj, fdSelect: t2.fdSelect, fdArray: t2.fdArray, privateDict: o2.privateDict });
    t2.charStrings = u2.charStrings;
    t2.seacs = u2.seacs;
    t2.widths = u2.widths;
    return t2;
  }
  parseHeader() {
    let e2 = this.bytes;
    const t2 = e2.length;
    let i2 = 0;
    for (; i2 < t2 && 1 !== e2[i2]; )
      ++i2;
    if (i2 >= t2)
      throw new FormatError("Invalid CFF header");
    if (0 !== i2) {
      info("cff data is shifted");
      e2 = e2.subarray(i2);
      this.bytes = e2;
    }
    const a2 = e2[0], s2 = e2[1], r2 = e2[2], n2 = e2[3];
    return { obj: new CFFHeader(a2, s2, r2, n2), endPos: r2 };
  }
  parseDict(e2) {
    let t2 = 0;
    function parseOperand() {
      let i3 = e2[t2++];
      if (30 === i3)
        return function parseFloatOperand() {
          let i4 = "";
          const a3 = 15, s3 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], r2 = e2.length;
          for (; t2 < r2; ) {
            const r3 = e2[t2++], n2 = r3 >> 4, g2 = 15 & r3;
            if (n2 === a3)
              break;
            i4 += s3[n2];
            if (g2 === a3)
              break;
            i4 += s3[g2];
          }
          return parseFloat(i4);
        }();
      if (28 === i3) {
        i3 = e2[t2++];
        i3 = (i3 << 24 | e2[t2++] << 16) >> 16;
        return i3;
      }
      if (29 === i3) {
        i3 = e2[t2++];
        i3 = i3 << 8 | e2[t2++];
        i3 = i3 << 8 | e2[t2++];
        i3 = i3 << 8 | e2[t2++];
        return i3;
      }
      if (i3 >= 32 && i3 <= 246)
        return i3 - 139;
      if (i3 >= 247 && i3 <= 250)
        return 256 * (i3 - 247) + e2[t2++] + 108;
      if (i3 >= 251 && i3 <= 254)
        return -256 * (i3 - 251) - e2[t2++] - 108;
      warn('CFFParser_parseDict: "' + i3 + '" is a reserved command.');
      return NaN;
    }
    let i2 = [];
    const a2 = [];
    t2 = 0;
    const s2 = e2.length;
    for (; t2 < s2; ) {
      let s3 = e2[t2];
      if (s3 <= 21) {
        12 === s3 && (s3 = s3 << 8 | e2[++t2]);
        a2.push([s3, i2]);
        i2 = [];
        ++t2;
      } else
        i2.push(parseOperand());
    }
    return a2;
  }
  parseIndex(e2) {
    const t2 = new CFFIndex(), i2 = this.bytes, a2 = i2[e2++] << 8 | i2[e2++], s2 = [];
    let r2, n2, g2 = e2;
    if (0 !== a2) {
      const t3 = i2[e2++], o2 = e2 + (a2 + 1) * t3 - 1;
      for (r2 = 0, n2 = a2 + 1; r2 < n2; ++r2) {
        let a3 = 0;
        for (let s3 = 0; s3 < t3; ++s3) {
          a3 <<= 8;
          a3 += i2[e2++];
        }
        s2.push(o2 + a3);
      }
      g2 = s2[a2];
    }
    for (r2 = 0, n2 = s2.length - 1; r2 < n2; ++r2) {
      const e3 = s2[r2], a3 = s2[r2 + 1];
      t2.add(i2.subarray(e3, a3));
    }
    return { obj: t2, endPos: g2 };
  }
  parseNameIndex(e2) {
    const t2 = [];
    for (let i2 = 0, a2 = e2.count; i2 < a2; ++i2) {
      const a3 = e2.get(i2);
      t2.push(bytesToString(a3));
    }
    return t2;
  }
  parseStringIndex(e2) {
    const t2 = new CFFStrings();
    for (let i2 = 0, a2 = e2.count; i2 < a2; ++i2) {
      const a3 = e2.get(i2);
      t2.add(bytesToString(a3));
    }
    return t2;
  }
  createDict(e2, t2, i2) {
    const a2 = new e2(i2);
    for (const [e3, i3] of t2)
      a2.setByKey(e3, i3);
    return a2;
  }
  parseCharString(e2, t2, i2, a2) {
    if (!t2 || e2.callDepth > 10)
      return false;
    let s2 = e2.stackSize;
    const r2 = e2.stack;
    let n2 = t2.length;
    for (let g2 = 0; g2 < n2; ) {
      const o2 = t2[g2++];
      let c2 = null;
      if (12 === o2) {
        const e3 = t2[g2++];
        if (0 === e3) {
          t2[g2 - 2] = 139;
          t2[g2 - 1] = 22;
          s2 = 0;
        } else
          c2 = Ri[e3];
      } else if (28 === o2) {
        r2[s2] = (t2[g2] << 24 | t2[g2 + 1] << 16) >> 16;
        g2 += 2;
        s2++;
      } else if (14 === o2) {
        if (s2 >= 4) {
          s2 -= 4;
          if (this.seacAnalysisEnabled) {
            e2.seac = r2.slice(s2, s2 + 4);
            return false;
          }
        }
        c2 = ki[o2];
      } else if (o2 >= 32 && o2 <= 246) {
        r2[s2] = o2 - 139;
        s2++;
      } else if (o2 >= 247 && o2 <= 254) {
        r2[s2] = o2 < 251 ? (o2 - 247 << 8) + t2[g2] + 108 : -(o2 - 251 << 8) - t2[g2] - 108;
        g2++;
        s2++;
      } else if (255 === o2) {
        r2[s2] = (t2[g2] << 24 | t2[g2 + 1] << 16 | t2[g2 + 2] << 8 | t2[g2 + 3]) / 65536;
        g2 += 4;
        s2++;
      } else if (19 === o2 || 20 === o2) {
        e2.hints += s2 >> 1;
        if (0 === e2.hints) {
          t2.copyWithin(g2 - 1, g2, -1);
          g2 -= 1;
          n2 -= 1;
          continue;
        }
        g2 += e2.hints + 7 >> 3;
        s2 %= 2;
        c2 = ki[o2];
      } else {
        if (10 === o2 || 29 === o2) {
          const t3 = 10 === o2 ? i2 : a2;
          if (!t3) {
            c2 = ki[o2];
            warn("Missing subrsIndex for " + c2.id);
            return false;
          }
          let n3 = 32768;
          t3.count < 1240 ? n3 = 107 : t3.count < 33900 && (n3 = 1131);
          const g3 = r2[--s2] + n3;
          if (g3 < 0 || g3 >= t3.count || isNaN(g3)) {
            c2 = ki[o2];
            warn("Out of bounds subrIndex for " + c2.id);
            return false;
          }
          e2.stackSize = s2;
          e2.callDepth++;
          if (!this.parseCharString(e2, t3.get(g3), i2, a2))
            return false;
          e2.callDepth--;
          s2 = e2.stackSize;
          continue;
        }
        if (11 === o2) {
          e2.stackSize = s2;
          return true;
        }
        if (0 === o2 && g2 === t2.length) {
          t2[g2 - 1] = 14;
          c2 = ki[14];
        } else {
          if (9 === o2) {
            t2.copyWithin(g2 - 1, g2, -1);
            g2 -= 1;
            n2 -= 1;
            continue;
          }
          c2 = ki[o2];
        }
      }
      if (c2) {
        if (c2.stem) {
          e2.hints += s2 >> 1;
          if (3 === o2 || 23 === o2)
            e2.hasVStems = true;
          else if (e2.hasVStems && (1 === o2 || 18 === o2)) {
            warn("CFF stem hints are in wrong order");
            t2[g2 - 1] = 1 === o2 ? 3 : 23;
          }
        }
        if ("min" in c2 && !e2.undefStack && s2 < c2.min) {
          warn("Not enough parameters for " + c2.id + "; actual: " + s2 + ", expected: " + c2.min);
          if (0 === s2) {
            t2[g2 - 1] = 14;
            return true;
          }
          return false;
        }
        if (e2.firstStackClearing && c2.stackClearing) {
          e2.firstStackClearing = false;
          s2 -= c2.min;
          s2 >= 2 && c2.stem ? s2 %= 2 : s2 > 1 && warn("Found too many parameters for stack-clearing command");
          s2 > 0 && (e2.width = r2[s2 - 1]);
        }
        if ("stackDelta" in c2) {
          "stackFn" in c2 && c2.stackFn(r2, s2);
          s2 += c2.stackDelta;
        } else if (c2.stackClearing)
          s2 = 0;
        else if (c2.resetStack) {
          s2 = 0;
          e2.undefStack = false;
        } else if (c2.undefStack) {
          s2 = 0;
          e2.undefStack = true;
          e2.firstStackClearing = false;
        }
      }
    }
    n2 < t2.length && t2.fill(14, n2);
    e2.stackSize = s2;
    return true;
  }
  parseCharStrings({ charStrings: e2, localSubrIndex: t2, globalSubrIndex: i2, fdSelect: a2, fdArray: s2, privateDict: r2 }) {
    const n2 = [], g2 = [], o2 = e2.count;
    for (let c2 = 0; c2 < o2; c2++) {
      const o3 = e2.get(c2), C2 = { callDepth: 0, stackSize: 0, stack: [], undefStack: true, hints: 0, firstStackClearing: true, seac: null, width: null, hasVStems: false };
      let h2 = true, l2 = null, Q2 = r2;
      if (a2 && s2.length) {
        const e3 = a2.getFDIndex(c2);
        if (-1 === e3) {
          warn("Glyph index is not in fd select.");
          h2 = false;
        }
        if (e3 >= s2.length) {
          warn("Invalid fd index for glyph index.");
          h2 = false;
        }
        if (h2) {
          Q2 = s2[e3].privateDict;
          l2 = Q2.subrsIndex;
        }
      } else
        t2 && (l2 = t2);
      h2 && (h2 = this.parseCharString(C2, o3, l2, i2));
      if (null !== C2.width) {
        const e3 = Q2.getByName("nominalWidthX");
        g2[c2] = e3 + C2.width;
      } else {
        const e3 = Q2.getByName("defaultWidthX");
        g2[c2] = e3;
      }
      null !== C2.seac && (n2[c2] = C2.seac);
      h2 || e2.set(c2, new Uint8Array([14]));
    }
    return { charStrings: e2, seacs: n2, widths: g2 };
  }
  emptyPrivateDictionary(e2) {
    const t2 = this.createDict(CFFPrivateDict, [], e2.strings);
    e2.setByKey(18, [0, 0]);
    e2.privateDict = t2;
  }
  parsePrivateDict(e2) {
    if (!e2.hasName("Private")) {
      this.emptyPrivateDictionary(e2);
      return;
    }
    const t2 = e2.getByName("Private");
    if (!Array.isArray(t2) || 2 !== t2.length) {
      e2.removeByName("Private");
      return;
    }
    const i2 = t2[0], a2 = t2[1];
    if (0 === i2 || a2 >= this.bytes.length) {
      this.emptyPrivateDictionary(e2);
      return;
    }
    const s2 = a2 + i2, r2 = this.bytes.subarray(a2, s2), n2 = this.parseDict(r2), g2 = this.createDict(CFFPrivateDict, n2, e2.strings);
    e2.privateDict = g2;
    0 === g2.getByName("ExpansionFactor") && g2.setByName("ExpansionFactor", 0.06);
    if (!g2.getByName("Subrs"))
      return;
    const o2 = g2.getByName("Subrs"), c2 = a2 + o2;
    if (0 === o2 || c2 >= this.bytes.length) {
      this.emptyPrivateDictionary(e2);
      return;
    }
    const C2 = this.parseIndex(c2);
    g2.subrsIndex = C2.obj;
  }
  parseCharsets(e2, t2, i2, a2) {
    if (0 === e2)
      return new CFFCharset(true, xi.ISO_ADOBE, Ei);
    if (1 === e2)
      return new CFFCharset(true, xi.EXPERT, ui);
    if (2 === e2)
      return new CFFCharset(true, xi.EXPERT_SUBSET, di);
    const s2 = this.bytes, r2 = e2, n2 = s2[e2++], g2 = [a2 ? 0 : ".notdef"];
    let o2, c2, C2;
    t2 -= 1;
    switch (n2) {
      case 0:
        for (C2 = 0; C2 < t2; C2++) {
          o2 = s2[e2++] << 8 | s2[e2++];
          g2.push(a2 ? o2 : i2.get(o2));
        }
        break;
      case 1:
        for (; g2.length <= t2; ) {
          o2 = s2[e2++] << 8 | s2[e2++];
          c2 = s2[e2++];
          for (C2 = 0; C2 <= c2; C2++)
            g2.push(a2 ? o2++ : i2.get(o2++));
        }
        break;
      case 2:
        for (; g2.length <= t2; ) {
          o2 = s2[e2++] << 8 | s2[e2++];
          c2 = s2[e2++] << 8 | s2[e2++];
          for (C2 = 0; C2 <= c2; C2++)
            g2.push(a2 ? o2++ : i2.get(o2++));
        }
        break;
      default:
        throw new FormatError("Unknown charset format");
    }
    const h2 = e2, l2 = s2.subarray(r2, h2);
    return new CFFCharset(false, n2, g2, l2);
  }
  parseEncoding(e2, t2, i2, a2) {
    const s2 = /* @__PURE__ */ Object.create(null), r2 = this.bytes;
    let n2, g2, o2, c2 = false, C2 = null;
    if (0 === e2 || 1 === e2) {
      c2 = true;
      n2 = e2;
      const t3 = e2 ? fi : yi;
      for (g2 = 0, o2 = a2.length; g2 < o2; g2++) {
        const e3 = t3.indexOf(a2[g2]);
        -1 !== e3 && (s2[e3] = g2);
      }
    } else {
      const t3 = e2;
      n2 = r2[e2++];
      switch (127 & n2) {
        case 0:
          const t4 = r2[e2++];
          for (g2 = 1; g2 <= t4; g2++)
            s2[r2[e2++]] = g2;
          break;
        case 1:
          const i3 = r2[e2++];
          let a3 = 1;
          for (g2 = 0; g2 < i3; g2++) {
            const t5 = r2[e2++], i4 = r2[e2++];
            for (let e3 = t5; e3 <= t5 + i4; e3++)
              s2[e3] = a3++;
          }
          break;
        default:
          throw new FormatError(`Unknown encoding format: ${n2} in CFF`);
      }
      const o3 = e2;
      if (128 & n2) {
        r2[t3] &= 127;
        !function readSupplement() {
          const t4 = r2[e2++];
          for (g2 = 0; g2 < t4; g2++) {
            const t5 = r2[e2++], n3 = (r2[e2++] << 8) + (255 & r2[e2++]);
            s2[t5] = a2.indexOf(i2.get(n3));
          }
        }();
      }
      C2 = r2.subarray(t3, o3);
    }
    n2 &= 127;
    return new CFFEncoding(c2, n2, s2, C2);
  }
  parseFDSelect(e2, t2) {
    const i2 = this.bytes, a2 = i2[e2++], s2 = [];
    let r2;
    switch (a2) {
      case 0:
        for (r2 = 0; r2 < t2; ++r2) {
          const t3 = i2[e2++];
          s2.push(t3);
        }
        break;
      case 3:
        const n2 = i2[e2++] << 8 | i2[e2++];
        for (r2 = 0; r2 < n2; ++r2) {
          let t3 = i2[e2++] << 8 | i2[e2++];
          if (0 === r2 && 0 !== t3) {
            warn("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");
            t3 = 0;
          }
          const a3 = i2[e2++], n3 = i2[e2] << 8 | i2[e2 + 1];
          for (let e3 = t3; e3 < n3; ++e3)
            s2.push(a3);
        }
        e2 += 2;
        break;
      default:
        throw new FormatError(`parseFDSelect: Unknown format "${a2}".`);
    }
    if (s2.length !== t2)
      throw new FormatError("parseFDSelect: Invalid font data.");
    return new CFFFDSelect(a2, s2);
  }
};
var CFF = class {
  constructor() {
    this.header = null;
    this.names = [];
    this.topDict = null;
    this.strings = new CFFStrings();
    this.globalSubrIndex = null;
    this.encoding = null;
    this.charset = null;
    this.charStrings = null;
    this.fdArray = [];
    this.fdSelect = null;
    this.isCIDFont = false;
  }
  duplicateFirstGlyph() {
    if (this.charStrings.count >= 65535) {
      warn("Not enough space in charstrings to duplicate first glyph.");
      return;
    }
    const e2 = this.charStrings.get(0);
    this.charStrings.add(e2);
    this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
  }
  hasGlyphId(e2) {
    if (e2 < 0 || e2 >= this.charStrings.count)
      return false;
    return this.charStrings.get(e2).length > 0;
  }
};
var CFFHeader = class {
  constructor(e2, t2, i2, a2) {
    this.major = e2;
    this.minor = t2;
    this.hdrSize = i2;
    this.offSize = a2;
  }
};
var CFFStrings = class {
  constructor() {
    this.strings = [];
  }
  get(e2) {
    return e2 >= 0 && e2 <= 390 ? Fi[e2] : e2 - Si <= this.strings.length ? this.strings[e2 - Si] : Fi[0];
  }
  getSID(e2) {
    let t2 = Fi.indexOf(e2);
    if (-1 !== t2)
      return t2;
    t2 = this.strings.indexOf(e2);
    return -1 !== t2 ? t2 + Si : -1;
  }
  add(e2) {
    this.strings.push(e2);
  }
  get count() {
    return this.strings.length;
  }
};
var CFFIndex = class {
  constructor() {
    this.objects = [];
    this.length = 0;
  }
  add(e2) {
    this.length += e2.length;
    this.objects.push(e2);
  }
  set(e2, t2) {
    this.length += t2.length - this.objects[e2].length;
    this.objects[e2] = t2;
  }
  get(e2) {
    return this.objects[e2];
  }
  get count() {
    return this.objects.length;
  }
};
var CFFDict = class {
  constructor(e2, t2) {
    this.keyToNameMap = e2.keyToNameMap;
    this.nameToKeyMap = e2.nameToKeyMap;
    this.defaults = e2.defaults;
    this.types = e2.types;
    this.opcodes = e2.opcodes;
    this.order = e2.order;
    this.strings = t2;
    this.values = /* @__PURE__ */ Object.create(null);
  }
  setByKey(e2, t2) {
    if (!(e2 in this.keyToNameMap))
      return false;
    if (0 === t2.length)
      return true;
    for (const i3 of t2)
      if (isNaN(i3)) {
        warn(`Invalid CFFDict value: "${t2}" for key "${e2}".`);
        return true;
      }
    const i2 = this.types[e2];
    "num" !== i2 && "sid" !== i2 && "offset" !== i2 || (t2 = t2[0]);
    this.values[e2] = t2;
    return true;
  }
  setByName(e2, t2) {
    if (!(e2 in this.nameToKeyMap))
      throw new FormatError(`Invalid dictionary name "${e2}"`);
    this.values[this.nameToKeyMap[e2]] = t2;
  }
  hasName(e2) {
    return this.nameToKeyMap[e2] in this.values;
  }
  getByName(e2) {
    if (!(e2 in this.nameToKeyMap))
      throw new FormatError(`Invalid dictionary name ${e2}"`);
    const t2 = this.nameToKeyMap[e2];
    return t2 in this.values ? this.values[t2] : this.defaults[t2];
  }
  removeByName(e2) {
    delete this.values[this.nameToKeyMap[e2]];
  }
  static createTables(e2) {
    const t2 = { keyToNameMap: {}, nameToKeyMap: {}, defaults: {}, types: {}, opcodes: {}, order: [] };
    for (const i2 of e2) {
      const e3 = Array.isArray(i2[0]) ? (i2[0][0] << 8) + i2[0][1] : i2[0];
      t2.keyToNameMap[e3] = i2[1];
      t2.nameToKeyMap[i2[1]] = e3;
      t2.types[e3] = i2[2];
      t2.defaults[e3] = i2[3];
      t2.opcodes[e3] = Array.isArray(i2[0]) ? i2[0] : [i2[0]];
      t2.order.push(e3);
    }
    return t2;
  }
};
var Ni = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
var CFFTopDict = class _CFFTopDict extends CFFDict {
  static get tables() {
    return shadow(this, "tables", this.createTables(Ni));
  }
  constructor(e2) {
    super(_CFFTopDict.tables, e2);
    this.privateDict = null;
  }
};
var Gi = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
var CFFPrivateDict = class _CFFPrivateDict extends CFFDict {
  static get tables() {
    return shadow(this, "tables", this.createTables(Gi));
  }
  constructor(e2) {
    super(_CFFPrivateDict.tables, e2);
    this.subrsIndex = null;
  }
};
var xi = { ISO_ADOBE: 0, EXPERT: 1, EXPERT_SUBSET: 2 };
var CFFCharset = class {
  constructor(e2, t2, i2, a2) {
    this.predefined = e2;
    this.format = t2;
    this.charset = i2;
    this.raw = a2;
  }
};
var CFFEncoding = class {
  constructor(e2, t2, i2, a2) {
    this.predefined = e2;
    this.format = t2;
    this.encoding = i2;
    this.raw = a2;
  }
};
var CFFFDSelect = class {
  constructor(e2, t2) {
    this.format = e2;
    this.fdSelect = t2;
  }
  getFDIndex(e2) {
    return e2 < 0 || e2 >= this.fdSelect.length ? -1 : this.fdSelect[e2];
  }
};
var CFFOffsetTracker = class {
  constructor() {
    this.offsets = /* @__PURE__ */ Object.create(null);
  }
  isTracking(e2) {
    return e2 in this.offsets;
  }
  track(e2, t2) {
    if (e2 in this.offsets)
      throw new FormatError(`Already tracking location of ${e2}`);
    this.offsets[e2] = t2;
  }
  offset(e2) {
    for (const t2 in this.offsets)
      this.offsets[t2] += e2;
  }
  setEntryLocation(e2, t2, i2) {
    if (!(e2 in this.offsets))
      throw new FormatError(`Not tracking location of ${e2}`);
    const a2 = i2.data, s2 = this.offsets[e2];
    for (let e3 = 0, i3 = t2.length; e3 < i3; ++e3) {
      const i4 = 5 * e3 + s2, r2 = i4 + 1, n2 = i4 + 2, g2 = i4 + 3, o2 = i4 + 4;
      if (29 !== a2[i4] || 0 !== a2[r2] || 0 !== a2[n2] || 0 !== a2[g2] || 0 !== a2[o2])
        throw new FormatError("writing to an offset that is not empty");
      const c2 = t2[e3];
      a2[i4] = 29;
      a2[r2] = c2 >> 24 & 255;
      a2[n2] = c2 >> 16 & 255;
      a2[g2] = c2 >> 8 & 255;
      a2[o2] = 255 & c2;
    }
  }
};
var CFFCompiler = class _CFFCompiler {
  constructor(e2) {
    this.cff = e2;
  }
  compile() {
    const e2 = this.cff, t2 = { data: [], length: 0, add(e3) {
      try {
        this.data.push(...e3);
      } catch {
        this.data = this.data.concat(e3);
      }
      this.length = this.data.length;
    } }, i2 = this.compileHeader(e2.header);
    t2.add(i2);
    const a2 = this.compileNameIndex(e2.names);
    t2.add(a2);
    if (e2.isCIDFont && e2.topDict.hasName("FontMatrix")) {
      const t3 = e2.topDict.getByName("FontMatrix");
      e2.topDict.removeByName("FontMatrix");
      for (const i3 of e2.fdArray) {
        let e3 = t3.slice(0);
        i3.hasName("FontMatrix") && (e3 = Util.transform(e3, i3.getByName("FontMatrix")));
        i3.setByName("FontMatrix", e3);
      }
    }
    const s2 = e2.topDict.getByName("XUID");
    (s2 == null ? void 0 : s2.length) > 16 && e2.topDict.removeByName("XUID");
    e2.topDict.setByName("charset", 0);
    let r2 = this.compileTopDicts([e2.topDict], t2.length, e2.isCIDFont);
    t2.add(r2.output);
    const n2 = r2.trackers[0], g2 = this.compileStringIndex(e2.strings.strings);
    t2.add(g2);
    const o2 = this.compileIndex(e2.globalSubrIndex);
    t2.add(o2);
    if (e2.encoding && e2.topDict.hasName("Encoding"))
      if (e2.encoding.predefined)
        n2.setEntryLocation("Encoding", [e2.encoding.format], t2);
      else {
        const i3 = this.compileEncoding(e2.encoding);
        n2.setEntryLocation("Encoding", [t2.length], t2);
        t2.add(i3);
      }
    const c2 = this.compileCharset(e2.charset, e2.charStrings.count, e2.strings, e2.isCIDFont);
    n2.setEntryLocation("charset", [t2.length], t2);
    t2.add(c2);
    const C2 = this.compileCharStrings(e2.charStrings);
    n2.setEntryLocation("CharStrings", [t2.length], t2);
    t2.add(C2);
    if (e2.isCIDFont) {
      n2.setEntryLocation("FDSelect", [t2.length], t2);
      const i3 = this.compileFDSelect(e2.fdSelect);
      t2.add(i3);
      r2 = this.compileTopDicts(e2.fdArray, t2.length, true);
      n2.setEntryLocation("FDArray", [t2.length], t2);
      t2.add(r2.output);
      const a3 = r2.trackers;
      this.compilePrivateDicts(e2.fdArray, a3, t2);
    }
    this.compilePrivateDicts([e2.topDict], [n2], t2);
    t2.add([0]);
    return t2.data;
  }
  encodeNumber(e2) {
    return Number.isInteger(e2) ? this.encodeInteger(e2) : this.encodeFloat(e2);
  }
  static get EncodeFloatRegExp() {
    return shadow(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
  }
  encodeFloat(e2) {
    let t2 = e2.toString();
    const i2 = _CFFCompiler.EncodeFloatRegExp.exec(t2);
    if (i2) {
      const a3 = parseFloat("1e" + ((i2[2] ? +i2[2] : 0) + i2[1].length));
      t2 = (Math.round(e2 * a3) / a3).toString();
    }
    let a2, s2, r2 = "";
    for (a2 = 0, s2 = t2.length; a2 < s2; ++a2) {
      const e3 = t2[a2];
      r2 += "e" === e3 ? "-" === t2[++a2] ? "c" : "b" : "." === e3 ? "a" : "-" === e3 ? "e" : e3;
    }
    r2 += 1 & r2.length ? "f" : "ff";
    const n2 = [30];
    for (a2 = 0, s2 = r2.length; a2 < s2; a2 += 2)
      n2.push(parseInt(r2.substring(a2, a2 + 2), 16));
    return n2;
  }
  encodeInteger(e2) {
    let t2;
    t2 = e2 >= -107 && e2 <= 107 ? [e2 + 139] : e2 >= 108 && e2 <= 1131 ? [247 + ((e2 -= 108) >> 8), 255 & e2] : e2 >= -1131 && e2 <= -108 ? [251 + ((e2 = -e2 - 108) >> 8), 255 & e2] : e2 >= -32768 && e2 <= 32767 ? [28, e2 >> 8 & 255, 255 & e2] : [29, e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2];
    return t2;
  }
  compileHeader(e2) {
    return [e2.major, e2.minor, 4, e2.offSize];
  }
  compileNameIndex(e2) {
    const t2 = new CFFIndex();
    for (const i2 of e2) {
      const e3 = Math.min(i2.length, 127);
      let a2 = new Array(e3);
      for (let t3 = 0; t3 < e3; t3++) {
        let e4 = i2[t3];
        (e4 < "!" || e4 > "~" || "[" === e4 || "]" === e4 || "(" === e4 || ")" === e4 || "{" === e4 || "}" === e4 || "<" === e4 || ">" === e4 || "/" === e4 || "%" === e4) && (e4 = "_");
        a2[t3] = e4;
      }
      a2 = a2.join("");
      "" === a2 && (a2 = "Bad_Font_Name");
      t2.add(stringToBytes(a2));
    }
    return this.compileIndex(t2);
  }
  compileTopDicts(e2, t2, i2) {
    const a2 = [];
    let s2 = new CFFIndex();
    for (const r2 of e2) {
      if (i2) {
        r2.removeByName("CIDFontVersion");
        r2.removeByName("CIDFontRevision");
        r2.removeByName("CIDFontType");
        r2.removeByName("CIDCount");
        r2.removeByName("UIDBase");
      }
      const e3 = new CFFOffsetTracker(), n2 = this.compileDict(r2, e3);
      a2.push(e3);
      s2.add(n2);
      e3.offset(t2);
    }
    s2 = this.compileIndex(s2, a2);
    return { trackers: a2, output: s2 };
  }
  compilePrivateDicts(e2, t2, i2) {
    for (let a2 = 0, s2 = e2.length; a2 < s2; ++a2) {
      const s3 = e2[a2], r2 = s3.privateDict;
      if (!r2 || !s3.hasName("Private"))
        throw new FormatError("There must be a private dictionary.");
      const n2 = new CFFOffsetTracker(), g2 = this.compileDict(r2, n2);
      let o2 = i2.length;
      n2.offset(o2);
      g2.length || (o2 = 0);
      t2[a2].setEntryLocation("Private", [g2.length, o2], i2);
      i2.add(g2);
      if (r2.subrsIndex && r2.hasName("Subrs")) {
        const e3 = this.compileIndex(r2.subrsIndex);
        n2.setEntryLocation("Subrs", [g2.length], i2);
        i2.add(e3);
      }
    }
  }
  compileDict(e2, t2) {
    const i2 = [];
    for (const a2 of e2.order) {
      if (!(a2 in e2.values))
        continue;
      let s2 = e2.values[a2], r2 = e2.types[a2];
      Array.isArray(r2) || (r2 = [r2]);
      Array.isArray(s2) || (s2 = [s2]);
      if (0 !== s2.length) {
        for (let n2 = 0, g2 = r2.length; n2 < g2; ++n2) {
          const g3 = r2[n2], o2 = s2[n2];
          switch (g3) {
            case "num":
            case "sid":
              i2.push(...this.encodeNumber(o2));
              break;
            case "offset":
              const r3 = e2.keyToNameMap[a2];
              t2.isTracking(r3) || t2.track(r3, i2.length);
              i2.push(29, 0, 0, 0, 0);
              break;
            case "array":
            case "delta":
              i2.push(...this.encodeNumber(o2));
              for (let e3 = 1, t3 = s2.length; e3 < t3; ++e3)
                i2.push(...this.encodeNumber(s2[e3]));
              break;
            default:
              throw new FormatError(`Unknown data type of ${g3}`);
          }
        }
        i2.push(...e2.opcodes[a2]);
      }
    }
    return i2;
  }
  compileStringIndex(e2) {
    const t2 = new CFFIndex();
    for (const i2 of e2)
      t2.add(stringToBytes(i2));
    return this.compileIndex(t2);
  }
  compileCharStrings(e2) {
    const t2 = new CFFIndex();
    for (let i2 = 0; i2 < e2.count; i2++) {
      const a2 = e2.get(i2);
      0 !== a2.length ? t2.add(a2) : t2.add(new Uint8Array([139, 14]));
    }
    return this.compileIndex(t2);
  }
  compileCharset(e2, t2, i2, a2) {
    let s2;
    const r2 = t2 - 1;
    if (a2)
      s2 = new Uint8Array([2, 0, 0, r2 >> 8 & 255, 255 & r2]);
    else {
      s2 = new Uint8Array(1 + 2 * r2);
      s2[0] = 0;
      let t3 = 0;
      const a3 = e2.charset.length;
      let n2 = false;
      for (let r3 = 1; r3 < s2.length; r3 += 2) {
        let g2 = 0;
        if (t3 < a3) {
          const a4 = e2.charset[t3++];
          g2 = i2.getSID(a4);
          if (-1 === g2) {
            g2 = 0;
            if (!n2) {
              n2 = true;
              warn(`Couldn't find ${a4} in CFF strings`);
            }
          }
        }
        s2[r3] = g2 >> 8 & 255;
        s2[r3 + 1] = 255 & g2;
      }
    }
    return this.compileTypedArray(s2);
  }
  compileEncoding(e2) {
    return this.compileTypedArray(e2.raw);
  }
  compileFDSelect(e2) {
    const t2 = e2.format;
    let i2, a2;
    switch (t2) {
      case 0:
        i2 = new Uint8Array(1 + e2.fdSelect.length);
        i2[0] = t2;
        for (a2 = 0; a2 < e2.fdSelect.length; a2++)
          i2[a2 + 1] = e2.fdSelect[a2];
        break;
      case 3:
        const s2 = 0;
        let r2 = e2.fdSelect[0];
        const n2 = [t2, 0, 0, s2 >> 8 & 255, 255 & s2, r2];
        for (a2 = 1; a2 < e2.fdSelect.length; a2++) {
          const t3 = e2.fdSelect[a2];
          if (t3 !== r2) {
            n2.push(a2 >> 8 & 255, 255 & a2, t3);
            r2 = t3;
          }
        }
        const g2 = (n2.length - 3) / 3;
        n2[1] = g2 >> 8 & 255;
        n2[2] = 255 & g2;
        n2.push(a2 >> 8 & 255, 255 & a2);
        i2 = new Uint8Array(n2);
    }
    return this.compileTypedArray(i2);
  }
  compileTypedArray(e2) {
    return Array.from(e2);
  }
  compileIndex(e2, t2 = []) {
    const i2 = e2.objects, a2 = i2.length;
    if (0 === a2)
      return [0, 0];
    const s2 = [a2 >> 8 & 255, 255 & a2];
    let r2, n2, g2 = 1;
    for (r2 = 0; r2 < a2; ++r2)
      g2 += i2[r2].length;
    n2 = g2 < 256 ? 1 : g2 < 65536 ? 2 : g2 < 16777216 ? 3 : 4;
    s2.push(n2);
    let o2 = 1;
    for (r2 = 0; r2 < a2 + 1; r2++) {
      1 === n2 ? s2.push(255 & o2) : 2 === n2 ? s2.push(o2 >> 8 & 255, 255 & o2) : 3 === n2 ? s2.push(o2 >> 16 & 255, o2 >> 8 & 255, 255 & o2) : s2.push(o2 >>> 24 & 255, o2 >> 16 & 255, o2 >> 8 & 255, 255 & o2);
      i2[r2] && (o2 += i2[r2].length);
    }
    for (r2 = 0; r2 < a2; r2++) {
      t2[r2] && t2[r2].offset(s2.length);
      s2.push(...i2[r2]);
    }
    return s2;
  }
};
var Mi = getLookupTableFactory(function(e2) {
  e2.A = 65;
  e2.AE = 198;
  e2.AEacute = 508;
  e2.AEmacron = 482;
  e2.AEsmall = 63462;
  e2.Aacute = 193;
  e2.Aacutesmall = 63457;
  e2.Abreve = 258;
  e2.Abreveacute = 7854;
  e2.Abrevecyrillic = 1232;
  e2.Abrevedotbelow = 7862;
  e2.Abrevegrave = 7856;
  e2.Abrevehookabove = 7858;
  e2.Abrevetilde = 7860;
  e2.Acaron = 461;
  e2.Acircle = 9398;
  e2.Acircumflex = 194;
  e2.Acircumflexacute = 7844;
  e2.Acircumflexdotbelow = 7852;
  e2.Acircumflexgrave = 7846;
  e2.Acircumflexhookabove = 7848;
  e2.Acircumflexsmall = 63458;
  e2.Acircumflextilde = 7850;
  e2.Acute = 63177;
  e2.Acutesmall = 63412;
  e2.Acyrillic = 1040;
  e2.Adblgrave = 512;
  e2.Adieresis = 196;
  e2.Adieresiscyrillic = 1234;
  e2.Adieresismacron = 478;
  e2.Adieresissmall = 63460;
  e2.Adotbelow = 7840;
  e2.Adotmacron = 480;
  e2.Agrave = 192;
  e2.Agravesmall = 63456;
  e2.Ahookabove = 7842;
  e2.Aiecyrillic = 1236;
  e2.Ainvertedbreve = 514;
  e2.Alpha = 913;
  e2.Alphatonos = 902;
  e2.Amacron = 256;
  e2.Amonospace = 65313;
  e2.Aogonek = 260;
  e2.Aring = 197;
  e2.Aringacute = 506;
  e2.Aringbelow = 7680;
  e2.Aringsmall = 63461;
  e2.Asmall = 63329;
  e2.Atilde = 195;
  e2.Atildesmall = 63459;
  e2.Aybarmenian = 1329;
  e2.B = 66;
  e2.Bcircle = 9399;
  e2.Bdotaccent = 7682;
  e2.Bdotbelow = 7684;
  e2.Becyrillic = 1041;
  e2.Benarmenian = 1330;
  e2.Beta = 914;
  e2.Bhook = 385;
  e2.Blinebelow = 7686;
  e2.Bmonospace = 65314;
  e2.Brevesmall = 63220;
  e2.Bsmall = 63330;
  e2.Btopbar = 386;
  e2.C = 67;
  e2.Caarmenian = 1342;
  e2.Cacute = 262;
  e2.Caron = 63178;
  e2.Caronsmall = 63221;
  e2.Ccaron = 268;
  e2.Ccedilla = 199;
  e2.Ccedillaacute = 7688;
  e2.Ccedillasmall = 63463;
  e2.Ccircle = 9400;
  e2.Ccircumflex = 264;
  e2.Cdot = 266;
  e2.Cdotaccent = 266;
  e2.Cedillasmall = 63416;
  e2.Chaarmenian = 1353;
  e2.Cheabkhasiancyrillic = 1212;
  e2.Checyrillic = 1063;
  e2.Chedescenderabkhasiancyrillic = 1214;
  e2.Chedescendercyrillic = 1206;
  e2.Chedieresiscyrillic = 1268;
  e2.Cheharmenian = 1347;
  e2.Chekhakassiancyrillic = 1227;
  e2.Cheverticalstrokecyrillic = 1208;
  e2.Chi = 935;
  e2.Chook = 391;
  e2.Circumflexsmall = 63222;
  e2.Cmonospace = 65315;
  e2.Coarmenian = 1361;
  e2.Csmall = 63331;
  e2.D = 68;
  e2.DZ = 497;
  e2.DZcaron = 452;
  e2.Daarmenian = 1332;
  e2.Dafrican = 393;
  e2.Dcaron = 270;
  e2.Dcedilla = 7696;
  e2.Dcircle = 9401;
  e2.Dcircumflexbelow = 7698;
  e2.Dcroat = 272;
  e2.Ddotaccent = 7690;
  e2.Ddotbelow = 7692;
  e2.Decyrillic = 1044;
  e2.Deicoptic = 1006;
  e2.Delta = 8710;
  e2.Deltagreek = 916;
  e2.Dhook = 394;
  e2.Dieresis = 63179;
  e2.DieresisAcute = 63180;
  e2.DieresisGrave = 63181;
  e2.Dieresissmall = 63400;
  e2.Digammagreek = 988;
  e2.Djecyrillic = 1026;
  e2.Dlinebelow = 7694;
  e2.Dmonospace = 65316;
  e2.Dotaccentsmall = 63223;
  e2.Dslash = 272;
  e2.Dsmall = 63332;
  e2.Dtopbar = 395;
  e2.Dz = 498;
  e2.Dzcaron = 453;
  e2.Dzeabkhasiancyrillic = 1248;
  e2.Dzecyrillic = 1029;
  e2.Dzhecyrillic = 1039;
  e2.E = 69;
  e2.Eacute = 201;
  e2.Eacutesmall = 63465;
  e2.Ebreve = 276;
  e2.Ecaron = 282;
  e2.Ecedillabreve = 7708;
  e2.Echarmenian = 1333;
  e2.Ecircle = 9402;
  e2.Ecircumflex = 202;
  e2.Ecircumflexacute = 7870;
  e2.Ecircumflexbelow = 7704;
  e2.Ecircumflexdotbelow = 7878;
  e2.Ecircumflexgrave = 7872;
  e2.Ecircumflexhookabove = 7874;
  e2.Ecircumflexsmall = 63466;
  e2.Ecircumflextilde = 7876;
  e2.Ecyrillic = 1028;
  e2.Edblgrave = 516;
  e2.Edieresis = 203;
  e2.Edieresissmall = 63467;
  e2.Edot = 278;
  e2.Edotaccent = 278;
  e2.Edotbelow = 7864;
  e2.Efcyrillic = 1060;
  e2.Egrave = 200;
  e2.Egravesmall = 63464;
  e2.Eharmenian = 1335;
  e2.Ehookabove = 7866;
  e2.Eightroman = 8551;
  e2.Einvertedbreve = 518;
  e2.Eiotifiedcyrillic = 1124;
  e2.Elcyrillic = 1051;
  e2.Elevenroman = 8554;
  e2.Emacron = 274;
  e2.Emacronacute = 7702;
  e2.Emacrongrave = 7700;
  e2.Emcyrillic = 1052;
  e2.Emonospace = 65317;
  e2.Encyrillic = 1053;
  e2.Endescendercyrillic = 1186;
  e2.Eng = 330;
  e2.Enghecyrillic = 1188;
  e2.Enhookcyrillic = 1223;
  e2.Eogonek = 280;
  e2.Eopen = 400;
  e2.Epsilon = 917;
  e2.Epsilontonos = 904;
  e2.Ercyrillic = 1056;
  e2.Ereversed = 398;
  e2.Ereversedcyrillic = 1069;
  e2.Escyrillic = 1057;
  e2.Esdescendercyrillic = 1194;
  e2.Esh = 425;
  e2.Esmall = 63333;
  e2.Eta = 919;
  e2.Etarmenian = 1336;
  e2.Etatonos = 905;
  e2.Eth = 208;
  e2.Ethsmall = 63472;
  e2.Etilde = 7868;
  e2.Etildebelow = 7706;
  e2.Euro = 8364;
  e2.Ezh = 439;
  e2.Ezhcaron = 494;
  e2.Ezhreversed = 440;
  e2.F = 70;
  e2.Fcircle = 9403;
  e2.Fdotaccent = 7710;
  e2.Feharmenian = 1366;
  e2.Feicoptic = 996;
  e2.Fhook = 401;
  e2.Fitacyrillic = 1138;
  e2.Fiveroman = 8548;
  e2.Fmonospace = 65318;
  e2.Fourroman = 8547;
  e2.Fsmall = 63334;
  e2.G = 71;
  e2.GBsquare = 13191;
  e2.Gacute = 500;
  e2.Gamma = 915;
  e2.Gammaafrican = 404;
  e2.Gangiacoptic = 1002;
  e2.Gbreve = 286;
  e2.Gcaron = 486;
  e2.Gcedilla = 290;
  e2.Gcircle = 9404;
  e2.Gcircumflex = 284;
  e2.Gcommaaccent = 290;
  e2.Gdot = 288;
  e2.Gdotaccent = 288;
  e2.Gecyrillic = 1043;
  e2.Ghadarmenian = 1346;
  e2.Ghemiddlehookcyrillic = 1172;
  e2.Ghestrokecyrillic = 1170;
  e2.Gheupturncyrillic = 1168;
  e2.Ghook = 403;
  e2.Gimarmenian = 1331;
  e2.Gjecyrillic = 1027;
  e2.Gmacron = 7712;
  e2.Gmonospace = 65319;
  e2.Grave = 63182;
  e2.Gravesmall = 63328;
  e2.Gsmall = 63335;
  e2.Gsmallhook = 667;
  e2.Gstroke = 484;
  e2.H = 72;
  e2.H18533 = 9679;
  e2.H18543 = 9642;
  e2.H18551 = 9643;
  e2.H22073 = 9633;
  e2.HPsquare = 13259;
  e2.Haabkhasiancyrillic = 1192;
  e2.Hadescendercyrillic = 1202;
  e2.Hardsigncyrillic = 1066;
  e2.Hbar = 294;
  e2.Hbrevebelow = 7722;
  e2.Hcedilla = 7720;
  e2.Hcircle = 9405;
  e2.Hcircumflex = 292;
  e2.Hdieresis = 7718;
  e2.Hdotaccent = 7714;
  e2.Hdotbelow = 7716;
  e2.Hmonospace = 65320;
  e2.Hoarmenian = 1344;
  e2.Horicoptic = 1e3;
  e2.Hsmall = 63336;
  e2.Hungarumlaut = 63183;
  e2.Hungarumlautsmall = 63224;
  e2.Hzsquare = 13200;
  e2.I = 73;
  e2.IAcyrillic = 1071;
  e2.IJ = 306;
  e2.IUcyrillic = 1070;
  e2.Iacute = 205;
  e2.Iacutesmall = 63469;
  e2.Ibreve = 300;
  e2.Icaron = 463;
  e2.Icircle = 9406;
  e2.Icircumflex = 206;
  e2.Icircumflexsmall = 63470;
  e2.Icyrillic = 1030;
  e2.Idblgrave = 520;
  e2.Idieresis = 207;
  e2.Idieresisacute = 7726;
  e2.Idieresiscyrillic = 1252;
  e2.Idieresissmall = 63471;
  e2.Idot = 304;
  e2.Idotaccent = 304;
  e2.Idotbelow = 7882;
  e2.Iebrevecyrillic = 1238;
  e2.Iecyrillic = 1045;
  e2.Ifraktur = 8465;
  e2.Igrave = 204;
  e2.Igravesmall = 63468;
  e2.Ihookabove = 7880;
  e2.Iicyrillic = 1048;
  e2.Iinvertedbreve = 522;
  e2.Iishortcyrillic = 1049;
  e2.Imacron = 298;
  e2.Imacroncyrillic = 1250;
  e2.Imonospace = 65321;
  e2.Iniarmenian = 1339;
  e2.Iocyrillic = 1025;
  e2.Iogonek = 302;
  e2.Iota = 921;
  e2.Iotaafrican = 406;
  e2.Iotadieresis = 938;
  e2.Iotatonos = 906;
  e2.Ismall = 63337;
  e2.Istroke = 407;
  e2.Itilde = 296;
  e2.Itildebelow = 7724;
  e2.Izhitsacyrillic = 1140;
  e2.Izhitsadblgravecyrillic = 1142;
  e2.J = 74;
  e2.Jaarmenian = 1345;
  e2.Jcircle = 9407;
  e2.Jcircumflex = 308;
  e2.Jecyrillic = 1032;
  e2.Jheharmenian = 1355;
  e2.Jmonospace = 65322;
  e2.Jsmall = 63338;
  e2.K = 75;
  e2.KBsquare = 13189;
  e2.KKsquare = 13261;
  e2.Kabashkircyrillic = 1184;
  e2.Kacute = 7728;
  e2.Kacyrillic = 1050;
  e2.Kadescendercyrillic = 1178;
  e2.Kahookcyrillic = 1219;
  e2.Kappa = 922;
  e2.Kastrokecyrillic = 1182;
  e2.Kaverticalstrokecyrillic = 1180;
  e2.Kcaron = 488;
  e2.Kcedilla = 310;
  e2.Kcircle = 9408;
  e2.Kcommaaccent = 310;
  e2.Kdotbelow = 7730;
  e2.Keharmenian = 1364;
  e2.Kenarmenian = 1343;
  e2.Khacyrillic = 1061;
  e2.Kheicoptic = 998;
  e2.Khook = 408;
  e2.Kjecyrillic = 1036;
  e2.Klinebelow = 7732;
  e2.Kmonospace = 65323;
  e2.Koppacyrillic = 1152;
  e2.Koppagreek = 990;
  e2.Ksicyrillic = 1134;
  e2.Ksmall = 63339;
  e2.L = 76;
  e2.LJ = 455;
  e2.LL = 63167;
  e2.Lacute = 313;
  e2.Lambda = 923;
  e2.Lcaron = 317;
  e2.Lcedilla = 315;
  e2.Lcircle = 9409;
  e2.Lcircumflexbelow = 7740;
  e2.Lcommaaccent = 315;
  e2.Ldot = 319;
  e2.Ldotaccent = 319;
  e2.Ldotbelow = 7734;
  e2.Ldotbelowmacron = 7736;
  e2.Liwnarmenian = 1340;
  e2.Lj = 456;
  e2.Ljecyrillic = 1033;
  e2.Llinebelow = 7738;
  e2.Lmonospace = 65324;
  e2.Lslash = 321;
  e2.Lslashsmall = 63225;
  e2.Lsmall = 63340;
  e2.M = 77;
  e2.MBsquare = 13190;
  e2.Macron = 63184;
  e2.Macronsmall = 63407;
  e2.Macute = 7742;
  e2.Mcircle = 9410;
  e2.Mdotaccent = 7744;
  e2.Mdotbelow = 7746;
  e2.Menarmenian = 1348;
  e2.Mmonospace = 65325;
  e2.Msmall = 63341;
  e2.Mturned = 412;
  e2.Mu = 924;
  e2.N = 78;
  e2.NJ = 458;
  e2.Nacute = 323;
  e2.Ncaron = 327;
  e2.Ncedilla = 325;
  e2.Ncircle = 9411;
  e2.Ncircumflexbelow = 7754;
  e2.Ncommaaccent = 325;
  e2.Ndotaccent = 7748;
  e2.Ndotbelow = 7750;
  e2.Nhookleft = 413;
  e2.Nineroman = 8552;
  e2.Nj = 459;
  e2.Njecyrillic = 1034;
  e2.Nlinebelow = 7752;
  e2.Nmonospace = 65326;
  e2.Nowarmenian = 1350;
  e2.Nsmall = 63342;
  e2.Ntilde = 209;
  e2.Ntildesmall = 63473;
  e2.Nu = 925;
  e2.O = 79;
  e2.OE = 338;
  e2.OEsmall = 63226;
  e2.Oacute = 211;
  e2.Oacutesmall = 63475;
  e2.Obarredcyrillic = 1256;
  e2.Obarreddieresiscyrillic = 1258;
  e2.Obreve = 334;
  e2.Ocaron = 465;
  e2.Ocenteredtilde = 415;
  e2.Ocircle = 9412;
  e2.Ocircumflex = 212;
  e2.Ocircumflexacute = 7888;
  e2.Ocircumflexdotbelow = 7896;
  e2.Ocircumflexgrave = 7890;
  e2.Ocircumflexhookabove = 7892;
  e2.Ocircumflexsmall = 63476;
  e2.Ocircumflextilde = 7894;
  e2.Ocyrillic = 1054;
  e2.Odblacute = 336;
  e2.Odblgrave = 524;
  e2.Odieresis = 214;
  e2.Odieresiscyrillic = 1254;
  e2.Odieresissmall = 63478;
  e2.Odotbelow = 7884;
  e2.Ogoneksmall = 63227;
  e2.Ograve = 210;
  e2.Ogravesmall = 63474;
  e2.Oharmenian = 1365;
  e2.Ohm = 8486;
  e2.Ohookabove = 7886;
  e2.Ohorn = 416;
  e2.Ohornacute = 7898;
  e2.Ohorndotbelow = 7906;
  e2.Ohorngrave = 7900;
  e2.Ohornhookabove = 7902;
  e2.Ohorntilde = 7904;
  e2.Ohungarumlaut = 336;
  e2.Oi = 418;
  e2.Oinvertedbreve = 526;
  e2.Omacron = 332;
  e2.Omacronacute = 7762;
  e2.Omacrongrave = 7760;
  e2.Omega = 8486;
  e2.Omegacyrillic = 1120;
  e2.Omegagreek = 937;
  e2.Omegaroundcyrillic = 1146;
  e2.Omegatitlocyrillic = 1148;
  e2.Omegatonos = 911;
  e2.Omicron = 927;
  e2.Omicrontonos = 908;
  e2.Omonospace = 65327;
  e2.Oneroman = 8544;
  e2.Oogonek = 490;
  e2.Oogonekmacron = 492;
  e2.Oopen = 390;
  e2.Oslash = 216;
  e2.Oslashacute = 510;
  e2.Oslashsmall = 63480;
  e2.Osmall = 63343;
  e2.Ostrokeacute = 510;
  e2.Otcyrillic = 1150;
  e2.Otilde = 213;
  e2.Otildeacute = 7756;
  e2.Otildedieresis = 7758;
  e2.Otildesmall = 63477;
  e2.P = 80;
  e2.Pacute = 7764;
  e2.Pcircle = 9413;
  e2.Pdotaccent = 7766;
  e2.Pecyrillic = 1055;
  e2.Peharmenian = 1354;
  e2.Pemiddlehookcyrillic = 1190;
  e2.Phi = 934;
  e2.Phook = 420;
  e2.Pi = 928;
  e2.Piwrarmenian = 1363;
  e2.Pmonospace = 65328;
  e2.Psi = 936;
  e2.Psicyrillic = 1136;
  e2.Psmall = 63344;
  e2.Q = 81;
  e2.Qcircle = 9414;
  e2.Qmonospace = 65329;
  e2.Qsmall = 63345;
  e2.R = 82;
  e2.Raarmenian = 1356;
  e2.Racute = 340;
  e2.Rcaron = 344;
  e2.Rcedilla = 342;
  e2.Rcircle = 9415;
  e2.Rcommaaccent = 342;
  e2.Rdblgrave = 528;
  e2.Rdotaccent = 7768;
  e2.Rdotbelow = 7770;
  e2.Rdotbelowmacron = 7772;
  e2.Reharmenian = 1360;
  e2.Rfraktur = 8476;
  e2.Rho = 929;
  e2.Ringsmall = 63228;
  e2.Rinvertedbreve = 530;
  e2.Rlinebelow = 7774;
  e2.Rmonospace = 65330;
  e2.Rsmall = 63346;
  e2.Rsmallinverted = 641;
  e2.Rsmallinvertedsuperior = 694;
  e2.S = 83;
  e2.SF010000 = 9484;
  e2.SF020000 = 9492;
  e2.SF030000 = 9488;
  e2.SF040000 = 9496;
  e2.SF050000 = 9532;
  e2.SF060000 = 9516;
  e2.SF070000 = 9524;
  e2.SF080000 = 9500;
  e2.SF090000 = 9508;
  e2.SF100000 = 9472;
  e2.SF110000 = 9474;
  e2.SF190000 = 9569;
  e2.SF200000 = 9570;
  e2.SF210000 = 9558;
  e2.SF220000 = 9557;
  e2.SF230000 = 9571;
  e2.SF240000 = 9553;
  e2.SF250000 = 9559;
  e2.SF260000 = 9565;
  e2.SF270000 = 9564;
  e2.SF280000 = 9563;
  e2.SF360000 = 9566;
  e2.SF370000 = 9567;
  e2.SF380000 = 9562;
  e2.SF390000 = 9556;
  e2.SF400000 = 9577;
  e2.SF410000 = 9574;
  e2.SF420000 = 9568;
  e2.SF430000 = 9552;
  e2.SF440000 = 9580;
  e2.SF450000 = 9575;
  e2.SF460000 = 9576;
  e2.SF470000 = 9572;
  e2.SF480000 = 9573;
  e2.SF490000 = 9561;
  e2.SF500000 = 9560;
  e2.SF510000 = 9554;
  e2.SF520000 = 9555;
  e2.SF530000 = 9579;
  e2.SF540000 = 9578;
  e2.Sacute = 346;
  e2.Sacutedotaccent = 7780;
  e2.Sampigreek = 992;
  e2.Scaron = 352;
  e2.Scarondotaccent = 7782;
  e2.Scaronsmall = 63229;
  e2.Scedilla = 350;
  e2.Schwa = 399;
  e2.Schwacyrillic = 1240;
  e2.Schwadieresiscyrillic = 1242;
  e2.Scircle = 9416;
  e2.Scircumflex = 348;
  e2.Scommaaccent = 536;
  e2.Sdotaccent = 7776;
  e2.Sdotbelow = 7778;
  e2.Sdotbelowdotaccent = 7784;
  e2.Seharmenian = 1357;
  e2.Sevenroman = 8550;
  e2.Shaarmenian = 1351;
  e2.Shacyrillic = 1064;
  e2.Shchacyrillic = 1065;
  e2.Sheicoptic = 994;
  e2.Shhacyrillic = 1210;
  e2.Shimacoptic = 1004;
  e2.Sigma = 931;
  e2.Sixroman = 8549;
  e2.Smonospace = 65331;
  e2.Softsigncyrillic = 1068;
  e2.Ssmall = 63347;
  e2.Stigmagreek = 986;
  e2.T = 84;
  e2.Tau = 932;
  e2.Tbar = 358;
  e2.Tcaron = 356;
  e2.Tcedilla = 354;
  e2.Tcircle = 9417;
  e2.Tcircumflexbelow = 7792;
  e2.Tcommaaccent = 354;
  e2.Tdotaccent = 7786;
  e2.Tdotbelow = 7788;
  e2.Tecyrillic = 1058;
  e2.Tedescendercyrillic = 1196;
  e2.Tenroman = 8553;
  e2.Tetsecyrillic = 1204;
  e2.Theta = 920;
  e2.Thook = 428;
  e2.Thorn = 222;
  e2.Thornsmall = 63486;
  e2.Threeroman = 8546;
  e2.Tildesmall = 63230;
  e2.Tiwnarmenian = 1359;
  e2.Tlinebelow = 7790;
  e2.Tmonospace = 65332;
  e2.Toarmenian = 1337;
  e2.Tonefive = 444;
  e2.Tonesix = 388;
  e2.Tonetwo = 423;
  e2.Tretroflexhook = 430;
  e2.Tsecyrillic = 1062;
  e2.Tshecyrillic = 1035;
  e2.Tsmall = 63348;
  e2.Twelveroman = 8555;
  e2.Tworoman = 8545;
  e2.U = 85;
  e2.Uacute = 218;
  e2.Uacutesmall = 63482;
  e2.Ubreve = 364;
  e2.Ucaron = 467;
  e2.Ucircle = 9418;
  e2.Ucircumflex = 219;
  e2.Ucircumflexbelow = 7798;
  e2.Ucircumflexsmall = 63483;
  e2.Ucyrillic = 1059;
  e2.Udblacute = 368;
  e2.Udblgrave = 532;
  e2.Udieresis = 220;
  e2.Udieresisacute = 471;
  e2.Udieresisbelow = 7794;
  e2.Udieresiscaron = 473;
  e2.Udieresiscyrillic = 1264;
  e2.Udieresisgrave = 475;
  e2.Udieresismacron = 469;
  e2.Udieresissmall = 63484;
  e2.Udotbelow = 7908;
  e2.Ugrave = 217;
  e2.Ugravesmall = 63481;
  e2.Uhookabove = 7910;
  e2.Uhorn = 431;
  e2.Uhornacute = 7912;
  e2.Uhorndotbelow = 7920;
  e2.Uhorngrave = 7914;
  e2.Uhornhookabove = 7916;
  e2.Uhorntilde = 7918;
  e2.Uhungarumlaut = 368;
  e2.Uhungarumlautcyrillic = 1266;
  e2.Uinvertedbreve = 534;
  e2.Ukcyrillic = 1144;
  e2.Umacron = 362;
  e2.Umacroncyrillic = 1262;
  e2.Umacrondieresis = 7802;
  e2.Umonospace = 65333;
  e2.Uogonek = 370;
  e2.Upsilon = 933;
  e2.Upsilon1 = 978;
  e2.Upsilonacutehooksymbolgreek = 979;
  e2.Upsilonafrican = 433;
  e2.Upsilondieresis = 939;
  e2.Upsilondieresishooksymbolgreek = 980;
  e2.Upsilonhooksymbol = 978;
  e2.Upsilontonos = 910;
  e2.Uring = 366;
  e2.Ushortcyrillic = 1038;
  e2.Usmall = 63349;
  e2.Ustraightcyrillic = 1198;
  e2.Ustraightstrokecyrillic = 1200;
  e2.Utilde = 360;
  e2.Utildeacute = 7800;
  e2.Utildebelow = 7796;
  e2.V = 86;
  e2.Vcircle = 9419;
  e2.Vdotbelow = 7806;
  e2.Vecyrillic = 1042;
  e2.Vewarmenian = 1358;
  e2.Vhook = 434;
  e2.Vmonospace = 65334;
  e2.Voarmenian = 1352;
  e2.Vsmall = 63350;
  e2.Vtilde = 7804;
  e2.W = 87;
  e2.Wacute = 7810;
  e2.Wcircle = 9420;
  e2.Wcircumflex = 372;
  e2.Wdieresis = 7812;
  e2.Wdotaccent = 7814;
  e2.Wdotbelow = 7816;
  e2.Wgrave = 7808;
  e2.Wmonospace = 65335;
  e2.Wsmall = 63351;
  e2.X = 88;
  e2.Xcircle = 9421;
  e2.Xdieresis = 7820;
  e2.Xdotaccent = 7818;
  e2.Xeharmenian = 1341;
  e2.Xi = 926;
  e2.Xmonospace = 65336;
  e2.Xsmall = 63352;
  e2.Y = 89;
  e2.Yacute = 221;
  e2.Yacutesmall = 63485;
  e2.Yatcyrillic = 1122;
  e2.Ycircle = 9422;
  e2.Ycircumflex = 374;
  e2.Ydieresis = 376;
  e2.Ydieresissmall = 63487;
  e2.Ydotaccent = 7822;
  e2.Ydotbelow = 7924;
  e2.Yericyrillic = 1067;
  e2.Yerudieresiscyrillic = 1272;
  e2.Ygrave = 7922;
  e2.Yhook = 435;
  e2.Yhookabove = 7926;
  e2.Yiarmenian = 1349;
  e2.Yicyrillic = 1031;
  e2.Yiwnarmenian = 1362;
  e2.Ymonospace = 65337;
  e2.Ysmall = 63353;
  e2.Ytilde = 7928;
  e2.Yusbigcyrillic = 1130;
  e2.Yusbigiotifiedcyrillic = 1132;
  e2.Yuslittlecyrillic = 1126;
  e2.Yuslittleiotifiedcyrillic = 1128;
  e2.Z = 90;
  e2.Zaarmenian = 1334;
  e2.Zacute = 377;
  e2.Zcaron = 381;
  e2.Zcaronsmall = 63231;
  e2.Zcircle = 9423;
  e2.Zcircumflex = 7824;
  e2.Zdot = 379;
  e2.Zdotaccent = 379;
  e2.Zdotbelow = 7826;
  e2.Zecyrillic = 1047;
  e2.Zedescendercyrillic = 1176;
  e2.Zedieresiscyrillic = 1246;
  e2.Zeta = 918;
  e2.Zhearmenian = 1338;
  e2.Zhebrevecyrillic = 1217;
  e2.Zhecyrillic = 1046;
  e2.Zhedescendercyrillic = 1174;
  e2.Zhedieresiscyrillic = 1244;
  e2.Zlinebelow = 7828;
  e2.Zmonospace = 65338;
  e2.Zsmall = 63354;
  e2.Zstroke = 437;
  e2.a = 97;
  e2.aabengali = 2438;
  e2.aacute = 225;
  e2.aadeva = 2310;
  e2.aagujarati = 2694;
  e2.aagurmukhi = 2566;
  e2.aamatragurmukhi = 2622;
  e2.aarusquare = 13059;
  e2.aavowelsignbengali = 2494;
  e2.aavowelsigndeva = 2366;
  e2.aavowelsigngujarati = 2750;
  e2.abbreviationmarkarmenian = 1375;
  e2.abbreviationsigndeva = 2416;
  e2.abengali = 2437;
  e2.abopomofo = 12570;
  e2.abreve = 259;
  e2.abreveacute = 7855;
  e2.abrevecyrillic = 1233;
  e2.abrevedotbelow = 7863;
  e2.abrevegrave = 7857;
  e2.abrevehookabove = 7859;
  e2.abrevetilde = 7861;
  e2.acaron = 462;
  e2.acircle = 9424;
  e2.acircumflex = 226;
  e2.acircumflexacute = 7845;
  e2.acircumflexdotbelow = 7853;
  e2.acircumflexgrave = 7847;
  e2.acircumflexhookabove = 7849;
  e2.acircumflextilde = 7851;
  e2.acute = 180;
  e2.acutebelowcmb = 791;
  e2.acutecmb = 769;
  e2.acutecomb = 769;
  e2.acutedeva = 2388;
  e2.acutelowmod = 719;
  e2.acutetonecmb = 833;
  e2.acyrillic = 1072;
  e2.adblgrave = 513;
  e2.addakgurmukhi = 2673;
  e2.adeva = 2309;
  e2.adieresis = 228;
  e2.adieresiscyrillic = 1235;
  e2.adieresismacron = 479;
  e2.adotbelow = 7841;
  e2.adotmacron = 481;
  e2.ae = 230;
  e2.aeacute = 509;
  e2.aekorean = 12624;
  e2.aemacron = 483;
  e2.afii00208 = 8213;
  e2.afii08941 = 8356;
  e2.afii10017 = 1040;
  e2.afii10018 = 1041;
  e2.afii10019 = 1042;
  e2.afii10020 = 1043;
  e2.afii10021 = 1044;
  e2.afii10022 = 1045;
  e2.afii10023 = 1025;
  e2.afii10024 = 1046;
  e2.afii10025 = 1047;
  e2.afii10026 = 1048;
  e2.afii10027 = 1049;
  e2.afii10028 = 1050;
  e2.afii10029 = 1051;
  e2.afii10030 = 1052;
  e2.afii10031 = 1053;
  e2.afii10032 = 1054;
  e2.afii10033 = 1055;
  e2.afii10034 = 1056;
  e2.afii10035 = 1057;
  e2.afii10036 = 1058;
  e2.afii10037 = 1059;
  e2.afii10038 = 1060;
  e2.afii10039 = 1061;
  e2.afii10040 = 1062;
  e2.afii10041 = 1063;
  e2.afii10042 = 1064;
  e2.afii10043 = 1065;
  e2.afii10044 = 1066;
  e2.afii10045 = 1067;
  e2.afii10046 = 1068;
  e2.afii10047 = 1069;
  e2.afii10048 = 1070;
  e2.afii10049 = 1071;
  e2.afii10050 = 1168;
  e2.afii10051 = 1026;
  e2.afii10052 = 1027;
  e2.afii10053 = 1028;
  e2.afii10054 = 1029;
  e2.afii10055 = 1030;
  e2.afii10056 = 1031;
  e2.afii10057 = 1032;
  e2.afii10058 = 1033;
  e2.afii10059 = 1034;
  e2.afii10060 = 1035;
  e2.afii10061 = 1036;
  e2.afii10062 = 1038;
  e2.afii10063 = 63172;
  e2.afii10064 = 63173;
  e2.afii10065 = 1072;
  e2.afii10066 = 1073;
  e2.afii10067 = 1074;
  e2.afii10068 = 1075;
  e2.afii10069 = 1076;
  e2.afii10070 = 1077;
  e2.afii10071 = 1105;
  e2.afii10072 = 1078;
  e2.afii10073 = 1079;
  e2.afii10074 = 1080;
  e2.afii10075 = 1081;
  e2.afii10076 = 1082;
  e2.afii10077 = 1083;
  e2.afii10078 = 1084;
  e2.afii10079 = 1085;
  e2.afii10080 = 1086;
  e2.afii10081 = 1087;
  e2.afii10082 = 1088;
  e2.afii10083 = 1089;
  e2.afii10084 = 1090;
  e2.afii10085 = 1091;
  e2.afii10086 = 1092;
  e2.afii10087 = 1093;
  e2.afii10088 = 1094;
  e2.afii10089 = 1095;
  e2.afii10090 = 1096;
  e2.afii10091 = 1097;
  e2.afii10092 = 1098;
  e2.afii10093 = 1099;
  e2.afii10094 = 1100;
  e2.afii10095 = 1101;
  e2.afii10096 = 1102;
  e2.afii10097 = 1103;
  e2.afii10098 = 1169;
  e2.afii10099 = 1106;
  e2.afii10100 = 1107;
  e2.afii10101 = 1108;
  e2.afii10102 = 1109;
  e2.afii10103 = 1110;
  e2.afii10104 = 1111;
  e2.afii10105 = 1112;
  e2.afii10106 = 1113;
  e2.afii10107 = 1114;
  e2.afii10108 = 1115;
  e2.afii10109 = 1116;
  e2.afii10110 = 1118;
  e2.afii10145 = 1039;
  e2.afii10146 = 1122;
  e2.afii10147 = 1138;
  e2.afii10148 = 1140;
  e2.afii10192 = 63174;
  e2.afii10193 = 1119;
  e2.afii10194 = 1123;
  e2.afii10195 = 1139;
  e2.afii10196 = 1141;
  e2.afii10831 = 63175;
  e2.afii10832 = 63176;
  e2.afii10846 = 1241;
  e2.afii299 = 8206;
  e2.afii300 = 8207;
  e2.afii301 = 8205;
  e2.afii57381 = 1642;
  e2.afii57388 = 1548;
  e2.afii57392 = 1632;
  e2.afii57393 = 1633;
  e2.afii57394 = 1634;
  e2.afii57395 = 1635;
  e2.afii57396 = 1636;
  e2.afii57397 = 1637;
  e2.afii57398 = 1638;
  e2.afii57399 = 1639;
  e2.afii57400 = 1640;
  e2.afii57401 = 1641;
  e2.afii57403 = 1563;
  e2.afii57407 = 1567;
  e2.afii57409 = 1569;
  e2.afii57410 = 1570;
  e2.afii57411 = 1571;
  e2.afii57412 = 1572;
  e2.afii57413 = 1573;
  e2.afii57414 = 1574;
  e2.afii57415 = 1575;
  e2.afii57416 = 1576;
  e2.afii57417 = 1577;
  e2.afii57418 = 1578;
  e2.afii57419 = 1579;
  e2.afii57420 = 1580;
  e2.afii57421 = 1581;
  e2.afii57422 = 1582;
  e2.afii57423 = 1583;
  e2.afii57424 = 1584;
  e2.afii57425 = 1585;
  e2.afii57426 = 1586;
  e2.afii57427 = 1587;
  e2.afii57428 = 1588;
  e2.afii57429 = 1589;
  e2.afii57430 = 1590;
  e2.afii57431 = 1591;
  e2.afii57432 = 1592;
  e2.afii57433 = 1593;
  e2.afii57434 = 1594;
  e2.afii57440 = 1600;
  e2.afii57441 = 1601;
  e2.afii57442 = 1602;
  e2.afii57443 = 1603;
  e2.afii57444 = 1604;
  e2.afii57445 = 1605;
  e2.afii57446 = 1606;
  e2.afii57448 = 1608;
  e2.afii57449 = 1609;
  e2.afii57450 = 1610;
  e2.afii57451 = 1611;
  e2.afii57452 = 1612;
  e2.afii57453 = 1613;
  e2.afii57454 = 1614;
  e2.afii57455 = 1615;
  e2.afii57456 = 1616;
  e2.afii57457 = 1617;
  e2.afii57458 = 1618;
  e2.afii57470 = 1607;
  e2.afii57505 = 1700;
  e2.afii57506 = 1662;
  e2.afii57507 = 1670;
  e2.afii57508 = 1688;
  e2.afii57509 = 1711;
  e2.afii57511 = 1657;
  e2.afii57512 = 1672;
  e2.afii57513 = 1681;
  e2.afii57514 = 1722;
  e2.afii57519 = 1746;
  e2.afii57534 = 1749;
  e2.afii57636 = 8362;
  e2.afii57645 = 1470;
  e2.afii57658 = 1475;
  e2.afii57664 = 1488;
  e2.afii57665 = 1489;
  e2.afii57666 = 1490;
  e2.afii57667 = 1491;
  e2.afii57668 = 1492;
  e2.afii57669 = 1493;
  e2.afii57670 = 1494;
  e2.afii57671 = 1495;
  e2.afii57672 = 1496;
  e2.afii57673 = 1497;
  e2.afii57674 = 1498;
  e2.afii57675 = 1499;
  e2.afii57676 = 1500;
  e2.afii57677 = 1501;
  e2.afii57678 = 1502;
  e2.afii57679 = 1503;
  e2.afii57680 = 1504;
  e2.afii57681 = 1505;
  e2.afii57682 = 1506;
  e2.afii57683 = 1507;
  e2.afii57684 = 1508;
  e2.afii57685 = 1509;
  e2.afii57686 = 1510;
  e2.afii57687 = 1511;
  e2.afii57688 = 1512;
  e2.afii57689 = 1513;
  e2.afii57690 = 1514;
  e2.afii57694 = 64298;
  e2.afii57695 = 64299;
  e2.afii57700 = 64331;
  e2.afii57705 = 64287;
  e2.afii57716 = 1520;
  e2.afii57717 = 1521;
  e2.afii57718 = 1522;
  e2.afii57723 = 64309;
  e2.afii57793 = 1460;
  e2.afii57794 = 1461;
  e2.afii57795 = 1462;
  e2.afii57796 = 1467;
  e2.afii57797 = 1464;
  e2.afii57798 = 1463;
  e2.afii57799 = 1456;
  e2.afii57800 = 1458;
  e2.afii57801 = 1457;
  e2.afii57802 = 1459;
  e2.afii57803 = 1474;
  e2.afii57804 = 1473;
  e2.afii57806 = 1465;
  e2.afii57807 = 1468;
  e2.afii57839 = 1469;
  e2.afii57841 = 1471;
  e2.afii57842 = 1472;
  e2.afii57929 = 700;
  e2.afii61248 = 8453;
  e2.afii61289 = 8467;
  e2.afii61352 = 8470;
  e2.afii61573 = 8236;
  e2.afii61574 = 8237;
  e2.afii61575 = 8238;
  e2.afii61664 = 8204;
  e2.afii63167 = 1645;
  e2.afii64937 = 701;
  e2.agrave = 224;
  e2.agujarati = 2693;
  e2.agurmukhi = 2565;
  e2.ahiragana = 12354;
  e2.ahookabove = 7843;
  e2.aibengali = 2448;
  e2.aibopomofo = 12574;
  e2.aideva = 2320;
  e2.aiecyrillic = 1237;
  e2.aigujarati = 2704;
  e2.aigurmukhi = 2576;
  e2.aimatragurmukhi = 2632;
  e2.ainarabic = 1593;
  e2.ainfinalarabic = 65226;
  e2.aininitialarabic = 65227;
  e2.ainmedialarabic = 65228;
  e2.ainvertedbreve = 515;
  e2.aivowelsignbengali = 2504;
  e2.aivowelsigndeva = 2376;
  e2.aivowelsigngujarati = 2760;
  e2.akatakana = 12450;
  e2.akatakanahalfwidth = 65393;
  e2.akorean = 12623;
  e2.alef = 1488;
  e2.alefarabic = 1575;
  e2.alefdageshhebrew = 64304;
  e2.aleffinalarabic = 65166;
  e2.alefhamzaabovearabic = 1571;
  e2.alefhamzaabovefinalarabic = 65156;
  e2.alefhamzabelowarabic = 1573;
  e2.alefhamzabelowfinalarabic = 65160;
  e2.alefhebrew = 1488;
  e2.aleflamedhebrew = 64335;
  e2.alefmaddaabovearabic = 1570;
  e2.alefmaddaabovefinalarabic = 65154;
  e2.alefmaksuraarabic = 1609;
  e2.alefmaksurafinalarabic = 65264;
  e2.alefmaksurainitialarabic = 65267;
  e2.alefmaksuramedialarabic = 65268;
  e2.alefpatahhebrew = 64302;
  e2.alefqamatshebrew = 64303;
  e2.aleph = 8501;
  e2.allequal = 8780;
  e2.alpha = 945;
  e2.alphatonos = 940;
  e2.amacron = 257;
  e2.amonospace = 65345;
  e2.ampersand = 38;
  e2.ampersandmonospace = 65286;
  e2.ampersandsmall = 63270;
  e2.amsquare = 13250;
  e2.anbopomofo = 12578;
  e2.angbopomofo = 12580;
  e2.angbracketleft = 12296;
  e2.angbracketright = 12297;
  e2.angkhankhuthai = 3674;
  e2.angle = 8736;
  e2.anglebracketleft = 12296;
  e2.anglebracketleftvertical = 65087;
  e2.anglebracketright = 12297;
  e2.anglebracketrightvertical = 65088;
  e2.angleleft = 9001;
  e2.angleright = 9002;
  e2.angstrom = 8491;
  e2.anoteleia = 903;
  e2.anudattadeva = 2386;
  e2.anusvarabengali = 2434;
  e2.anusvaradeva = 2306;
  e2.anusvaragujarati = 2690;
  e2.aogonek = 261;
  e2.apaatosquare = 13056;
  e2.aparen = 9372;
  e2.apostrophearmenian = 1370;
  e2.apostrophemod = 700;
  e2.apple = 63743;
  e2.approaches = 8784;
  e2.approxequal = 8776;
  e2.approxequalorimage = 8786;
  e2.approximatelyequal = 8773;
  e2.araeaekorean = 12686;
  e2.araeakorean = 12685;
  e2.arc = 8978;
  e2.arighthalfring = 7834;
  e2.aring = 229;
  e2.aringacute = 507;
  e2.aringbelow = 7681;
  e2.arrowboth = 8596;
  e2.arrowdashdown = 8675;
  e2.arrowdashleft = 8672;
  e2.arrowdashright = 8674;
  e2.arrowdashup = 8673;
  e2.arrowdblboth = 8660;
  e2.arrowdbldown = 8659;
  e2.arrowdblleft = 8656;
  e2.arrowdblright = 8658;
  e2.arrowdblup = 8657;
  e2.arrowdown = 8595;
  e2.arrowdownleft = 8601;
  e2.arrowdownright = 8600;
  e2.arrowdownwhite = 8681;
  e2.arrowheaddownmod = 709;
  e2.arrowheadleftmod = 706;
  e2.arrowheadrightmod = 707;
  e2.arrowheadupmod = 708;
  e2.arrowhorizex = 63719;
  e2.arrowleft = 8592;
  e2.arrowleftdbl = 8656;
  e2.arrowleftdblstroke = 8653;
  e2.arrowleftoverright = 8646;
  e2.arrowleftwhite = 8678;
  e2.arrowright = 8594;
  e2.arrowrightdblstroke = 8655;
  e2.arrowrightheavy = 10142;
  e2.arrowrightoverleft = 8644;
  e2.arrowrightwhite = 8680;
  e2.arrowtableft = 8676;
  e2.arrowtabright = 8677;
  e2.arrowup = 8593;
  e2.arrowupdn = 8597;
  e2.arrowupdnbse = 8616;
  e2.arrowupdownbase = 8616;
  e2.arrowupleft = 8598;
  e2.arrowupleftofdown = 8645;
  e2.arrowupright = 8599;
  e2.arrowupwhite = 8679;
  e2.arrowvertex = 63718;
  e2.asciicircum = 94;
  e2.asciicircummonospace = 65342;
  e2.asciitilde = 126;
  e2.asciitildemonospace = 65374;
  e2.ascript = 593;
  e2.ascriptturned = 594;
  e2.asmallhiragana = 12353;
  e2.asmallkatakana = 12449;
  e2.asmallkatakanahalfwidth = 65383;
  e2.asterisk = 42;
  e2.asteriskaltonearabic = 1645;
  e2.asteriskarabic = 1645;
  e2.asteriskmath = 8727;
  e2.asteriskmonospace = 65290;
  e2.asterisksmall = 65121;
  e2.asterism = 8258;
  e2.asuperior = 63209;
  e2.asymptoticallyequal = 8771;
  e2.at = 64;
  e2.atilde = 227;
  e2.atmonospace = 65312;
  e2.atsmall = 65131;
  e2.aturned = 592;
  e2.aubengali = 2452;
  e2.aubopomofo = 12576;
  e2.audeva = 2324;
  e2.augujarati = 2708;
  e2.augurmukhi = 2580;
  e2.aulengthmarkbengali = 2519;
  e2.aumatragurmukhi = 2636;
  e2.auvowelsignbengali = 2508;
  e2.auvowelsigndeva = 2380;
  e2.auvowelsigngujarati = 2764;
  e2.avagrahadeva = 2365;
  e2.aybarmenian = 1377;
  e2.ayin = 1506;
  e2.ayinaltonehebrew = 64288;
  e2.ayinhebrew = 1506;
  e2.b = 98;
  e2.babengali = 2476;
  e2.backslash = 92;
  e2.backslashmonospace = 65340;
  e2.badeva = 2348;
  e2.bagujarati = 2732;
  e2.bagurmukhi = 2604;
  e2.bahiragana = 12400;
  e2.bahtthai = 3647;
  e2.bakatakana = 12496;
  e2.bar = 124;
  e2.barmonospace = 65372;
  e2.bbopomofo = 12549;
  e2.bcircle = 9425;
  e2.bdotaccent = 7683;
  e2.bdotbelow = 7685;
  e2.beamedsixteenthnotes = 9836;
  e2.because = 8757;
  e2.becyrillic = 1073;
  e2.beharabic = 1576;
  e2.behfinalarabic = 65168;
  e2.behinitialarabic = 65169;
  e2.behiragana = 12409;
  e2.behmedialarabic = 65170;
  e2.behmeeminitialarabic = 64671;
  e2.behmeemisolatedarabic = 64520;
  e2.behnoonfinalarabic = 64621;
  e2.bekatakana = 12505;
  e2.benarmenian = 1378;
  e2.bet = 1489;
  e2.beta = 946;
  e2.betasymbolgreek = 976;
  e2.betdagesh = 64305;
  e2.betdageshhebrew = 64305;
  e2.bethebrew = 1489;
  e2.betrafehebrew = 64332;
  e2.bhabengali = 2477;
  e2.bhadeva = 2349;
  e2.bhagujarati = 2733;
  e2.bhagurmukhi = 2605;
  e2.bhook = 595;
  e2.bihiragana = 12403;
  e2.bikatakana = 12499;
  e2.bilabialclick = 664;
  e2.bindigurmukhi = 2562;
  e2.birusquare = 13105;
  e2.blackcircle = 9679;
  e2.blackdiamond = 9670;
  e2.blackdownpointingtriangle = 9660;
  e2.blackleftpointingpointer = 9668;
  e2.blackleftpointingtriangle = 9664;
  e2.blacklenticularbracketleft = 12304;
  e2.blacklenticularbracketleftvertical = 65083;
  e2.blacklenticularbracketright = 12305;
  e2.blacklenticularbracketrightvertical = 65084;
  e2.blacklowerlefttriangle = 9699;
  e2.blacklowerrighttriangle = 9698;
  e2.blackrectangle = 9644;
  e2.blackrightpointingpointer = 9658;
  e2.blackrightpointingtriangle = 9654;
  e2.blacksmallsquare = 9642;
  e2.blacksmilingface = 9787;
  e2.blacksquare = 9632;
  e2.blackstar = 9733;
  e2.blackupperlefttriangle = 9700;
  e2.blackupperrighttriangle = 9701;
  e2.blackuppointingsmalltriangle = 9652;
  e2.blackuppointingtriangle = 9650;
  e2.blank = 9251;
  e2.blinebelow = 7687;
  e2.block = 9608;
  e2.bmonospace = 65346;
  e2.bobaimaithai = 3610;
  e2.bohiragana = 12412;
  e2.bokatakana = 12508;
  e2.bparen = 9373;
  e2.bqsquare = 13251;
  e2.braceex = 63732;
  e2.braceleft = 123;
  e2.braceleftbt = 63731;
  e2.braceleftmid = 63730;
  e2.braceleftmonospace = 65371;
  e2.braceleftsmall = 65115;
  e2.bracelefttp = 63729;
  e2.braceleftvertical = 65079;
  e2.braceright = 125;
  e2.bracerightbt = 63742;
  e2.bracerightmid = 63741;
  e2.bracerightmonospace = 65373;
  e2.bracerightsmall = 65116;
  e2.bracerighttp = 63740;
  e2.bracerightvertical = 65080;
  e2.bracketleft = 91;
  e2.bracketleftbt = 63728;
  e2.bracketleftex = 63727;
  e2.bracketleftmonospace = 65339;
  e2.bracketlefttp = 63726;
  e2.bracketright = 93;
  e2.bracketrightbt = 63739;
  e2.bracketrightex = 63738;
  e2.bracketrightmonospace = 65341;
  e2.bracketrighttp = 63737;
  e2.breve = 728;
  e2.brevebelowcmb = 814;
  e2.brevecmb = 774;
  e2.breveinvertedbelowcmb = 815;
  e2.breveinvertedcmb = 785;
  e2.breveinverteddoublecmb = 865;
  e2.bridgebelowcmb = 810;
  e2.bridgeinvertedbelowcmb = 826;
  e2.brokenbar = 166;
  e2.bstroke = 384;
  e2.bsuperior = 63210;
  e2.btopbar = 387;
  e2.buhiragana = 12406;
  e2.bukatakana = 12502;
  e2.bullet = 8226;
  e2.bulletinverse = 9688;
  e2.bulletoperator = 8729;
  e2.bullseye = 9678;
  e2.c = 99;
  e2.caarmenian = 1390;
  e2.cabengali = 2458;
  e2.cacute = 263;
  e2.cadeva = 2330;
  e2.cagujarati = 2714;
  e2.cagurmukhi = 2586;
  e2.calsquare = 13192;
  e2.candrabindubengali = 2433;
  e2.candrabinducmb = 784;
  e2.candrabindudeva = 2305;
  e2.candrabindugujarati = 2689;
  e2.capslock = 8682;
  e2.careof = 8453;
  e2.caron = 711;
  e2.caronbelowcmb = 812;
  e2.caroncmb = 780;
  e2.carriagereturn = 8629;
  e2.cbopomofo = 12568;
  e2.ccaron = 269;
  e2.ccedilla = 231;
  e2.ccedillaacute = 7689;
  e2.ccircle = 9426;
  e2.ccircumflex = 265;
  e2.ccurl = 597;
  e2.cdot = 267;
  e2.cdotaccent = 267;
  e2.cdsquare = 13253;
  e2.cedilla = 184;
  e2.cedillacmb = 807;
  e2.cent = 162;
  e2.centigrade = 8451;
  e2.centinferior = 63199;
  e2.centmonospace = 65504;
  e2.centoldstyle = 63394;
  e2.centsuperior = 63200;
  e2.chaarmenian = 1401;
  e2.chabengali = 2459;
  e2.chadeva = 2331;
  e2.chagujarati = 2715;
  e2.chagurmukhi = 2587;
  e2.chbopomofo = 12564;
  e2.cheabkhasiancyrillic = 1213;
  e2.checkmark = 10003;
  e2.checyrillic = 1095;
  e2.chedescenderabkhasiancyrillic = 1215;
  e2.chedescendercyrillic = 1207;
  e2.chedieresiscyrillic = 1269;
  e2.cheharmenian = 1395;
  e2.chekhakassiancyrillic = 1228;
  e2.cheverticalstrokecyrillic = 1209;
  e2.chi = 967;
  e2.chieuchacirclekorean = 12919;
  e2.chieuchaparenkorean = 12823;
  e2.chieuchcirclekorean = 12905;
  e2.chieuchkorean = 12618;
  e2.chieuchparenkorean = 12809;
  e2.chochangthai = 3594;
  e2.chochanthai = 3592;
  e2.chochingthai = 3593;
  e2.chochoethai = 3596;
  e2.chook = 392;
  e2.cieucacirclekorean = 12918;
  e2.cieucaparenkorean = 12822;
  e2.cieuccirclekorean = 12904;
  e2.cieuckorean = 12616;
  e2.cieucparenkorean = 12808;
  e2.cieucuparenkorean = 12828;
  e2.circle = 9675;
  e2.circlecopyrt = 169;
  e2.circlemultiply = 8855;
  e2.circleot = 8857;
  e2.circleplus = 8853;
  e2.circlepostalmark = 12342;
  e2.circlewithlefthalfblack = 9680;
  e2.circlewithrighthalfblack = 9681;
  e2.circumflex = 710;
  e2.circumflexbelowcmb = 813;
  e2.circumflexcmb = 770;
  e2.clear = 8999;
  e2.clickalveolar = 450;
  e2.clickdental = 448;
  e2.clicklateral = 449;
  e2.clickretroflex = 451;
  e2.club = 9827;
  e2.clubsuitblack = 9827;
  e2.clubsuitwhite = 9831;
  e2.cmcubedsquare = 13220;
  e2.cmonospace = 65347;
  e2.cmsquaredsquare = 13216;
  e2.coarmenian = 1409;
  e2.colon = 58;
  e2.colonmonetary = 8353;
  e2.colonmonospace = 65306;
  e2.colonsign = 8353;
  e2.colonsmall = 65109;
  e2.colontriangularhalfmod = 721;
  e2.colontriangularmod = 720;
  e2.comma = 44;
  e2.commaabovecmb = 787;
  e2.commaaboverightcmb = 789;
  e2.commaaccent = 63171;
  e2.commaarabic = 1548;
  e2.commaarmenian = 1373;
  e2.commainferior = 63201;
  e2.commamonospace = 65292;
  e2.commareversedabovecmb = 788;
  e2.commareversedmod = 701;
  e2.commasmall = 65104;
  e2.commasuperior = 63202;
  e2.commaturnedabovecmb = 786;
  e2.commaturnedmod = 699;
  e2.compass = 9788;
  e2.congruent = 8773;
  e2.contourintegral = 8750;
  e2.control = 8963;
  e2.controlACK = 6;
  e2.controlBEL = 7;
  e2.controlBS = 8;
  e2.controlCAN = 24;
  e2.controlCR = 13;
  e2.controlDC1 = 17;
  e2.controlDC2 = 18;
  e2.controlDC3 = 19;
  e2.controlDC4 = 20;
  e2.controlDEL = 127;
  e2.controlDLE = 16;
  e2.controlEM = 25;
  e2.controlENQ = 5;
  e2.controlEOT = 4;
  e2.controlESC = 27;
  e2.controlETB = 23;
  e2.controlETX = 3;
  e2.controlFF = 12;
  e2.controlFS = 28;
  e2.controlGS = 29;
  e2.controlHT = 9;
  e2.controlLF = 10;
  e2.controlNAK = 21;
  e2.controlNULL = 0;
  e2.controlRS = 30;
  e2.controlSI = 15;
  e2.controlSO = 14;
  e2.controlSOT = 2;
  e2.controlSTX = 1;
  e2.controlSUB = 26;
  e2.controlSYN = 22;
  e2.controlUS = 31;
  e2.controlVT = 11;
  e2.copyright = 169;
  e2.copyrightsans = 63721;
  e2.copyrightserif = 63193;
  e2.cornerbracketleft = 12300;
  e2.cornerbracketlefthalfwidth = 65378;
  e2.cornerbracketleftvertical = 65089;
  e2.cornerbracketright = 12301;
  e2.cornerbracketrighthalfwidth = 65379;
  e2.cornerbracketrightvertical = 65090;
  e2.corporationsquare = 13183;
  e2.cosquare = 13255;
  e2.coverkgsquare = 13254;
  e2.cparen = 9374;
  e2.cruzeiro = 8354;
  e2.cstretched = 663;
  e2.curlyand = 8911;
  e2.curlyor = 8910;
  e2.currency = 164;
  e2.cyrBreve = 63185;
  e2.cyrFlex = 63186;
  e2.cyrbreve = 63188;
  e2.cyrflex = 63189;
  e2.d = 100;
  e2.daarmenian = 1380;
  e2.dabengali = 2470;
  e2.dadarabic = 1590;
  e2.dadeva = 2342;
  e2.dadfinalarabic = 65214;
  e2.dadinitialarabic = 65215;
  e2.dadmedialarabic = 65216;
  e2.dagesh = 1468;
  e2.dageshhebrew = 1468;
  e2.dagger = 8224;
  e2.daggerdbl = 8225;
  e2.dagujarati = 2726;
  e2.dagurmukhi = 2598;
  e2.dahiragana = 12384;
  e2.dakatakana = 12480;
  e2.dalarabic = 1583;
  e2.dalet = 1491;
  e2.daletdagesh = 64307;
  e2.daletdageshhebrew = 64307;
  e2.dalethebrew = 1491;
  e2.dalfinalarabic = 65194;
  e2.dammaarabic = 1615;
  e2.dammalowarabic = 1615;
  e2.dammatanaltonearabic = 1612;
  e2.dammatanarabic = 1612;
  e2.danda = 2404;
  e2.dargahebrew = 1447;
  e2.dargalefthebrew = 1447;
  e2.dasiapneumatacyrilliccmb = 1157;
  e2.dblGrave = 63187;
  e2.dblanglebracketleft = 12298;
  e2.dblanglebracketleftvertical = 65085;
  e2.dblanglebracketright = 12299;
  e2.dblanglebracketrightvertical = 65086;
  e2.dblarchinvertedbelowcmb = 811;
  e2.dblarrowleft = 8660;
  e2.dblarrowright = 8658;
  e2.dbldanda = 2405;
  e2.dblgrave = 63190;
  e2.dblgravecmb = 783;
  e2.dblintegral = 8748;
  e2.dbllowline = 8215;
  e2.dbllowlinecmb = 819;
  e2.dbloverlinecmb = 831;
  e2.dblprimemod = 698;
  e2.dblverticalbar = 8214;
  e2.dblverticallineabovecmb = 782;
  e2.dbopomofo = 12553;
  e2.dbsquare = 13256;
  e2.dcaron = 271;
  e2.dcedilla = 7697;
  e2.dcircle = 9427;
  e2.dcircumflexbelow = 7699;
  e2.dcroat = 273;
  e2.ddabengali = 2465;
  e2.ddadeva = 2337;
  e2.ddagujarati = 2721;
  e2.ddagurmukhi = 2593;
  e2.ddalarabic = 1672;
  e2.ddalfinalarabic = 64393;
  e2.dddhadeva = 2396;
  e2.ddhabengali = 2466;
  e2.ddhadeva = 2338;
  e2.ddhagujarati = 2722;
  e2.ddhagurmukhi = 2594;
  e2.ddotaccent = 7691;
  e2.ddotbelow = 7693;
  e2.decimalseparatorarabic = 1643;
  e2.decimalseparatorpersian = 1643;
  e2.decyrillic = 1076;
  e2.degree = 176;
  e2.dehihebrew = 1453;
  e2.dehiragana = 12391;
  e2.deicoptic = 1007;
  e2.dekatakana = 12487;
  e2.deleteleft = 9003;
  e2.deleteright = 8998;
  e2.delta = 948;
  e2.deltaturned = 397;
  e2.denominatorminusonenumeratorbengali = 2552;
  e2.dezh = 676;
  e2.dhabengali = 2471;
  e2.dhadeva = 2343;
  e2.dhagujarati = 2727;
  e2.dhagurmukhi = 2599;
  e2.dhook = 599;
  e2.dialytikatonos = 901;
  e2.dialytikatonoscmb = 836;
  e2.diamond = 9830;
  e2.diamondsuitwhite = 9826;
  e2.dieresis = 168;
  e2.dieresisacute = 63191;
  e2.dieresisbelowcmb = 804;
  e2.dieresiscmb = 776;
  e2.dieresisgrave = 63192;
  e2.dieresistonos = 901;
  e2.dihiragana = 12386;
  e2.dikatakana = 12482;
  e2.dittomark = 12291;
  e2.divide = 247;
  e2.divides = 8739;
  e2.divisionslash = 8725;
  e2.djecyrillic = 1106;
  e2.dkshade = 9619;
  e2.dlinebelow = 7695;
  e2.dlsquare = 13207;
  e2.dmacron = 273;
  e2.dmonospace = 65348;
  e2.dnblock = 9604;
  e2.dochadathai = 3598;
  e2.dodekthai = 3604;
  e2.dohiragana = 12393;
  e2.dokatakana = 12489;
  e2.dollar = 36;
  e2.dollarinferior = 63203;
  e2.dollarmonospace = 65284;
  e2.dollaroldstyle = 63268;
  e2.dollarsmall = 65129;
  e2.dollarsuperior = 63204;
  e2.dong = 8363;
  e2.dorusquare = 13094;
  e2.dotaccent = 729;
  e2.dotaccentcmb = 775;
  e2.dotbelowcmb = 803;
  e2.dotbelowcomb = 803;
  e2.dotkatakana = 12539;
  e2.dotlessi = 305;
  e2.dotlessj = 63166;
  e2.dotlessjstrokehook = 644;
  e2.dotmath = 8901;
  e2.dottedcircle = 9676;
  e2.doubleyodpatah = 64287;
  e2.doubleyodpatahhebrew = 64287;
  e2.downtackbelowcmb = 798;
  e2.downtackmod = 725;
  e2.dparen = 9375;
  e2.dsuperior = 63211;
  e2.dtail = 598;
  e2.dtopbar = 396;
  e2.duhiragana = 12389;
  e2.dukatakana = 12485;
  e2.dz = 499;
  e2.dzaltone = 675;
  e2.dzcaron = 454;
  e2.dzcurl = 677;
  e2.dzeabkhasiancyrillic = 1249;
  e2.dzecyrillic = 1109;
  e2.dzhecyrillic = 1119;
  e2.e = 101;
  e2.eacute = 233;
  e2.earth = 9793;
  e2.ebengali = 2447;
  e2.ebopomofo = 12572;
  e2.ebreve = 277;
  e2.ecandradeva = 2317;
  e2.ecandragujarati = 2701;
  e2.ecandravowelsigndeva = 2373;
  e2.ecandravowelsigngujarati = 2757;
  e2.ecaron = 283;
  e2.ecedillabreve = 7709;
  e2.echarmenian = 1381;
  e2.echyiwnarmenian = 1415;
  e2.ecircle = 9428;
  e2.ecircumflex = 234;
  e2.ecircumflexacute = 7871;
  e2.ecircumflexbelow = 7705;
  e2.ecircumflexdotbelow = 7879;
  e2.ecircumflexgrave = 7873;
  e2.ecircumflexhookabove = 7875;
  e2.ecircumflextilde = 7877;
  e2.ecyrillic = 1108;
  e2.edblgrave = 517;
  e2.edeva = 2319;
  e2.edieresis = 235;
  e2.edot = 279;
  e2.edotaccent = 279;
  e2.edotbelow = 7865;
  e2.eegurmukhi = 2575;
  e2.eematragurmukhi = 2631;
  e2.efcyrillic = 1092;
  e2.egrave = 232;
  e2.egujarati = 2703;
  e2.eharmenian = 1383;
  e2.ehbopomofo = 12573;
  e2.ehiragana = 12360;
  e2.ehookabove = 7867;
  e2.eibopomofo = 12575;
  e2.eight = 56;
  e2.eightarabic = 1640;
  e2.eightbengali = 2542;
  e2.eightcircle = 9319;
  e2.eightcircleinversesansserif = 10129;
  e2.eightdeva = 2414;
  e2.eighteencircle = 9329;
  e2.eighteenparen = 9349;
  e2.eighteenperiod = 9369;
  e2.eightgujarati = 2798;
  e2.eightgurmukhi = 2670;
  e2.eighthackarabic = 1640;
  e2.eighthangzhou = 12328;
  e2.eighthnotebeamed = 9835;
  e2.eightideographicparen = 12839;
  e2.eightinferior = 8328;
  e2.eightmonospace = 65304;
  e2.eightoldstyle = 63288;
  e2.eightparen = 9339;
  e2.eightperiod = 9359;
  e2.eightpersian = 1784;
  e2.eightroman = 8567;
  e2.eightsuperior = 8312;
  e2.eightthai = 3672;
  e2.einvertedbreve = 519;
  e2.eiotifiedcyrillic = 1125;
  e2.ekatakana = 12456;
  e2.ekatakanahalfwidth = 65396;
  e2.ekonkargurmukhi = 2676;
  e2.ekorean = 12628;
  e2.elcyrillic = 1083;
  e2.element = 8712;
  e2.elevencircle = 9322;
  e2.elevenparen = 9342;
  e2.elevenperiod = 9362;
  e2.elevenroman = 8570;
  e2.ellipsis = 8230;
  e2.ellipsisvertical = 8942;
  e2.emacron = 275;
  e2.emacronacute = 7703;
  e2.emacrongrave = 7701;
  e2.emcyrillic = 1084;
  e2.emdash = 8212;
  e2.emdashvertical = 65073;
  e2.emonospace = 65349;
  e2.emphasismarkarmenian = 1371;
  e2.emptyset = 8709;
  e2.enbopomofo = 12579;
  e2.encyrillic = 1085;
  e2.endash = 8211;
  e2.endashvertical = 65074;
  e2.endescendercyrillic = 1187;
  e2.eng = 331;
  e2.engbopomofo = 12581;
  e2.enghecyrillic = 1189;
  e2.enhookcyrillic = 1224;
  e2.enspace = 8194;
  e2.eogonek = 281;
  e2.eokorean = 12627;
  e2.eopen = 603;
  e2.eopenclosed = 666;
  e2.eopenreversed = 604;
  e2.eopenreversedclosed = 606;
  e2.eopenreversedhook = 605;
  e2.eparen = 9376;
  e2.epsilon = 949;
  e2.epsilontonos = 941;
  e2.equal = 61;
  e2.equalmonospace = 65309;
  e2.equalsmall = 65126;
  e2.equalsuperior = 8316;
  e2.equivalence = 8801;
  e2.erbopomofo = 12582;
  e2.ercyrillic = 1088;
  e2.ereversed = 600;
  e2.ereversedcyrillic = 1101;
  e2.escyrillic = 1089;
  e2.esdescendercyrillic = 1195;
  e2.esh = 643;
  e2.eshcurl = 646;
  e2.eshortdeva = 2318;
  e2.eshortvowelsigndeva = 2374;
  e2.eshreversedloop = 426;
  e2.eshsquatreversed = 645;
  e2.esmallhiragana = 12359;
  e2.esmallkatakana = 12455;
  e2.esmallkatakanahalfwidth = 65386;
  e2.estimated = 8494;
  e2.esuperior = 63212;
  e2.eta = 951;
  e2.etarmenian = 1384;
  e2.etatonos = 942;
  e2.eth = 240;
  e2.etilde = 7869;
  e2.etildebelow = 7707;
  e2.etnahtafoukhhebrew = 1425;
  e2.etnahtafoukhlefthebrew = 1425;
  e2.etnahtahebrew = 1425;
  e2.etnahtalefthebrew = 1425;
  e2.eturned = 477;
  e2.eukorean = 12641;
  e2.euro = 8364;
  e2.evowelsignbengali = 2503;
  e2.evowelsigndeva = 2375;
  e2.evowelsigngujarati = 2759;
  e2.exclam = 33;
  e2.exclamarmenian = 1372;
  e2.exclamdbl = 8252;
  e2.exclamdown = 161;
  e2.exclamdownsmall = 63393;
  e2.exclammonospace = 65281;
  e2.exclamsmall = 63265;
  e2.existential = 8707;
  e2.ezh = 658;
  e2.ezhcaron = 495;
  e2.ezhcurl = 659;
  e2.ezhreversed = 441;
  e2.ezhtail = 442;
  e2.f = 102;
  e2.fadeva = 2398;
  e2.fagurmukhi = 2654;
  e2.fahrenheit = 8457;
  e2.fathaarabic = 1614;
  e2.fathalowarabic = 1614;
  e2.fathatanarabic = 1611;
  e2.fbopomofo = 12552;
  e2.fcircle = 9429;
  e2.fdotaccent = 7711;
  e2.feharabic = 1601;
  e2.feharmenian = 1414;
  e2.fehfinalarabic = 65234;
  e2.fehinitialarabic = 65235;
  e2.fehmedialarabic = 65236;
  e2.feicoptic = 997;
  e2.female = 9792;
  e2.ff = 64256;
  e2.f_f = 64256;
  e2.ffi = 64259;
  e2.f_f_i = 64259;
  e2.ffl = 64260;
  e2.f_f_l = 64260;
  e2.fi = 64257;
  e2.f_i = 64257;
  e2.fifteencircle = 9326;
  e2.fifteenparen = 9346;
  e2.fifteenperiod = 9366;
  e2.figuredash = 8210;
  e2.filledbox = 9632;
  e2.filledrect = 9644;
  e2.finalkaf = 1498;
  e2.finalkafdagesh = 64314;
  e2.finalkafdageshhebrew = 64314;
  e2.finalkafhebrew = 1498;
  e2.finalmem = 1501;
  e2.finalmemhebrew = 1501;
  e2.finalnun = 1503;
  e2.finalnunhebrew = 1503;
  e2.finalpe = 1507;
  e2.finalpehebrew = 1507;
  e2.finaltsadi = 1509;
  e2.finaltsadihebrew = 1509;
  e2.firsttonechinese = 713;
  e2.fisheye = 9673;
  e2.fitacyrillic = 1139;
  e2.five = 53;
  e2.fivearabic = 1637;
  e2.fivebengali = 2539;
  e2.fivecircle = 9316;
  e2.fivecircleinversesansserif = 10126;
  e2.fivedeva = 2411;
  e2.fiveeighths = 8541;
  e2.fivegujarati = 2795;
  e2.fivegurmukhi = 2667;
  e2.fivehackarabic = 1637;
  e2.fivehangzhou = 12325;
  e2.fiveideographicparen = 12836;
  e2.fiveinferior = 8325;
  e2.fivemonospace = 65301;
  e2.fiveoldstyle = 63285;
  e2.fiveparen = 9336;
  e2.fiveperiod = 9356;
  e2.fivepersian = 1781;
  e2.fiveroman = 8564;
  e2.fivesuperior = 8309;
  e2.fivethai = 3669;
  e2.fl = 64258;
  e2.f_l = 64258;
  e2.florin = 402;
  e2.fmonospace = 65350;
  e2.fmsquare = 13209;
  e2.fofanthai = 3615;
  e2.fofathai = 3613;
  e2.fongmanthai = 3663;
  e2.forall = 8704;
  e2.four = 52;
  e2.fourarabic = 1636;
  e2.fourbengali = 2538;
  e2.fourcircle = 9315;
  e2.fourcircleinversesansserif = 10125;
  e2.fourdeva = 2410;
  e2.fourgujarati = 2794;
  e2.fourgurmukhi = 2666;
  e2.fourhackarabic = 1636;
  e2.fourhangzhou = 12324;
  e2.fourideographicparen = 12835;
  e2.fourinferior = 8324;
  e2.fourmonospace = 65300;
  e2.fournumeratorbengali = 2551;
  e2.fouroldstyle = 63284;
  e2.fourparen = 9335;
  e2.fourperiod = 9355;
  e2.fourpersian = 1780;
  e2.fourroman = 8563;
  e2.foursuperior = 8308;
  e2.fourteencircle = 9325;
  e2.fourteenparen = 9345;
  e2.fourteenperiod = 9365;
  e2.fourthai = 3668;
  e2.fourthtonechinese = 715;
  e2.fparen = 9377;
  e2.fraction = 8260;
  e2.franc = 8355;
  e2.g = 103;
  e2.gabengali = 2455;
  e2.gacute = 501;
  e2.gadeva = 2327;
  e2.gafarabic = 1711;
  e2.gaffinalarabic = 64403;
  e2.gafinitialarabic = 64404;
  e2.gafmedialarabic = 64405;
  e2.gagujarati = 2711;
  e2.gagurmukhi = 2583;
  e2.gahiragana = 12364;
  e2.gakatakana = 12460;
  e2.gamma = 947;
  e2.gammalatinsmall = 611;
  e2.gammasuperior = 736;
  e2.gangiacoptic = 1003;
  e2.gbopomofo = 12557;
  e2.gbreve = 287;
  e2.gcaron = 487;
  e2.gcedilla = 291;
  e2.gcircle = 9430;
  e2.gcircumflex = 285;
  e2.gcommaaccent = 291;
  e2.gdot = 289;
  e2.gdotaccent = 289;
  e2.gecyrillic = 1075;
  e2.gehiragana = 12370;
  e2.gekatakana = 12466;
  e2.geometricallyequal = 8785;
  e2.gereshaccenthebrew = 1436;
  e2.gereshhebrew = 1523;
  e2.gereshmuqdamhebrew = 1437;
  e2.germandbls = 223;
  e2.gershayimaccenthebrew = 1438;
  e2.gershayimhebrew = 1524;
  e2.getamark = 12307;
  e2.ghabengali = 2456;
  e2.ghadarmenian = 1394;
  e2.ghadeva = 2328;
  e2.ghagujarati = 2712;
  e2.ghagurmukhi = 2584;
  e2.ghainarabic = 1594;
  e2.ghainfinalarabic = 65230;
  e2.ghaininitialarabic = 65231;
  e2.ghainmedialarabic = 65232;
  e2.ghemiddlehookcyrillic = 1173;
  e2.ghestrokecyrillic = 1171;
  e2.gheupturncyrillic = 1169;
  e2.ghhadeva = 2394;
  e2.ghhagurmukhi = 2650;
  e2.ghook = 608;
  e2.ghzsquare = 13203;
  e2.gihiragana = 12366;
  e2.gikatakana = 12462;
  e2.gimarmenian = 1379;
  e2.gimel = 1490;
  e2.gimeldagesh = 64306;
  e2.gimeldageshhebrew = 64306;
  e2.gimelhebrew = 1490;
  e2.gjecyrillic = 1107;
  e2.glottalinvertedstroke = 446;
  e2.glottalstop = 660;
  e2.glottalstopinverted = 662;
  e2.glottalstopmod = 704;
  e2.glottalstopreversed = 661;
  e2.glottalstopreversedmod = 705;
  e2.glottalstopreversedsuperior = 740;
  e2.glottalstopstroke = 673;
  e2.glottalstopstrokereversed = 674;
  e2.gmacron = 7713;
  e2.gmonospace = 65351;
  e2.gohiragana = 12372;
  e2.gokatakana = 12468;
  e2.gparen = 9378;
  e2.gpasquare = 13228;
  e2.gradient = 8711;
  e2.grave = 96;
  e2.gravebelowcmb = 790;
  e2.gravecmb = 768;
  e2.gravecomb = 768;
  e2.gravedeva = 2387;
  e2.gravelowmod = 718;
  e2.gravemonospace = 65344;
  e2.gravetonecmb = 832;
  e2.greater = 62;
  e2.greaterequal = 8805;
  e2.greaterequalorless = 8923;
  e2.greatermonospace = 65310;
  e2.greaterorequivalent = 8819;
  e2.greaterorless = 8823;
  e2.greateroverequal = 8807;
  e2.greatersmall = 65125;
  e2.gscript = 609;
  e2.gstroke = 485;
  e2.guhiragana = 12368;
  e2.guillemotleft = 171;
  e2.guillemotright = 187;
  e2.guilsinglleft = 8249;
  e2.guilsinglright = 8250;
  e2.gukatakana = 12464;
  e2.guramusquare = 13080;
  e2.gysquare = 13257;
  e2.h = 104;
  e2.haabkhasiancyrillic = 1193;
  e2.haaltonearabic = 1729;
  e2.habengali = 2489;
  e2.hadescendercyrillic = 1203;
  e2.hadeva = 2361;
  e2.hagujarati = 2745;
  e2.hagurmukhi = 2617;
  e2.haharabic = 1581;
  e2.hahfinalarabic = 65186;
  e2.hahinitialarabic = 65187;
  e2.hahiragana = 12399;
  e2.hahmedialarabic = 65188;
  e2.haitusquare = 13098;
  e2.hakatakana = 12495;
  e2.hakatakanahalfwidth = 65418;
  e2.halantgurmukhi = 2637;
  e2.hamzaarabic = 1569;
  e2.hamzalowarabic = 1569;
  e2.hangulfiller = 12644;
  e2.hardsigncyrillic = 1098;
  e2.harpoonleftbarbup = 8636;
  e2.harpoonrightbarbup = 8640;
  e2.hasquare = 13258;
  e2.hatafpatah = 1458;
  e2.hatafpatah16 = 1458;
  e2.hatafpatah23 = 1458;
  e2.hatafpatah2f = 1458;
  e2.hatafpatahhebrew = 1458;
  e2.hatafpatahnarrowhebrew = 1458;
  e2.hatafpatahquarterhebrew = 1458;
  e2.hatafpatahwidehebrew = 1458;
  e2.hatafqamats = 1459;
  e2.hatafqamats1b = 1459;
  e2.hatafqamats28 = 1459;
  e2.hatafqamats34 = 1459;
  e2.hatafqamatshebrew = 1459;
  e2.hatafqamatsnarrowhebrew = 1459;
  e2.hatafqamatsquarterhebrew = 1459;
  e2.hatafqamatswidehebrew = 1459;
  e2.hatafsegol = 1457;
  e2.hatafsegol17 = 1457;
  e2.hatafsegol24 = 1457;
  e2.hatafsegol30 = 1457;
  e2.hatafsegolhebrew = 1457;
  e2.hatafsegolnarrowhebrew = 1457;
  e2.hatafsegolquarterhebrew = 1457;
  e2.hatafsegolwidehebrew = 1457;
  e2.hbar = 295;
  e2.hbopomofo = 12559;
  e2.hbrevebelow = 7723;
  e2.hcedilla = 7721;
  e2.hcircle = 9431;
  e2.hcircumflex = 293;
  e2.hdieresis = 7719;
  e2.hdotaccent = 7715;
  e2.hdotbelow = 7717;
  e2.he = 1492;
  e2.heart = 9829;
  e2.heartsuitblack = 9829;
  e2.heartsuitwhite = 9825;
  e2.hedagesh = 64308;
  e2.hedageshhebrew = 64308;
  e2.hehaltonearabic = 1729;
  e2.heharabic = 1607;
  e2.hehebrew = 1492;
  e2.hehfinalaltonearabic = 64423;
  e2.hehfinalalttwoarabic = 65258;
  e2.hehfinalarabic = 65258;
  e2.hehhamzaabovefinalarabic = 64421;
  e2.hehhamzaaboveisolatedarabic = 64420;
  e2.hehinitialaltonearabic = 64424;
  e2.hehinitialarabic = 65259;
  e2.hehiragana = 12408;
  e2.hehmedialaltonearabic = 64425;
  e2.hehmedialarabic = 65260;
  e2.heiseierasquare = 13179;
  e2.hekatakana = 12504;
  e2.hekatakanahalfwidth = 65421;
  e2.hekutaarusquare = 13110;
  e2.henghook = 615;
  e2.herutusquare = 13113;
  e2.het = 1495;
  e2.hethebrew = 1495;
  e2.hhook = 614;
  e2.hhooksuperior = 689;
  e2.hieuhacirclekorean = 12923;
  e2.hieuhaparenkorean = 12827;
  e2.hieuhcirclekorean = 12909;
  e2.hieuhkorean = 12622;
  e2.hieuhparenkorean = 12813;
  e2.hihiragana = 12402;
  e2.hikatakana = 12498;
  e2.hikatakanahalfwidth = 65419;
  e2.hiriq = 1460;
  e2.hiriq14 = 1460;
  e2.hiriq21 = 1460;
  e2.hiriq2d = 1460;
  e2.hiriqhebrew = 1460;
  e2.hiriqnarrowhebrew = 1460;
  e2.hiriqquarterhebrew = 1460;
  e2.hiriqwidehebrew = 1460;
  e2.hlinebelow = 7830;
  e2.hmonospace = 65352;
  e2.hoarmenian = 1392;
  e2.hohipthai = 3627;
  e2.hohiragana = 12411;
  e2.hokatakana = 12507;
  e2.hokatakanahalfwidth = 65422;
  e2.holam = 1465;
  e2.holam19 = 1465;
  e2.holam26 = 1465;
  e2.holam32 = 1465;
  e2.holamhebrew = 1465;
  e2.holamnarrowhebrew = 1465;
  e2.holamquarterhebrew = 1465;
  e2.holamwidehebrew = 1465;
  e2.honokhukthai = 3630;
  e2.hookabovecomb = 777;
  e2.hookcmb = 777;
  e2.hookpalatalizedbelowcmb = 801;
  e2.hookretroflexbelowcmb = 802;
  e2.hoonsquare = 13122;
  e2.horicoptic = 1001;
  e2.horizontalbar = 8213;
  e2.horncmb = 795;
  e2.hotsprings = 9832;
  e2.house = 8962;
  e2.hparen = 9379;
  e2.hsuperior = 688;
  e2.hturned = 613;
  e2.huhiragana = 12405;
  e2.huiitosquare = 13107;
  e2.hukatakana = 12501;
  e2.hukatakanahalfwidth = 65420;
  e2.hungarumlaut = 733;
  e2.hungarumlautcmb = 779;
  e2.hv = 405;
  e2.hyphen = 45;
  e2.hypheninferior = 63205;
  e2.hyphenmonospace = 65293;
  e2.hyphensmall = 65123;
  e2.hyphensuperior = 63206;
  e2.hyphentwo = 8208;
  e2.i = 105;
  e2.iacute = 237;
  e2.iacyrillic = 1103;
  e2.ibengali = 2439;
  e2.ibopomofo = 12583;
  e2.ibreve = 301;
  e2.icaron = 464;
  e2.icircle = 9432;
  e2.icircumflex = 238;
  e2.icyrillic = 1110;
  e2.idblgrave = 521;
  e2.ideographearthcircle = 12943;
  e2.ideographfirecircle = 12939;
  e2.ideographicallianceparen = 12863;
  e2.ideographiccallparen = 12858;
  e2.ideographiccentrecircle = 12965;
  e2.ideographicclose = 12294;
  e2.ideographiccomma = 12289;
  e2.ideographiccommaleft = 65380;
  e2.ideographiccongratulationparen = 12855;
  e2.ideographiccorrectcircle = 12963;
  e2.ideographicearthparen = 12847;
  e2.ideographicenterpriseparen = 12861;
  e2.ideographicexcellentcircle = 12957;
  e2.ideographicfestivalparen = 12864;
  e2.ideographicfinancialcircle = 12950;
  e2.ideographicfinancialparen = 12854;
  e2.ideographicfireparen = 12843;
  e2.ideographichaveparen = 12850;
  e2.ideographichighcircle = 12964;
  e2.ideographiciterationmark = 12293;
  e2.ideographiclaborcircle = 12952;
  e2.ideographiclaborparen = 12856;
  e2.ideographicleftcircle = 12967;
  e2.ideographiclowcircle = 12966;
  e2.ideographicmedicinecircle = 12969;
  e2.ideographicmetalparen = 12846;
  e2.ideographicmoonparen = 12842;
  e2.ideographicnameparen = 12852;
  e2.ideographicperiod = 12290;
  e2.ideographicprintcircle = 12958;
  e2.ideographicreachparen = 12867;
  e2.ideographicrepresentparen = 12857;
  e2.ideographicresourceparen = 12862;
  e2.ideographicrightcircle = 12968;
  e2.ideographicsecretcircle = 12953;
  e2.ideographicselfparen = 12866;
  e2.ideographicsocietyparen = 12851;
  e2.ideographicspace = 12288;
  e2.ideographicspecialparen = 12853;
  e2.ideographicstockparen = 12849;
  e2.ideographicstudyparen = 12859;
  e2.ideographicsunparen = 12848;
  e2.ideographicsuperviseparen = 12860;
  e2.ideographicwaterparen = 12844;
  e2.ideographicwoodparen = 12845;
  e2.ideographiczero = 12295;
  e2.ideographmetalcircle = 12942;
  e2.ideographmooncircle = 12938;
  e2.ideographnamecircle = 12948;
  e2.ideographsuncircle = 12944;
  e2.ideographwatercircle = 12940;
  e2.ideographwoodcircle = 12941;
  e2.ideva = 2311;
  e2.idieresis = 239;
  e2.idieresisacute = 7727;
  e2.idieresiscyrillic = 1253;
  e2.idotbelow = 7883;
  e2.iebrevecyrillic = 1239;
  e2.iecyrillic = 1077;
  e2.ieungacirclekorean = 12917;
  e2.ieungaparenkorean = 12821;
  e2.ieungcirclekorean = 12903;
  e2.ieungkorean = 12615;
  e2.ieungparenkorean = 12807;
  e2.igrave = 236;
  e2.igujarati = 2695;
  e2.igurmukhi = 2567;
  e2.ihiragana = 12356;
  e2.ihookabove = 7881;
  e2.iibengali = 2440;
  e2.iicyrillic = 1080;
  e2.iideva = 2312;
  e2.iigujarati = 2696;
  e2.iigurmukhi = 2568;
  e2.iimatragurmukhi = 2624;
  e2.iinvertedbreve = 523;
  e2.iishortcyrillic = 1081;
  e2.iivowelsignbengali = 2496;
  e2.iivowelsigndeva = 2368;
  e2.iivowelsigngujarati = 2752;
  e2.ij = 307;
  e2.ikatakana = 12452;
  e2.ikatakanahalfwidth = 65394;
  e2.ikorean = 12643;
  e2.ilde = 732;
  e2.iluyhebrew = 1452;
  e2.imacron = 299;
  e2.imacroncyrillic = 1251;
  e2.imageorapproximatelyequal = 8787;
  e2.imatragurmukhi = 2623;
  e2.imonospace = 65353;
  e2.increment = 8710;
  e2.infinity = 8734;
  e2.iniarmenian = 1387;
  e2.integral = 8747;
  e2.integralbottom = 8993;
  e2.integralbt = 8993;
  e2.integralex = 63733;
  e2.integraltop = 8992;
  e2.integraltp = 8992;
  e2.intersection = 8745;
  e2.intisquare = 13061;
  e2.invbullet = 9688;
  e2.invcircle = 9689;
  e2.invsmileface = 9787;
  e2.iocyrillic = 1105;
  e2.iogonek = 303;
  e2.iota = 953;
  e2.iotadieresis = 970;
  e2.iotadieresistonos = 912;
  e2.iotalatin = 617;
  e2.iotatonos = 943;
  e2.iparen = 9380;
  e2.irigurmukhi = 2674;
  e2.ismallhiragana = 12355;
  e2.ismallkatakana = 12451;
  e2.ismallkatakanahalfwidth = 65384;
  e2.issharbengali = 2554;
  e2.istroke = 616;
  e2.isuperior = 63213;
  e2.iterationhiragana = 12445;
  e2.iterationkatakana = 12541;
  e2.itilde = 297;
  e2.itildebelow = 7725;
  e2.iubopomofo = 12585;
  e2.iucyrillic = 1102;
  e2.ivowelsignbengali = 2495;
  e2.ivowelsigndeva = 2367;
  e2.ivowelsigngujarati = 2751;
  e2.izhitsacyrillic = 1141;
  e2.izhitsadblgravecyrillic = 1143;
  e2.j = 106;
  e2.jaarmenian = 1393;
  e2.jabengali = 2460;
  e2.jadeva = 2332;
  e2.jagujarati = 2716;
  e2.jagurmukhi = 2588;
  e2.jbopomofo = 12560;
  e2.jcaron = 496;
  e2.jcircle = 9433;
  e2.jcircumflex = 309;
  e2.jcrossedtail = 669;
  e2.jdotlessstroke = 607;
  e2.jecyrillic = 1112;
  e2.jeemarabic = 1580;
  e2.jeemfinalarabic = 65182;
  e2.jeeminitialarabic = 65183;
  e2.jeemmedialarabic = 65184;
  e2.jeharabic = 1688;
  e2.jehfinalarabic = 64395;
  e2.jhabengali = 2461;
  e2.jhadeva = 2333;
  e2.jhagujarati = 2717;
  e2.jhagurmukhi = 2589;
  e2.jheharmenian = 1403;
  e2.jis = 12292;
  e2.jmonospace = 65354;
  e2.jparen = 9381;
  e2.jsuperior = 690;
  e2.k = 107;
  e2.kabashkircyrillic = 1185;
  e2.kabengali = 2453;
  e2.kacute = 7729;
  e2.kacyrillic = 1082;
  e2.kadescendercyrillic = 1179;
  e2.kadeva = 2325;
  e2.kaf = 1499;
  e2.kafarabic = 1603;
  e2.kafdagesh = 64315;
  e2.kafdageshhebrew = 64315;
  e2.kaffinalarabic = 65242;
  e2.kafhebrew = 1499;
  e2.kafinitialarabic = 65243;
  e2.kafmedialarabic = 65244;
  e2.kafrafehebrew = 64333;
  e2.kagujarati = 2709;
  e2.kagurmukhi = 2581;
  e2.kahiragana = 12363;
  e2.kahookcyrillic = 1220;
  e2.kakatakana = 12459;
  e2.kakatakanahalfwidth = 65398;
  e2.kappa = 954;
  e2.kappasymbolgreek = 1008;
  e2.kapyeounmieumkorean = 12657;
  e2.kapyeounphieuphkorean = 12676;
  e2.kapyeounpieupkorean = 12664;
  e2.kapyeounssangpieupkorean = 12665;
  e2.karoriisquare = 13069;
  e2.kashidaautoarabic = 1600;
  e2.kashidaautonosidebearingarabic = 1600;
  e2.kasmallkatakana = 12533;
  e2.kasquare = 13188;
  e2.kasraarabic = 1616;
  e2.kasratanarabic = 1613;
  e2.kastrokecyrillic = 1183;
  e2.katahiraprolongmarkhalfwidth = 65392;
  e2.kaverticalstrokecyrillic = 1181;
  e2.kbopomofo = 12558;
  e2.kcalsquare = 13193;
  e2.kcaron = 489;
  e2.kcedilla = 311;
  e2.kcircle = 9434;
  e2.kcommaaccent = 311;
  e2.kdotbelow = 7731;
  e2.keharmenian = 1412;
  e2.kehiragana = 12369;
  e2.kekatakana = 12465;
  e2.kekatakanahalfwidth = 65401;
  e2.kenarmenian = 1391;
  e2.kesmallkatakana = 12534;
  e2.kgreenlandic = 312;
  e2.khabengali = 2454;
  e2.khacyrillic = 1093;
  e2.khadeva = 2326;
  e2.khagujarati = 2710;
  e2.khagurmukhi = 2582;
  e2.khaharabic = 1582;
  e2.khahfinalarabic = 65190;
  e2.khahinitialarabic = 65191;
  e2.khahmedialarabic = 65192;
  e2.kheicoptic = 999;
  e2.khhadeva = 2393;
  e2.khhagurmukhi = 2649;
  e2.khieukhacirclekorean = 12920;
  e2.khieukhaparenkorean = 12824;
  e2.khieukhcirclekorean = 12906;
  e2.khieukhkorean = 12619;
  e2.khieukhparenkorean = 12810;
  e2.khokhaithai = 3586;
  e2.khokhonthai = 3589;
  e2.khokhuatthai = 3587;
  e2.khokhwaithai = 3588;
  e2.khomutthai = 3675;
  e2.khook = 409;
  e2.khorakhangthai = 3590;
  e2.khzsquare = 13201;
  e2.kihiragana = 12365;
  e2.kikatakana = 12461;
  e2.kikatakanahalfwidth = 65399;
  e2.kiroguramusquare = 13077;
  e2.kiromeetorusquare = 13078;
  e2.kirosquare = 13076;
  e2.kiyeokacirclekorean = 12910;
  e2.kiyeokaparenkorean = 12814;
  e2.kiyeokcirclekorean = 12896;
  e2.kiyeokkorean = 12593;
  e2.kiyeokparenkorean = 12800;
  e2.kiyeoksioskorean = 12595;
  e2.kjecyrillic = 1116;
  e2.klinebelow = 7733;
  e2.klsquare = 13208;
  e2.kmcubedsquare = 13222;
  e2.kmonospace = 65355;
  e2.kmsquaredsquare = 13218;
  e2.kohiragana = 12371;
  e2.kohmsquare = 13248;
  e2.kokaithai = 3585;
  e2.kokatakana = 12467;
  e2.kokatakanahalfwidth = 65402;
  e2.kooposquare = 13086;
  e2.koppacyrillic = 1153;
  e2.koreanstandardsymbol = 12927;
  e2.koroniscmb = 835;
  e2.kparen = 9382;
  e2.kpasquare = 13226;
  e2.ksicyrillic = 1135;
  e2.ktsquare = 13263;
  e2.kturned = 670;
  e2.kuhiragana = 12367;
  e2.kukatakana = 12463;
  e2.kukatakanahalfwidth = 65400;
  e2.kvsquare = 13240;
  e2.kwsquare = 13246;
  e2.l = 108;
  e2.labengali = 2482;
  e2.lacute = 314;
  e2.ladeva = 2354;
  e2.lagujarati = 2738;
  e2.lagurmukhi = 2610;
  e2.lakkhangyaothai = 3653;
  e2.lamaleffinalarabic = 65276;
  e2.lamalefhamzaabovefinalarabic = 65272;
  e2.lamalefhamzaaboveisolatedarabic = 65271;
  e2.lamalefhamzabelowfinalarabic = 65274;
  e2.lamalefhamzabelowisolatedarabic = 65273;
  e2.lamalefisolatedarabic = 65275;
  e2.lamalefmaddaabovefinalarabic = 65270;
  e2.lamalefmaddaaboveisolatedarabic = 65269;
  e2.lamarabic = 1604;
  e2.lambda = 955;
  e2.lambdastroke = 411;
  e2.lamed = 1500;
  e2.lameddagesh = 64316;
  e2.lameddageshhebrew = 64316;
  e2.lamedhebrew = 1500;
  e2.lamfinalarabic = 65246;
  e2.lamhahinitialarabic = 64714;
  e2.laminitialarabic = 65247;
  e2.lamjeeminitialarabic = 64713;
  e2.lamkhahinitialarabic = 64715;
  e2.lamlamhehisolatedarabic = 65010;
  e2.lammedialarabic = 65248;
  e2.lammeemhahinitialarabic = 64904;
  e2.lammeeminitialarabic = 64716;
  e2.largecircle = 9711;
  e2.lbar = 410;
  e2.lbelt = 620;
  e2.lbopomofo = 12556;
  e2.lcaron = 318;
  e2.lcedilla = 316;
  e2.lcircle = 9435;
  e2.lcircumflexbelow = 7741;
  e2.lcommaaccent = 316;
  e2.ldot = 320;
  e2.ldotaccent = 320;
  e2.ldotbelow = 7735;
  e2.ldotbelowmacron = 7737;
  e2.leftangleabovecmb = 794;
  e2.lefttackbelowcmb = 792;
  e2.less = 60;
  e2.lessequal = 8804;
  e2.lessequalorgreater = 8922;
  e2.lessmonospace = 65308;
  e2.lessorequivalent = 8818;
  e2.lessorgreater = 8822;
  e2.lessoverequal = 8806;
  e2.lesssmall = 65124;
  e2.lezh = 622;
  e2.lfblock = 9612;
  e2.lhookretroflex = 621;
  e2.lira = 8356;
  e2.liwnarmenian = 1388;
  e2.lj = 457;
  e2.ljecyrillic = 1113;
  e2.ll = 63168;
  e2.lladeva = 2355;
  e2.llagujarati = 2739;
  e2.llinebelow = 7739;
  e2.llladeva = 2356;
  e2.llvocalicbengali = 2529;
  e2.llvocalicdeva = 2401;
  e2.llvocalicvowelsignbengali = 2531;
  e2.llvocalicvowelsigndeva = 2403;
  e2.lmiddletilde = 619;
  e2.lmonospace = 65356;
  e2.lmsquare = 13264;
  e2.lochulathai = 3628;
  e2.logicaland = 8743;
  e2.logicalnot = 172;
  e2.logicalnotreversed = 8976;
  e2.logicalor = 8744;
  e2.lolingthai = 3621;
  e2.longs = 383;
  e2.lowlinecenterline = 65102;
  e2.lowlinecmb = 818;
  e2.lowlinedashed = 65101;
  e2.lozenge = 9674;
  e2.lparen = 9383;
  e2.lslash = 322;
  e2.lsquare = 8467;
  e2.lsuperior = 63214;
  e2.ltshade = 9617;
  e2.luthai = 3622;
  e2.lvocalicbengali = 2444;
  e2.lvocalicdeva = 2316;
  e2.lvocalicvowelsignbengali = 2530;
  e2.lvocalicvowelsigndeva = 2402;
  e2.lxsquare = 13267;
  e2.m = 109;
  e2.mabengali = 2478;
  e2.macron = 175;
  e2.macronbelowcmb = 817;
  e2.macroncmb = 772;
  e2.macronlowmod = 717;
  e2.macronmonospace = 65507;
  e2.macute = 7743;
  e2.madeva = 2350;
  e2.magujarati = 2734;
  e2.magurmukhi = 2606;
  e2.mahapakhhebrew = 1444;
  e2.mahapakhlefthebrew = 1444;
  e2.mahiragana = 12414;
  e2.maichattawalowleftthai = 63637;
  e2.maichattawalowrightthai = 63636;
  e2.maichattawathai = 3659;
  e2.maichattawaupperleftthai = 63635;
  e2.maieklowleftthai = 63628;
  e2.maieklowrightthai = 63627;
  e2.maiekthai = 3656;
  e2.maiekupperleftthai = 63626;
  e2.maihanakatleftthai = 63620;
  e2.maihanakatthai = 3633;
  e2.maitaikhuleftthai = 63625;
  e2.maitaikhuthai = 3655;
  e2.maitholowleftthai = 63631;
  e2.maitholowrightthai = 63630;
  e2.maithothai = 3657;
  e2.maithoupperleftthai = 63629;
  e2.maitrilowleftthai = 63634;
  e2.maitrilowrightthai = 63633;
  e2.maitrithai = 3658;
  e2.maitriupperleftthai = 63632;
  e2.maiyamokthai = 3654;
  e2.makatakana = 12510;
  e2.makatakanahalfwidth = 65423;
  e2.male = 9794;
  e2.mansyonsquare = 13127;
  e2.maqafhebrew = 1470;
  e2.mars = 9794;
  e2.masoracirclehebrew = 1455;
  e2.masquare = 13187;
  e2.mbopomofo = 12551;
  e2.mbsquare = 13268;
  e2.mcircle = 9436;
  e2.mcubedsquare = 13221;
  e2.mdotaccent = 7745;
  e2.mdotbelow = 7747;
  e2.meemarabic = 1605;
  e2.meemfinalarabic = 65250;
  e2.meeminitialarabic = 65251;
  e2.meemmedialarabic = 65252;
  e2.meemmeeminitialarabic = 64721;
  e2.meemmeemisolatedarabic = 64584;
  e2.meetorusquare = 13133;
  e2.mehiragana = 12417;
  e2.meizierasquare = 13182;
  e2.mekatakana = 12513;
  e2.mekatakanahalfwidth = 65426;
  e2.mem = 1502;
  e2.memdagesh = 64318;
  e2.memdageshhebrew = 64318;
  e2.memhebrew = 1502;
  e2.menarmenian = 1396;
  e2.merkhahebrew = 1445;
  e2.merkhakefulahebrew = 1446;
  e2.merkhakefulalefthebrew = 1446;
  e2.merkhalefthebrew = 1445;
  e2.mhook = 625;
  e2.mhzsquare = 13202;
  e2.middledotkatakanahalfwidth = 65381;
  e2.middot = 183;
  e2.mieumacirclekorean = 12914;
  e2.mieumaparenkorean = 12818;
  e2.mieumcirclekorean = 12900;
  e2.mieumkorean = 12609;
  e2.mieumpansioskorean = 12656;
  e2.mieumparenkorean = 12804;
  e2.mieumpieupkorean = 12654;
  e2.mieumsioskorean = 12655;
  e2.mihiragana = 12415;
  e2.mikatakana = 12511;
  e2.mikatakanahalfwidth = 65424;
  e2.minus = 8722;
  e2.minusbelowcmb = 800;
  e2.minuscircle = 8854;
  e2.minusmod = 727;
  e2.minusplus = 8723;
  e2.minute = 8242;
  e2.miribaarusquare = 13130;
  e2.mirisquare = 13129;
  e2.mlonglegturned = 624;
  e2.mlsquare = 13206;
  e2.mmcubedsquare = 13219;
  e2.mmonospace = 65357;
  e2.mmsquaredsquare = 13215;
  e2.mohiragana = 12418;
  e2.mohmsquare = 13249;
  e2.mokatakana = 12514;
  e2.mokatakanahalfwidth = 65427;
  e2.molsquare = 13270;
  e2.momathai = 3617;
  e2.moverssquare = 13223;
  e2.moverssquaredsquare = 13224;
  e2.mparen = 9384;
  e2.mpasquare = 13227;
  e2.mssquare = 13235;
  e2.msuperior = 63215;
  e2.mturned = 623;
  e2.mu = 181;
  e2.mu1 = 181;
  e2.muasquare = 13186;
  e2.muchgreater = 8811;
  e2.muchless = 8810;
  e2.mufsquare = 13196;
  e2.mugreek = 956;
  e2.mugsquare = 13197;
  e2.muhiragana = 12416;
  e2.mukatakana = 12512;
  e2.mukatakanahalfwidth = 65425;
  e2.mulsquare = 13205;
  e2.multiply = 215;
  e2.mumsquare = 13211;
  e2.munahhebrew = 1443;
  e2.munahlefthebrew = 1443;
  e2.musicalnote = 9834;
  e2.musicalnotedbl = 9835;
  e2.musicflatsign = 9837;
  e2.musicsharpsign = 9839;
  e2.mussquare = 13234;
  e2.muvsquare = 13238;
  e2.muwsquare = 13244;
  e2.mvmegasquare = 13241;
  e2.mvsquare = 13239;
  e2.mwmegasquare = 13247;
  e2.mwsquare = 13245;
  e2.n = 110;
  e2.nabengali = 2472;
  e2.nabla = 8711;
  e2.nacute = 324;
  e2.nadeva = 2344;
  e2.nagujarati = 2728;
  e2.nagurmukhi = 2600;
  e2.nahiragana = 12394;
  e2.nakatakana = 12490;
  e2.nakatakanahalfwidth = 65413;
  e2.napostrophe = 329;
  e2.nasquare = 13185;
  e2.nbopomofo = 12555;
  e2.nbspace = 160;
  e2.ncaron = 328;
  e2.ncedilla = 326;
  e2.ncircle = 9437;
  e2.ncircumflexbelow = 7755;
  e2.ncommaaccent = 326;
  e2.ndotaccent = 7749;
  e2.ndotbelow = 7751;
  e2.nehiragana = 12397;
  e2.nekatakana = 12493;
  e2.nekatakanahalfwidth = 65416;
  e2.newsheqelsign = 8362;
  e2.nfsquare = 13195;
  e2.ngabengali = 2457;
  e2.ngadeva = 2329;
  e2.ngagujarati = 2713;
  e2.ngagurmukhi = 2585;
  e2.ngonguthai = 3591;
  e2.nhiragana = 12435;
  e2.nhookleft = 626;
  e2.nhookretroflex = 627;
  e2.nieunacirclekorean = 12911;
  e2.nieunaparenkorean = 12815;
  e2.nieuncieuckorean = 12597;
  e2.nieuncirclekorean = 12897;
  e2.nieunhieuhkorean = 12598;
  e2.nieunkorean = 12596;
  e2.nieunpansioskorean = 12648;
  e2.nieunparenkorean = 12801;
  e2.nieunsioskorean = 12647;
  e2.nieuntikeutkorean = 12646;
  e2.nihiragana = 12395;
  e2.nikatakana = 12491;
  e2.nikatakanahalfwidth = 65414;
  e2.nikhahitleftthai = 63641;
  e2.nikhahitthai = 3661;
  e2.nine = 57;
  e2.ninearabic = 1641;
  e2.ninebengali = 2543;
  e2.ninecircle = 9320;
  e2.ninecircleinversesansserif = 10130;
  e2.ninedeva = 2415;
  e2.ninegujarati = 2799;
  e2.ninegurmukhi = 2671;
  e2.ninehackarabic = 1641;
  e2.ninehangzhou = 12329;
  e2.nineideographicparen = 12840;
  e2.nineinferior = 8329;
  e2.ninemonospace = 65305;
  e2.nineoldstyle = 63289;
  e2.nineparen = 9340;
  e2.nineperiod = 9360;
  e2.ninepersian = 1785;
  e2.nineroman = 8568;
  e2.ninesuperior = 8313;
  e2.nineteencircle = 9330;
  e2.nineteenparen = 9350;
  e2.nineteenperiod = 9370;
  e2.ninethai = 3673;
  e2.nj = 460;
  e2.njecyrillic = 1114;
  e2.nkatakana = 12531;
  e2.nkatakanahalfwidth = 65437;
  e2.nlegrightlong = 414;
  e2.nlinebelow = 7753;
  e2.nmonospace = 65358;
  e2.nmsquare = 13210;
  e2.nnabengali = 2467;
  e2.nnadeva = 2339;
  e2.nnagujarati = 2723;
  e2.nnagurmukhi = 2595;
  e2.nnnadeva = 2345;
  e2.nohiragana = 12398;
  e2.nokatakana = 12494;
  e2.nokatakanahalfwidth = 65417;
  e2.nonbreakingspace = 160;
  e2.nonenthai = 3603;
  e2.nonuthai = 3609;
  e2.noonarabic = 1606;
  e2.noonfinalarabic = 65254;
  e2.noonghunnaarabic = 1722;
  e2.noonghunnafinalarabic = 64415;
  e2.nooninitialarabic = 65255;
  e2.noonjeeminitialarabic = 64722;
  e2.noonjeemisolatedarabic = 64587;
  e2.noonmedialarabic = 65256;
  e2.noonmeeminitialarabic = 64725;
  e2.noonmeemisolatedarabic = 64590;
  e2.noonnoonfinalarabic = 64653;
  e2.notcontains = 8716;
  e2.notelement = 8713;
  e2.notelementof = 8713;
  e2.notequal = 8800;
  e2.notgreater = 8815;
  e2.notgreaternorequal = 8817;
  e2.notgreaternorless = 8825;
  e2.notidentical = 8802;
  e2.notless = 8814;
  e2.notlessnorequal = 8816;
  e2.notparallel = 8742;
  e2.notprecedes = 8832;
  e2.notsubset = 8836;
  e2.notsucceeds = 8833;
  e2.notsuperset = 8837;
  e2.nowarmenian = 1398;
  e2.nparen = 9385;
  e2.nssquare = 13233;
  e2.nsuperior = 8319;
  e2.ntilde = 241;
  e2.nu = 957;
  e2.nuhiragana = 12396;
  e2.nukatakana = 12492;
  e2.nukatakanahalfwidth = 65415;
  e2.nuktabengali = 2492;
  e2.nuktadeva = 2364;
  e2.nuktagujarati = 2748;
  e2.nuktagurmukhi = 2620;
  e2.numbersign = 35;
  e2.numbersignmonospace = 65283;
  e2.numbersignsmall = 65119;
  e2.numeralsigngreek = 884;
  e2.numeralsignlowergreek = 885;
  e2.numero = 8470;
  e2.nun = 1504;
  e2.nundagesh = 64320;
  e2.nundageshhebrew = 64320;
  e2.nunhebrew = 1504;
  e2.nvsquare = 13237;
  e2.nwsquare = 13243;
  e2.nyabengali = 2462;
  e2.nyadeva = 2334;
  e2.nyagujarati = 2718;
  e2.nyagurmukhi = 2590;
  e2.o = 111;
  e2.oacute = 243;
  e2.oangthai = 3629;
  e2.obarred = 629;
  e2.obarredcyrillic = 1257;
  e2.obarreddieresiscyrillic = 1259;
  e2.obengali = 2451;
  e2.obopomofo = 12571;
  e2.obreve = 335;
  e2.ocandradeva = 2321;
  e2.ocandragujarati = 2705;
  e2.ocandravowelsigndeva = 2377;
  e2.ocandravowelsigngujarati = 2761;
  e2.ocaron = 466;
  e2.ocircle = 9438;
  e2.ocircumflex = 244;
  e2.ocircumflexacute = 7889;
  e2.ocircumflexdotbelow = 7897;
  e2.ocircumflexgrave = 7891;
  e2.ocircumflexhookabove = 7893;
  e2.ocircumflextilde = 7895;
  e2.ocyrillic = 1086;
  e2.odblacute = 337;
  e2.odblgrave = 525;
  e2.odeva = 2323;
  e2.odieresis = 246;
  e2.odieresiscyrillic = 1255;
  e2.odotbelow = 7885;
  e2.oe = 339;
  e2.oekorean = 12634;
  e2.ogonek = 731;
  e2.ogonekcmb = 808;
  e2.ograve = 242;
  e2.ogujarati = 2707;
  e2.oharmenian = 1413;
  e2.ohiragana = 12362;
  e2.ohookabove = 7887;
  e2.ohorn = 417;
  e2.ohornacute = 7899;
  e2.ohorndotbelow = 7907;
  e2.ohorngrave = 7901;
  e2.ohornhookabove = 7903;
  e2.ohorntilde = 7905;
  e2.ohungarumlaut = 337;
  e2.oi = 419;
  e2.oinvertedbreve = 527;
  e2.okatakana = 12458;
  e2.okatakanahalfwidth = 65397;
  e2.okorean = 12631;
  e2.olehebrew = 1451;
  e2.omacron = 333;
  e2.omacronacute = 7763;
  e2.omacrongrave = 7761;
  e2.omdeva = 2384;
  e2.omega = 969;
  e2.omega1 = 982;
  e2.omegacyrillic = 1121;
  e2.omegalatinclosed = 631;
  e2.omegaroundcyrillic = 1147;
  e2.omegatitlocyrillic = 1149;
  e2.omegatonos = 974;
  e2.omgujarati = 2768;
  e2.omicron = 959;
  e2.omicrontonos = 972;
  e2.omonospace = 65359;
  e2.one = 49;
  e2.onearabic = 1633;
  e2.onebengali = 2535;
  e2.onecircle = 9312;
  e2.onecircleinversesansserif = 10122;
  e2.onedeva = 2407;
  e2.onedotenleader = 8228;
  e2.oneeighth = 8539;
  e2.onefitted = 63196;
  e2.onegujarati = 2791;
  e2.onegurmukhi = 2663;
  e2.onehackarabic = 1633;
  e2.onehalf = 189;
  e2.onehangzhou = 12321;
  e2.oneideographicparen = 12832;
  e2.oneinferior = 8321;
  e2.onemonospace = 65297;
  e2.onenumeratorbengali = 2548;
  e2.oneoldstyle = 63281;
  e2.oneparen = 9332;
  e2.oneperiod = 9352;
  e2.onepersian = 1777;
  e2.onequarter = 188;
  e2.oneroman = 8560;
  e2.onesuperior = 185;
  e2.onethai = 3665;
  e2.onethird = 8531;
  e2.oogonek = 491;
  e2.oogonekmacron = 493;
  e2.oogurmukhi = 2579;
  e2.oomatragurmukhi = 2635;
  e2.oopen = 596;
  e2.oparen = 9386;
  e2.openbullet = 9702;
  e2.option = 8997;
  e2.ordfeminine = 170;
  e2.ordmasculine = 186;
  e2.orthogonal = 8735;
  e2.oshortdeva = 2322;
  e2.oshortvowelsigndeva = 2378;
  e2.oslash = 248;
  e2.oslashacute = 511;
  e2.osmallhiragana = 12361;
  e2.osmallkatakana = 12457;
  e2.osmallkatakanahalfwidth = 65387;
  e2.ostrokeacute = 511;
  e2.osuperior = 63216;
  e2.otcyrillic = 1151;
  e2.otilde = 245;
  e2.otildeacute = 7757;
  e2.otildedieresis = 7759;
  e2.oubopomofo = 12577;
  e2.overline = 8254;
  e2.overlinecenterline = 65098;
  e2.overlinecmb = 773;
  e2.overlinedashed = 65097;
  e2.overlinedblwavy = 65100;
  e2.overlinewavy = 65099;
  e2.overscore = 175;
  e2.ovowelsignbengali = 2507;
  e2.ovowelsigndeva = 2379;
  e2.ovowelsigngujarati = 2763;
  e2.p = 112;
  e2.paampssquare = 13184;
  e2.paasentosquare = 13099;
  e2.pabengali = 2474;
  e2.pacute = 7765;
  e2.padeva = 2346;
  e2.pagedown = 8671;
  e2.pageup = 8670;
  e2.pagujarati = 2730;
  e2.pagurmukhi = 2602;
  e2.pahiragana = 12401;
  e2.paiyannoithai = 3631;
  e2.pakatakana = 12497;
  e2.palatalizationcyrilliccmb = 1156;
  e2.palochkacyrillic = 1216;
  e2.pansioskorean = 12671;
  e2.paragraph = 182;
  e2.parallel = 8741;
  e2.parenleft = 40;
  e2.parenleftaltonearabic = 64830;
  e2.parenleftbt = 63725;
  e2.parenleftex = 63724;
  e2.parenleftinferior = 8333;
  e2.parenleftmonospace = 65288;
  e2.parenleftsmall = 65113;
  e2.parenleftsuperior = 8317;
  e2.parenlefttp = 63723;
  e2.parenleftvertical = 65077;
  e2.parenright = 41;
  e2.parenrightaltonearabic = 64831;
  e2.parenrightbt = 63736;
  e2.parenrightex = 63735;
  e2.parenrightinferior = 8334;
  e2.parenrightmonospace = 65289;
  e2.parenrightsmall = 65114;
  e2.parenrightsuperior = 8318;
  e2.parenrighttp = 63734;
  e2.parenrightvertical = 65078;
  e2.partialdiff = 8706;
  e2.paseqhebrew = 1472;
  e2.pashtahebrew = 1433;
  e2.pasquare = 13225;
  e2.patah = 1463;
  e2.patah11 = 1463;
  e2.patah1d = 1463;
  e2.patah2a = 1463;
  e2.patahhebrew = 1463;
  e2.patahnarrowhebrew = 1463;
  e2.patahquarterhebrew = 1463;
  e2.patahwidehebrew = 1463;
  e2.pazerhebrew = 1441;
  e2.pbopomofo = 12550;
  e2.pcircle = 9439;
  e2.pdotaccent = 7767;
  e2.pe = 1508;
  e2.pecyrillic = 1087;
  e2.pedagesh = 64324;
  e2.pedageshhebrew = 64324;
  e2.peezisquare = 13115;
  e2.pefinaldageshhebrew = 64323;
  e2.peharabic = 1662;
  e2.peharmenian = 1402;
  e2.pehebrew = 1508;
  e2.pehfinalarabic = 64343;
  e2.pehinitialarabic = 64344;
  e2.pehiragana = 12410;
  e2.pehmedialarabic = 64345;
  e2.pekatakana = 12506;
  e2.pemiddlehookcyrillic = 1191;
  e2.perafehebrew = 64334;
  e2.percent = 37;
  e2.percentarabic = 1642;
  e2.percentmonospace = 65285;
  e2.percentsmall = 65130;
  e2.period = 46;
  e2.periodarmenian = 1417;
  e2.periodcentered = 183;
  e2.periodhalfwidth = 65377;
  e2.periodinferior = 63207;
  e2.periodmonospace = 65294;
  e2.periodsmall = 65106;
  e2.periodsuperior = 63208;
  e2.perispomenigreekcmb = 834;
  e2.perpendicular = 8869;
  e2.perthousand = 8240;
  e2.peseta = 8359;
  e2.pfsquare = 13194;
  e2.phabengali = 2475;
  e2.phadeva = 2347;
  e2.phagujarati = 2731;
  e2.phagurmukhi = 2603;
  e2.phi = 966;
  e2.phi1 = 981;
  e2.phieuphacirclekorean = 12922;
  e2.phieuphaparenkorean = 12826;
  e2.phieuphcirclekorean = 12908;
  e2.phieuphkorean = 12621;
  e2.phieuphparenkorean = 12812;
  e2.philatin = 632;
  e2.phinthuthai = 3642;
  e2.phisymbolgreek = 981;
  e2.phook = 421;
  e2.phophanthai = 3614;
  e2.phophungthai = 3612;
  e2.phosamphaothai = 3616;
  e2.pi = 960;
  e2.pieupacirclekorean = 12915;
  e2.pieupaparenkorean = 12819;
  e2.pieupcieuckorean = 12662;
  e2.pieupcirclekorean = 12901;
  e2.pieupkiyeokkorean = 12658;
  e2.pieupkorean = 12610;
  e2.pieupparenkorean = 12805;
  e2.pieupsioskiyeokkorean = 12660;
  e2.pieupsioskorean = 12612;
  e2.pieupsiostikeutkorean = 12661;
  e2.pieupthieuthkorean = 12663;
  e2.pieuptikeutkorean = 12659;
  e2.pihiragana = 12404;
  e2.pikatakana = 12500;
  e2.pisymbolgreek = 982;
  e2.piwrarmenian = 1411;
  e2.planckover2pi = 8463;
  e2.planckover2pi1 = 8463;
  e2.plus = 43;
  e2.plusbelowcmb = 799;
  e2.pluscircle = 8853;
  e2.plusminus = 177;
  e2.plusmod = 726;
  e2.plusmonospace = 65291;
  e2.plussmall = 65122;
  e2.plussuperior = 8314;
  e2.pmonospace = 65360;
  e2.pmsquare = 13272;
  e2.pohiragana = 12413;
  e2.pointingindexdownwhite = 9759;
  e2.pointingindexleftwhite = 9756;
  e2.pointingindexrightwhite = 9758;
  e2.pointingindexupwhite = 9757;
  e2.pokatakana = 12509;
  e2.poplathai = 3611;
  e2.postalmark = 12306;
  e2.postalmarkface = 12320;
  e2.pparen = 9387;
  e2.precedes = 8826;
  e2.prescription = 8478;
  e2.primemod = 697;
  e2.primereversed = 8245;
  e2.product = 8719;
  e2.projective = 8965;
  e2.prolongedkana = 12540;
  e2.propellor = 8984;
  e2.propersubset = 8834;
  e2.propersuperset = 8835;
  e2.proportion = 8759;
  e2.proportional = 8733;
  e2.psi = 968;
  e2.psicyrillic = 1137;
  e2.psilipneumatacyrilliccmb = 1158;
  e2.pssquare = 13232;
  e2.puhiragana = 12407;
  e2.pukatakana = 12503;
  e2.pvsquare = 13236;
  e2.pwsquare = 13242;
  e2.q = 113;
  e2.qadeva = 2392;
  e2.qadmahebrew = 1448;
  e2.qafarabic = 1602;
  e2.qaffinalarabic = 65238;
  e2.qafinitialarabic = 65239;
  e2.qafmedialarabic = 65240;
  e2.qamats = 1464;
  e2.qamats10 = 1464;
  e2.qamats1a = 1464;
  e2.qamats1c = 1464;
  e2.qamats27 = 1464;
  e2.qamats29 = 1464;
  e2.qamats33 = 1464;
  e2.qamatsde = 1464;
  e2.qamatshebrew = 1464;
  e2.qamatsnarrowhebrew = 1464;
  e2.qamatsqatanhebrew = 1464;
  e2.qamatsqatannarrowhebrew = 1464;
  e2.qamatsqatanquarterhebrew = 1464;
  e2.qamatsqatanwidehebrew = 1464;
  e2.qamatsquarterhebrew = 1464;
  e2.qamatswidehebrew = 1464;
  e2.qarneyparahebrew = 1439;
  e2.qbopomofo = 12561;
  e2.qcircle = 9440;
  e2.qhook = 672;
  e2.qmonospace = 65361;
  e2.qof = 1511;
  e2.qofdagesh = 64327;
  e2.qofdageshhebrew = 64327;
  e2.qofhebrew = 1511;
  e2.qparen = 9388;
  e2.quarternote = 9833;
  e2.qubuts = 1467;
  e2.qubuts18 = 1467;
  e2.qubuts25 = 1467;
  e2.qubuts31 = 1467;
  e2.qubutshebrew = 1467;
  e2.qubutsnarrowhebrew = 1467;
  e2.qubutsquarterhebrew = 1467;
  e2.qubutswidehebrew = 1467;
  e2.question = 63;
  e2.questionarabic = 1567;
  e2.questionarmenian = 1374;
  e2.questiondown = 191;
  e2.questiondownsmall = 63423;
  e2.questiongreek = 894;
  e2.questionmonospace = 65311;
  e2.questionsmall = 63295;
  e2.quotedbl = 34;
  e2.quotedblbase = 8222;
  e2.quotedblleft = 8220;
  e2.quotedblmonospace = 65282;
  e2.quotedblprime = 12318;
  e2.quotedblprimereversed = 12317;
  e2.quotedblright = 8221;
  e2.quoteleft = 8216;
  e2.quoteleftreversed = 8219;
  e2.quotereversed = 8219;
  e2.quoteright = 8217;
  e2.quoterightn = 329;
  e2.quotesinglbase = 8218;
  e2.quotesingle = 39;
  e2.quotesinglemonospace = 65287;
  e2.r = 114;
  e2.raarmenian = 1404;
  e2.rabengali = 2480;
  e2.racute = 341;
  e2.radeva = 2352;
  e2.radical = 8730;
  e2.radicalex = 63717;
  e2.radoverssquare = 13230;
  e2.radoverssquaredsquare = 13231;
  e2.radsquare = 13229;
  e2.rafe = 1471;
  e2.rafehebrew = 1471;
  e2.ragujarati = 2736;
  e2.ragurmukhi = 2608;
  e2.rahiragana = 12425;
  e2.rakatakana = 12521;
  e2.rakatakanahalfwidth = 65431;
  e2.ralowerdiagonalbengali = 2545;
  e2.ramiddlediagonalbengali = 2544;
  e2.ramshorn = 612;
  e2.ratio = 8758;
  e2.rbopomofo = 12566;
  e2.rcaron = 345;
  e2.rcedilla = 343;
  e2.rcircle = 9441;
  e2.rcommaaccent = 343;
  e2.rdblgrave = 529;
  e2.rdotaccent = 7769;
  e2.rdotbelow = 7771;
  e2.rdotbelowmacron = 7773;
  e2.referencemark = 8251;
  e2.reflexsubset = 8838;
  e2.reflexsuperset = 8839;
  e2.registered = 174;
  e2.registersans = 63720;
  e2.registerserif = 63194;
  e2.reharabic = 1585;
  e2.reharmenian = 1408;
  e2.rehfinalarabic = 65198;
  e2.rehiragana = 12428;
  e2.rekatakana = 12524;
  e2.rekatakanahalfwidth = 65434;
  e2.resh = 1512;
  e2.reshdageshhebrew = 64328;
  e2.reshhebrew = 1512;
  e2.reversedtilde = 8765;
  e2.reviahebrew = 1431;
  e2.reviamugrashhebrew = 1431;
  e2.revlogicalnot = 8976;
  e2.rfishhook = 638;
  e2.rfishhookreversed = 639;
  e2.rhabengali = 2525;
  e2.rhadeva = 2397;
  e2.rho = 961;
  e2.rhook = 637;
  e2.rhookturned = 635;
  e2.rhookturnedsuperior = 693;
  e2.rhosymbolgreek = 1009;
  e2.rhotichookmod = 734;
  e2.rieulacirclekorean = 12913;
  e2.rieulaparenkorean = 12817;
  e2.rieulcirclekorean = 12899;
  e2.rieulhieuhkorean = 12608;
  e2.rieulkiyeokkorean = 12602;
  e2.rieulkiyeoksioskorean = 12649;
  e2.rieulkorean = 12601;
  e2.rieulmieumkorean = 12603;
  e2.rieulpansioskorean = 12652;
  e2.rieulparenkorean = 12803;
  e2.rieulphieuphkorean = 12607;
  e2.rieulpieupkorean = 12604;
  e2.rieulpieupsioskorean = 12651;
  e2.rieulsioskorean = 12605;
  e2.rieulthieuthkorean = 12606;
  e2.rieultikeutkorean = 12650;
  e2.rieulyeorinhieuhkorean = 12653;
  e2.rightangle = 8735;
  e2.righttackbelowcmb = 793;
  e2.righttriangle = 8895;
  e2.rihiragana = 12426;
  e2.rikatakana = 12522;
  e2.rikatakanahalfwidth = 65432;
  e2.ring = 730;
  e2.ringbelowcmb = 805;
  e2.ringcmb = 778;
  e2.ringhalfleft = 703;
  e2.ringhalfleftarmenian = 1369;
  e2.ringhalfleftbelowcmb = 796;
  e2.ringhalfleftcentered = 723;
  e2.ringhalfright = 702;
  e2.ringhalfrightbelowcmb = 825;
  e2.ringhalfrightcentered = 722;
  e2.rinvertedbreve = 531;
  e2.rittorusquare = 13137;
  e2.rlinebelow = 7775;
  e2.rlongleg = 636;
  e2.rlonglegturned = 634;
  e2.rmonospace = 65362;
  e2.rohiragana = 12429;
  e2.rokatakana = 12525;
  e2.rokatakanahalfwidth = 65435;
  e2.roruathai = 3619;
  e2.rparen = 9389;
  e2.rrabengali = 2524;
  e2.rradeva = 2353;
  e2.rragurmukhi = 2652;
  e2.rreharabic = 1681;
  e2.rrehfinalarabic = 64397;
  e2.rrvocalicbengali = 2528;
  e2.rrvocalicdeva = 2400;
  e2.rrvocalicgujarati = 2784;
  e2.rrvocalicvowelsignbengali = 2500;
  e2.rrvocalicvowelsigndeva = 2372;
  e2.rrvocalicvowelsigngujarati = 2756;
  e2.rsuperior = 63217;
  e2.rtblock = 9616;
  e2.rturned = 633;
  e2.rturnedsuperior = 692;
  e2.ruhiragana = 12427;
  e2.rukatakana = 12523;
  e2.rukatakanahalfwidth = 65433;
  e2.rupeemarkbengali = 2546;
  e2.rupeesignbengali = 2547;
  e2.rupiah = 63197;
  e2.ruthai = 3620;
  e2.rvocalicbengali = 2443;
  e2.rvocalicdeva = 2315;
  e2.rvocalicgujarati = 2699;
  e2.rvocalicvowelsignbengali = 2499;
  e2.rvocalicvowelsigndeva = 2371;
  e2.rvocalicvowelsigngujarati = 2755;
  e2.s = 115;
  e2.sabengali = 2488;
  e2.sacute = 347;
  e2.sacutedotaccent = 7781;
  e2.sadarabic = 1589;
  e2.sadeva = 2360;
  e2.sadfinalarabic = 65210;
  e2.sadinitialarabic = 65211;
  e2.sadmedialarabic = 65212;
  e2.sagujarati = 2744;
  e2.sagurmukhi = 2616;
  e2.sahiragana = 12373;
  e2.sakatakana = 12469;
  e2.sakatakanahalfwidth = 65403;
  e2.sallallahoualayhewasallamarabic = 65018;
  e2.samekh = 1505;
  e2.samekhdagesh = 64321;
  e2.samekhdageshhebrew = 64321;
  e2.samekhhebrew = 1505;
  e2.saraaathai = 3634;
  e2.saraaethai = 3649;
  e2.saraaimaimalaithai = 3652;
  e2.saraaimaimuanthai = 3651;
  e2.saraamthai = 3635;
  e2.saraathai = 3632;
  e2.saraethai = 3648;
  e2.saraiileftthai = 63622;
  e2.saraiithai = 3637;
  e2.saraileftthai = 63621;
  e2.saraithai = 3636;
  e2.saraothai = 3650;
  e2.saraueeleftthai = 63624;
  e2.saraueethai = 3639;
  e2.saraueleftthai = 63623;
  e2.sarauethai = 3638;
  e2.sarauthai = 3640;
  e2.sarauuthai = 3641;
  e2.sbopomofo = 12569;
  e2.scaron = 353;
  e2.scarondotaccent = 7783;
  e2.scedilla = 351;
  e2.schwa = 601;
  e2.schwacyrillic = 1241;
  e2.schwadieresiscyrillic = 1243;
  e2.schwahook = 602;
  e2.scircle = 9442;
  e2.scircumflex = 349;
  e2.scommaaccent = 537;
  e2.sdotaccent = 7777;
  e2.sdotbelow = 7779;
  e2.sdotbelowdotaccent = 7785;
  e2.seagullbelowcmb = 828;
  e2.second = 8243;
  e2.secondtonechinese = 714;
  e2.section = 167;
  e2.seenarabic = 1587;
  e2.seenfinalarabic = 65202;
  e2.seeninitialarabic = 65203;
  e2.seenmedialarabic = 65204;
  e2.segol = 1462;
  e2.segol13 = 1462;
  e2.segol1f = 1462;
  e2.segol2c = 1462;
  e2.segolhebrew = 1462;
  e2.segolnarrowhebrew = 1462;
  e2.segolquarterhebrew = 1462;
  e2.segoltahebrew = 1426;
  e2.segolwidehebrew = 1462;
  e2.seharmenian = 1405;
  e2.sehiragana = 12379;
  e2.sekatakana = 12475;
  e2.sekatakanahalfwidth = 65406;
  e2.semicolon = 59;
  e2.semicolonarabic = 1563;
  e2.semicolonmonospace = 65307;
  e2.semicolonsmall = 65108;
  e2.semivoicedmarkkana = 12444;
  e2.semivoicedmarkkanahalfwidth = 65439;
  e2.sentisquare = 13090;
  e2.sentosquare = 13091;
  e2.seven = 55;
  e2.sevenarabic = 1639;
  e2.sevenbengali = 2541;
  e2.sevencircle = 9318;
  e2.sevencircleinversesansserif = 10128;
  e2.sevendeva = 2413;
  e2.seveneighths = 8542;
  e2.sevengujarati = 2797;
  e2.sevengurmukhi = 2669;
  e2.sevenhackarabic = 1639;
  e2.sevenhangzhou = 12327;
  e2.sevenideographicparen = 12838;
  e2.seveninferior = 8327;
  e2.sevenmonospace = 65303;
  e2.sevenoldstyle = 63287;
  e2.sevenparen = 9338;
  e2.sevenperiod = 9358;
  e2.sevenpersian = 1783;
  e2.sevenroman = 8566;
  e2.sevensuperior = 8311;
  e2.seventeencircle = 9328;
  e2.seventeenparen = 9348;
  e2.seventeenperiod = 9368;
  e2.seventhai = 3671;
  e2.sfthyphen = 173;
  e2.shaarmenian = 1399;
  e2.shabengali = 2486;
  e2.shacyrillic = 1096;
  e2.shaddaarabic = 1617;
  e2.shaddadammaarabic = 64609;
  e2.shaddadammatanarabic = 64606;
  e2.shaddafathaarabic = 64608;
  e2.shaddakasraarabic = 64610;
  e2.shaddakasratanarabic = 64607;
  e2.shade = 9618;
  e2.shadedark = 9619;
  e2.shadelight = 9617;
  e2.shademedium = 9618;
  e2.shadeva = 2358;
  e2.shagujarati = 2742;
  e2.shagurmukhi = 2614;
  e2.shalshelethebrew = 1427;
  e2.shbopomofo = 12565;
  e2.shchacyrillic = 1097;
  e2.sheenarabic = 1588;
  e2.sheenfinalarabic = 65206;
  e2.sheeninitialarabic = 65207;
  e2.sheenmedialarabic = 65208;
  e2.sheicoptic = 995;
  e2.sheqel = 8362;
  e2.sheqelhebrew = 8362;
  e2.sheva = 1456;
  e2.sheva115 = 1456;
  e2.sheva15 = 1456;
  e2.sheva22 = 1456;
  e2.sheva2e = 1456;
  e2.shevahebrew = 1456;
  e2.shevanarrowhebrew = 1456;
  e2.shevaquarterhebrew = 1456;
  e2.shevawidehebrew = 1456;
  e2.shhacyrillic = 1211;
  e2.shimacoptic = 1005;
  e2.shin = 1513;
  e2.shindagesh = 64329;
  e2.shindageshhebrew = 64329;
  e2.shindageshshindot = 64300;
  e2.shindageshshindothebrew = 64300;
  e2.shindageshsindot = 64301;
  e2.shindageshsindothebrew = 64301;
  e2.shindothebrew = 1473;
  e2.shinhebrew = 1513;
  e2.shinshindot = 64298;
  e2.shinshindothebrew = 64298;
  e2.shinsindot = 64299;
  e2.shinsindothebrew = 64299;
  e2.shook = 642;
  e2.sigma = 963;
  e2.sigma1 = 962;
  e2.sigmafinal = 962;
  e2.sigmalunatesymbolgreek = 1010;
  e2.sihiragana = 12375;
  e2.sikatakana = 12471;
  e2.sikatakanahalfwidth = 65404;
  e2.siluqhebrew = 1469;
  e2.siluqlefthebrew = 1469;
  e2.similar = 8764;
  e2.sindothebrew = 1474;
  e2.siosacirclekorean = 12916;
  e2.siosaparenkorean = 12820;
  e2.sioscieuckorean = 12670;
  e2.sioscirclekorean = 12902;
  e2.sioskiyeokkorean = 12666;
  e2.sioskorean = 12613;
  e2.siosnieunkorean = 12667;
  e2.siosparenkorean = 12806;
  e2.siospieupkorean = 12669;
  e2.siostikeutkorean = 12668;
  e2.six = 54;
  e2.sixarabic = 1638;
  e2.sixbengali = 2540;
  e2.sixcircle = 9317;
  e2.sixcircleinversesansserif = 10127;
  e2.sixdeva = 2412;
  e2.sixgujarati = 2796;
  e2.sixgurmukhi = 2668;
  e2.sixhackarabic = 1638;
  e2.sixhangzhou = 12326;
  e2.sixideographicparen = 12837;
  e2.sixinferior = 8326;
  e2.sixmonospace = 65302;
  e2.sixoldstyle = 63286;
  e2.sixparen = 9337;
  e2.sixperiod = 9357;
  e2.sixpersian = 1782;
  e2.sixroman = 8565;
  e2.sixsuperior = 8310;
  e2.sixteencircle = 9327;
  e2.sixteencurrencydenominatorbengali = 2553;
  e2.sixteenparen = 9347;
  e2.sixteenperiod = 9367;
  e2.sixthai = 3670;
  e2.slash = 47;
  e2.slashmonospace = 65295;
  e2.slong = 383;
  e2.slongdotaccent = 7835;
  e2.smileface = 9786;
  e2.smonospace = 65363;
  e2.sofpasuqhebrew = 1475;
  e2.softhyphen = 173;
  e2.softsigncyrillic = 1100;
  e2.sohiragana = 12381;
  e2.sokatakana = 12477;
  e2.sokatakanahalfwidth = 65407;
  e2.soliduslongoverlaycmb = 824;
  e2.solidusshortoverlaycmb = 823;
  e2.sorusithai = 3625;
  e2.sosalathai = 3624;
  e2.sosothai = 3595;
  e2.sosuathai = 3626;
  e2.space = 32;
  e2.spacehackarabic = 32;
  e2.spade = 9824;
  e2.spadesuitblack = 9824;
  e2.spadesuitwhite = 9828;
  e2.sparen = 9390;
  e2.squarebelowcmb = 827;
  e2.squarecc = 13252;
  e2.squarecm = 13213;
  e2.squarediagonalcrosshatchfill = 9641;
  e2.squarehorizontalfill = 9636;
  e2.squarekg = 13199;
  e2.squarekm = 13214;
  e2.squarekmcapital = 13262;
  e2.squareln = 13265;
  e2.squarelog = 13266;
  e2.squaremg = 13198;
  e2.squaremil = 13269;
  e2.squaremm = 13212;
  e2.squaremsquared = 13217;
  e2.squareorthogonalcrosshatchfill = 9638;
  e2.squareupperlefttolowerrightfill = 9639;
  e2.squareupperrighttolowerleftfill = 9640;
  e2.squareverticalfill = 9637;
  e2.squarewhitewithsmallblack = 9635;
  e2.srsquare = 13275;
  e2.ssabengali = 2487;
  e2.ssadeva = 2359;
  e2.ssagujarati = 2743;
  e2.ssangcieuckorean = 12617;
  e2.ssanghieuhkorean = 12677;
  e2.ssangieungkorean = 12672;
  e2.ssangkiyeokkorean = 12594;
  e2.ssangnieunkorean = 12645;
  e2.ssangpieupkorean = 12611;
  e2.ssangsioskorean = 12614;
  e2.ssangtikeutkorean = 12600;
  e2.ssuperior = 63218;
  e2.sterling = 163;
  e2.sterlingmonospace = 65505;
  e2.strokelongoverlaycmb = 822;
  e2.strokeshortoverlaycmb = 821;
  e2.subset = 8834;
  e2.subsetnotequal = 8842;
  e2.subsetorequal = 8838;
  e2.succeeds = 8827;
  e2.suchthat = 8715;
  e2.suhiragana = 12377;
  e2.sukatakana = 12473;
  e2.sukatakanahalfwidth = 65405;
  e2.sukunarabic = 1618;
  e2.summation = 8721;
  e2.sun = 9788;
  e2.superset = 8835;
  e2.supersetnotequal = 8843;
  e2.supersetorequal = 8839;
  e2.svsquare = 13276;
  e2.syouwaerasquare = 13180;
  e2.t = 116;
  e2.tabengali = 2468;
  e2.tackdown = 8868;
  e2.tackleft = 8867;
  e2.tadeva = 2340;
  e2.tagujarati = 2724;
  e2.tagurmukhi = 2596;
  e2.taharabic = 1591;
  e2.tahfinalarabic = 65218;
  e2.tahinitialarabic = 65219;
  e2.tahiragana = 12383;
  e2.tahmedialarabic = 65220;
  e2.taisyouerasquare = 13181;
  e2.takatakana = 12479;
  e2.takatakanahalfwidth = 65408;
  e2.tatweelarabic = 1600;
  e2.tau = 964;
  e2.tav = 1514;
  e2.tavdages = 64330;
  e2.tavdagesh = 64330;
  e2.tavdageshhebrew = 64330;
  e2.tavhebrew = 1514;
  e2.tbar = 359;
  e2.tbopomofo = 12554;
  e2.tcaron = 357;
  e2.tccurl = 680;
  e2.tcedilla = 355;
  e2.tcheharabic = 1670;
  e2.tchehfinalarabic = 64379;
  e2.tchehinitialarabic = 64380;
  e2.tchehmedialarabic = 64381;
  e2.tcircle = 9443;
  e2.tcircumflexbelow = 7793;
  e2.tcommaaccent = 355;
  e2.tdieresis = 7831;
  e2.tdotaccent = 7787;
  e2.tdotbelow = 7789;
  e2.tecyrillic = 1090;
  e2.tedescendercyrillic = 1197;
  e2.teharabic = 1578;
  e2.tehfinalarabic = 65174;
  e2.tehhahinitialarabic = 64674;
  e2.tehhahisolatedarabic = 64524;
  e2.tehinitialarabic = 65175;
  e2.tehiragana = 12390;
  e2.tehjeeminitialarabic = 64673;
  e2.tehjeemisolatedarabic = 64523;
  e2.tehmarbutaarabic = 1577;
  e2.tehmarbutafinalarabic = 65172;
  e2.tehmedialarabic = 65176;
  e2.tehmeeminitialarabic = 64676;
  e2.tehmeemisolatedarabic = 64526;
  e2.tehnoonfinalarabic = 64627;
  e2.tekatakana = 12486;
  e2.tekatakanahalfwidth = 65411;
  e2.telephone = 8481;
  e2.telephoneblack = 9742;
  e2.telishagedolahebrew = 1440;
  e2.telishaqetanahebrew = 1449;
  e2.tencircle = 9321;
  e2.tenideographicparen = 12841;
  e2.tenparen = 9341;
  e2.tenperiod = 9361;
  e2.tenroman = 8569;
  e2.tesh = 679;
  e2.tet = 1496;
  e2.tetdagesh = 64312;
  e2.tetdageshhebrew = 64312;
  e2.tethebrew = 1496;
  e2.tetsecyrillic = 1205;
  e2.tevirhebrew = 1435;
  e2.tevirlefthebrew = 1435;
  e2.thabengali = 2469;
  e2.thadeva = 2341;
  e2.thagujarati = 2725;
  e2.thagurmukhi = 2597;
  e2.thalarabic = 1584;
  e2.thalfinalarabic = 65196;
  e2.thanthakhatlowleftthai = 63640;
  e2.thanthakhatlowrightthai = 63639;
  e2.thanthakhatthai = 3660;
  e2.thanthakhatupperleftthai = 63638;
  e2.theharabic = 1579;
  e2.thehfinalarabic = 65178;
  e2.thehinitialarabic = 65179;
  e2.thehmedialarabic = 65180;
  e2.thereexists = 8707;
  e2.therefore = 8756;
  e2.theta = 952;
  e2.theta1 = 977;
  e2.thetasymbolgreek = 977;
  e2.thieuthacirclekorean = 12921;
  e2.thieuthaparenkorean = 12825;
  e2.thieuthcirclekorean = 12907;
  e2.thieuthkorean = 12620;
  e2.thieuthparenkorean = 12811;
  e2.thirteencircle = 9324;
  e2.thirteenparen = 9344;
  e2.thirteenperiod = 9364;
  e2.thonangmonthothai = 3601;
  e2.thook = 429;
  e2.thophuthaothai = 3602;
  e2.thorn = 254;
  e2.thothahanthai = 3607;
  e2.thothanthai = 3600;
  e2.thothongthai = 3608;
  e2.thothungthai = 3606;
  e2.thousandcyrillic = 1154;
  e2.thousandsseparatorarabic = 1644;
  e2.thousandsseparatorpersian = 1644;
  e2.three = 51;
  e2.threearabic = 1635;
  e2.threebengali = 2537;
  e2.threecircle = 9314;
  e2.threecircleinversesansserif = 10124;
  e2.threedeva = 2409;
  e2.threeeighths = 8540;
  e2.threegujarati = 2793;
  e2.threegurmukhi = 2665;
  e2.threehackarabic = 1635;
  e2.threehangzhou = 12323;
  e2.threeideographicparen = 12834;
  e2.threeinferior = 8323;
  e2.threemonospace = 65299;
  e2.threenumeratorbengali = 2550;
  e2.threeoldstyle = 63283;
  e2.threeparen = 9334;
  e2.threeperiod = 9354;
  e2.threepersian = 1779;
  e2.threequarters = 190;
  e2.threequartersemdash = 63198;
  e2.threeroman = 8562;
  e2.threesuperior = 179;
  e2.threethai = 3667;
  e2.thzsquare = 13204;
  e2.tihiragana = 12385;
  e2.tikatakana = 12481;
  e2.tikatakanahalfwidth = 65409;
  e2.tikeutacirclekorean = 12912;
  e2.tikeutaparenkorean = 12816;
  e2.tikeutcirclekorean = 12898;
  e2.tikeutkorean = 12599;
  e2.tikeutparenkorean = 12802;
  e2.tilde = 732;
  e2.tildebelowcmb = 816;
  e2.tildecmb = 771;
  e2.tildecomb = 771;
  e2.tildedoublecmb = 864;
  e2.tildeoperator = 8764;
  e2.tildeoverlaycmb = 820;
  e2.tildeverticalcmb = 830;
  e2.timescircle = 8855;
  e2.tipehahebrew = 1430;
  e2.tipehalefthebrew = 1430;
  e2.tippigurmukhi = 2672;
  e2.titlocyrilliccmb = 1155;
  e2.tiwnarmenian = 1407;
  e2.tlinebelow = 7791;
  e2.tmonospace = 65364;
  e2.toarmenian = 1385;
  e2.tohiragana = 12392;
  e2.tokatakana = 12488;
  e2.tokatakanahalfwidth = 65412;
  e2.tonebarextrahighmod = 741;
  e2.tonebarextralowmod = 745;
  e2.tonebarhighmod = 742;
  e2.tonebarlowmod = 744;
  e2.tonebarmidmod = 743;
  e2.tonefive = 445;
  e2.tonesix = 389;
  e2.tonetwo = 424;
  e2.tonos = 900;
  e2.tonsquare = 13095;
  e2.topatakthai = 3599;
  e2.tortoiseshellbracketleft = 12308;
  e2.tortoiseshellbracketleftsmall = 65117;
  e2.tortoiseshellbracketleftvertical = 65081;
  e2.tortoiseshellbracketright = 12309;
  e2.tortoiseshellbracketrightsmall = 65118;
  e2.tortoiseshellbracketrightvertical = 65082;
  e2.totaothai = 3605;
  e2.tpalatalhook = 427;
  e2.tparen = 9391;
  e2.trademark = 8482;
  e2.trademarksans = 63722;
  e2.trademarkserif = 63195;
  e2.tretroflexhook = 648;
  e2.triagdn = 9660;
  e2.triaglf = 9668;
  e2.triagrt = 9658;
  e2.triagup = 9650;
  e2.ts = 678;
  e2.tsadi = 1510;
  e2.tsadidagesh = 64326;
  e2.tsadidageshhebrew = 64326;
  e2.tsadihebrew = 1510;
  e2.tsecyrillic = 1094;
  e2.tsere = 1461;
  e2.tsere12 = 1461;
  e2.tsere1e = 1461;
  e2.tsere2b = 1461;
  e2.tserehebrew = 1461;
  e2.tserenarrowhebrew = 1461;
  e2.tserequarterhebrew = 1461;
  e2.tserewidehebrew = 1461;
  e2.tshecyrillic = 1115;
  e2.tsuperior = 63219;
  e2.ttabengali = 2463;
  e2.ttadeva = 2335;
  e2.ttagujarati = 2719;
  e2.ttagurmukhi = 2591;
  e2.tteharabic = 1657;
  e2.ttehfinalarabic = 64359;
  e2.ttehinitialarabic = 64360;
  e2.ttehmedialarabic = 64361;
  e2.tthabengali = 2464;
  e2.tthadeva = 2336;
  e2.tthagujarati = 2720;
  e2.tthagurmukhi = 2592;
  e2.tturned = 647;
  e2.tuhiragana = 12388;
  e2.tukatakana = 12484;
  e2.tukatakanahalfwidth = 65410;
  e2.tusmallhiragana = 12387;
  e2.tusmallkatakana = 12483;
  e2.tusmallkatakanahalfwidth = 65391;
  e2.twelvecircle = 9323;
  e2.twelveparen = 9343;
  e2.twelveperiod = 9363;
  e2.twelveroman = 8571;
  e2.twentycircle = 9331;
  e2.twentyhangzhou = 21316;
  e2.twentyparen = 9351;
  e2.twentyperiod = 9371;
  e2.two = 50;
  e2.twoarabic = 1634;
  e2.twobengali = 2536;
  e2.twocircle = 9313;
  e2.twocircleinversesansserif = 10123;
  e2.twodeva = 2408;
  e2.twodotenleader = 8229;
  e2.twodotleader = 8229;
  e2.twodotleadervertical = 65072;
  e2.twogujarati = 2792;
  e2.twogurmukhi = 2664;
  e2.twohackarabic = 1634;
  e2.twohangzhou = 12322;
  e2.twoideographicparen = 12833;
  e2.twoinferior = 8322;
  e2.twomonospace = 65298;
  e2.twonumeratorbengali = 2549;
  e2.twooldstyle = 63282;
  e2.twoparen = 9333;
  e2.twoperiod = 9353;
  e2.twopersian = 1778;
  e2.tworoman = 8561;
  e2.twostroke = 443;
  e2.twosuperior = 178;
  e2.twothai = 3666;
  e2.twothirds = 8532;
  e2.u = 117;
  e2.uacute = 250;
  e2.ubar = 649;
  e2.ubengali = 2441;
  e2.ubopomofo = 12584;
  e2.ubreve = 365;
  e2.ucaron = 468;
  e2.ucircle = 9444;
  e2.ucircumflex = 251;
  e2.ucircumflexbelow = 7799;
  e2.ucyrillic = 1091;
  e2.udattadeva = 2385;
  e2.udblacute = 369;
  e2.udblgrave = 533;
  e2.udeva = 2313;
  e2.udieresis = 252;
  e2.udieresisacute = 472;
  e2.udieresisbelow = 7795;
  e2.udieresiscaron = 474;
  e2.udieresiscyrillic = 1265;
  e2.udieresisgrave = 476;
  e2.udieresismacron = 470;
  e2.udotbelow = 7909;
  e2.ugrave = 249;
  e2.ugujarati = 2697;
  e2.ugurmukhi = 2569;
  e2.uhiragana = 12358;
  e2.uhookabove = 7911;
  e2.uhorn = 432;
  e2.uhornacute = 7913;
  e2.uhorndotbelow = 7921;
  e2.uhorngrave = 7915;
  e2.uhornhookabove = 7917;
  e2.uhorntilde = 7919;
  e2.uhungarumlaut = 369;
  e2.uhungarumlautcyrillic = 1267;
  e2.uinvertedbreve = 535;
  e2.ukatakana = 12454;
  e2.ukatakanahalfwidth = 65395;
  e2.ukcyrillic = 1145;
  e2.ukorean = 12636;
  e2.umacron = 363;
  e2.umacroncyrillic = 1263;
  e2.umacrondieresis = 7803;
  e2.umatragurmukhi = 2625;
  e2.umonospace = 65365;
  e2.underscore = 95;
  e2.underscoredbl = 8215;
  e2.underscoremonospace = 65343;
  e2.underscorevertical = 65075;
  e2.underscorewavy = 65103;
  e2.union = 8746;
  e2.universal = 8704;
  e2.uogonek = 371;
  e2.uparen = 9392;
  e2.upblock = 9600;
  e2.upperdothebrew = 1476;
  e2.upsilon = 965;
  e2.upsilondieresis = 971;
  e2.upsilondieresistonos = 944;
  e2.upsilonlatin = 650;
  e2.upsilontonos = 973;
  e2.uptackbelowcmb = 797;
  e2.uptackmod = 724;
  e2.uragurmukhi = 2675;
  e2.uring = 367;
  e2.ushortcyrillic = 1118;
  e2.usmallhiragana = 12357;
  e2.usmallkatakana = 12453;
  e2.usmallkatakanahalfwidth = 65385;
  e2.ustraightcyrillic = 1199;
  e2.ustraightstrokecyrillic = 1201;
  e2.utilde = 361;
  e2.utildeacute = 7801;
  e2.utildebelow = 7797;
  e2.uubengali = 2442;
  e2.uudeva = 2314;
  e2.uugujarati = 2698;
  e2.uugurmukhi = 2570;
  e2.uumatragurmukhi = 2626;
  e2.uuvowelsignbengali = 2498;
  e2.uuvowelsigndeva = 2370;
  e2.uuvowelsigngujarati = 2754;
  e2.uvowelsignbengali = 2497;
  e2.uvowelsigndeva = 2369;
  e2.uvowelsigngujarati = 2753;
  e2.v = 118;
  e2.vadeva = 2357;
  e2.vagujarati = 2741;
  e2.vagurmukhi = 2613;
  e2.vakatakana = 12535;
  e2.vav = 1493;
  e2.vavdagesh = 64309;
  e2.vavdagesh65 = 64309;
  e2.vavdageshhebrew = 64309;
  e2.vavhebrew = 1493;
  e2.vavholam = 64331;
  e2.vavholamhebrew = 64331;
  e2.vavvavhebrew = 1520;
  e2.vavyodhebrew = 1521;
  e2.vcircle = 9445;
  e2.vdotbelow = 7807;
  e2.vecyrillic = 1074;
  e2.veharabic = 1700;
  e2.vehfinalarabic = 64363;
  e2.vehinitialarabic = 64364;
  e2.vehmedialarabic = 64365;
  e2.vekatakana = 12537;
  e2.venus = 9792;
  e2.verticalbar = 124;
  e2.verticallineabovecmb = 781;
  e2.verticallinebelowcmb = 809;
  e2.verticallinelowmod = 716;
  e2.verticallinemod = 712;
  e2.vewarmenian = 1406;
  e2.vhook = 651;
  e2.vikatakana = 12536;
  e2.viramabengali = 2509;
  e2.viramadeva = 2381;
  e2.viramagujarati = 2765;
  e2.visargabengali = 2435;
  e2.visargadeva = 2307;
  e2.visargagujarati = 2691;
  e2.vmonospace = 65366;
  e2.voarmenian = 1400;
  e2.voicediterationhiragana = 12446;
  e2.voicediterationkatakana = 12542;
  e2.voicedmarkkana = 12443;
  e2.voicedmarkkanahalfwidth = 65438;
  e2.vokatakana = 12538;
  e2.vparen = 9393;
  e2.vtilde = 7805;
  e2.vturned = 652;
  e2.vuhiragana = 12436;
  e2.vukatakana = 12532;
  e2.w = 119;
  e2.wacute = 7811;
  e2.waekorean = 12633;
  e2.wahiragana = 12431;
  e2.wakatakana = 12527;
  e2.wakatakanahalfwidth = 65436;
  e2.wakorean = 12632;
  e2.wasmallhiragana = 12430;
  e2.wasmallkatakana = 12526;
  e2.wattosquare = 13143;
  e2.wavedash = 12316;
  e2.wavyunderscorevertical = 65076;
  e2.wawarabic = 1608;
  e2.wawfinalarabic = 65262;
  e2.wawhamzaabovearabic = 1572;
  e2.wawhamzaabovefinalarabic = 65158;
  e2.wbsquare = 13277;
  e2.wcircle = 9446;
  e2.wcircumflex = 373;
  e2.wdieresis = 7813;
  e2.wdotaccent = 7815;
  e2.wdotbelow = 7817;
  e2.wehiragana = 12433;
  e2.weierstrass = 8472;
  e2.wekatakana = 12529;
  e2.wekorean = 12638;
  e2.weokorean = 12637;
  e2.wgrave = 7809;
  e2.whitebullet = 9702;
  e2.whitecircle = 9675;
  e2.whitecircleinverse = 9689;
  e2.whitecornerbracketleft = 12302;
  e2.whitecornerbracketleftvertical = 65091;
  e2.whitecornerbracketright = 12303;
  e2.whitecornerbracketrightvertical = 65092;
  e2.whitediamond = 9671;
  e2.whitediamondcontainingblacksmalldiamond = 9672;
  e2.whitedownpointingsmalltriangle = 9663;
  e2.whitedownpointingtriangle = 9661;
  e2.whiteleftpointingsmalltriangle = 9667;
  e2.whiteleftpointingtriangle = 9665;
  e2.whitelenticularbracketleft = 12310;
  e2.whitelenticularbracketright = 12311;
  e2.whiterightpointingsmalltriangle = 9657;
  e2.whiterightpointingtriangle = 9655;
  e2.whitesmallsquare = 9643;
  e2.whitesmilingface = 9786;
  e2.whitesquare = 9633;
  e2.whitestar = 9734;
  e2.whitetelephone = 9743;
  e2.whitetortoiseshellbracketleft = 12312;
  e2.whitetortoiseshellbracketright = 12313;
  e2.whiteuppointingsmalltriangle = 9653;
  e2.whiteuppointingtriangle = 9651;
  e2.wihiragana = 12432;
  e2.wikatakana = 12528;
  e2.wikorean = 12639;
  e2.wmonospace = 65367;
  e2.wohiragana = 12434;
  e2.wokatakana = 12530;
  e2.wokatakanahalfwidth = 65382;
  e2.won = 8361;
  e2.wonmonospace = 65510;
  e2.wowaenthai = 3623;
  e2.wparen = 9394;
  e2.wring = 7832;
  e2.wsuperior = 695;
  e2.wturned = 653;
  e2.wynn = 447;
  e2.x = 120;
  e2.xabovecmb = 829;
  e2.xbopomofo = 12562;
  e2.xcircle = 9447;
  e2.xdieresis = 7821;
  e2.xdotaccent = 7819;
  e2.xeharmenian = 1389;
  e2.xi = 958;
  e2.xmonospace = 65368;
  e2.xparen = 9395;
  e2.xsuperior = 739;
  e2.y = 121;
  e2.yaadosquare = 13134;
  e2.yabengali = 2479;
  e2.yacute = 253;
  e2.yadeva = 2351;
  e2.yaekorean = 12626;
  e2.yagujarati = 2735;
  e2.yagurmukhi = 2607;
  e2.yahiragana = 12420;
  e2.yakatakana = 12516;
  e2.yakatakanahalfwidth = 65428;
  e2.yakorean = 12625;
  e2.yamakkanthai = 3662;
  e2.yasmallhiragana = 12419;
  e2.yasmallkatakana = 12515;
  e2.yasmallkatakanahalfwidth = 65388;
  e2.yatcyrillic = 1123;
  e2.ycircle = 9448;
  e2.ycircumflex = 375;
  e2.ydieresis = 255;
  e2.ydotaccent = 7823;
  e2.ydotbelow = 7925;
  e2.yeharabic = 1610;
  e2.yehbarreearabic = 1746;
  e2.yehbarreefinalarabic = 64431;
  e2.yehfinalarabic = 65266;
  e2.yehhamzaabovearabic = 1574;
  e2.yehhamzaabovefinalarabic = 65162;
  e2.yehhamzaaboveinitialarabic = 65163;
  e2.yehhamzaabovemedialarabic = 65164;
  e2.yehinitialarabic = 65267;
  e2.yehmedialarabic = 65268;
  e2.yehmeeminitialarabic = 64733;
  e2.yehmeemisolatedarabic = 64600;
  e2.yehnoonfinalarabic = 64660;
  e2.yehthreedotsbelowarabic = 1745;
  e2.yekorean = 12630;
  e2.yen = 165;
  e2.yenmonospace = 65509;
  e2.yeokorean = 12629;
  e2.yeorinhieuhkorean = 12678;
  e2.yerahbenyomohebrew = 1450;
  e2.yerahbenyomolefthebrew = 1450;
  e2.yericyrillic = 1099;
  e2.yerudieresiscyrillic = 1273;
  e2.yesieungkorean = 12673;
  e2.yesieungpansioskorean = 12675;
  e2.yesieungsioskorean = 12674;
  e2.yetivhebrew = 1434;
  e2.ygrave = 7923;
  e2.yhook = 436;
  e2.yhookabove = 7927;
  e2.yiarmenian = 1397;
  e2.yicyrillic = 1111;
  e2.yikorean = 12642;
  e2.yinyang = 9775;
  e2.yiwnarmenian = 1410;
  e2.ymonospace = 65369;
  e2.yod = 1497;
  e2.yoddagesh = 64313;
  e2.yoddageshhebrew = 64313;
  e2.yodhebrew = 1497;
  e2.yodyodhebrew = 1522;
  e2.yodyodpatahhebrew = 64287;
  e2.yohiragana = 12424;
  e2.yoikorean = 12681;
  e2.yokatakana = 12520;
  e2.yokatakanahalfwidth = 65430;
  e2.yokorean = 12635;
  e2.yosmallhiragana = 12423;
  e2.yosmallkatakana = 12519;
  e2.yosmallkatakanahalfwidth = 65390;
  e2.yotgreek = 1011;
  e2.yoyaekorean = 12680;
  e2.yoyakorean = 12679;
  e2.yoyakthai = 3618;
  e2.yoyingthai = 3597;
  e2.yparen = 9396;
  e2.ypogegrammeni = 890;
  e2.ypogegrammenigreekcmb = 837;
  e2.yr = 422;
  e2.yring = 7833;
  e2.ysuperior = 696;
  e2.ytilde = 7929;
  e2.yturned = 654;
  e2.yuhiragana = 12422;
  e2.yuikorean = 12684;
  e2.yukatakana = 12518;
  e2.yukatakanahalfwidth = 65429;
  e2.yukorean = 12640;
  e2.yusbigcyrillic = 1131;
  e2.yusbigiotifiedcyrillic = 1133;
  e2.yuslittlecyrillic = 1127;
  e2.yuslittleiotifiedcyrillic = 1129;
  e2.yusmallhiragana = 12421;
  e2.yusmallkatakana = 12517;
  e2.yusmallkatakanahalfwidth = 65389;
  e2.yuyekorean = 12683;
  e2.yuyeokorean = 12682;
  e2.yyabengali = 2527;
  e2.yyadeva = 2399;
  e2.z = 122;
  e2.zaarmenian = 1382;
  e2.zacute = 378;
  e2.zadeva = 2395;
  e2.zagurmukhi = 2651;
  e2.zaharabic = 1592;
  e2.zahfinalarabic = 65222;
  e2.zahinitialarabic = 65223;
  e2.zahiragana = 12374;
  e2.zahmedialarabic = 65224;
  e2.zainarabic = 1586;
  e2.zainfinalarabic = 65200;
  e2.zakatakana = 12470;
  e2.zaqefgadolhebrew = 1429;
  e2.zaqefqatanhebrew = 1428;
  e2.zarqahebrew = 1432;
  e2.zayin = 1494;
  e2.zayindagesh = 64310;
  e2.zayindageshhebrew = 64310;
  e2.zayinhebrew = 1494;
  e2.zbopomofo = 12567;
  e2.zcaron = 382;
  e2.zcircle = 9449;
  e2.zcircumflex = 7825;
  e2.zcurl = 657;
  e2.zdot = 380;
  e2.zdotaccent = 380;
  e2.zdotbelow = 7827;
  e2.zecyrillic = 1079;
  e2.zedescendercyrillic = 1177;
  e2.zedieresiscyrillic = 1247;
  e2.zehiragana = 12380;
  e2.zekatakana = 12476;
  e2.zero = 48;
  e2.zeroarabic = 1632;
  e2.zerobengali = 2534;
  e2.zerodeva = 2406;
  e2.zerogujarati = 2790;
  e2.zerogurmukhi = 2662;
  e2.zerohackarabic = 1632;
  e2.zeroinferior = 8320;
  e2.zeromonospace = 65296;
  e2.zerooldstyle = 63280;
  e2.zeropersian = 1776;
  e2.zerosuperior = 8304;
  e2.zerothai = 3664;
  e2.zerowidthjoiner = 65279;
  e2.zerowidthnonjoiner = 8204;
  e2.zerowidthspace = 8203;
  e2.zeta = 950;
  e2.zhbopomofo = 12563;
  e2.zhearmenian = 1386;
  e2.zhebrevecyrillic = 1218;
  e2.zhecyrillic = 1078;
  e2.zhedescendercyrillic = 1175;
  e2.zhedieresiscyrillic = 1245;
  e2.zihiragana = 12376;
  e2.zikatakana = 12472;
  e2.zinorhebrew = 1454;
  e2.zlinebelow = 7829;
  e2.zmonospace = 65370;
  e2.zohiragana = 12382;
  e2.zokatakana = 12478;
  e2.zparen = 9397;
  e2.zretroflexhook = 656;
  e2.zstroke = 438;
  e2.zuhiragana = 12378;
  e2.zukatakana = 12474;
  e2[".notdef"] = 0;
  e2.angbracketleftbig = 9001;
  e2.angbracketleftBig = 9001;
  e2.angbracketleftbigg = 9001;
  e2.angbracketleftBigg = 9001;
  e2.angbracketrightBig = 9002;
  e2.angbracketrightbig = 9002;
  e2.angbracketrightBigg = 9002;
  e2.angbracketrightbigg = 9002;
  e2.arrowhookleft = 8618;
  e2.arrowhookright = 8617;
  e2.arrowlefttophalf = 8636;
  e2.arrowleftbothalf = 8637;
  e2.arrownortheast = 8599;
  e2.arrownorthwest = 8598;
  e2.arrowrighttophalf = 8640;
  e2.arrowrightbothalf = 8641;
  e2.arrowsoutheast = 8600;
  e2.arrowsouthwest = 8601;
  e2.backslashbig = 8726;
  e2.backslashBig = 8726;
  e2.backslashBigg = 8726;
  e2.backslashbigg = 8726;
  e2.bardbl = 8214;
  e2.bracehtipdownleft = 65079;
  e2.bracehtipdownright = 65079;
  e2.bracehtipupleft = 65080;
  e2.bracehtipupright = 65080;
  e2.braceleftBig = 123;
  e2.braceleftbig = 123;
  e2.braceleftbigg = 123;
  e2.braceleftBigg = 123;
  e2.bracerightBig = 125;
  e2.bracerightbig = 125;
  e2.bracerightbigg = 125;
  e2.bracerightBigg = 125;
  e2.bracketleftbig = 91;
  e2.bracketleftBig = 91;
  e2.bracketleftbigg = 91;
  e2.bracketleftBigg = 91;
  e2.bracketrightBig = 93;
  e2.bracketrightbig = 93;
  e2.bracketrightbigg = 93;
  e2.bracketrightBigg = 93;
  e2.ceilingleftbig = 8968;
  e2.ceilingleftBig = 8968;
  e2.ceilingleftBigg = 8968;
  e2.ceilingleftbigg = 8968;
  e2.ceilingrightbig = 8969;
  e2.ceilingrightBig = 8969;
  e2.ceilingrightbigg = 8969;
  e2.ceilingrightBigg = 8969;
  e2.circledotdisplay = 8857;
  e2.circledottext = 8857;
  e2.circlemultiplydisplay = 8855;
  e2.circlemultiplytext = 8855;
  e2.circleplusdisplay = 8853;
  e2.circleplustext = 8853;
  e2.contintegraldisplay = 8750;
  e2.contintegraltext = 8750;
  e2.coproductdisplay = 8720;
  e2.coproducttext = 8720;
  e2.floorleftBig = 8970;
  e2.floorleftbig = 8970;
  e2.floorleftbigg = 8970;
  e2.floorleftBigg = 8970;
  e2.floorrightbig = 8971;
  e2.floorrightBig = 8971;
  e2.floorrightBigg = 8971;
  e2.floorrightbigg = 8971;
  e2.hatwide = 770;
  e2.hatwider = 770;
  e2.hatwidest = 770;
  e2.intercal = 7488;
  e2.integraldisplay = 8747;
  e2.integraltext = 8747;
  e2.intersectiondisplay = 8898;
  e2.intersectiontext = 8898;
  e2.logicalanddisplay = 8743;
  e2.logicalandtext = 8743;
  e2.logicalordisplay = 8744;
  e2.logicalortext = 8744;
  e2.parenleftBig = 40;
  e2.parenleftbig = 40;
  e2.parenleftBigg = 40;
  e2.parenleftbigg = 40;
  e2.parenrightBig = 41;
  e2.parenrightbig = 41;
  e2.parenrightBigg = 41;
  e2.parenrightbigg = 41;
  e2.prime = 8242;
  e2.productdisplay = 8719;
  e2.producttext = 8719;
  e2.radicalbig = 8730;
  e2.radicalBig = 8730;
  e2.radicalBigg = 8730;
  e2.radicalbigg = 8730;
  e2.radicalbt = 8730;
  e2.radicaltp = 8730;
  e2.radicalvertex = 8730;
  e2.slashbig = 47;
  e2.slashBig = 47;
  e2.slashBigg = 47;
  e2.slashbigg = 47;
  e2.summationdisplay = 8721;
  e2.summationtext = 8721;
  e2.tildewide = 732;
  e2.tildewider = 732;
  e2.tildewidest = 732;
  e2.uniondisplay = 8899;
  e2.unionmultidisplay = 8846;
  e2.unionmultitext = 8846;
  e2.unionsqdisplay = 8852;
  e2.unionsqtext = 8852;
  e2.uniontext = 8899;
  e2.vextenddouble = 8741;
  e2.vextendsingle = 8739;
});
var Hi = getLookupTableFactory(function(e2) {
  e2.space = 32;
  e2.a1 = 9985;
  e2.a2 = 9986;
  e2.a202 = 9987;
  e2.a3 = 9988;
  e2.a4 = 9742;
  e2.a5 = 9990;
  e2.a119 = 9991;
  e2.a118 = 9992;
  e2.a117 = 9993;
  e2.a11 = 9755;
  e2.a12 = 9758;
  e2.a13 = 9996;
  e2.a14 = 9997;
  e2.a15 = 9998;
  e2.a16 = 9999;
  e2.a105 = 1e4;
  e2.a17 = 10001;
  e2.a18 = 10002;
  e2.a19 = 10003;
  e2.a20 = 10004;
  e2.a21 = 10005;
  e2.a22 = 10006;
  e2.a23 = 10007;
  e2.a24 = 10008;
  e2.a25 = 10009;
  e2.a26 = 10010;
  e2.a27 = 10011;
  e2.a28 = 10012;
  e2.a6 = 10013;
  e2.a7 = 10014;
  e2.a8 = 10015;
  e2.a9 = 10016;
  e2.a10 = 10017;
  e2.a29 = 10018;
  e2.a30 = 10019;
  e2.a31 = 10020;
  e2.a32 = 10021;
  e2.a33 = 10022;
  e2.a34 = 10023;
  e2.a35 = 9733;
  e2.a36 = 10025;
  e2.a37 = 10026;
  e2.a38 = 10027;
  e2.a39 = 10028;
  e2.a40 = 10029;
  e2.a41 = 10030;
  e2.a42 = 10031;
  e2.a43 = 10032;
  e2.a44 = 10033;
  e2.a45 = 10034;
  e2.a46 = 10035;
  e2.a47 = 10036;
  e2.a48 = 10037;
  e2.a49 = 10038;
  e2.a50 = 10039;
  e2.a51 = 10040;
  e2.a52 = 10041;
  e2.a53 = 10042;
  e2.a54 = 10043;
  e2.a55 = 10044;
  e2.a56 = 10045;
  e2.a57 = 10046;
  e2.a58 = 10047;
  e2.a59 = 10048;
  e2.a60 = 10049;
  e2.a61 = 10050;
  e2.a62 = 10051;
  e2.a63 = 10052;
  e2.a64 = 10053;
  e2.a65 = 10054;
  e2.a66 = 10055;
  e2.a67 = 10056;
  e2.a68 = 10057;
  e2.a69 = 10058;
  e2.a70 = 10059;
  e2.a71 = 9679;
  e2.a72 = 10061;
  e2.a73 = 9632;
  e2.a74 = 10063;
  e2.a203 = 10064;
  e2.a75 = 10065;
  e2.a204 = 10066;
  e2.a76 = 9650;
  e2.a77 = 9660;
  e2.a78 = 9670;
  e2.a79 = 10070;
  e2.a81 = 9687;
  e2.a82 = 10072;
  e2.a83 = 10073;
  e2.a84 = 10074;
  e2.a97 = 10075;
  e2.a98 = 10076;
  e2.a99 = 10077;
  e2.a100 = 10078;
  e2.a101 = 10081;
  e2.a102 = 10082;
  e2.a103 = 10083;
  e2.a104 = 10084;
  e2.a106 = 10085;
  e2.a107 = 10086;
  e2.a108 = 10087;
  e2.a112 = 9827;
  e2.a111 = 9830;
  e2.a110 = 9829;
  e2.a109 = 9824;
  e2.a120 = 9312;
  e2.a121 = 9313;
  e2.a122 = 9314;
  e2.a123 = 9315;
  e2.a124 = 9316;
  e2.a125 = 9317;
  e2.a126 = 9318;
  e2.a127 = 9319;
  e2.a128 = 9320;
  e2.a129 = 9321;
  e2.a130 = 10102;
  e2.a131 = 10103;
  e2.a132 = 10104;
  e2.a133 = 10105;
  e2.a134 = 10106;
  e2.a135 = 10107;
  e2.a136 = 10108;
  e2.a137 = 10109;
  e2.a138 = 10110;
  e2.a139 = 10111;
  e2.a140 = 10112;
  e2.a141 = 10113;
  e2.a142 = 10114;
  e2.a143 = 10115;
  e2.a144 = 10116;
  e2.a145 = 10117;
  e2.a146 = 10118;
  e2.a147 = 10119;
  e2.a148 = 10120;
  e2.a149 = 10121;
  e2.a150 = 10122;
  e2.a151 = 10123;
  e2.a152 = 10124;
  e2.a153 = 10125;
  e2.a154 = 10126;
  e2.a155 = 10127;
  e2.a156 = 10128;
  e2.a157 = 10129;
  e2.a158 = 10130;
  e2.a159 = 10131;
  e2.a160 = 10132;
  e2.a161 = 8594;
  e2.a163 = 8596;
  e2.a164 = 8597;
  e2.a196 = 10136;
  e2.a165 = 10137;
  e2.a192 = 10138;
  e2.a166 = 10139;
  e2.a167 = 10140;
  e2.a168 = 10141;
  e2.a169 = 10142;
  e2.a170 = 10143;
  e2.a171 = 10144;
  e2.a172 = 10145;
  e2.a173 = 10146;
  e2.a162 = 10147;
  e2.a174 = 10148;
  e2.a175 = 10149;
  e2.a176 = 10150;
  e2.a177 = 10151;
  e2.a178 = 10152;
  e2.a179 = 10153;
  e2.a193 = 10154;
  e2.a180 = 10155;
  e2.a199 = 10156;
  e2.a181 = 10157;
  e2.a200 = 10158;
  e2.a182 = 10159;
  e2.a201 = 10161;
  e2.a183 = 10162;
  e2.a184 = 10163;
  e2.a197 = 10164;
  e2.a185 = 10165;
  e2.a194 = 10166;
  e2.a198 = 10167;
  e2.a186 = 10168;
  e2.a195 = 10169;
  e2.a187 = 10170;
  e2.a188 = 10171;
  e2.a189 = 10172;
  e2.a190 = 10173;
  e2.a191 = 10174;
  e2.a89 = 10088;
  e2.a90 = 10089;
  e2.a93 = 10090;
  e2.a94 = 10091;
  e2.a91 = 10092;
  e2.a92 = 10093;
  e2.a205 = 10094;
  e2.a85 = 10095;
  e2.a206 = 10096;
  e2.a86 = 10097;
  e2.a87 = 10098;
  e2.a88 = 10099;
  e2.a95 = 10100;
  e2.a96 = 10101;
  e2[".notdef"] = 0;
});
var Ji = getLookupTableFactory(function(e2) {
  e2[63721] = 169;
  e2[63193] = 169;
  e2[63720] = 174;
  e2[63194] = 174;
  e2[63722] = 8482;
  e2[63195] = 8482;
  e2[63729] = 9127;
  e2[63730] = 9128;
  e2[63731] = 9129;
  e2[63740] = 9131;
  e2[63741] = 9132;
  e2[63742] = 9133;
  e2[63726] = 9121;
  e2[63727] = 9122;
  e2[63728] = 9123;
  e2[63737] = 9124;
  e2[63738] = 9125;
  e2[63739] = 9126;
  e2[63723] = 9115;
  e2[63724] = 9116;
  e2[63725] = 9117;
  e2[63734] = 9118;
  e2[63735] = 9119;
  e2[63736] = 9120;
});
function getUnicodeForGlyph(e2, t2) {
  let i2 = t2[e2];
  if (void 0 !== i2)
    return i2;
  if (!e2)
    return -1;
  if ("u" === e2[0]) {
    const t3 = e2.length;
    let a2;
    if (7 === t3 && "n" === e2[1] && "i" === e2[2])
      a2 = e2.substring(3);
    else {
      if (!(t3 >= 5 && t3 <= 7))
        return -1;
      a2 = e2.substring(1);
    }
    if (a2 === a2.toUpperCase()) {
      i2 = parseInt(a2, 16);
      if (i2 >= 0)
        return i2;
    }
  }
  return -1;
}
var Yi = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
function getUnicodeRangeFor(e2, t2 = -1) {
  if (-1 !== t2) {
    const i2 = Yi[t2];
    for (let a2 = 0, s2 = i2.length; a2 < s2; a2 += 2)
      if (e2 >= i2[a2] && e2 <= i2[a2 + 1])
        return t2;
  }
  for (let t3 = 0, i2 = Yi.length; t3 < i2; t3++) {
    const i3 = Yi[t3];
    for (let a2 = 0, s2 = i3.length; a2 < s2; a2 += 2)
      if (e2 >= i3[a2] && e2 <= i3[a2 + 1])
        return t3;
  }
  return -1;
}
var vi = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u");
var Ki = /* @__PURE__ */ new Map();
var Ti = true;
var qi = 1;
var Oi = 2;
var Pi = 4;
var Wi = 32;
var ji = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
function recoverGlyphName(e2, t2) {
  if (void 0 !== t2[e2])
    return e2;
  const i2 = getUnicodeForGlyph(e2, t2);
  if (-1 !== i2) {
    for (const e3 in t2)
      if (t2[e3] === i2)
        return e3;
  }
  info("Unable to recover a standard glyph name for: " + e2);
  return e2;
}
function type1FontGlyphMapping(e2, t2, i2) {
  const a2 = /* @__PURE__ */ Object.create(null);
  let s2, r2, n2;
  const g2 = !!(e2.flags & Pi);
  if (e2.isInternalFont) {
    n2 = t2;
    for (r2 = 0; r2 < n2.length; r2++) {
      s2 = i2.indexOf(n2[r2]);
      a2[r2] = s2 >= 0 ? s2 : 0;
    }
  } else if (e2.baseEncodingName) {
    n2 = getEncoding(e2.baseEncodingName);
    for (r2 = 0; r2 < n2.length; r2++) {
      s2 = i2.indexOf(n2[r2]);
      a2[r2] = s2 >= 0 ? s2 : 0;
    }
  } else if (g2)
    for (r2 in t2)
      a2[r2] = t2[r2];
  else {
    n2 = yi;
    for (r2 = 0; r2 < n2.length; r2++) {
      s2 = i2.indexOf(n2[r2]);
      a2[r2] = s2 >= 0 ? s2 : 0;
    }
  }
  const o2 = e2.differences;
  let c2;
  if (o2)
    for (r2 in o2) {
      const e3 = o2[r2];
      s2 = i2.indexOf(e3);
      if (-1 === s2) {
        c2 || (c2 = Mi());
        const t3 = recoverGlyphName(e3, c2);
        t3 !== e3 && (s2 = i2.indexOf(t3));
      }
      a2[r2] = s2 >= 0 ? s2 : 0;
    }
  return a2;
}
function normalizeFontName(e2) {
  return e2.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}
var Xi = getLookupTableFactory((e2) => {
  e2[8211] = 65074;
  e2[8212] = 65073;
  e2[8229] = 65072;
  e2[8230] = 65049;
  e2[12289] = 65041;
  e2[12290] = 65042;
  e2[12296] = 65087;
  e2[12297] = 65088;
  e2[12298] = 65085;
  e2[12299] = 65086;
  e2[12300] = 65089;
  e2[12301] = 65090;
  e2[12302] = 65091;
  e2[12303] = 65092;
  e2[12304] = 65083;
  e2[12305] = 65084;
  e2[12308] = 65081;
  e2[12309] = 65082;
  e2[12310] = 65047;
  e2[12311] = 65048;
  e2[65103] = 65076;
  e2[65281] = 65045;
  e2[65288] = 65077;
  e2[65289] = 65078;
  e2[65292] = 65040;
  e2[65306] = 65043;
  e2[65307] = 65044;
  e2[65311] = 65046;
  e2[65339] = 65095;
  e2[65341] = 65096;
  e2[65343] = 65075;
  e2[65371] = 65079;
  e2[65373] = 65080;
});
var Zi = getLookupTableFactory(function(e2) {
  e2["Times-Roman"] = "Times-Roman";
  e2.Helvetica = "Helvetica";
  e2.Courier = "Courier";
  e2.Symbol = "Symbol";
  e2["Times-Bold"] = "Times-Bold";
  e2["Helvetica-Bold"] = "Helvetica-Bold";
  e2["Courier-Bold"] = "Courier-Bold";
  e2.ZapfDingbats = "ZapfDingbats";
  e2["Times-Italic"] = "Times-Italic";
  e2["Helvetica-Oblique"] = "Helvetica-Oblique";
  e2["Courier-Oblique"] = "Courier-Oblique";
  e2["Times-BoldItalic"] = "Times-BoldItalic";
  e2["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
  e2["Courier-BoldOblique"] = "Courier-BoldOblique";
  e2.ArialNarrow = "Helvetica";
  e2["ArialNarrow-Bold"] = "Helvetica-Bold";
  e2["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
  e2["ArialNarrow-Italic"] = "Helvetica-Oblique";
  e2.ArialBlack = "Helvetica";
  e2["ArialBlack-Bold"] = "Helvetica-Bold";
  e2["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
  e2["ArialBlack-Italic"] = "Helvetica-Oblique";
  e2["Arial-Black"] = "Helvetica";
  e2["Arial-Black-Bold"] = "Helvetica-Bold";
  e2["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
  e2["Arial-Black-Italic"] = "Helvetica-Oblique";
  e2.Arial = "Helvetica";
  e2["Arial-Bold"] = "Helvetica-Bold";
  e2["Arial-BoldItalic"] = "Helvetica-BoldOblique";
  e2["Arial-Italic"] = "Helvetica-Oblique";
  e2.ArialMT = "Helvetica";
  e2["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
  e2["Arial-BoldMT"] = "Helvetica-Bold";
  e2["Arial-ItalicMT"] = "Helvetica-Oblique";
  e2["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique";
  e2["Arial-BoldMT-Bold"] = "Helvetica-Bold";
  e2["Arial-ItalicMT-Italic"] = "Helvetica-Oblique";
  e2.ArialUnicodeMS = "Helvetica";
  e2["ArialUnicodeMS-Bold"] = "Helvetica-Bold";
  e2["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique";
  e2["ArialUnicodeMS-Italic"] = "Helvetica-Oblique";
  e2["Courier-BoldItalic"] = "Courier-BoldOblique";
  e2["Courier-Italic"] = "Courier-Oblique";
  e2.CourierNew = "Courier";
  e2["CourierNew-Bold"] = "Courier-Bold";
  e2["CourierNew-BoldItalic"] = "Courier-BoldOblique";
  e2["CourierNew-Italic"] = "Courier-Oblique";
  e2["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
  e2["CourierNewPS-BoldMT"] = "Courier-Bold";
  e2["CourierNewPS-ItalicMT"] = "Courier-Oblique";
  e2.CourierNewPSMT = "Courier";
  e2["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
  e2["Helvetica-Italic"] = "Helvetica-Oblique";
  e2["Symbol-Bold"] = "Symbol";
  e2["Symbol-BoldItalic"] = "Symbol";
  e2["Symbol-Italic"] = "Symbol";
  e2.TimesNewRoman = "Times-Roman";
  e2["TimesNewRoman-Bold"] = "Times-Bold";
  e2["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
  e2["TimesNewRoman-Italic"] = "Times-Italic";
  e2.TimesNewRomanPS = "Times-Roman";
  e2["TimesNewRomanPS-Bold"] = "Times-Bold";
  e2["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
  e2["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
  e2["TimesNewRomanPS-BoldMT"] = "Times-Bold";
  e2["TimesNewRomanPS-Italic"] = "Times-Italic";
  e2["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
  e2.TimesNewRomanPSMT = "Times-Roman";
  e2["TimesNewRomanPSMT-Bold"] = "Times-Bold";
  e2["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
  e2["TimesNewRomanPSMT-Italic"] = "Times-Italic";
});
var Vi = getLookupTableFactory(function(e2) {
  e2.Courier = "FoxitFixed.pfb";
  e2["Courier-Bold"] = "FoxitFixedBold.pfb";
  e2["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb";
  e2["Courier-Oblique"] = "FoxitFixedItalic.pfb";
  e2.Helvetica = "LiberationSans-Regular.ttf";
  e2["Helvetica-Bold"] = "LiberationSans-Bold.ttf";
  e2["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf";
  e2["Helvetica-Oblique"] = "LiberationSans-Italic.ttf";
  e2["Times-Roman"] = "FoxitSerif.pfb";
  e2["Times-Bold"] = "FoxitSerifBold.pfb";
  e2["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb";
  e2["Times-Italic"] = "FoxitSerifItalic.pfb";
  e2.Symbol = "FoxitSymbol.pfb";
  e2.ZapfDingbats = "FoxitDingbats.pfb";
  e2["LiberationSans-Regular"] = "LiberationSans-Regular.ttf";
  e2["LiberationSans-Bold"] = "LiberationSans-Bold.ttf";
  e2["LiberationSans-Italic"] = "LiberationSans-Italic.ttf";
  e2["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
});
var zi = getLookupTableFactory(function(e2) {
  e2.Calibri = "Helvetica";
  e2["Calibri-Bold"] = "Helvetica-Bold";
  e2["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
  e2["Calibri-Italic"] = "Helvetica-Oblique";
  e2.CenturyGothic = "Helvetica";
  e2["CenturyGothic-Bold"] = "Helvetica-Bold";
  e2["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
  e2["CenturyGothic-Italic"] = "Helvetica-Oblique";
  e2.ComicSansMS = "Comic Sans MS";
  e2["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
  e2["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
  e2["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
  e2.Impact = "Helvetica";
  e2["ItcSymbol-Bold"] = "Helvetica-Bold";
  e2["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique";
  e2["ItcSymbol-Book"] = "Helvetica";
  e2["ItcSymbol-BookItalic"] = "Helvetica-Oblique";
  e2["ItcSymbol-Medium"] = "Helvetica";
  e2["ItcSymbol-MediumItalic"] = "Helvetica-Oblique";
  e2.LucidaConsole = "Courier";
  e2["LucidaConsole-Bold"] = "Courier-Bold";
  e2["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
  e2["LucidaConsole-Italic"] = "Courier-Oblique";
  e2["LucidaSans-Demi"] = "Helvetica-Bold";
  e2["MS-Gothic"] = "MS Gothic";
  e2["MS-Gothic-Bold"] = "MS Gothic-Bold";
  e2["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
  e2["MS-Gothic-Italic"] = "MS Gothic-Italic";
  e2["MS-Mincho"] = "MS Mincho";
  e2["MS-Mincho-Bold"] = "MS Mincho-Bold";
  e2["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
  e2["MS-Mincho-Italic"] = "MS Mincho-Italic";
  e2["MS-PGothic"] = "MS PGothic";
  e2["MS-PGothic-Bold"] = "MS PGothic-Bold";
  e2["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
  e2["MS-PGothic-Italic"] = "MS PGothic-Italic";
  e2["MS-PMincho"] = "MS PMincho";
  e2["MS-PMincho-Bold"] = "MS PMincho-Bold";
  e2["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
  e2["MS-PMincho-Italic"] = "MS PMincho-Italic";
  e2.NuptialScript = "Times-Italic";
  e2.SegoeUISymbol = "Helvetica";
});
var _i2 = getLookupTableFactory(function(e2) {
  e2["Adobe Jenson"] = true;
  e2["Adobe Text"] = true;
  e2.Albertus = true;
  e2.Aldus = true;
  e2.Alexandria = true;
  e2.Algerian = true;
  e2["American Typewriter"] = true;
  e2.Antiqua = true;
  e2.Apex = true;
  e2.Arno = true;
  e2.Aster = true;
  e2.Aurora = true;
  e2.Baskerville = true;
  e2.Bell = true;
  e2.Bembo = true;
  e2["Bembo Schoolbook"] = true;
  e2.Benguiat = true;
  e2["Berkeley Old Style"] = true;
  e2["Bernhard Modern"] = true;
  e2["Berthold City"] = true;
  e2.Bodoni = true;
  e2["Bauer Bodoni"] = true;
  e2["Book Antiqua"] = true;
  e2.Bookman = true;
  e2["Bordeaux Roman"] = true;
  e2["Californian FB"] = true;
  e2.Calisto = true;
  e2.Calvert = true;
  e2.Capitals = true;
  e2.Cambria = true;
  e2.Cartier = true;
  e2.Caslon = true;
  e2.Catull = true;
  e2.Centaur = true;
  e2["Century Old Style"] = true;
  e2["Century Schoolbook"] = true;
  e2.Chaparral = true;
  e2["Charis SIL"] = true;
  e2.Cheltenham = true;
  e2["Cholla Slab"] = true;
  e2.Clarendon = true;
  e2.Clearface = true;
  e2.Cochin = true;
  e2.Colonna = true;
  e2["Computer Modern"] = true;
  e2["Concrete Roman"] = true;
  e2.Constantia = true;
  e2["Cooper Black"] = true;
  e2.Corona = true;
  e2.Ecotype = true;
  e2.Egyptienne = true;
  e2.Elephant = true;
  e2.Excelsior = true;
  e2.Fairfield = true;
  e2["FF Scala"] = true;
  e2.Folkard = true;
  e2.Footlight = true;
  e2.FreeSerif = true;
  e2["Friz Quadrata"] = true;
  e2.Garamond = true;
  e2.Gentium = true;
  e2.Georgia = true;
  e2.Gloucester = true;
  e2["Goudy Old Style"] = true;
  e2["Goudy Schoolbook"] = true;
  e2["Goudy Pro Font"] = true;
  e2.Granjon = true;
  e2["Guardian Egyptian"] = true;
  e2.Heather = true;
  e2.Hercules = true;
  e2["High Tower Text"] = true;
  e2.Hiroshige = true;
  e2["Hoefler Text"] = true;
  e2["Humana Serif"] = true;
  e2.Imprint = true;
  e2["Ionic No. 5"] = true;
  e2.Janson = true;
  e2.Joanna = true;
  e2.Korinna = true;
  e2.Lexicon = true;
  e2.LiberationSerif = true;
  e2["Liberation Serif"] = true;
  e2["Linux Libertine"] = true;
  e2.Literaturnaya = true;
  e2.Lucida = true;
  e2["Lucida Bright"] = true;
  e2.Melior = true;
  e2.Memphis = true;
  e2.Miller = true;
  e2.Minion = true;
  e2.Modern = true;
  e2["Mona Lisa"] = true;
  e2["Mrs Eaves"] = true;
  e2["MS Serif"] = true;
  e2["Museo Slab"] = true;
  e2["New York"] = true;
  e2["Nimbus Roman"] = true;
  e2["NPS Rawlinson Roadway"] = true;
  e2.NuptialScript = true;
  e2.Palatino = true;
  e2.Perpetua = true;
  e2.Plantin = true;
  e2["Plantin Schoolbook"] = true;
  e2.Playbill = true;
  e2["Poor Richard"] = true;
  e2["Rawlinson Roadway"] = true;
  e2.Renault = true;
  e2.Requiem = true;
  e2.Rockwell = true;
  e2.Roman = true;
  e2["Rotis Serif"] = true;
  e2.Sabon = true;
  e2.Scala = true;
  e2.Seagull = true;
  e2.Sistina = true;
  e2.Souvenir = true;
  e2.STIX = true;
  e2["Stone Informal"] = true;
  e2["Stone Serif"] = true;
  e2.Sylfaen = true;
  e2.Times = true;
  e2.Trajan = true;
  e2["Trinité"] = true;
  e2["Trump Mediaeval"] = true;
  e2.Utopia = true;
  e2["Vale Type"] = true;
  e2["Bitstream Vera"] = true;
  e2["Vera Serif"] = true;
  e2.Versailles = true;
  e2.Wanted = true;
  e2.Weiss = true;
  e2["Wide Latin"] = true;
  e2.Windsor = true;
  e2.XITS = true;
});
var $i = getLookupTableFactory(function(e2) {
  e2.Dingbats = true;
  e2.Symbol = true;
  e2.ZapfDingbats = true;
  e2.Wingdings = true;
  e2["Wingdings-Bold"] = true;
  e2["Wingdings-Regular"] = true;
});
var Aa = getLookupTableFactory(function(e2) {
  e2[2] = 10;
  e2[3] = 32;
  e2[4] = 33;
  e2[5] = 34;
  e2[6] = 35;
  e2[7] = 36;
  e2[8] = 37;
  e2[9] = 38;
  e2[10] = 39;
  e2[11] = 40;
  e2[12] = 41;
  e2[13] = 42;
  e2[14] = 43;
  e2[15] = 44;
  e2[16] = 45;
  e2[17] = 46;
  e2[18] = 47;
  e2[19] = 48;
  e2[20] = 49;
  e2[21] = 50;
  e2[22] = 51;
  e2[23] = 52;
  e2[24] = 53;
  e2[25] = 54;
  e2[26] = 55;
  e2[27] = 56;
  e2[28] = 57;
  e2[29] = 58;
  e2[30] = 894;
  e2[31] = 60;
  e2[32] = 61;
  e2[33] = 62;
  e2[34] = 63;
  e2[35] = 64;
  e2[36] = 65;
  e2[37] = 66;
  e2[38] = 67;
  e2[39] = 68;
  e2[40] = 69;
  e2[41] = 70;
  e2[42] = 71;
  e2[43] = 72;
  e2[44] = 73;
  e2[45] = 74;
  e2[46] = 75;
  e2[47] = 76;
  e2[48] = 77;
  e2[49] = 78;
  e2[50] = 79;
  e2[51] = 80;
  e2[52] = 81;
  e2[53] = 82;
  e2[54] = 83;
  e2[55] = 84;
  e2[56] = 85;
  e2[57] = 86;
  e2[58] = 87;
  e2[59] = 88;
  e2[60] = 89;
  e2[61] = 90;
  e2[62] = 91;
  e2[63] = 92;
  e2[64] = 93;
  e2[65] = 94;
  e2[66] = 95;
  e2[67] = 96;
  e2[68] = 97;
  e2[69] = 98;
  e2[70] = 99;
  e2[71] = 100;
  e2[72] = 101;
  e2[73] = 102;
  e2[74] = 103;
  e2[75] = 104;
  e2[76] = 105;
  e2[77] = 106;
  e2[78] = 107;
  e2[79] = 108;
  e2[80] = 109;
  e2[81] = 110;
  e2[82] = 111;
  e2[83] = 112;
  e2[84] = 113;
  e2[85] = 114;
  e2[86] = 115;
  e2[87] = 116;
  e2[88] = 117;
  e2[89] = 118;
  e2[90] = 119;
  e2[91] = 120;
  e2[92] = 121;
  e2[93] = 122;
  e2[94] = 123;
  e2[95] = 124;
  e2[96] = 125;
  e2[97] = 126;
  e2[98] = 196;
  e2[99] = 197;
  e2[100] = 199;
  e2[101] = 201;
  e2[102] = 209;
  e2[103] = 214;
  e2[104] = 220;
  e2[105] = 225;
  e2[106] = 224;
  e2[107] = 226;
  e2[108] = 228;
  e2[109] = 227;
  e2[110] = 229;
  e2[111] = 231;
  e2[112] = 233;
  e2[113] = 232;
  e2[114] = 234;
  e2[115] = 235;
  e2[116] = 237;
  e2[117] = 236;
  e2[118] = 238;
  e2[119] = 239;
  e2[120] = 241;
  e2[121] = 243;
  e2[122] = 242;
  e2[123] = 244;
  e2[124] = 246;
  e2[125] = 245;
  e2[126] = 250;
  e2[127] = 249;
  e2[128] = 251;
  e2[129] = 252;
  e2[130] = 8224;
  e2[131] = 176;
  e2[132] = 162;
  e2[133] = 163;
  e2[134] = 167;
  e2[135] = 8226;
  e2[136] = 182;
  e2[137] = 223;
  e2[138] = 174;
  e2[139] = 169;
  e2[140] = 8482;
  e2[141] = 180;
  e2[142] = 168;
  e2[143] = 8800;
  e2[144] = 198;
  e2[145] = 216;
  e2[146] = 8734;
  e2[147] = 177;
  e2[148] = 8804;
  e2[149] = 8805;
  e2[150] = 165;
  e2[151] = 181;
  e2[152] = 8706;
  e2[153] = 8721;
  e2[154] = 8719;
  e2[156] = 8747;
  e2[157] = 170;
  e2[158] = 186;
  e2[159] = 8486;
  e2[160] = 230;
  e2[161] = 248;
  e2[162] = 191;
  e2[163] = 161;
  e2[164] = 172;
  e2[165] = 8730;
  e2[166] = 402;
  e2[167] = 8776;
  e2[168] = 8710;
  e2[169] = 171;
  e2[170] = 187;
  e2[171] = 8230;
  e2[179] = 8220;
  e2[180] = 8221;
  e2[181] = 8216;
  e2[182] = 8217;
  e2[200] = 193;
  e2[203] = 205;
  e2[207] = 211;
  e2[210] = 218;
  e2[223] = 711;
  e2[224] = 321;
  e2[225] = 322;
  e2[226] = 352;
  e2[227] = 353;
  e2[228] = 381;
  e2[229] = 382;
  e2[233] = 221;
  e2[234] = 253;
  e2[252] = 263;
  e2[253] = 268;
  e2[254] = 269;
  e2[258] = 258;
  e2[260] = 260;
  e2[261] = 261;
  e2[265] = 280;
  e2[266] = 281;
  e2[267] = 282;
  e2[268] = 283;
  e2[269] = 313;
  e2[275] = 323;
  e2[276] = 324;
  e2[278] = 328;
  e2[283] = 344;
  e2[284] = 345;
  e2[285] = 346;
  e2[286] = 347;
  e2[292] = 367;
  e2[295] = 377;
  e2[296] = 378;
  e2[298] = 380;
  e2[305] = 963;
  e2[306] = 964;
  e2[307] = 966;
  e2[308] = 8215;
  e2[309] = 8252;
  e2[310] = 8319;
  e2[311] = 8359;
  e2[312] = 8592;
  e2[313] = 8593;
  e2[337] = 9552;
  e2[493] = 1039;
  e2[494] = 1040;
  e2[672] = 1488;
  e2[673] = 1489;
  e2[674] = 1490;
  e2[675] = 1491;
  e2[676] = 1492;
  e2[677] = 1493;
  e2[678] = 1494;
  e2[679] = 1495;
  e2[680] = 1496;
  e2[681] = 1497;
  e2[682] = 1498;
  e2[683] = 1499;
  e2[684] = 1500;
  e2[685] = 1501;
  e2[686] = 1502;
  e2[687] = 1503;
  e2[688] = 1504;
  e2[689] = 1505;
  e2[690] = 1506;
  e2[691] = 1507;
  e2[692] = 1508;
  e2[693] = 1509;
  e2[694] = 1510;
  e2[695] = 1511;
  e2[696] = 1512;
  e2[697] = 1513;
  e2[698] = 1514;
  e2[705] = 1524;
  e2[706] = 8362;
  e2[710] = 64288;
  e2[711] = 64298;
  e2[759] = 1617;
  e2[761] = 1776;
  e2[763] = 1778;
  e2[775] = 1652;
  e2[777] = 1764;
  e2[778] = 1780;
  e2[779] = 1781;
  e2[780] = 1782;
  e2[782] = 771;
  e2[783] = 64726;
  e2[786] = 8363;
  e2[788] = 8532;
  e2[790] = 768;
  e2[791] = 769;
  e2[792] = 768;
  e2[795] = 803;
  e2[797] = 64336;
  e2[798] = 64337;
  e2[799] = 64342;
  e2[800] = 64343;
  e2[801] = 64344;
  e2[802] = 64345;
  e2[803] = 64362;
  e2[804] = 64363;
  e2[805] = 64364;
  e2[2424] = 7821;
  e2[2425] = 7822;
  e2[2426] = 7823;
  e2[2427] = 7824;
  e2[2428] = 7825;
  e2[2429] = 7826;
  e2[2430] = 7827;
  e2[2433] = 7682;
  e2[2678] = 8045;
  e2[2679] = 8046;
  e2[2830] = 1552;
  e2[2838] = 686;
  e2[2840] = 751;
  e2[2842] = 753;
  e2[2843] = 754;
  e2[2844] = 755;
  e2[2846] = 757;
  e2[2856] = 767;
  e2[2857] = 848;
  e2[2858] = 849;
  e2[2862] = 853;
  e2[2863] = 854;
  e2[2864] = 855;
  e2[2865] = 861;
  e2[2866] = 862;
  e2[2906] = 7460;
  e2[2908] = 7462;
  e2[2909] = 7463;
  e2[2910] = 7464;
  e2[2912] = 7466;
  e2[2913] = 7467;
  e2[2914] = 7468;
  e2[2916] = 7470;
  e2[2917] = 7471;
  e2[2918] = 7472;
  e2[2920] = 7474;
  e2[2921] = 7475;
  e2[2922] = 7476;
  e2[2924] = 7478;
  e2[2925] = 7479;
  e2[2926] = 7480;
  e2[2928] = 7482;
  e2[2929] = 7483;
  e2[2930] = 7484;
  e2[2932] = 7486;
  e2[2933] = 7487;
  e2[2934] = 7488;
  e2[2936] = 7490;
  e2[2937] = 7491;
  e2[2938] = 7492;
  e2[2940] = 7494;
  e2[2941] = 7495;
  e2[2942] = 7496;
  e2[2944] = 7498;
  e2[2946] = 7500;
  e2[2948] = 7502;
  e2[2950] = 7504;
  e2[2951] = 7505;
  e2[2952] = 7506;
  e2[2954] = 7508;
  e2[2955] = 7509;
  e2[2956] = 7510;
  e2[2958] = 7512;
  e2[2959] = 7513;
  e2[2960] = 7514;
  e2[2962] = 7516;
  e2[2963] = 7517;
  e2[2964] = 7518;
  e2[2966] = 7520;
  e2[2967] = 7521;
  e2[2968] = 7522;
  e2[2970] = 7524;
  e2[2971] = 7525;
  e2[2972] = 7526;
  e2[2974] = 7528;
  e2[2975] = 7529;
  e2[2976] = 7530;
  e2[2978] = 1537;
  e2[2979] = 1538;
  e2[2980] = 1539;
  e2[2982] = 1549;
  e2[2983] = 1551;
  e2[2984] = 1552;
  e2[2986] = 1554;
  e2[2987] = 1555;
  e2[2988] = 1556;
  e2[2990] = 1623;
  e2[2991] = 1624;
  e2[2995] = 1775;
  e2[2999] = 1791;
  e2[3002] = 64290;
  e2[3003] = 64291;
  e2[3004] = 64292;
  e2[3006] = 64294;
  e2[3007] = 64295;
  e2[3008] = 64296;
  e2[3011] = 1900;
  e2[3014] = 8223;
  e2[3015] = 8244;
  e2[3017] = 7532;
  e2[3018] = 7533;
  e2[3019] = 7534;
  e2[3075] = 7590;
  e2[3076] = 7591;
  e2[3079] = 7594;
  e2[3080] = 7595;
  e2[3083] = 7598;
  e2[3084] = 7599;
  e2[3087] = 7602;
  e2[3088] = 7603;
  e2[3091] = 7606;
  e2[3092] = 7607;
  e2[3095] = 7610;
  e2[3096] = 7611;
  e2[3099] = 7614;
  e2[3100] = 7615;
  e2[3103] = 7618;
  e2[3104] = 7619;
  e2[3107] = 8337;
  e2[3108] = 8338;
  e2[3116] = 1884;
  e2[3119] = 1885;
  e2[3120] = 1885;
  e2[3123] = 1886;
  e2[3124] = 1886;
  e2[3127] = 1887;
  e2[3128] = 1887;
  e2[3131] = 1888;
  e2[3132] = 1888;
  e2[3135] = 1889;
  e2[3136] = 1889;
  e2[3139] = 1890;
  e2[3140] = 1890;
  e2[3143] = 1891;
  e2[3144] = 1891;
  e2[3147] = 1892;
  e2[3148] = 1892;
  e2[3153] = 580;
  e2[3154] = 581;
  e2[3157] = 584;
  e2[3158] = 585;
  e2[3161] = 588;
  e2[3162] = 589;
  e2[3165] = 891;
  e2[3166] = 892;
  e2[3169] = 1274;
  e2[3170] = 1275;
  e2[3173] = 1278;
  e2[3174] = 1279;
  e2[3181] = 7622;
  e2[3182] = 7623;
  e2[3282] = 11799;
  e2[3316] = 578;
  e2[3379] = 42785;
  e2[3393] = 1159;
  e2[3416] = 8377;
});
var ea = getLookupTableFactory(function(e2) {
  e2[227] = 322;
  e2[264] = 261;
  e2[291] = 346;
});
var ta = getLookupTableFactory(function(e2) {
  e2[1] = 32;
  e2[4] = 65;
  e2[5] = 192;
  e2[6] = 193;
  e2[9] = 196;
  e2[17] = 66;
  e2[18] = 67;
  e2[21] = 268;
  e2[24] = 68;
  e2[28] = 69;
  e2[29] = 200;
  e2[30] = 201;
  e2[32] = 282;
  e2[38] = 70;
  e2[39] = 71;
  e2[44] = 72;
  e2[47] = 73;
  e2[48] = 204;
  e2[49] = 205;
  e2[58] = 74;
  e2[60] = 75;
  e2[62] = 76;
  e2[68] = 77;
  e2[69] = 78;
  e2[75] = 79;
  e2[76] = 210;
  e2[80] = 214;
  e2[87] = 80;
  e2[89] = 81;
  e2[90] = 82;
  e2[92] = 344;
  e2[94] = 83;
  e2[97] = 352;
  e2[100] = 84;
  e2[104] = 85;
  e2[109] = 220;
  e2[115] = 86;
  e2[116] = 87;
  e2[121] = 88;
  e2[122] = 89;
  e2[124] = 221;
  e2[127] = 90;
  e2[129] = 381;
  e2[258] = 97;
  e2[259] = 224;
  e2[260] = 225;
  e2[263] = 228;
  e2[268] = 261;
  e2[271] = 98;
  e2[272] = 99;
  e2[273] = 263;
  e2[275] = 269;
  e2[282] = 100;
  e2[286] = 101;
  e2[287] = 232;
  e2[288] = 233;
  e2[290] = 283;
  e2[295] = 281;
  e2[296] = 102;
  e2[336] = 103;
  e2[346] = 104;
  e2[349] = 105;
  e2[350] = 236;
  e2[351] = 237;
  e2[361] = 106;
  e2[364] = 107;
  e2[367] = 108;
  e2[371] = 322;
  e2[373] = 109;
  e2[374] = 110;
  e2[381] = 111;
  e2[382] = 242;
  e2[383] = 243;
  e2[386] = 246;
  e2[393] = 112;
  e2[395] = 113;
  e2[396] = 114;
  e2[398] = 345;
  e2[400] = 115;
  e2[401] = 347;
  e2[403] = 353;
  e2[410] = 116;
  e2[437] = 117;
  e2[442] = 252;
  e2[448] = 118;
  e2[449] = 119;
  e2[454] = 120;
  e2[455] = 121;
  e2[457] = 253;
  e2[460] = 122;
  e2[462] = 382;
  e2[463] = 380;
  e2[853] = 44;
  e2[855] = 58;
  e2[856] = 46;
  e2[876] = 47;
  e2[878] = 45;
  e2[882] = 45;
  e2[894] = 40;
  e2[895] = 41;
  e2[896] = 91;
  e2[897] = 93;
  e2[923] = 64;
  e2[1004] = 48;
  e2[1005] = 49;
  e2[1006] = 50;
  e2[1007] = 51;
  e2[1008] = 52;
  e2[1009] = 53;
  e2[1010] = 54;
  e2[1011] = 55;
  e2[1012] = 56;
  e2[1013] = 57;
  e2[1081] = 37;
  e2[1085] = 43;
  e2[1086] = 45;
});
function getStandardFontName(e2) {
  const t2 = normalizeFontName(e2);
  return Zi()[t2];
}
function isKnownFontName(e2) {
  const t2 = normalizeFontName(e2);
  return !!(Zi()[t2] || zi()[t2] || _i2()[t2] || $i()[t2]);
}
var ToUnicodeMap = class {
  constructor(e2 = []) {
    this._map = e2;
  }
  get length() {
    return this._map.length;
  }
  forEach(e2) {
    for (const t2 in this._map)
      e2(t2, this._map[t2].charCodeAt(0));
  }
  has(e2) {
    return void 0 !== this._map[e2];
  }
  get(e2) {
    return this._map[e2];
  }
  charCodeOf(e2) {
    const t2 = this._map;
    if (t2.length <= 65536)
      return t2.indexOf(e2);
    for (const i2 in t2)
      if (t2[i2] === e2)
        return 0 | i2;
    return -1;
  }
  amend(e2) {
    for (const t2 in e2)
      this._map[t2] = e2[t2];
  }
};
var IdentityToUnicodeMap = class {
  constructor(e2, t2) {
    this.firstChar = e2;
    this.lastChar = t2;
  }
  get length() {
    return this.lastChar + 1 - this.firstChar;
  }
  forEach(e2) {
    for (let t2 = this.firstChar, i2 = this.lastChar; t2 <= i2; t2++)
      e2(t2, t2);
  }
  has(e2) {
    return this.firstChar <= e2 && e2 <= this.lastChar;
  }
  get(e2) {
    if (this.firstChar <= e2 && e2 <= this.lastChar)
      return String.fromCharCode(e2);
  }
  charCodeOf(e2) {
    return Number.isInteger(e2) && e2 >= this.firstChar && e2 <= this.lastChar ? e2 : -1;
  }
  amend(e2) {
    unreachable("Should not call amend()");
  }
};
var CFFFont = class {
  constructor(e2, t2) {
    this.properties = t2;
    const i2 = new CFFParser(e2, t2, Ti);
    this.cff = i2.parse();
    this.cff.duplicateFirstGlyph();
    const a2 = new CFFCompiler(this.cff);
    this.seacs = this.cff.seacs;
    try {
      this.data = a2.compile();
    } catch {
      warn("Failed to compile font " + t2.loadedName);
      this.data = e2;
    }
    this._createBuiltInEncoding();
  }
  get numGlyphs() {
    return this.cff.charStrings.count;
  }
  getCharset() {
    return this.cff.charset.charset;
  }
  getGlyphMapping() {
    const e2 = this.cff, t2 = this.properties, { cidToGidMap: i2, cMap: a2 } = t2, s2 = e2.charset.charset;
    let r2, n2;
    if (t2.composite) {
      let t3, g3;
      if ((i2 == null ? void 0 : i2.length) > 0) {
        t3 = /* @__PURE__ */ Object.create(null);
        for (let e3 = 0, a3 = i2.length; e3 < a3; e3++) {
          const a4 = i2[e3];
          void 0 !== a4 && (t3[a4] = e3);
        }
      }
      r2 = /* @__PURE__ */ Object.create(null);
      if (e2.isCIDFont)
        for (n2 = 0; n2 < s2.length; n2++) {
          const e3 = s2[n2];
          g3 = a2.charCodeOf(e3);
          void 0 !== (t3 == null ? void 0 : t3[g3]) && (g3 = t3[g3]);
          r2[g3] = n2;
        }
      else
        for (n2 = 0; n2 < e2.charStrings.count; n2++) {
          g3 = a2.charCodeOf(n2);
          r2[g3] = n2;
        }
      return r2;
    }
    let g2 = e2.encoding ? e2.encoding.encoding : null;
    t2.isInternalFont && (g2 = t2.defaultEncoding);
    r2 = type1FontGlyphMapping(t2, g2, s2);
    return r2;
  }
  hasGlyphId(e2) {
    return this.cff.hasGlyphId(e2);
  }
  _createBuiltInEncoding() {
    const { charset: e2, encoding: t2 } = this.cff;
    if (!e2 || !t2)
      return;
    const i2 = e2.charset, a2 = t2.encoding, s2 = [];
    for (const e3 in a2) {
      const t3 = a2[e3];
      if (t3 >= 0) {
        const a3 = i2[t3];
        a3 && (s2[e3] = a3);
      }
    }
    s2.length > 0 && (this.properties.builtInEncoding = s2);
  }
};
function getUint32(e2, t2) {
  return (e2[t2] << 24 | e2[t2 + 1] << 16 | e2[t2 + 2] << 8 | e2[t2 + 3]) >>> 0;
}
function getUint16(e2, t2) {
  return e2[t2] << 8 | e2[t2 + 1];
}
function getInt16(e2, t2) {
  return (e2[t2] << 24 | e2[t2 + 1] << 16) >> 16;
}
function getInt8(e2, t2) {
  return e2[t2] << 24 >> 24;
}
function getFloat214(e2, t2) {
  return getInt16(e2, t2) / 16384;
}
function getSubroutineBias(e2) {
  const t2 = e2.length;
  let i2 = 32768;
  t2 < 1240 ? i2 = 107 : t2 < 33900 && (i2 = 1131);
  return i2;
}
function parseCmap(e2, t2, i2) {
  const a2 = 1 === getUint16(e2, t2 + 2) ? getUint32(e2, t2 + 8) : getUint32(e2, t2 + 16), s2 = getUint16(e2, t2 + a2);
  let r2, n2, g2;
  if (4 === s2) {
    getUint16(e2, t2 + a2 + 2);
    const i3 = getUint16(e2, t2 + a2 + 6) >> 1;
    n2 = t2 + a2 + 14;
    r2 = [];
    for (g2 = 0; g2 < i3; g2++, n2 += 2)
      r2[g2] = { end: getUint16(e2, n2) };
    n2 += 2;
    for (g2 = 0; g2 < i3; g2++, n2 += 2)
      r2[g2].start = getUint16(e2, n2);
    for (g2 = 0; g2 < i3; g2++, n2 += 2)
      r2[g2].idDelta = getUint16(e2, n2);
    for (g2 = 0; g2 < i3; g2++, n2 += 2) {
      let t3 = getUint16(e2, n2);
      if (0 !== t3) {
        r2[g2].ids = [];
        for (let i4 = 0, a3 = r2[g2].end - r2[g2].start + 1; i4 < a3; i4++) {
          r2[g2].ids[i4] = getUint16(e2, n2 + t3);
          t3 += 2;
        }
      }
    }
    return r2;
  }
  if (12 === s2) {
    const i3 = getUint32(e2, t2 + a2 + 12);
    n2 = t2 + a2 + 16;
    r2 = [];
    for (g2 = 0; g2 < i3; g2++) {
      t2 = getUint32(e2, n2);
      r2.push({ start: t2, end: getUint32(e2, n2 + 4), idDelta: getUint32(e2, n2 + 8) - t2 });
      n2 += 12;
    }
    return r2;
  }
  throw new FormatError(`unsupported cmap: ${s2}`);
}
function parseCff(e2, t2, i2, a2) {
  var _a4, _b2, _c2;
  const s2 = new CFFParser(new Stream(e2, t2, i2 - t2), {}, a2).parse();
  return { glyphs: s2.charStrings.objects, subrs: (_b2 = (_a4 = s2.topDict.privateDict) == null ? void 0 : _a4.subrsIndex) == null ? void 0 : _b2.objects, gsubrs: (_c2 = s2.globalSubrIndex) == null ? void 0 : _c2.objects, isCFFCIDFont: s2.isCIDFont, fdSelect: s2.fdSelect, fdArray: s2.fdArray };
}
function lookupCmap(e2, t2) {
  const i2 = t2.codePointAt(0);
  let a2 = 0, s2 = 0, r2 = e2.length - 1;
  for (; s2 < r2; ) {
    const t3 = s2 + r2 + 1 >> 1;
    i2 < e2[t3].start ? r2 = t3 - 1 : s2 = t3;
  }
  e2[s2].start <= i2 && i2 <= e2[s2].end && (a2 = e2[s2].idDelta + (e2[s2].ids ? e2[s2].ids[i2 - e2[s2].start] : i2) & 65535);
  return { charCode: i2, glyphId: a2 };
}
function compileGlyf(e2, t2, i2) {
  function moveTo(e3, i3) {
    t2.add(lt, [e3, i3]);
  }
  function lineTo(e3, i3) {
    t2.add(Qt, [e3, i3]);
  }
  function quadraticCurveTo(e3, i3, a3, s3) {
    t2.add(Et, [e3, i3, a3, s3]);
  }
  let a2 = 0;
  const s2 = getInt16(e2, a2);
  let r2, n2 = 0, g2 = 0;
  a2 += 10;
  if (s2 < 0)
    do {
      r2 = getUint16(e2, a2);
      const s3 = getUint16(e2, a2 + 2);
      a2 += 4;
      let o2, c2;
      if (1 & r2) {
        if (2 & r2) {
          o2 = getInt16(e2, a2);
          c2 = getInt16(e2, a2 + 2);
        } else {
          o2 = getUint16(e2, a2);
          c2 = getUint16(e2, a2 + 2);
        }
        a2 += 4;
      } else if (2 & r2) {
        o2 = getInt8(e2, a2++);
        c2 = getInt8(e2, a2++);
      } else {
        o2 = e2[a2++];
        c2 = e2[a2++];
      }
      if (2 & r2) {
        n2 = o2;
        g2 = c2;
      } else {
        n2 = 0;
        g2 = 0;
      }
      let C2 = 1, h2 = 1, l2 = 0, Q2 = 0;
      if (8 & r2) {
        C2 = h2 = getFloat214(e2, a2);
        a2 += 2;
      } else if (64 & r2) {
        C2 = getFloat214(e2, a2);
        h2 = getFloat214(e2, a2 + 2);
        a2 += 4;
      } else if (128 & r2) {
        C2 = getFloat214(e2, a2);
        l2 = getFloat214(e2, a2 + 2);
        Q2 = getFloat214(e2, a2 + 4);
        h2 = getFloat214(e2, a2 + 6);
        a2 += 8;
      }
      const E2 = i2.glyphs[s3];
      if (E2) {
        t2.add(dt);
        t2.add(pt, [C2, l2, Q2, h2, n2, g2]);
        compileGlyf(E2, t2, i2);
        t2.add(ut);
      }
    } while (32 & r2);
  else {
    const t3 = [];
    let i3, o2;
    for (i3 = 0; i3 < s2; i3++) {
      t3.push(getUint16(e2, a2));
      a2 += 2;
    }
    a2 += 2 + getUint16(e2, a2);
    const c2 = t3.at(-1) + 1, C2 = [];
    for (; C2.length < c2; ) {
      r2 = e2[a2++];
      let t4 = 1;
      8 & r2 && (t4 += e2[a2++]);
      for (; t4-- > 0; )
        C2.push({ flags: r2 });
    }
    for (i3 = 0; i3 < c2; i3++) {
      switch (18 & C2[i3].flags) {
        case 0:
          n2 += getInt16(e2, a2);
          a2 += 2;
          break;
        case 2:
          n2 -= e2[a2++];
          break;
        case 18:
          n2 += e2[a2++];
      }
      C2[i3].x = n2;
    }
    for (i3 = 0; i3 < c2; i3++) {
      switch (36 & C2[i3].flags) {
        case 0:
          g2 += getInt16(e2, a2);
          a2 += 2;
          break;
        case 4:
          g2 -= e2[a2++];
          break;
        case 36:
          g2 += e2[a2++];
      }
      C2[i3].y = g2;
    }
    let h2 = 0;
    for (a2 = 0; a2 < s2; a2++) {
      const e3 = t3[a2], s3 = C2.slice(h2, e3 + 1);
      if (1 & s3[0].flags)
        s3.push(s3[0]);
      else if (1 & s3.at(-1).flags)
        s3.unshift(s3.at(-1));
      else {
        const e4 = { flags: 1, x: (s3[0].x + s3.at(-1).x) / 2, y: (s3[0].y + s3.at(-1).y) / 2 };
        s3.unshift(e4);
        s3.push(e4);
      }
      moveTo(s3[0].x, s3[0].y);
      for (i3 = 1, o2 = s3.length; i3 < o2; i3++)
        if (1 & s3[i3].flags)
          lineTo(s3[i3].x, s3[i3].y);
        else if (1 & s3[i3 + 1].flags) {
          quadraticCurveTo(s3[i3].x, s3[i3].y, s3[i3 + 1].x, s3[i3 + 1].y);
          i3++;
        } else
          quadraticCurveTo(s3[i3].x, s3[i3].y, (s3[i3].x + s3[i3 + 1].x) / 2, (s3[i3].y + s3[i3 + 1].y) / 2);
      h2 = e3 + 1;
    }
  }
}
function compileCharString(e2, t2, i2, a2) {
  function moveTo(e3, i3) {
    t2.add(lt, [e3, i3]);
  }
  function lineTo(e3, i3) {
    t2.add(Qt, [e3, i3]);
  }
  function bezierCurveTo(e3, i3, a3, s3, r3, n3) {
    t2.add(Bt, [e3, i3, a3, s3, r3, n3]);
  }
  const s2 = [];
  let r2 = 0, n2 = 0, g2 = 0;
  !function parse(e3) {
    var _a4;
    let o2 = 0;
    for (; o2 < e3.length; ) {
      let c2, C2, h2, l2, Q2, E2, u2, d2, f2, p2 = false, m2 = e3[o2++];
      switch (m2) {
        case 1:
        case 3:
        case 18:
        case 23:
          g2 += s2.length >> 1;
          p2 = true;
          break;
        case 4:
          n2 += s2.pop();
          moveTo(r2, n2);
          p2 = true;
          break;
        case 5:
          for (; s2.length > 0; ) {
            r2 += s2.shift();
            n2 += s2.shift();
            lineTo(r2, n2);
          }
          break;
        case 6:
          for (; s2.length > 0; ) {
            r2 += s2.shift();
            lineTo(r2, n2);
            if (0 === s2.length)
              break;
            n2 += s2.shift();
            lineTo(r2, n2);
          }
          break;
        case 7:
          for (; s2.length > 0; ) {
            n2 += s2.shift();
            lineTo(r2, n2);
            if (0 === s2.length)
              break;
            r2 += s2.shift();
            lineTo(r2, n2);
          }
          break;
        case 8:
          for (; s2.length > 0; ) {
            c2 = r2 + s2.shift();
            h2 = n2 + s2.shift();
            C2 = c2 + s2.shift();
            l2 = h2 + s2.shift();
            r2 = C2 + s2.shift();
            n2 = l2 + s2.shift();
            bezierCurveTo(c2, h2, C2, l2, r2, n2);
          }
          break;
        case 10:
          d2 = s2.pop();
          f2 = null;
          if (i2.isCFFCIDFont) {
            const e4 = i2.fdSelect.getFDIndex(a2);
            if (e4 >= 0 && e4 < i2.fdArray.length) {
              const t3 = i2.fdArray[e4];
              let a3;
              ((_a4 = t3.privateDict) == null ? void 0 : _a4.subrsIndex) && (a3 = t3.privateDict.subrsIndex.objects);
              if (a3) {
                d2 += getSubroutineBias(a3);
                f2 = a3[d2];
              }
            } else
              warn("Invalid fd index for glyph index.");
          } else
            f2 = i2.subrs[d2 + i2.subrsBias];
          f2 && parse(f2);
          break;
        case 11:
          return;
        case 12:
          m2 = e3[o2++];
          switch (m2) {
            case 34:
              c2 = r2 + s2.shift();
              C2 = c2 + s2.shift();
              Q2 = n2 + s2.shift();
              r2 = C2 + s2.shift();
              bezierCurveTo(c2, n2, C2, Q2, r2, Q2);
              c2 = r2 + s2.shift();
              C2 = c2 + s2.shift();
              r2 = C2 + s2.shift();
              bezierCurveTo(c2, Q2, C2, n2, r2, n2);
              break;
            case 35:
              c2 = r2 + s2.shift();
              h2 = n2 + s2.shift();
              C2 = c2 + s2.shift();
              l2 = h2 + s2.shift();
              r2 = C2 + s2.shift();
              n2 = l2 + s2.shift();
              bezierCurveTo(c2, h2, C2, l2, r2, n2);
              c2 = r2 + s2.shift();
              h2 = n2 + s2.shift();
              C2 = c2 + s2.shift();
              l2 = h2 + s2.shift();
              r2 = C2 + s2.shift();
              n2 = l2 + s2.shift();
              bezierCurveTo(c2, h2, C2, l2, r2, n2);
              s2.pop();
              break;
            case 36:
              c2 = r2 + s2.shift();
              Q2 = n2 + s2.shift();
              C2 = c2 + s2.shift();
              E2 = Q2 + s2.shift();
              r2 = C2 + s2.shift();
              bezierCurveTo(c2, Q2, C2, E2, r2, E2);
              c2 = r2 + s2.shift();
              C2 = c2 + s2.shift();
              u2 = E2 + s2.shift();
              r2 = C2 + s2.shift();
              bezierCurveTo(c2, E2, C2, u2, r2, n2);
              break;
            case 37:
              const e4 = r2, t3 = n2;
              c2 = r2 + s2.shift();
              h2 = n2 + s2.shift();
              C2 = c2 + s2.shift();
              l2 = h2 + s2.shift();
              r2 = C2 + s2.shift();
              n2 = l2 + s2.shift();
              bezierCurveTo(c2, h2, C2, l2, r2, n2);
              c2 = r2 + s2.shift();
              h2 = n2 + s2.shift();
              C2 = c2 + s2.shift();
              l2 = h2 + s2.shift();
              r2 = C2;
              n2 = l2;
              Math.abs(r2 - e4) > Math.abs(n2 - t3) ? r2 += s2.shift() : n2 += s2.shift();
              bezierCurveTo(c2, h2, C2, l2, r2, n2);
              break;
            default:
              throw new FormatError(`unknown operator: 12 ${m2}`);
          }
          break;
        case 14:
          if (s2.length >= 4) {
            const e4 = s2.pop(), a3 = s2.pop();
            n2 = s2.pop();
            r2 = s2.pop();
            t2.add(dt);
            t2.add(mt, [r2, n2]);
            let g3 = lookupCmap(i2.cmap, String.fromCharCode(i2.glyphNameMap[yi[e4]]));
            compileCharString(i2.glyphs[g3.glyphId], t2, i2, g3.glyphId);
            t2.add(ut);
            g3 = lookupCmap(i2.cmap, String.fromCharCode(i2.glyphNameMap[yi[a3]]));
            compileCharString(i2.glyphs[g3.glyphId], t2, i2, g3.glyphId);
          }
          return;
        case 19:
        case 20:
          g2 += s2.length >> 1;
          o2 += g2 + 7 >> 3;
          p2 = true;
          break;
        case 21:
          n2 += s2.pop();
          r2 += s2.pop();
          moveTo(r2, n2);
          p2 = true;
          break;
        case 22:
          r2 += s2.pop();
          moveTo(r2, n2);
          p2 = true;
          break;
        case 24:
          for (; s2.length > 2; ) {
            c2 = r2 + s2.shift();
            h2 = n2 + s2.shift();
            C2 = c2 + s2.shift();
            l2 = h2 + s2.shift();
            r2 = C2 + s2.shift();
            n2 = l2 + s2.shift();
            bezierCurveTo(c2, h2, C2, l2, r2, n2);
          }
          r2 += s2.shift();
          n2 += s2.shift();
          lineTo(r2, n2);
          break;
        case 25:
          for (; s2.length > 6; ) {
            r2 += s2.shift();
            n2 += s2.shift();
            lineTo(r2, n2);
          }
          c2 = r2 + s2.shift();
          h2 = n2 + s2.shift();
          C2 = c2 + s2.shift();
          l2 = h2 + s2.shift();
          r2 = C2 + s2.shift();
          n2 = l2 + s2.shift();
          bezierCurveTo(c2, h2, C2, l2, r2, n2);
          break;
        case 26:
          s2.length % 2 && (r2 += s2.shift());
          for (; s2.length > 0; ) {
            c2 = r2;
            h2 = n2 + s2.shift();
            C2 = c2 + s2.shift();
            l2 = h2 + s2.shift();
            r2 = C2;
            n2 = l2 + s2.shift();
            bezierCurveTo(c2, h2, C2, l2, r2, n2);
          }
          break;
        case 27:
          s2.length % 2 && (n2 += s2.shift());
          for (; s2.length > 0; ) {
            c2 = r2 + s2.shift();
            h2 = n2;
            C2 = c2 + s2.shift();
            l2 = h2 + s2.shift();
            r2 = C2 + s2.shift();
            n2 = l2;
            bezierCurveTo(c2, h2, C2, l2, r2, n2);
          }
          break;
        case 28:
          s2.push((e3[o2] << 24 | e3[o2 + 1] << 16) >> 16);
          o2 += 2;
          break;
        case 29:
          d2 = s2.pop() + i2.gsubrsBias;
          f2 = i2.gsubrs[d2];
          f2 && parse(f2);
          break;
        case 30:
          for (; s2.length > 0; ) {
            c2 = r2;
            h2 = n2 + s2.shift();
            C2 = c2 + s2.shift();
            l2 = h2 + s2.shift();
            r2 = C2 + s2.shift();
            n2 = l2 + (1 === s2.length ? s2.shift() : 0);
            bezierCurveTo(c2, h2, C2, l2, r2, n2);
            if (0 === s2.length)
              break;
            c2 = r2 + s2.shift();
            h2 = n2;
            C2 = c2 + s2.shift();
            l2 = h2 + s2.shift();
            n2 = l2 + s2.shift();
            r2 = C2 + (1 === s2.length ? s2.shift() : 0);
            bezierCurveTo(c2, h2, C2, l2, r2, n2);
          }
          break;
        case 31:
          for (; s2.length > 0; ) {
            c2 = r2 + s2.shift();
            h2 = n2;
            C2 = c2 + s2.shift();
            l2 = h2 + s2.shift();
            n2 = l2 + s2.shift();
            r2 = C2 + (1 === s2.length ? s2.shift() : 0);
            bezierCurveTo(c2, h2, C2, l2, r2, n2);
            if (0 === s2.length)
              break;
            c2 = r2;
            h2 = n2 + s2.shift();
            C2 = c2 + s2.shift();
            l2 = h2 + s2.shift();
            r2 = C2 + s2.shift();
            n2 = l2 + (1 === s2.length ? s2.shift() : 0);
            bezierCurveTo(c2, h2, C2, l2, r2, n2);
          }
          break;
        default:
          if (m2 < 32)
            throw new FormatError(`unknown operator: ${m2}`);
          if (m2 < 247)
            s2.push(m2 - 139);
          else if (m2 < 251)
            s2.push(256 * (m2 - 247) + e3[o2++] + 108);
          else if (m2 < 255)
            s2.push(256 * -(m2 - 251) - e3[o2++] - 108);
          else {
            s2.push((e3[o2] << 24 | e3[o2 + 1] << 16 | e3[o2 + 2] << 8 | e3[o2 + 3]) / 65536);
            o2 += 4;
          }
      }
      p2 && (s2.length = 0);
    }
  }(e2);
}
var ia = [];
var Commands = class {
  constructor() {
    __publicField(this, "cmds", []);
  }
  add(e2, t2) {
    if (t2)
      if (isNumberArray(t2, null))
        this.cmds.push(e2, ...t2);
      else {
        warn(`Commands.add - "${e2}" has at least one non-number arg: "${t2}".`);
        const i2 = t2.map((e3) => "number" == typeof e3 ? e3 : 0);
        this.cmds.push(e2, ...i2);
      }
    else
      this.cmds.push(e2);
  }
};
var CompiledFont = class _CompiledFont {
  constructor(e2) {
    this.constructor === _CompiledFont && unreachable("Cannot initialize CompiledFont.");
    this.fontMatrix = e2;
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
  }
  getPathJs(e2) {
    var _a4;
    const { charCode: t2, glyphId: i2 } = lookupCmap(this.cmap, e2);
    let a2, s2 = this.compiledGlyphs[i2];
    if (!s2) {
      try {
        s2 = this.compileGlyph(this.glyphs[i2], i2);
      } catch (e3) {
        s2 = ia;
        a2 = e3;
      }
      this.compiledGlyphs[i2] = s2;
    }
    (_a4 = this.compiledCharCodeToGlyphId)[t2] ?? (_a4[t2] = i2);
    if (a2)
      throw a2;
    return s2;
  }
  compileGlyph(e2, t2) {
    if (!e2 || 0 === e2.length || 14 === e2[0])
      return ia;
    let i2 = this.fontMatrix;
    if (this.isCFFCIDFont) {
      const e3 = this.fdSelect.getFDIndex(t2);
      if (e3 >= 0 && e3 < this.fdArray.length) {
        i2 = this.fdArray[e3].getByName("FontMatrix") || a;
      } else
        warn("Invalid fd index for glyph index.");
    }
    const s2 = new Commands();
    s2.add(dt);
    s2.add(pt, i2.slice());
    s2.add(ft);
    this.compileGlyphImpl(e2, s2, t2);
    s2.add(ut);
    return s2.cmds;
  }
  compileGlyphImpl() {
    unreachable("Children classes should implement this.");
  }
  hasBuiltPath(e2) {
    const { charCode: t2, glyphId: i2 } = lookupCmap(this.cmap, e2);
    return void 0 !== this.compiledGlyphs[i2] && void 0 !== this.compiledCharCodeToGlyphId[t2];
  }
};
var TrueTypeCompiled = class extends CompiledFont {
  constructor(e2, t2, i2) {
    super(i2 || [488e-6, 0, 0, 488e-6, 0, 0]);
    this.glyphs = e2;
    this.cmap = t2;
  }
  compileGlyphImpl(e2, t2) {
    compileGlyf(e2, t2, this);
  }
};
var Type2Compiled = class extends CompiledFont {
  constructor(e2, t2, i2, a2) {
    super(i2 || [1e-3, 0, 0, 1e-3, 0, 0]);
    this.glyphs = e2.glyphs;
    this.gsubrs = e2.gsubrs || [];
    this.subrs = e2.subrs || [];
    this.cmap = t2;
    this.glyphNameMap = a2 || Mi();
    this.gsubrsBias = getSubroutineBias(this.gsubrs);
    this.subrsBias = getSubroutineBias(this.subrs);
    this.isCFFCIDFont = e2.isCFFCIDFont;
    this.fdSelect = e2.fdSelect;
    this.fdArray = e2.fdArray;
  }
  compileGlyphImpl(e2, t2, i2) {
    compileCharString(e2, t2, this, i2);
  }
};
var FontRendererFactory = class {
  static create(e2, t2) {
    const i2 = new Uint8Array(e2.data);
    let a2, s2, r2, n2, g2, o2;
    const c2 = getUint16(i2, 4);
    for (let e3 = 0, C2 = 12; e3 < c2; e3++, C2 += 16) {
      const e4 = bytesToString(i2.subarray(C2, C2 + 4)), c3 = getUint32(i2, C2 + 8), h2 = getUint32(i2, C2 + 12);
      switch (e4) {
        case "cmap":
          a2 = parseCmap(i2, c3);
          break;
        case "glyf":
          s2 = i2.subarray(c3, c3 + h2);
          break;
        case "loca":
          r2 = i2.subarray(c3, c3 + h2);
          break;
        case "head":
          o2 = getUint16(i2, c3 + 18);
          g2 = getUint16(i2, c3 + 50);
          break;
        case "CFF ":
          n2 = parseCff(i2, c3, c3 + h2, t2);
      }
    }
    if (s2) {
      const t3 = o2 ? [1 / o2, 0, 0, 1 / o2, 0, 0] : e2.fontMatrix;
      return new TrueTypeCompiled(function parseGlyfTable(e3, t4, i3) {
        let a3, s3;
        if (i3) {
          a3 = 4;
          s3 = getUint32;
        } else {
          a3 = 2;
          s3 = (e4, t5) => 2 * getUint16(e4, t5);
        }
        const r3 = [];
        let n3 = s3(t4, 0);
        for (let i4 = a3; i4 < t4.length; i4 += a3) {
          const a4 = s3(t4, i4);
          r3.push(e3.subarray(n3, a4));
          n3 = a4;
        }
        return r3;
      }(s2, r2, g2), a2, t3);
    }
    return new Type2Compiled(n2, a2, e2.fontMatrix, e2.glyphNameMap);
  }
};
var aa = getLookupTableFactory(function(e2) {
  e2.Courier = 600;
  e2["Courier-Bold"] = 600;
  e2["Courier-BoldOblique"] = 600;
  e2["Courier-Oblique"] = 600;
  e2.Helvetica = getLookupTableFactory(function(e3) {
    e3.space = 278;
    e3.exclam = 278;
    e3.quotedbl = 355;
    e3.numbersign = 556;
    e3.dollar = 556;
    e3.percent = 889;
    e3.ampersand = 667;
    e3.quoteright = 222;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 389;
    e3.plus = 584;
    e3.comma = 278;
    e3.hyphen = 333;
    e3.period = 278;
    e3.slash = 278;
    e3.zero = 556;
    e3.one = 556;
    e3.two = 556;
    e3.three = 556;
    e3.four = 556;
    e3.five = 556;
    e3.six = 556;
    e3.seven = 556;
    e3.eight = 556;
    e3.nine = 556;
    e3.colon = 278;
    e3.semicolon = 278;
    e3.less = 584;
    e3.equal = 584;
    e3.greater = 584;
    e3.question = 556;
    e3.at = 1015;
    e3.A = 667;
    e3.B = 667;
    e3.C = 722;
    e3.D = 722;
    e3.E = 667;
    e3.F = 611;
    e3.G = 778;
    e3.H = 722;
    e3.I = 278;
    e3.J = 500;
    e3.K = 667;
    e3.L = 556;
    e3.M = 833;
    e3.N = 722;
    e3.O = 778;
    e3.P = 667;
    e3.Q = 778;
    e3.R = 722;
    e3.S = 667;
    e3.T = 611;
    e3.U = 722;
    e3.V = 667;
    e3.W = 944;
    e3.X = 667;
    e3.Y = 667;
    e3.Z = 611;
    e3.bracketleft = 278;
    e3.backslash = 278;
    e3.bracketright = 278;
    e3.asciicircum = 469;
    e3.underscore = 556;
    e3.quoteleft = 222;
    e3.a = 556;
    e3.b = 556;
    e3.c = 500;
    e3.d = 556;
    e3.e = 556;
    e3.f = 278;
    e3.g = 556;
    e3.h = 556;
    e3.i = 222;
    e3.j = 222;
    e3.k = 500;
    e3.l = 222;
    e3.m = 833;
    e3.n = 556;
    e3.o = 556;
    e3.p = 556;
    e3.q = 556;
    e3.r = 333;
    e3.s = 500;
    e3.t = 278;
    e3.u = 556;
    e3.v = 500;
    e3.w = 722;
    e3.x = 500;
    e3.y = 500;
    e3.z = 500;
    e3.braceleft = 334;
    e3.bar = 260;
    e3.braceright = 334;
    e3.asciitilde = 584;
    e3.exclamdown = 333;
    e3.cent = 556;
    e3.sterling = 556;
    e3.fraction = 167;
    e3.yen = 556;
    e3.florin = 556;
    e3.section = 556;
    e3.currency = 556;
    e3.quotesingle = 191;
    e3.quotedblleft = 333;
    e3.guillemotleft = 556;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 500;
    e3.fl = 500;
    e3.endash = 556;
    e3.dagger = 556;
    e3.daggerdbl = 556;
    e3.periodcentered = 278;
    e3.paragraph = 537;
    e3.bullet = 350;
    e3.quotesinglbase = 222;
    e3.quotedblbase = 333;
    e3.quotedblright = 333;
    e3.guillemotright = 556;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 611;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 1e3;
    e3.ordfeminine = 370;
    e3.Lslash = 556;
    e3.Oslash = 778;
    e3.OE = 1e3;
    e3.ordmasculine = 365;
    e3.ae = 889;
    e3.dotlessi = 278;
    e3.lslash = 222;
    e3.oslash = 611;
    e3.oe = 944;
    e3.germandbls = 611;
    e3.Idieresis = 278;
    e3.eacute = 556;
    e3.abreve = 556;
    e3.uhungarumlaut = 556;
    e3.ecaron = 556;
    e3.Ydieresis = 667;
    e3.divide = 584;
    e3.Yacute = 667;
    e3.Acircumflex = 667;
    e3.aacute = 556;
    e3.Ucircumflex = 722;
    e3.yacute = 500;
    e3.scommaaccent = 500;
    e3.ecircumflex = 556;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 556;
    e3.Uacute = 722;
    e3.uogonek = 556;
    e3.Edieresis = 667;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 737;
    e3.Emacron = 667;
    e3.ccaron = 500;
    e3.aring = 556;
    e3.Ncommaaccent = 722;
    e3.lacute = 222;
    e3.agrave = 556;
    e3.Tcommaaccent = 611;
    e3.Cacute = 722;
    e3.atilde = 556;
    e3.Edotaccent = 667;
    e3.scaron = 500;
    e3.scedilla = 500;
    e3.iacute = 278;
    e3.lozenge = 471;
    e3.Rcaron = 722;
    e3.Gcommaaccent = 778;
    e3.ucircumflex = 556;
    e3.acircumflex = 556;
    e3.Amacron = 667;
    e3.rcaron = 333;
    e3.ccedilla = 500;
    e3.Zdotaccent = 611;
    e3.Thorn = 667;
    e3.Omacron = 778;
    e3.Racute = 722;
    e3.Sacute = 667;
    e3.dcaron = 643;
    e3.Umacron = 722;
    e3.uring = 556;
    e3.threesuperior = 333;
    e3.Ograve = 778;
    e3.Agrave = 667;
    e3.Abreve = 667;
    e3.multiply = 584;
    e3.uacute = 556;
    e3.Tcaron = 611;
    e3.partialdiff = 476;
    e3.ydieresis = 500;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 667;
    e3.adieresis = 556;
    e3.edieresis = 556;
    e3.cacute = 500;
    e3.nacute = 556;
    e3.umacron = 556;
    e3.Ncaron = 722;
    e3.Iacute = 278;
    e3.plusminus = 584;
    e3.brokenbar = 260;
    e3.registered = 737;
    e3.Gbreve = 778;
    e3.Idotaccent = 278;
    e3.summation = 600;
    e3.Egrave = 667;
    e3.racute = 333;
    e3.omacron = 556;
    e3.Zacute = 611;
    e3.Zcaron = 611;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 722;
    e3.lcommaaccent = 222;
    e3.tcaron = 317;
    e3.eogonek = 556;
    e3.Uogonek = 722;
    e3.Aacute = 667;
    e3.Adieresis = 667;
    e3.egrave = 556;
    e3.zacute = 500;
    e3.iogonek = 222;
    e3.Oacute = 778;
    e3.oacute = 556;
    e3.amacron = 556;
    e3.sacute = 500;
    e3.idieresis = 278;
    e3.Ocircumflex = 778;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 556;
    e3.twosuperior = 333;
    e3.Odieresis = 778;
    e3.mu = 556;
    e3.igrave = 278;
    e3.ohungarumlaut = 556;
    e3.Eogonek = 667;
    e3.dcroat = 556;
    e3.threequarters = 834;
    e3.Scedilla = 667;
    e3.lcaron = 299;
    e3.Kcommaaccent = 667;
    e3.Lacute = 556;
    e3.trademark = 1e3;
    e3.edotaccent = 556;
    e3.Igrave = 278;
    e3.Imacron = 278;
    e3.Lcaron = 556;
    e3.onehalf = 834;
    e3.lessequal = 549;
    e3.ocircumflex = 556;
    e3.ntilde = 556;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 667;
    e3.emacron = 556;
    e3.gbreve = 556;
    e3.onequarter = 834;
    e3.Scaron = 667;
    e3.Scommaaccent = 667;
    e3.Ohungarumlaut = 778;
    e3.degree = 400;
    e3.ograve = 556;
    e3.Ccaron = 722;
    e3.ugrave = 556;
    e3.radical = 453;
    e3.Dcaron = 722;
    e3.rcommaaccent = 333;
    e3.Ntilde = 722;
    e3.otilde = 556;
    e3.Rcommaaccent = 722;
    e3.Lcommaaccent = 556;
    e3.Atilde = 667;
    e3.Aogonek = 667;
    e3.Aring = 667;
    e3.Otilde = 778;
    e3.zdotaccent = 500;
    e3.Ecaron = 667;
    e3.Iogonek = 278;
    e3.kcommaaccent = 500;
    e3.minus = 584;
    e3.Icircumflex = 278;
    e3.ncaron = 556;
    e3.tcommaaccent = 278;
    e3.logicalnot = 584;
    e3.odieresis = 556;
    e3.udieresis = 556;
    e3.notequal = 549;
    e3.gcommaaccent = 556;
    e3.eth = 556;
    e3.zcaron = 500;
    e3.ncommaaccent = 556;
    e3.onesuperior = 333;
    e3.imacron = 278;
    e3.Euro = 556;
  });
  e2["Helvetica-Bold"] = getLookupTableFactory(function(e3) {
    e3.space = 278;
    e3.exclam = 333;
    e3.quotedbl = 474;
    e3.numbersign = 556;
    e3.dollar = 556;
    e3.percent = 889;
    e3.ampersand = 722;
    e3.quoteright = 278;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 389;
    e3.plus = 584;
    e3.comma = 278;
    e3.hyphen = 333;
    e3.period = 278;
    e3.slash = 278;
    e3.zero = 556;
    e3.one = 556;
    e3.two = 556;
    e3.three = 556;
    e3.four = 556;
    e3.five = 556;
    e3.six = 556;
    e3.seven = 556;
    e3.eight = 556;
    e3.nine = 556;
    e3.colon = 333;
    e3.semicolon = 333;
    e3.less = 584;
    e3.equal = 584;
    e3.greater = 584;
    e3.question = 611;
    e3.at = 975;
    e3.A = 722;
    e3.B = 722;
    e3.C = 722;
    e3.D = 722;
    e3.E = 667;
    e3.F = 611;
    e3.G = 778;
    e3.H = 722;
    e3.I = 278;
    e3.J = 556;
    e3.K = 722;
    e3.L = 611;
    e3.M = 833;
    e3.N = 722;
    e3.O = 778;
    e3.P = 667;
    e3.Q = 778;
    e3.R = 722;
    e3.S = 667;
    e3.T = 611;
    e3.U = 722;
    e3.V = 667;
    e3.W = 944;
    e3.X = 667;
    e3.Y = 667;
    e3.Z = 611;
    e3.bracketleft = 333;
    e3.backslash = 278;
    e3.bracketright = 333;
    e3.asciicircum = 584;
    e3.underscore = 556;
    e3.quoteleft = 278;
    e3.a = 556;
    e3.b = 611;
    e3.c = 556;
    e3.d = 611;
    e3.e = 556;
    e3.f = 333;
    e3.g = 611;
    e3.h = 611;
    e3.i = 278;
    e3.j = 278;
    e3.k = 556;
    e3.l = 278;
    e3.m = 889;
    e3.n = 611;
    e3.o = 611;
    e3.p = 611;
    e3.q = 611;
    e3.r = 389;
    e3.s = 556;
    e3.t = 333;
    e3.u = 611;
    e3.v = 556;
    e3.w = 778;
    e3.x = 556;
    e3.y = 556;
    e3.z = 500;
    e3.braceleft = 389;
    e3.bar = 280;
    e3.braceright = 389;
    e3.asciitilde = 584;
    e3.exclamdown = 333;
    e3.cent = 556;
    e3.sterling = 556;
    e3.fraction = 167;
    e3.yen = 556;
    e3.florin = 556;
    e3.section = 556;
    e3.currency = 556;
    e3.quotesingle = 238;
    e3.quotedblleft = 500;
    e3.guillemotleft = 556;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 611;
    e3.fl = 611;
    e3.endash = 556;
    e3.dagger = 556;
    e3.daggerdbl = 556;
    e3.periodcentered = 278;
    e3.paragraph = 556;
    e3.bullet = 350;
    e3.quotesinglbase = 278;
    e3.quotedblbase = 500;
    e3.quotedblright = 500;
    e3.guillemotright = 556;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 611;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 1e3;
    e3.ordfeminine = 370;
    e3.Lslash = 611;
    e3.Oslash = 778;
    e3.OE = 1e3;
    e3.ordmasculine = 365;
    e3.ae = 889;
    e3.dotlessi = 278;
    e3.lslash = 278;
    e3.oslash = 611;
    e3.oe = 944;
    e3.germandbls = 611;
    e3.Idieresis = 278;
    e3.eacute = 556;
    e3.abreve = 556;
    e3.uhungarumlaut = 611;
    e3.ecaron = 556;
    e3.Ydieresis = 667;
    e3.divide = 584;
    e3.Yacute = 667;
    e3.Acircumflex = 722;
    e3.aacute = 556;
    e3.Ucircumflex = 722;
    e3.yacute = 556;
    e3.scommaaccent = 556;
    e3.ecircumflex = 556;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 556;
    e3.Uacute = 722;
    e3.uogonek = 611;
    e3.Edieresis = 667;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 737;
    e3.Emacron = 667;
    e3.ccaron = 556;
    e3.aring = 556;
    e3.Ncommaaccent = 722;
    e3.lacute = 278;
    e3.agrave = 556;
    e3.Tcommaaccent = 611;
    e3.Cacute = 722;
    e3.atilde = 556;
    e3.Edotaccent = 667;
    e3.scaron = 556;
    e3.scedilla = 556;
    e3.iacute = 278;
    e3.lozenge = 494;
    e3.Rcaron = 722;
    e3.Gcommaaccent = 778;
    e3.ucircumflex = 611;
    e3.acircumflex = 556;
    e3.Amacron = 722;
    e3.rcaron = 389;
    e3.ccedilla = 556;
    e3.Zdotaccent = 611;
    e3.Thorn = 667;
    e3.Omacron = 778;
    e3.Racute = 722;
    e3.Sacute = 667;
    e3.dcaron = 743;
    e3.Umacron = 722;
    e3.uring = 611;
    e3.threesuperior = 333;
    e3.Ograve = 778;
    e3.Agrave = 722;
    e3.Abreve = 722;
    e3.multiply = 584;
    e3.uacute = 611;
    e3.Tcaron = 611;
    e3.partialdiff = 494;
    e3.ydieresis = 556;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 667;
    e3.adieresis = 556;
    e3.edieresis = 556;
    e3.cacute = 556;
    e3.nacute = 611;
    e3.umacron = 611;
    e3.Ncaron = 722;
    e3.Iacute = 278;
    e3.plusminus = 584;
    e3.brokenbar = 280;
    e3.registered = 737;
    e3.Gbreve = 778;
    e3.Idotaccent = 278;
    e3.summation = 600;
    e3.Egrave = 667;
    e3.racute = 389;
    e3.omacron = 611;
    e3.Zacute = 611;
    e3.Zcaron = 611;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 722;
    e3.lcommaaccent = 278;
    e3.tcaron = 389;
    e3.eogonek = 556;
    e3.Uogonek = 722;
    e3.Aacute = 722;
    e3.Adieresis = 722;
    e3.egrave = 556;
    e3.zacute = 500;
    e3.iogonek = 278;
    e3.Oacute = 778;
    e3.oacute = 611;
    e3.amacron = 556;
    e3.sacute = 556;
    e3.idieresis = 278;
    e3.Ocircumflex = 778;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 611;
    e3.twosuperior = 333;
    e3.Odieresis = 778;
    e3.mu = 611;
    e3.igrave = 278;
    e3.ohungarumlaut = 611;
    e3.Eogonek = 667;
    e3.dcroat = 611;
    e3.threequarters = 834;
    e3.Scedilla = 667;
    e3.lcaron = 400;
    e3.Kcommaaccent = 722;
    e3.Lacute = 611;
    e3.trademark = 1e3;
    e3.edotaccent = 556;
    e3.Igrave = 278;
    e3.Imacron = 278;
    e3.Lcaron = 611;
    e3.onehalf = 834;
    e3.lessequal = 549;
    e3.ocircumflex = 611;
    e3.ntilde = 611;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 667;
    e3.emacron = 556;
    e3.gbreve = 611;
    e3.onequarter = 834;
    e3.Scaron = 667;
    e3.Scommaaccent = 667;
    e3.Ohungarumlaut = 778;
    e3.degree = 400;
    e3.ograve = 611;
    e3.Ccaron = 722;
    e3.ugrave = 611;
    e3.radical = 549;
    e3.Dcaron = 722;
    e3.rcommaaccent = 389;
    e3.Ntilde = 722;
    e3.otilde = 611;
    e3.Rcommaaccent = 722;
    e3.Lcommaaccent = 611;
    e3.Atilde = 722;
    e3.Aogonek = 722;
    e3.Aring = 722;
    e3.Otilde = 778;
    e3.zdotaccent = 500;
    e3.Ecaron = 667;
    e3.Iogonek = 278;
    e3.kcommaaccent = 556;
    e3.minus = 584;
    e3.Icircumflex = 278;
    e3.ncaron = 611;
    e3.tcommaaccent = 333;
    e3.logicalnot = 584;
    e3.odieresis = 611;
    e3.udieresis = 611;
    e3.notequal = 549;
    e3.gcommaaccent = 611;
    e3.eth = 611;
    e3.zcaron = 500;
    e3.ncommaaccent = 611;
    e3.onesuperior = 333;
    e3.imacron = 278;
    e3.Euro = 556;
  });
  e2["Helvetica-BoldOblique"] = getLookupTableFactory(function(e3) {
    e3.space = 278;
    e3.exclam = 333;
    e3.quotedbl = 474;
    e3.numbersign = 556;
    e3.dollar = 556;
    e3.percent = 889;
    e3.ampersand = 722;
    e3.quoteright = 278;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 389;
    e3.plus = 584;
    e3.comma = 278;
    e3.hyphen = 333;
    e3.period = 278;
    e3.slash = 278;
    e3.zero = 556;
    e3.one = 556;
    e3.two = 556;
    e3.three = 556;
    e3.four = 556;
    e3.five = 556;
    e3.six = 556;
    e3.seven = 556;
    e3.eight = 556;
    e3.nine = 556;
    e3.colon = 333;
    e3.semicolon = 333;
    e3.less = 584;
    e3.equal = 584;
    e3.greater = 584;
    e3.question = 611;
    e3.at = 975;
    e3.A = 722;
    e3.B = 722;
    e3.C = 722;
    e3.D = 722;
    e3.E = 667;
    e3.F = 611;
    e3.G = 778;
    e3.H = 722;
    e3.I = 278;
    e3.J = 556;
    e3.K = 722;
    e3.L = 611;
    e3.M = 833;
    e3.N = 722;
    e3.O = 778;
    e3.P = 667;
    e3.Q = 778;
    e3.R = 722;
    e3.S = 667;
    e3.T = 611;
    e3.U = 722;
    e3.V = 667;
    e3.W = 944;
    e3.X = 667;
    e3.Y = 667;
    e3.Z = 611;
    e3.bracketleft = 333;
    e3.backslash = 278;
    e3.bracketright = 333;
    e3.asciicircum = 584;
    e3.underscore = 556;
    e3.quoteleft = 278;
    e3.a = 556;
    e3.b = 611;
    e3.c = 556;
    e3.d = 611;
    e3.e = 556;
    e3.f = 333;
    e3.g = 611;
    e3.h = 611;
    e3.i = 278;
    e3.j = 278;
    e3.k = 556;
    e3.l = 278;
    e3.m = 889;
    e3.n = 611;
    e3.o = 611;
    e3.p = 611;
    e3.q = 611;
    e3.r = 389;
    e3.s = 556;
    e3.t = 333;
    e3.u = 611;
    e3.v = 556;
    e3.w = 778;
    e3.x = 556;
    e3.y = 556;
    e3.z = 500;
    e3.braceleft = 389;
    e3.bar = 280;
    e3.braceright = 389;
    e3.asciitilde = 584;
    e3.exclamdown = 333;
    e3.cent = 556;
    e3.sterling = 556;
    e3.fraction = 167;
    e3.yen = 556;
    e3.florin = 556;
    e3.section = 556;
    e3.currency = 556;
    e3.quotesingle = 238;
    e3.quotedblleft = 500;
    e3.guillemotleft = 556;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 611;
    e3.fl = 611;
    e3.endash = 556;
    e3.dagger = 556;
    e3.daggerdbl = 556;
    e3.periodcentered = 278;
    e3.paragraph = 556;
    e3.bullet = 350;
    e3.quotesinglbase = 278;
    e3.quotedblbase = 500;
    e3.quotedblright = 500;
    e3.guillemotright = 556;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 611;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 1e3;
    e3.ordfeminine = 370;
    e3.Lslash = 611;
    e3.Oslash = 778;
    e3.OE = 1e3;
    e3.ordmasculine = 365;
    e3.ae = 889;
    e3.dotlessi = 278;
    e3.lslash = 278;
    e3.oslash = 611;
    e3.oe = 944;
    e3.germandbls = 611;
    e3.Idieresis = 278;
    e3.eacute = 556;
    e3.abreve = 556;
    e3.uhungarumlaut = 611;
    e3.ecaron = 556;
    e3.Ydieresis = 667;
    e3.divide = 584;
    e3.Yacute = 667;
    e3.Acircumflex = 722;
    e3.aacute = 556;
    e3.Ucircumflex = 722;
    e3.yacute = 556;
    e3.scommaaccent = 556;
    e3.ecircumflex = 556;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 556;
    e3.Uacute = 722;
    e3.uogonek = 611;
    e3.Edieresis = 667;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 737;
    e3.Emacron = 667;
    e3.ccaron = 556;
    e3.aring = 556;
    e3.Ncommaaccent = 722;
    e3.lacute = 278;
    e3.agrave = 556;
    e3.Tcommaaccent = 611;
    e3.Cacute = 722;
    e3.atilde = 556;
    e3.Edotaccent = 667;
    e3.scaron = 556;
    e3.scedilla = 556;
    e3.iacute = 278;
    e3.lozenge = 494;
    e3.Rcaron = 722;
    e3.Gcommaaccent = 778;
    e3.ucircumflex = 611;
    e3.acircumflex = 556;
    e3.Amacron = 722;
    e3.rcaron = 389;
    e3.ccedilla = 556;
    e3.Zdotaccent = 611;
    e3.Thorn = 667;
    e3.Omacron = 778;
    e3.Racute = 722;
    e3.Sacute = 667;
    e3.dcaron = 743;
    e3.Umacron = 722;
    e3.uring = 611;
    e3.threesuperior = 333;
    e3.Ograve = 778;
    e3.Agrave = 722;
    e3.Abreve = 722;
    e3.multiply = 584;
    e3.uacute = 611;
    e3.Tcaron = 611;
    e3.partialdiff = 494;
    e3.ydieresis = 556;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 667;
    e3.adieresis = 556;
    e3.edieresis = 556;
    e3.cacute = 556;
    e3.nacute = 611;
    e3.umacron = 611;
    e3.Ncaron = 722;
    e3.Iacute = 278;
    e3.plusminus = 584;
    e3.brokenbar = 280;
    e3.registered = 737;
    e3.Gbreve = 778;
    e3.Idotaccent = 278;
    e3.summation = 600;
    e3.Egrave = 667;
    e3.racute = 389;
    e3.omacron = 611;
    e3.Zacute = 611;
    e3.Zcaron = 611;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 722;
    e3.lcommaaccent = 278;
    e3.tcaron = 389;
    e3.eogonek = 556;
    e3.Uogonek = 722;
    e3.Aacute = 722;
    e3.Adieresis = 722;
    e3.egrave = 556;
    e3.zacute = 500;
    e3.iogonek = 278;
    e3.Oacute = 778;
    e3.oacute = 611;
    e3.amacron = 556;
    e3.sacute = 556;
    e3.idieresis = 278;
    e3.Ocircumflex = 778;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 611;
    e3.twosuperior = 333;
    e3.Odieresis = 778;
    e3.mu = 611;
    e3.igrave = 278;
    e3.ohungarumlaut = 611;
    e3.Eogonek = 667;
    e3.dcroat = 611;
    e3.threequarters = 834;
    e3.Scedilla = 667;
    e3.lcaron = 400;
    e3.Kcommaaccent = 722;
    e3.Lacute = 611;
    e3.trademark = 1e3;
    e3.edotaccent = 556;
    e3.Igrave = 278;
    e3.Imacron = 278;
    e3.Lcaron = 611;
    e3.onehalf = 834;
    e3.lessequal = 549;
    e3.ocircumflex = 611;
    e3.ntilde = 611;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 667;
    e3.emacron = 556;
    e3.gbreve = 611;
    e3.onequarter = 834;
    e3.Scaron = 667;
    e3.Scommaaccent = 667;
    e3.Ohungarumlaut = 778;
    e3.degree = 400;
    e3.ograve = 611;
    e3.Ccaron = 722;
    e3.ugrave = 611;
    e3.radical = 549;
    e3.Dcaron = 722;
    e3.rcommaaccent = 389;
    e3.Ntilde = 722;
    e3.otilde = 611;
    e3.Rcommaaccent = 722;
    e3.Lcommaaccent = 611;
    e3.Atilde = 722;
    e3.Aogonek = 722;
    e3.Aring = 722;
    e3.Otilde = 778;
    e3.zdotaccent = 500;
    e3.Ecaron = 667;
    e3.Iogonek = 278;
    e3.kcommaaccent = 556;
    e3.minus = 584;
    e3.Icircumflex = 278;
    e3.ncaron = 611;
    e3.tcommaaccent = 333;
    e3.logicalnot = 584;
    e3.odieresis = 611;
    e3.udieresis = 611;
    e3.notequal = 549;
    e3.gcommaaccent = 611;
    e3.eth = 611;
    e3.zcaron = 500;
    e3.ncommaaccent = 611;
    e3.onesuperior = 333;
    e3.imacron = 278;
    e3.Euro = 556;
  });
  e2["Helvetica-Oblique"] = getLookupTableFactory(function(e3) {
    e3.space = 278;
    e3.exclam = 278;
    e3.quotedbl = 355;
    e3.numbersign = 556;
    e3.dollar = 556;
    e3.percent = 889;
    e3.ampersand = 667;
    e3.quoteright = 222;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 389;
    e3.plus = 584;
    e3.comma = 278;
    e3.hyphen = 333;
    e3.period = 278;
    e3.slash = 278;
    e3.zero = 556;
    e3.one = 556;
    e3.two = 556;
    e3.three = 556;
    e3.four = 556;
    e3.five = 556;
    e3.six = 556;
    e3.seven = 556;
    e3.eight = 556;
    e3.nine = 556;
    e3.colon = 278;
    e3.semicolon = 278;
    e3.less = 584;
    e3.equal = 584;
    e3.greater = 584;
    e3.question = 556;
    e3.at = 1015;
    e3.A = 667;
    e3.B = 667;
    e3.C = 722;
    e3.D = 722;
    e3.E = 667;
    e3.F = 611;
    e3.G = 778;
    e3.H = 722;
    e3.I = 278;
    e3.J = 500;
    e3.K = 667;
    e3.L = 556;
    e3.M = 833;
    e3.N = 722;
    e3.O = 778;
    e3.P = 667;
    e3.Q = 778;
    e3.R = 722;
    e3.S = 667;
    e3.T = 611;
    e3.U = 722;
    e3.V = 667;
    e3.W = 944;
    e3.X = 667;
    e3.Y = 667;
    e3.Z = 611;
    e3.bracketleft = 278;
    e3.backslash = 278;
    e3.bracketright = 278;
    e3.asciicircum = 469;
    e3.underscore = 556;
    e3.quoteleft = 222;
    e3.a = 556;
    e3.b = 556;
    e3.c = 500;
    e3.d = 556;
    e3.e = 556;
    e3.f = 278;
    e3.g = 556;
    e3.h = 556;
    e3.i = 222;
    e3.j = 222;
    e3.k = 500;
    e3.l = 222;
    e3.m = 833;
    e3.n = 556;
    e3.o = 556;
    e3.p = 556;
    e3.q = 556;
    e3.r = 333;
    e3.s = 500;
    e3.t = 278;
    e3.u = 556;
    e3.v = 500;
    e3.w = 722;
    e3.x = 500;
    e3.y = 500;
    e3.z = 500;
    e3.braceleft = 334;
    e3.bar = 260;
    e3.braceright = 334;
    e3.asciitilde = 584;
    e3.exclamdown = 333;
    e3.cent = 556;
    e3.sterling = 556;
    e3.fraction = 167;
    e3.yen = 556;
    e3.florin = 556;
    e3.section = 556;
    e3.currency = 556;
    e3.quotesingle = 191;
    e3.quotedblleft = 333;
    e3.guillemotleft = 556;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 500;
    e3.fl = 500;
    e3.endash = 556;
    e3.dagger = 556;
    e3.daggerdbl = 556;
    e3.periodcentered = 278;
    e3.paragraph = 537;
    e3.bullet = 350;
    e3.quotesinglbase = 222;
    e3.quotedblbase = 333;
    e3.quotedblright = 333;
    e3.guillemotright = 556;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 611;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 1e3;
    e3.ordfeminine = 370;
    e3.Lslash = 556;
    e3.Oslash = 778;
    e3.OE = 1e3;
    e3.ordmasculine = 365;
    e3.ae = 889;
    e3.dotlessi = 278;
    e3.lslash = 222;
    e3.oslash = 611;
    e3.oe = 944;
    e3.germandbls = 611;
    e3.Idieresis = 278;
    e3.eacute = 556;
    e3.abreve = 556;
    e3.uhungarumlaut = 556;
    e3.ecaron = 556;
    e3.Ydieresis = 667;
    e3.divide = 584;
    e3.Yacute = 667;
    e3.Acircumflex = 667;
    e3.aacute = 556;
    e3.Ucircumflex = 722;
    e3.yacute = 500;
    e3.scommaaccent = 500;
    e3.ecircumflex = 556;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 556;
    e3.Uacute = 722;
    e3.uogonek = 556;
    e3.Edieresis = 667;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 737;
    e3.Emacron = 667;
    e3.ccaron = 500;
    e3.aring = 556;
    e3.Ncommaaccent = 722;
    e3.lacute = 222;
    e3.agrave = 556;
    e3.Tcommaaccent = 611;
    e3.Cacute = 722;
    e3.atilde = 556;
    e3.Edotaccent = 667;
    e3.scaron = 500;
    e3.scedilla = 500;
    e3.iacute = 278;
    e3.lozenge = 471;
    e3.Rcaron = 722;
    e3.Gcommaaccent = 778;
    e3.ucircumflex = 556;
    e3.acircumflex = 556;
    e3.Amacron = 667;
    e3.rcaron = 333;
    e3.ccedilla = 500;
    e3.Zdotaccent = 611;
    e3.Thorn = 667;
    e3.Omacron = 778;
    e3.Racute = 722;
    e3.Sacute = 667;
    e3.dcaron = 643;
    e3.Umacron = 722;
    e3.uring = 556;
    e3.threesuperior = 333;
    e3.Ograve = 778;
    e3.Agrave = 667;
    e3.Abreve = 667;
    e3.multiply = 584;
    e3.uacute = 556;
    e3.Tcaron = 611;
    e3.partialdiff = 476;
    e3.ydieresis = 500;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 667;
    e3.adieresis = 556;
    e3.edieresis = 556;
    e3.cacute = 500;
    e3.nacute = 556;
    e3.umacron = 556;
    e3.Ncaron = 722;
    e3.Iacute = 278;
    e3.plusminus = 584;
    e3.brokenbar = 260;
    e3.registered = 737;
    e3.Gbreve = 778;
    e3.Idotaccent = 278;
    e3.summation = 600;
    e3.Egrave = 667;
    e3.racute = 333;
    e3.omacron = 556;
    e3.Zacute = 611;
    e3.Zcaron = 611;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 722;
    e3.lcommaaccent = 222;
    e3.tcaron = 317;
    e3.eogonek = 556;
    e3.Uogonek = 722;
    e3.Aacute = 667;
    e3.Adieresis = 667;
    e3.egrave = 556;
    e3.zacute = 500;
    e3.iogonek = 222;
    e3.Oacute = 778;
    e3.oacute = 556;
    e3.amacron = 556;
    e3.sacute = 500;
    e3.idieresis = 278;
    e3.Ocircumflex = 778;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 556;
    e3.twosuperior = 333;
    e3.Odieresis = 778;
    e3.mu = 556;
    e3.igrave = 278;
    e3.ohungarumlaut = 556;
    e3.Eogonek = 667;
    e3.dcroat = 556;
    e3.threequarters = 834;
    e3.Scedilla = 667;
    e3.lcaron = 299;
    e3.Kcommaaccent = 667;
    e3.Lacute = 556;
    e3.trademark = 1e3;
    e3.edotaccent = 556;
    e3.Igrave = 278;
    e3.Imacron = 278;
    e3.Lcaron = 556;
    e3.onehalf = 834;
    e3.lessequal = 549;
    e3.ocircumflex = 556;
    e3.ntilde = 556;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 667;
    e3.emacron = 556;
    e3.gbreve = 556;
    e3.onequarter = 834;
    e3.Scaron = 667;
    e3.Scommaaccent = 667;
    e3.Ohungarumlaut = 778;
    e3.degree = 400;
    e3.ograve = 556;
    e3.Ccaron = 722;
    e3.ugrave = 556;
    e3.radical = 453;
    e3.Dcaron = 722;
    e3.rcommaaccent = 333;
    e3.Ntilde = 722;
    e3.otilde = 556;
    e3.Rcommaaccent = 722;
    e3.Lcommaaccent = 556;
    e3.Atilde = 667;
    e3.Aogonek = 667;
    e3.Aring = 667;
    e3.Otilde = 778;
    e3.zdotaccent = 500;
    e3.Ecaron = 667;
    e3.Iogonek = 278;
    e3.kcommaaccent = 500;
    e3.minus = 584;
    e3.Icircumflex = 278;
    e3.ncaron = 556;
    e3.tcommaaccent = 278;
    e3.logicalnot = 584;
    e3.odieresis = 556;
    e3.udieresis = 556;
    e3.notequal = 549;
    e3.gcommaaccent = 556;
    e3.eth = 556;
    e3.zcaron = 500;
    e3.ncommaaccent = 556;
    e3.onesuperior = 333;
    e3.imacron = 278;
    e3.Euro = 556;
  });
  e2.Symbol = getLookupTableFactory(function(e3) {
    e3.space = 250;
    e3.exclam = 333;
    e3.universal = 713;
    e3.numbersign = 500;
    e3.existential = 549;
    e3.percent = 833;
    e3.ampersand = 778;
    e3.suchthat = 439;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asteriskmath = 500;
    e3.plus = 549;
    e3.comma = 250;
    e3.minus = 549;
    e3.period = 250;
    e3.slash = 278;
    e3.zero = 500;
    e3.one = 500;
    e3.two = 500;
    e3.three = 500;
    e3.four = 500;
    e3.five = 500;
    e3.six = 500;
    e3.seven = 500;
    e3.eight = 500;
    e3.nine = 500;
    e3.colon = 278;
    e3.semicolon = 278;
    e3.less = 549;
    e3.equal = 549;
    e3.greater = 549;
    e3.question = 444;
    e3.congruent = 549;
    e3.Alpha = 722;
    e3.Beta = 667;
    e3.Chi = 722;
    e3.Delta = 612;
    e3.Epsilon = 611;
    e3.Phi = 763;
    e3.Gamma = 603;
    e3.Eta = 722;
    e3.Iota = 333;
    e3.theta1 = 631;
    e3.Kappa = 722;
    e3.Lambda = 686;
    e3.Mu = 889;
    e3.Nu = 722;
    e3.Omicron = 722;
    e3.Pi = 768;
    e3.Theta = 741;
    e3.Rho = 556;
    e3.Sigma = 592;
    e3.Tau = 611;
    e3.Upsilon = 690;
    e3.sigma1 = 439;
    e3.Omega = 768;
    e3.Xi = 645;
    e3.Psi = 795;
    e3.Zeta = 611;
    e3.bracketleft = 333;
    e3.therefore = 863;
    e3.bracketright = 333;
    e3.perpendicular = 658;
    e3.underscore = 500;
    e3.radicalex = 500;
    e3.alpha = 631;
    e3.beta = 549;
    e3.chi = 549;
    e3.delta = 494;
    e3.epsilon = 439;
    e3.phi = 521;
    e3.gamma = 411;
    e3.eta = 603;
    e3.iota = 329;
    e3.phi1 = 603;
    e3.kappa = 549;
    e3.lambda = 549;
    e3.mu = 576;
    e3.nu = 521;
    e3.omicron = 549;
    e3.pi = 549;
    e3.theta = 521;
    e3.rho = 549;
    e3.sigma = 603;
    e3.tau = 439;
    e3.upsilon = 576;
    e3.omega1 = 713;
    e3.omega = 686;
    e3.xi = 493;
    e3.psi = 686;
    e3.zeta = 494;
    e3.braceleft = 480;
    e3.bar = 200;
    e3.braceright = 480;
    e3.similar = 549;
    e3.Euro = 750;
    e3.Upsilon1 = 620;
    e3.minute = 247;
    e3.lessequal = 549;
    e3.fraction = 167;
    e3.infinity = 713;
    e3.florin = 500;
    e3.club = 753;
    e3.diamond = 753;
    e3.heart = 753;
    e3.spade = 753;
    e3.arrowboth = 1042;
    e3.arrowleft = 987;
    e3.arrowup = 603;
    e3.arrowright = 987;
    e3.arrowdown = 603;
    e3.degree = 400;
    e3.plusminus = 549;
    e3.second = 411;
    e3.greaterequal = 549;
    e3.multiply = 549;
    e3.proportional = 713;
    e3.partialdiff = 494;
    e3.bullet = 460;
    e3.divide = 549;
    e3.notequal = 549;
    e3.equivalence = 549;
    e3.approxequal = 549;
    e3.ellipsis = 1e3;
    e3.arrowvertex = 603;
    e3.arrowhorizex = 1e3;
    e3.carriagereturn = 658;
    e3.aleph = 823;
    e3.Ifraktur = 686;
    e3.Rfraktur = 795;
    e3.weierstrass = 987;
    e3.circlemultiply = 768;
    e3.circleplus = 768;
    e3.emptyset = 823;
    e3.intersection = 768;
    e3.union = 768;
    e3.propersuperset = 713;
    e3.reflexsuperset = 713;
    e3.notsubset = 713;
    e3.propersubset = 713;
    e3.reflexsubset = 713;
    e3.element = 713;
    e3.notelement = 713;
    e3.angle = 768;
    e3.gradient = 713;
    e3.registerserif = 790;
    e3.copyrightserif = 790;
    e3.trademarkserif = 890;
    e3.product = 823;
    e3.radical = 549;
    e3.dotmath = 250;
    e3.logicalnot = 713;
    e3.logicaland = 603;
    e3.logicalor = 603;
    e3.arrowdblboth = 1042;
    e3.arrowdblleft = 987;
    e3.arrowdblup = 603;
    e3.arrowdblright = 987;
    e3.arrowdbldown = 603;
    e3.lozenge = 494;
    e3.angleleft = 329;
    e3.registersans = 790;
    e3.copyrightsans = 790;
    e3.trademarksans = 786;
    e3.summation = 713;
    e3.parenlefttp = 384;
    e3.parenleftex = 384;
    e3.parenleftbt = 384;
    e3.bracketlefttp = 384;
    e3.bracketleftex = 384;
    e3.bracketleftbt = 384;
    e3.bracelefttp = 494;
    e3.braceleftmid = 494;
    e3.braceleftbt = 494;
    e3.braceex = 494;
    e3.angleright = 329;
    e3.integral = 274;
    e3.integraltp = 686;
    e3.integralex = 686;
    e3.integralbt = 686;
    e3.parenrighttp = 384;
    e3.parenrightex = 384;
    e3.parenrightbt = 384;
    e3.bracketrighttp = 384;
    e3.bracketrightex = 384;
    e3.bracketrightbt = 384;
    e3.bracerighttp = 494;
    e3.bracerightmid = 494;
    e3.bracerightbt = 494;
    e3.apple = 790;
  });
  e2["Times-Roman"] = getLookupTableFactory(function(e3) {
    e3.space = 250;
    e3.exclam = 333;
    e3.quotedbl = 408;
    e3.numbersign = 500;
    e3.dollar = 500;
    e3.percent = 833;
    e3.ampersand = 778;
    e3.quoteright = 333;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 500;
    e3.plus = 564;
    e3.comma = 250;
    e3.hyphen = 333;
    e3.period = 250;
    e3.slash = 278;
    e3.zero = 500;
    e3.one = 500;
    e3.two = 500;
    e3.three = 500;
    e3.four = 500;
    e3.five = 500;
    e3.six = 500;
    e3.seven = 500;
    e3.eight = 500;
    e3.nine = 500;
    e3.colon = 278;
    e3.semicolon = 278;
    e3.less = 564;
    e3.equal = 564;
    e3.greater = 564;
    e3.question = 444;
    e3.at = 921;
    e3.A = 722;
    e3.B = 667;
    e3.C = 667;
    e3.D = 722;
    e3.E = 611;
    e3.F = 556;
    e3.G = 722;
    e3.H = 722;
    e3.I = 333;
    e3.J = 389;
    e3.K = 722;
    e3.L = 611;
    e3.M = 889;
    e3.N = 722;
    e3.O = 722;
    e3.P = 556;
    e3.Q = 722;
    e3.R = 667;
    e3.S = 556;
    e3.T = 611;
    e3.U = 722;
    e3.V = 722;
    e3.W = 944;
    e3.X = 722;
    e3.Y = 722;
    e3.Z = 611;
    e3.bracketleft = 333;
    e3.backslash = 278;
    e3.bracketright = 333;
    e3.asciicircum = 469;
    e3.underscore = 500;
    e3.quoteleft = 333;
    e3.a = 444;
    e3.b = 500;
    e3.c = 444;
    e3.d = 500;
    e3.e = 444;
    e3.f = 333;
    e3.g = 500;
    e3.h = 500;
    e3.i = 278;
    e3.j = 278;
    e3.k = 500;
    e3.l = 278;
    e3.m = 778;
    e3.n = 500;
    e3.o = 500;
    e3.p = 500;
    e3.q = 500;
    e3.r = 333;
    e3.s = 389;
    e3.t = 278;
    e3.u = 500;
    e3.v = 500;
    e3.w = 722;
    e3.x = 500;
    e3.y = 500;
    e3.z = 444;
    e3.braceleft = 480;
    e3.bar = 200;
    e3.braceright = 480;
    e3.asciitilde = 541;
    e3.exclamdown = 333;
    e3.cent = 500;
    e3.sterling = 500;
    e3.fraction = 167;
    e3.yen = 500;
    e3.florin = 500;
    e3.section = 500;
    e3.currency = 500;
    e3.quotesingle = 180;
    e3.quotedblleft = 444;
    e3.guillemotleft = 500;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 556;
    e3.fl = 556;
    e3.endash = 500;
    e3.dagger = 500;
    e3.daggerdbl = 500;
    e3.periodcentered = 250;
    e3.paragraph = 453;
    e3.bullet = 350;
    e3.quotesinglbase = 333;
    e3.quotedblbase = 444;
    e3.quotedblright = 444;
    e3.guillemotright = 500;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 444;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 889;
    e3.ordfeminine = 276;
    e3.Lslash = 611;
    e3.Oslash = 722;
    e3.OE = 889;
    e3.ordmasculine = 310;
    e3.ae = 667;
    e3.dotlessi = 278;
    e3.lslash = 278;
    e3.oslash = 500;
    e3.oe = 722;
    e3.germandbls = 500;
    e3.Idieresis = 333;
    e3.eacute = 444;
    e3.abreve = 444;
    e3.uhungarumlaut = 500;
    e3.ecaron = 444;
    e3.Ydieresis = 722;
    e3.divide = 564;
    e3.Yacute = 722;
    e3.Acircumflex = 722;
    e3.aacute = 444;
    e3.Ucircumflex = 722;
    e3.yacute = 500;
    e3.scommaaccent = 389;
    e3.ecircumflex = 444;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 444;
    e3.Uacute = 722;
    e3.uogonek = 500;
    e3.Edieresis = 611;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 760;
    e3.Emacron = 611;
    e3.ccaron = 444;
    e3.aring = 444;
    e3.Ncommaaccent = 722;
    e3.lacute = 278;
    e3.agrave = 444;
    e3.Tcommaaccent = 611;
    e3.Cacute = 667;
    e3.atilde = 444;
    e3.Edotaccent = 611;
    e3.scaron = 389;
    e3.scedilla = 389;
    e3.iacute = 278;
    e3.lozenge = 471;
    e3.Rcaron = 667;
    e3.Gcommaaccent = 722;
    e3.ucircumflex = 500;
    e3.acircumflex = 444;
    e3.Amacron = 722;
    e3.rcaron = 333;
    e3.ccedilla = 444;
    e3.Zdotaccent = 611;
    e3.Thorn = 556;
    e3.Omacron = 722;
    e3.Racute = 667;
    e3.Sacute = 556;
    e3.dcaron = 588;
    e3.Umacron = 722;
    e3.uring = 500;
    e3.threesuperior = 300;
    e3.Ograve = 722;
    e3.Agrave = 722;
    e3.Abreve = 722;
    e3.multiply = 564;
    e3.uacute = 500;
    e3.Tcaron = 611;
    e3.partialdiff = 476;
    e3.ydieresis = 500;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 611;
    e3.adieresis = 444;
    e3.edieresis = 444;
    e3.cacute = 444;
    e3.nacute = 500;
    e3.umacron = 500;
    e3.Ncaron = 722;
    e3.Iacute = 333;
    e3.plusminus = 564;
    e3.brokenbar = 200;
    e3.registered = 760;
    e3.Gbreve = 722;
    e3.Idotaccent = 333;
    e3.summation = 600;
    e3.Egrave = 611;
    e3.racute = 333;
    e3.omacron = 500;
    e3.Zacute = 611;
    e3.Zcaron = 611;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 667;
    e3.lcommaaccent = 278;
    e3.tcaron = 326;
    e3.eogonek = 444;
    e3.Uogonek = 722;
    e3.Aacute = 722;
    e3.Adieresis = 722;
    e3.egrave = 444;
    e3.zacute = 444;
    e3.iogonek = 278;
    e3.Oacute = 722;
    e3.oacute = 500;
    e3.amacron = 444;
    e3.sacute = 389;
    e3.idieresis = 278;
    e3.Ocircumflex = 722;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 500;
    e3.twosuperior = 300;
    e3.Odieresis = 722;
    e3.mu = 500;
    e3.igrave = 278;
    e3.ohungarumlaut = 500;
    e3.Eogonek = 611;
    e3.dcroat = 500;
    e3.threequarters = 750;
    e3.Scedilla = 556;
    e3.lcaron = 344;
    e3.Kcommaaccent = 722;
    e3.Lacute = 611;
    e3.trademark = 980;
    e3.edotaccent = 444;
    e3.Igrave = 333;
    e3.Imacron = 333;
    e3.Lcaron = 611;
    e3.onehalf = 750;
    e3.lessequal = 549;
    e3.ocircumflex = 500;
    e3.ntilde = 500;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 611;
    e3.emacron = 444;
    e3.gbreve = 500;
    e3.onequarter = 750;
    e3.Scaron = 556;
    e3.Scommaaccent = 556;
    e3.Ohungarumlaut = 722;
    e3.degree = 400;
    e3.ograve = 500;
    e3.Ccaron = 667;
    e3.ugrave = 500;
    e3.radical = 453;
    e3.Dcaron = 722;
    e3.rcommaaccent = 333;
    e3.Ntilde = 722;
    e3.otilde = 500;
    e3.Rcommaaccent = 667;
    e3.Lcommaaccent = 611;
    e3.Atilde = 722;
    e3.Aogonek = 722;
    e3.Aring = 722;
    e3.Otilde = 722;
    e3.zdotaccent = 444;
    e3.Ecaron = 611;
    e3.Iogonek = 333;
    e3.kcommaaccent = 500;
    e3.minus = 564;
    e3.Icircumflex = 333;
    e3.ncaron = 500;
    e3.tcommaaccent = 278;
    e3.logicalnot = 564;
    e3.odieresis = 500;
    e3.udieresis = 500;
    e3.notequal = 549;
    e3.gcommaaccent = 500;
    e3.eth = 500;
    e3.zcaron = 444;
    e3.ncommaaccent = 500;
    e3.onesuperior = 300;
    e3.imacron = 278;
    e3.Euro = 500;
  });
  e2["Times-Bold"] = getLookupTableFactory(function(e3) {
    e3.space = 250;
    e3.exclam = 333;
    e3.quotedbl = 555;
    e3.numbersign = 500;
    e3.dollar = 500;
    e3.percent = 1e3;
    e3.ampersand = 833;
    e3.quoteright = 333;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 500;
    e3.plus = 570;
    e3.comma = 250;
    e3.hyphen = 333;
    e3.period = 250;
    e3.slash = 278;
    e3.zero = 500;
    e3.one = 500;
    e3.two = 500;
    e3.three = 500;
    e3.four = 500;
    e3.five = 500;
    e3.six = 500;
    e3.seven = 500;
    e3.eight = 500;
    e3.nine = 500;
    e3.colon = 333;
    e3.semicolon = 333;
    e3.less = 570;
    e3.equal = 570;
    e3.greater = 570;
    e3.question = 500;
    e3.at = 930;
    e3.A = 722;
    e3.B = 667;
    e3.C = 722;
    e3.D = 722;
    e3.E = 667;
    e3.F = 611;
    e3.G = 778;
    e3.H = 778;
    e3.I = 389;
    e3.J = 500;
    e3.K = 778;
    e3.L = 667;
    e3.M = 944;
    e3.N = 722;
    e3.O = 778;
    e3.P = 611;
    e3.Q = 778;
    e3.R = 722;
    e3.S = 556;
    e3.T = 667;
    e3.U = 722;
    e3.V = 722;
    e3.W = 1e3;
    e3.X = 722;
    e3.Y = 722;
    e3.Z = 667;
    e3.bracketleft = 333;
    e3.backslash = 278;
    e3.bracketright = 333;
    e3.asciicircum = 581;
    e3.underscore = 500;
    e3.quoteleft = 333;
    e3.a = 500;
    e3.b = 556;
    e3.c = 444;
    e3.d = 556;
    e3.e = 444;
    e3.f = 333;
    e3.g = 500;
    e3.h = 556;
    e3.i = 278;
    e3.j = 333;
    e3.k = 556;
    e3.l = 278;
    e3.m = 833;
    e3.n = 556;
    e3.o = 500;
    e3.p = 556;
    e3.q = 556;
    e3.r = 444;
    e3.s = 389;
    e3.t = 333;
    e3.u = 556;
    e3.v = 500;
    e3.w = 722;
    e3.x = 500;
    e3.y = 500;
    e3.z = 444;
    e3.braceleft = 394;
    e3.bar = 220;
    e3.braceright = 394;
    e3.asciitilde = 520;
    e3.exclamdown = 333;
    e3.cent = 500;
    e3.sterling = 500;
    e3.fraction = 167;
    e3.yen = 500;
    e3.florin = 500;
    e3.section = 500;
    e3.currency = 500;
    e3.quotesingle = 278;
    e3.quotedblleft = 500;
    e3.guillemotleft = 500;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 556;
    e3.fl = 556;
    e3.endash = 500;
    e3.dagger = 500;
    e3.daggerdbl = 500;
    e3.periodcentered = 250;
    e3.paragraph = 540;
    e3.bullet = 350;
    e3.quotesinglbase = 333;
    e3.quotedblbase = 500;
    e3.quotedblright = 500;
    e3.guillemotright = 500;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 500;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 1e3;
    e3.ordfeminine = 300;
    e3.Lslash = 667;
    e3.Oslash = 778;
    e3.OE = 1e3;
    e3.ordmasculine = 330;
    e3.ae = 722;
    e3.dotlessi = 278;
    e3.lslash = 278;
    e3.oslash = 500;
    e3.oe = 722;
    e3.germandbls = 556;
    e3.Idieresis = 389;
    e3.eacute = 444;
    e3.abreve = 500;
    e3.uhungarumlaut = 556;
    e3.ecaron = 444;
    e3.Ydieresis = 722;
    e3.divide = 570;
    e3.Yacute = 722;
    e3.Acircumflex = 722;
    e3.aacute = 500;
    e3.Ucircumflex = 722;
    e3.yacute = 500;
    e3.scommaaccent = 389;
    e3.ecircumflex = 444;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 500;
    e3.Uacute = 722;
    e3.uogonek = 556;
    e3.Edieresis = 667;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 747;
    e3.Emacron = 667;
    e3.ccaron = 444;
    e3.aring = 500;
    e3.Ncommaaccent = 722;
    e3.lacute = 278;
    e3.agrave = 500;
    e3.Tcommaaccent = 667;
    e3.Cacute = 722;
    e3.atilde = 500;
    e3.Edotaccent = 667;
    e3.scaron = 389;
    e3.scedilla = 389;
    e3.iacute = 278;
    e3.lozenge = 494;
    e3.Rcaron = 722;
    e3.Gcommaaccent = 778;
    e3.ucircumflex = 556;
    e3.acircumflex = 500;
    e3.Amacron = 722;
    e3.rcaron = 444;
    e3.ccedilla = 444;
    e3.Zdotaccent = 667;
    e3.Thorn = 611;
    e3.Omacron = 778;
    e3.Racute = 722;
    e3.Sacute = 556;
    e3.dcaron = 672;
    e3.Umacron = 722;
    e3.uring = 556;
    e3.threesuperior = 300;
    e3.Ograve = 778;
    e3.Agrave = 722;
    e3.Abreve = 722;
    e3.multiply = 570;
    e3.uacute = 556;
    e3.Tcaron = 667;
    e3.partialdiff = 494;
    e3.ydieresis = 500;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 667;
    e3.adieresis = 500;
    e3.edieresis = 444;
    e3.cacute = 444;
    e3.nacute = 556;
    e3.umacron = 556;
    e3.Ncaron = 722;
    e3.Iacute = 389;
    e3.plusminus = 570;
    e3.brokenbar = 220;
    e3.registered = 747;
    e3.Gbreve = 778;
    e3.Idotaccent = 389;
    e3.summation = 600;
    e3.Egrave = 667;
    e3.racute = 444;
    e3.omacron = 500;
    e3.Zacute = 667;
    e3.Zcaron = 667;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 722;
    e3.lcommaaccent = 278;
    e3.tcaron = 416;
    e3.eogonek = 444;
    e3.Uogonek = 722;
    e3.Aacute = 722;
    e3.Adieresis = 722;
    e3.egrave = 444;
    e3.zacute = 444;
    e3.iogonek = 278;
    e3.Oacute = 778;
    e3.oacute = 500;
    e3.amacron = 500;
    e3.sacute = 389;
    e3.idieresis = 278;
    e3.Ocircumflex = 778;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 556;
    e3.twosuperior = 300;
    e3.Odieresis = 778;
    e3.mu = 556;
    e3.igrave = 278;
    e3.ohungarumlaut = 500;
    e3.Eogonek = 667;
    e3.dcroat = 556;
    e3.threequarters = 750;
    e3.Scedilla = 556;
    e3.lcaron = 394;
    e3.Kcommaaccent = 778;
    e3.Lacute = 667;
    e3.trademark = 1e3;
    e3.edotaccent = 444;
    e3.Igrave = 389;
    e3.Imacron = 389;
    e3.Lcaron = 667;
    e3.onehalf = 750;
    e3.lessequal = 549;
    e3.ocircumflex = 500;
    e3.ntilde = 556;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 667;
    e3.emacron = 444;
    e3.gbreve = 500;
    e3.onequarter = 750;
    e3.Scaron = 556;
    e3.Scommaaccent = 556;
    e3.Ohungarumlaut = 778;
    e3.degree = 400;
    e3.ograve = 500;
    e3.Ccaron = 722;
    e3.ugrave = 556;
    e3.radical = 549;
    e3.Dcaron = 722;
    e3.rcommaaccent = 444;
    e3.Ntilde = 722;
    e3.otilde = 500;
    e3.Rcommaaccent = 722;
    e3.Lcommaaccent = 667;
    e3.Atilde = 722;
    e3.Aogonek = 722;
    e3.Aring = 722;
    e3.Otilde = 778;
    e3.zdotaccent = 444;
    e3.Ecaron = 667;
    e3.Iogonek = 389;
    e3.kcommaaccent = 556;
    e3.minus = 570;
    e3.Icircumflex = 389;
    e3.ncaron = 556;
    e3.tcommaaccent = 333;
    e3.logicalnot = 570;
    e3.odieresis = 500;
    e3.udieresis = 556;
    e3.notequal = 549;
    e3.gcommaaccent = 500;
    e3.eth = 500;
    e3.zcaron = 444;
    e3.ncommaaccent = 556;
    e3.onesuperior = 300;
    e3.imacron = 278;
    e3.Euro = 500;
  });
  e2["Times-BoldItalic"] = getLookupTableFactory(function(e3) {
    e3.space = 250;
    e3.exclam = 389;
    e3.quotedbl = 555;
    e3.numbersign = 500;
    e3.dollar = 500;
    e3.percent = 833;
    e3.ampersand = 778;
    e3.quoteright = 333;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 500;
    e3.plus = 570;
    e3.comma = 250;
    e3.hyphen = 333;
    e3.period = 250;
    e3.slash = 278;
    e3.zero = 500;
    e3.one = 500;
    e3.two = 500;
    e3.three = 500;
    e3.four = 500;
    e3.five = 500;
    e3.six = 500;
    e3.seven = 500;
    e3.eight = 500;
    e3.nine = 500;
    e3.colon = 333;
    e3.semicolon = 333;
    e3.less = 570;
    e3.equal = 570;
    e3.greater = 570;
    e3.question = 500;
    e3.at = 832;
    e3.A = 667;
    e3.B = 667;
    e3.C = 667;
    e3.D = 722;
    e3.E = 667;
    e3.F = 667;
    e3.G = 722;
    e3.H = 778;
    e3.I = 389;
    e3.J = 500;
    e3.K = 667;
    e3.L = 611;
    e3.M = 889;
    e3.N = 722;
    e3.O = 722;
    e3.P = 611;
    e3.Q = 722;
    e3.R = 667;
    e3.S = 556;
    e3.T = 611;
    e3.U = 722;
    e3.V = 667;
    e3.W = 889;
    e3.X = 667;
    e3.Y = 611;
    e3.Z = 611;
    e3.bracketleft = 333;
    e3.backslash = 278;
    e3.bracketright = 333;
    e3.asciicircum = 570;
    e3.underscore = 500;
    e3.quoteleft = 333;
    e3.a = 500;
    e3.b = 500;
    e3.c = 444;
    e3.d = 500;
    e3.e = 444;
    e3.f = 333;
    e3.g = 500;
    e3.h = 556;
    e3.i = 278;
    e3.j = 278;
    e3.k = 500;
    e3.l = 278;
    e3.m = 778;
    e3.n = 556;
    e3.o = 500;
    e3.p = 500;
    e3.q = 500;
    e3.r = 389;
    e3.s = 389;
    e3.t = 278;
    e3.u = 556;
    e3.v = 444;
    e3.w = 667;
    e3.x = 500;
    e3.y = 444;
    e3.z = 389;
    e3.braceleft = 348;
    e3.bar = 220;
    e3.braceright = 348;
    e3.asciitilde = 570;
    e3.exclamdown = 389;
    e3.cent = 500;
    e3.sterling = 500;
    e3.fraction = 167;
    e3.yen = 500;
    e3.florin = 500;
    e3.section = 500;
    e3.currency = 500;
    e3.quotesingle = 278;
    e3.quotedblleft = 500;
    e3.guillemotleft = 500;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 556;
    e3.fl = 556;
    e3.endash = 500;
    e3.dagger = 500;
    e3.daggerdbl = 500;
    e3.periodcentered = 250;
    e3.paragraph = 500;
    e3.bullet = 350;
    e3.quotesinglbase = 333;
    e3.quotedblbase = 500;
    e3.quotedblright = 500;
    e3.guillemotright = 500;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 500;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 944;
    e3.ordfeminine = 266;
    e3.Lslash = 611;
    e3.Oslash = 722;
    e3.OE = 944;
    e3.ordmasculine = 300;
    e3.ae = 722;
    e3.dotlessi = 278;
    e3.lslash = 278;
    e3.oslash = 500;
    e3.oe = 722;
    e3.germandbls = 500;
    e3.Idieresis = 389;
    e3.eacute = 444;
    e3.abreve = 500;
    e3.uhungarumlaut = 556;
    e3.ecaron = 444;
    e3.Ydieresis = 611;
    e3.divide = 570;
    e3.Yacute = 611;
    e3.Acircumflex = 667;
    e3.aacute = 500;
    e3.Ucircumflex = 722;
    e3.yacute = 444;
    e3.scommaaccent = 389;
    e3.ecircumflex = 444;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 500;
    e3.Uacute = 722;
    e3.uogonek = 556;
    e3.Edieresis = 667;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 747;
    e3.Emacron = 667;
    e3.ccaron = 444;
    e3.aring = 500;
    e3.Ncommaaccent = 722;
    e3.lacute = 278;
    e3.agrave = 500;
    e3.Tcommaaccent = 611;
    e3.Cacute = 667;
    e3.atilde = 500;
    e3.Edotaccent = 667;
    e3.scaron = 389;
    e3.scedilla = 389;
    e3.iacute = 278;
    e3.lozenge = 494;
    e3.Rcaron = 667;
    e3.Gcommaaccent = 722;
    e3.ucircumflex = 556;
    e3.acircumflex = 500;
    e3.Amacron = 667;
    e3.rcaron = 389;
    e3.ccedilla = 444;
    e3.Zdotaccent = 611;
    e3.Thorn = 611;
    e3.Omacron = 722;
    e3.Racute = 667;
    e3.Sacute = 556;
    e3.dcaron = 608;
    e3.Umacron = 722;
    e3.uring = 556;
    e3.threesuperior = 300;
    e3.Ograve = 722;
    e3.Agrave = 667;
    e3.Abreve = 667;
    e3.multiply = 570;
    e3.uacute = 556;
    e3.Tcaron = 611;
    e3.partialdiff = 494;
    e3.ydieresis = 444;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 667;
    e3.adieresis = 500;
    e3.edieresis = 444;
    e3.cacute = 444;
    e3.nacute = 556;
    e3.umacron = 556;
    e3.Ncaron = 722;
    e3.Iacute = 389;
    e3.plusminus = 570;
    e3.brokenbar = 220;
    e3.registered = 747;
    e3.Gbreve = 722;
    e3.Idotaccent = 389;
    e3.summation = 600;
    e3.Egrave = 667;
    e3.racute = 389;
    e3.omacron = 500;
    e3.Zacute = 611;
    e3.Zcaron = 611;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 667;
    e3.lcommaaccent = 278;
    e3.tcaron = 366;
    e3.eogonek = 444;
    e3.Uogonek = 722;
    e3.Aacute = 667;
    e3.Adieresis = 667;
    e3.egrave = 444;
    e3.zacute = 389;
    e3.iogonek = 278;
    e3.Oacute = 722;
    e3.oacute = 500;
    e3.amacron = 500;
    e3.sacute = 389;
    e3.idieresis = 278;
    e3.Ocircumflex = 722;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 500;
    e3.twosuperior = 300;
    e3.Odieresis = 722;
    e3.mu = 576;
    e3.igrave = 278;
    e3.ohungarumlaut = 500;
    e3.Eogonek = 667;
    e3.dcroat = 500;
    e3.threequarters = 750;
    e3.Scedilla = 556;
    e3.lcaron = 382;
    e3.Kcommaaccent = 667;
    e3.Lacute = 611;
    e3.trademark = 1e3;
    e3.edotaccent = 444;
    e3.Igrave = 389;
    e3.Imacron = 389;
    e3.Lcaron = 611;
    e3.onehalf = 750;
    e3.lessequal = 549;
    e3.ocircumflex = 500;
    e3.ntilde = 556;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 667;
    e3.emacron = 444;
    e3.gbreve = 500;
    e3.onequarter = 750;
    e3.Scaron = 556;
    e3.Scommaaccent = 556;
    e3.Ohungarumlaut = 722;
    e3.degree = 400;
    e3.ograve = 500;
    e3.Ccaron = 667;
    e3.ugrave = 556;
    e3.radical = 549;
    e3.Dcaron = 722;
    e3.rcommaaccent = 389;
    e3.Ntilde = 722;
    e3.otilde = 500;
    e3.Rcommaaccent = 667;
    e3.Lcommaaccent = 611;
    e3.Atilde = 667;
    e3.Aogonek = 667;
    e3.Aring = 667;
    e3.Otilde = 722;
    e3.zdotaccent = 389;
    e3.Ecaron = 667;
    e3.Iogonek = 389;
    e3.kcommaaccent = 500;
    e3.minus = 606;
    e3.Icircumflex = 389;
    e3.ncaron = 556;
    e3.tcommaaccent = 278;
    e3.logicalnot = 606;
    e3.odieresis = 500;
    e3.udieresis = 556;
    e3.notequal = 549;
    e3.gcommaaccent = 500;
    e3.eth = 500;
    e3.zcaron = 389;
    e3.ncommaaccent = 556;
    e3.onesuperior = 300;
    e3.imacron = 278;
    e3.Euro = 500;
  });
  e2["Times-Italic"] = getLookupTableFactory(function(e3) {
    e3.space = 250;
    e3.exclam = 333;
    e3.quotedbl = 420;
    e3.numbersign = 500;
    e3.dollar = 500;
    e3.percent = 833;
    e3.ampersand = 778;
    e3.quoteright = 333;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 500;
    e3.plus = 675;
    e3.comma = 250;
    e3.hyphen = 333;
    e3.period = 250;
    e3.slash = 278;
    e3.zero = 500;
    e3.one = 500;
    e3.two = 500;
    e3.three = 500;
    e3.four = 500;
    e3.five = 500;
    e3.six = 500;
    e3.seven = 500;
    e3.eight = 500;
    e3.nine = 500;
    e3.colon = 333;
    e3.semicolon = 333;
    e3.less = 675;
    e3.equal = 675;
    e3.greater = 675;
    e3.question = 500;
    e3.at = 920;
    e3.A = 611;
    e3.B = 611;
    e3.C = 667;
    e3.D = 722;
    e3.E = 611;
    e3.F = 611;
    e3.G = 722;
    e3.H = 722;
    e3.I = 333;
    e3.J = 444;
    e3.K = 667;
    e3.L = 556;
    e3.M = 833;
    e3.N = 667;
    e3.O = 722;
    e3.P = 611;
    e3.Q = 722;
    e3.R = 611;
    e3.S = 500;
    e3.T = 556;
    e3.U = 722;
    e3.V = 611;
    e3.W = 833;
    e3.X = 611;
    e3.Y = 556;
    e3.Z = 556;
    e3.bracketleft = 389;
    e3.backslash = 278;
    e3.bracketright = 389;
    e3.asciicircum = 422;
    e3.underscore = 500;
    e3.quoteleft = 333;
    e3.a = 500;
    e3.b = 500;
    e3.c = 444;
    e3.d = 500;
    e3.e = 444;
    e3.f = 278;
    e3.g = 500;
    e3.h = 500;
    e3.i = 278;
    e3.j = 278;
    e3.k = 444;
    e3.l = 278;
    e3.m = 722;
    e3.n = 500;
    e3.o = 500;
    e3.p = 500;
    e3.q = 500;
    e3.r = 389;
    e3.s = 389;
    e3.t = 278;
    e3.u = 500;
    e3.v = 444;
    e3.w = 667;
    e3.x = 444;
    e3.y = 444;
    e3.z = 389;
    e3.braceleft = 400;
    e3.bar = 275;
    e3.braceright = 400;
    e3.asciitilde = 541;
    e3.exclamdown = 389;
    e3.cent = 500;
    e3.sterling = 500;
    e3.fraction = 167;
    e3.yen = 500;
    e3.florin = 500;
    e3.section = 500;
    e3.currency = 500;
    e3.quotesingle = 214;
    e3.quotedblleft = 556;
    e3.guillemotleft = 500;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 500;
    e3.fl = 500;
    e3.endash = 500;
    e3.dagger = 500;
    e3.daggerdbl = 500;
    e3.periodcentered = 250;
    e3.paragraph = 523;
    e3.bullet = 350;
    e3.quotesinglbase = 333;
    e3.quotedblbase = 556;
    e3.quotedblright = 556;
    e3.guillemotright = 500;
    e3.ellipsis = 889;
    e3.perthousand = 1e3;
    e3.questiondown = 500;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 889;
    e3.AE = 889;
    e3.ordfeminine = 276;
    e3.Lslash = 556;
    e3.Oslash = 722;
    e3.OE = 944;
    e3.ordmasculine = 310;
    e3.ae = 667;
    e3.dotlessi = 278;
    e3.lslash = 278;
    e3.oslash = 500;
    e3.oe = 667;
    e3.germandbls = 500;
    e3.Idieresis = 333;
    e3.eacute = 444;
    e3.abreve = 500;
    e3.uhungarumlaut = 500;
    e3.ecaron = 444;
    e3.Ydieresis = 556;
    e3.divide = 675;
    e3.Yacute = 556;
    e3.Acircumflex = 611;
    e3.aacute = 500;
    e3.Ucircumflex = 722;
    e3.yacute = 444;
    e3.scommaaccent = 389;
    e3.ecircumflex = 444;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 500;
    e3.Uacute = 722;
    e3.uogonek = 500;
    e3.Edieresis = 611;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 760;
    e3.Emacron = 611;
    e3.ccaron = 444;
    e3.aring = 500;
    e3.Ncommaaccent = 667;
    e3.lacute = 278;
    e3.agrave = 500;
    e3.Tcommaaccent = 556;
    e3.Cacute = 667;
    e3.atilde = 500;
    e3.Edotaccent = 611;
    e3.scaron = 389;
    e3.scedilla = 389;
    e3.iacute = 278;
    e3.lozenge = 471;
    e3.Rcaron = 611;
    e3.Gcommaaccent = 722;
    e3.ucircumflex = 500;
    e3.acircumflex = 500;
    e3.Amacron = 611;
    e3.rcaron = 389;
    e3.ccedilla = 444;
    e3.Zdotaccent = 556;
    e3.Thorn = 611;
    e3.Omacron = 722;
    e3.Racute = 611;
    e3.Sacute = 500;
    e3.dcaron = 544;
    e3.Umacron = 722;
    e3.uring = 500;
    e3.threesuperior = 300;
    e3.Ograve = 722;
    e3.Agrave = 611;
    e3.Abreve = 611;
    e3.multiply = 675;
    e3.uacute = 500;
    e3.Tcaron = 556;
    e3.partialdiff = 476;
    e3.ydieresis = 444;
    e3.Nacute = 667;
    e3.icircumflex = 278;
    e3.Ecircumflex = 611;
    e3.adieresis = 500;
    e3.edieresis = 444;
    e3.cacute = 444;
    e3.nacute = 500;
    e3.umacron = 500;
    e3.Ncaron = 667;
    e3.Iacute = 333;
    e3.plusminus = 675;
    e3.brokenbar = 275;
    e3.registered = 760;
    e3.Gbreve = 722;
    e3.Idotaccent = 333;
    e3.summation = 600;
    e3.Egrave = 611;
    e3.racute = 389;
    e3.omacron = 500;
    e3.Zacute = 556;
    e3.Zcaron = 556;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 667;
    e3.lcommaaccent = 278;
    e3.tcaron = 300;
    e3.eogonek = 444;
    e3.Uogonek = 722;
    e3.Aacute = 611;
    e3.Adieresis = 611;
    e3.egrave = 444;
    e3.zacute = 389;
    e3.iogonek = 278;
    e3.Oacute = 722;
    e3.oacute = 500;
    e3.amacron = 500;
    e3.sacute = 389;
    e3.idieresis = 278;
    e3.Ocircumflex = 722;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 500;
    e3.twosuperior = 300;
    e3.Odieresis = 722;
    e3.mu = 500;
    e3.igrave = 278;
    e3.ohungarumlaut = 500;
    e3.Eogonek = 611;
    e3.dcroat = 500;
    e3.threequarters = 750;
    e3.Scedilla = 500;
    e3.lcaron = 300;
    e3.Kcommaaccent = 667;
    e3.Lacute = 556;
    e3.trademark = 980;
    e3.edotaccent = 444;
    e3.Igrave = 333;
    e3.Imacron = 333;
    e3.Lcaron = 611;
    e3.onehalf = 750;
    e3.lessequal = 549;
    e3.ocircumflex = 500;
    e3.ntilde = 500;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 611;
    e3.emacron = 444;
    e3.gbreve = 500;
    e3.onequarter = 750;
    e3.Scaron = 500;
    e3.Scommaaccent = 500;
    e3.Ohungarumlaut = 722;
    e3.degree = 400;
    e3.ograve = 500;
    e3.Ccaron = 667;
    e3.ugrave = 500;
    e3.radical = 453;
    e3.Dcaron = 722;
    e3.rcommaaccent = 389;
    e3.Ntilde = 667;
    e3.otilde = 500;
    e3.Rcommaaccent = 611;
    e3.Lcommaaccent = 556;
    e3.Atilde = 611;
    e3.Aogonek = 611;
    e3.Aring = 611;
    e3.Otilde = 722;
    e3.zdotaccent = 389;
    e3.Ecaron = 611;
    e3.Iogonek = 333;
    e3.kcommaaccent = 444;
    e3.minus = 675;
    e3.Icircumflex = 333;
    e3.ncaron = 500;
    e3.tcommaaccent = 278;
    e3.logicalnot = 675;
    e3.odieresis = 500;
    e3.udieresis = 500;
    e3.notequal = 549;
    e3.gcommaaccent = 500;
    e3.eth = 500;
    e3.zcaron = 389;
    e3.ncommaaccent = 500;
    e3.onesuperior = 300;
    e3.imacron = 278;
    e3.Euro = 500;
  });
  e2.ZapfDingbats = getLookupTableFactory(function(e3) {
    e3.space = 278;
    e3.a1 = 974;
    e3.a2 = 961;
    e3.a202 = 974;
    e3.a3 = 980;
    e3.a4 = 719;
    e3.a5 = 789;
    e3.a119 = 790;
    e3.a118 = 791;
    e3.a117 = 690;
    e3.a11 = 960;
    e3.a12 = 939;
    e3.a13 = 549;
    e3.a14 = 855;
    e3.a15 = 911;
    e3.a16 = 933;
    e3.a105 = 911;
    e3.a17 = 945;
    e3.a18 = 974;
    e3.a19 = 755;
    e3.a20 = 846;
    e3.a21 = 762;
    e3.a22 = 761;
    e3.a23 = 571;
    e3.a24 = 677;
    e3.a25 = 763;
    e3.a26 = 760;
    e3.a27 = 759;
    e3.a28 = 754;
    e3.a6 = 494;
    e3.a7 = 552;
    e3.a8 = 537;
    e3.a9 = 577;
    e3.a10 = 692;
    e3.a29 = 786;
    e3.a30 = 788;
    e3.a31 = 788;
    e3.a32 = 790;
    e3.a33 = 793;
    e3.a34 = 794;
    e3.a35 = 816;
    e3.a36 = 823;
    e3.a37 = 789;
    e3.a38 = 841;
    e3.a39 = 823;
    e3.a40 = 833;
    e3.a41 = 816;
    e3.a42 = 831;
    e3.a43 = 923;
    e3.a44 = 744;
    e3.a45 = 723;
    e3.a46 = 749;
    e3.a47 = 790;
    e3.a48 = 792;
    e3.a49 = 695;
    e3.a50 = 776;
    e3.a51 = 768;
    e3.a52 = 792;
    e3.a53 = 759;
    e3.a54 = 707;
    e3.a55 = 708;
    e3.a56 = 682;
    e3.a57 = 701;
    e3.a58 = 826;
    e3.a59 = 815;
    e3.a60 = 789;
    e3.a61 = 789;
    e3.a62 = 707;
    e3.a63 = 687;
    e3.a64 = 696;
    e3.a65 = 689;
    e3.a66 = 786;
    e3.a67 = 787;
    e3.a68 = 713;
    e3.a69 = 791;
    e3.a70 = 785;
    e3.a71 = 791;
    e3.a72 = 873;
    e3.a73 = 761;
    e3.a74 = 762;
    e3.a203 = 762;
    e3.a75 = 759;
    e3.a204 = 759;
    e3.a76 = 892;
    e3.a77 = 892;
    e3.a78 = 788;
    e3.a79 = 784;
    e3.a81 = 438;
    e3.a82 = 138;
    e3.a83 = 277;
    e3.a84 = 415;
    e3.a97 = 392;
    e3.a98 = 392;
    e3.a99 = 668;
    e3.a100 = 668;
    e3.a89 = 390;
    e3.a90 = 390;
    e3.a93 = 317;
    e3.a94 = 317;
    e3.a91 = 276;
    e3.a92 = 276;
    e3.a205 = 509;
    e3.a85 = 509;
    e3.a206 = 410;
    e3.a86 = 410;
    e3.a87 = 234;
    e3.a88 = 234;
    e3.a95 = 334;
    e3.a96 = 334;
    e3.a101 = 732;
    e3.a102 = 544;
    e3.a103 = 544;
    e3.a104 = 910;
    e3.a106 = 667;
    e3.a107 = 760;
    e3.a108 = 760;
    e3.a112 = 776;
    e3.a111 = 595;
    e3.a110 = 694;
    e3.a109 = 626;
    e3.a120 = 788;
    e3.a121 = 788;
    e3.a122 = 788;
    e3.a123 = 788;
    e3.a124 = 788;
    e3.a125 = 788;
    e3.a126 = 788;
    e3.a127 = 788;
    e3.a128 = 788;
    e3.a129 = 788;
    e3.a130 = 788;
    e3.a131 = 788;
    e3.a132 = 788;
    e3.a133 = 788;
    e3.a134 = 788;
    e3.a135 = 788;
    e3.a136 = 788;
    e3.a137 = 788;
    e3.a138 = 788;
    e3.a139 = 788;
    e3.a140 = 788;
    e3.a141 = 788;
    e3.a142 = 788;
    e3.a143 = 788;
    e3.a144 = 788;
    e3.a145 = 788;
    e3.a146 = 788;
    e3.a147 = 788;
    e3.a148 = 788;
    e3.a149 = 788;
    e3.a150 = 788;
    e3.a151 = 788;
    e3.a152 = 788;
    e3.a153 = 788;
    e3.a154 = 788;
    e3.a155 = 788;
    e3.a156 = 788;
    e3.a157 = 788;
    e3.a158 = 788;
    e3.a159 = 788;
    e3.a160 = 894;
    e3.a161 = 838;
    e3.a163 = 1016;
    e3.a164 = 458;
    e3.a196 = 748;
    e3.a165 = 924;
    e3.a192 = 748;
    e3.a166 = 918;
    e3.a167 = 927;
    e3.a168 = 928;
    e3.a169 = 928;
    e3.a170 = 834;
    e3.a171 = 873;
    e3.a172 = 828;
    e3.a173 = 924;
    e3.a162 = 924;
    e3.a174 = 917;
    e3.a175 = 930;
    e3.a176 = 931;
    e3.a177 = 463;
    e3.a178 = 883;
    e3.a179 = 836;
    e3.a193 = 836;
    e3.a180 = 867;
    e3.a199 = 867;
    e3.a181 = 696;
    e3.a200 = 696;
    e3.a182 = 874;
    e3.a201 = 874;
    e3.a183 = 760;
    e3.a184 = 946;
    e3.a197 = 771;
    e3.a185 = 865;
    e3.a194 = 771;
    e3.a198 = 888;
    e3.a186 = 967;
    e3.a195 = 888;
    e3.a187 = 831;
    e3.a188 = 873;
    e3.a189 = 927;
    e3.a190 = 970;
    e3.a191 = 918;
  });
});
var sa = getLookupTableFactory(function(e2) {
  e2.Courier = { ascent: 629, descent: -157, capHeight: 562, xHeight: -426 };
  e2["Courier-Bold"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 439 };
  e2["Courier-Oblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 };
  e2["Courier-BoldOblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 };
  e2.Helvetica = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 };
  e2["Helvetica-Bold"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 };
  e2["Helvetica-Oblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 };
  e2["Helvetica-BoldOblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 };
  e2["Times-Roman"] = { ascent: 683, descent: -217, capHeight: 662, xHeight: 450 };
  e2["Times-Bold"] = { ascent: 683, descent: -217, capHeight: 676, xHeight: 461 };
  e2["Times-Italic"] = { ascent: 683, descent: -217, capHeight: 653, xHeight: 441 };
  e2["Times-BoldItalic"] = { ascent: 683, descent: -217, capHeight: 669, xHeight: 462 };
  e2.Symbol = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN };
  e2.ZapfDingbats = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN };
});
var GlyfTable = class {
  constructor({ glyfTable: e2, isGlyphLocationsLong: t2, locaTable: i2, numGlyphs: a2 }) {
    this.glyphs = [];
    const s2 = new DataView(i2.buffer, i2.byteOffset, i2.byteLength), r2 = new DataView(e2.buffer, e2.byteOffset, e2.byteLength), n2 = t2 ? 4 : 2;
    let g2 = t2 ? s2.getUint32(0) : 2 * s2.getUint16(0), o2 = 0;
    for (let e3 = 0; e3 < a2; e3++) {
      o2 += n2;
      const e4 = t2 ? s2.getUint32(o2) : 2 * s2.getUint16(o2);
      if (e4 === g2) {
        this.glyphs.push(new Glyph({}));
        continue;
      }
      const i3 = Glyph.parse(g2, r2);
      this.glyphs.push(i3);
      g2 = e4;
    }
  }
  getSize() {
    return this.glyphs.reduce((e2, t2) => e2 + (t2.getSize() + 3 & -4), 0);
  }
  write() {
    const e2 = this.getSize(), t2 = new DataView(new ArrayBuffer(e2)), i2 = e2 > 131070, a2 = i2 ? 4 : 2, s2 = new DataView(new ArrayBuffer((this.glyphs.length + 1) * a2));
    i2 ? s2.setUint32(0, 0) : s2.setUint16(0, 0);
    let r2 = 0, n2 = 0;
    for (const e3 of this.glyphs) {
      r2 += e3.write(r2, t2);
      r2 = r2 + 3 & -4;
      n2 += a2;
      i2 ? s2.setUint32(n2, r2) : s2.setUint16(n2, r2 >> 1);
    }
    return { isLocationLong: i2, loca: new Uint8Array(s2.buffer), glyf: new Uint8Array(t2.buffer) };
  }
  scale(e2) {
    for (let t2 = 0, i2 = this.glyphs.length; t2 < i2; t2++)
      this.glyphs[t2].scale(e2[t2]);
  }
};
var Glyph = class _Glyph {
  constructor({ header: e2 = null, simple: t2 = null, composites: i2 = null }) {
    this.header = e2;
    this.simple = t2;
    this.composites = i2;
  }
  static parse(e2, t2) {
    const [i2, a2] = GlyphHeader.parse(e2, t2);
    e2 += i2;
    if (a2.numberOfContours < 0) {
      const i3 = [];
      for (; ; ) {
        const [a3, s3] = CompositeGlyph.parse(e2, t2);
        e2 += a3;
        i3.push(s3);
        if (!(32 & s3.flags))
          break;
      }
      return new _Glyph({ header: a2, composites: i3 });
    }
    const s2 = SimpleGlyph.parse(e2, t2, a2.numberOfContours);
    return new _Glyph({ header: a2, simple: s2 });
  }
  getSize() {
    if (!this.header)
      return 0;
    const e2 = this.simple ? this.simple.getSize() : this.composites.reduce((e3, t2) => e3 + t2.getSize(), 0);
    return this.header.getSize() + e2;
  }
  write(e2, t2) {
    if (!this.header)
      return 0;
    const i2 = e2;
    e2 += this.header.write(e2, t2);
    if (this.simple)
      e2 += this.simple.write(e2, t2);
    else
      for (const i3 of this.composites)
        e2 += i3.write(e2, t2);
    return e2 - i2;
  }
  scale(e2) {
    if (!this.header)
      return;
    const t2 = (this.header.xMin + this.header.xMax) / 2;
    this.header.scale(t2, e2);
    if (this.simple)
      this.simple.scale(t2, e2);
    else
      for (const i2 of this.composites)
        i2.scale(t2, e2);
  }
};
var GlyphHeader = class _GlyphHeader {
  constructor({ numberOfContours: e2, xMin: t2, yMin: i2, xMax: a2, yMax: s2 }) {
    this.numberOfContours = e2;
    this.xMin = t2;
    this.yMin = i2;
    this.xMax = a2;
    this.yMax = s2;
  }
  static parse(e2, t2) {
    return [10, new _GlyphHeader({ numberOfContours: t2.getInt16(e2), xMin: t2.getInt16(e2 + 2), yMin: t2.getInt16(e2 + 4), xMax: t2.getInt16(e2 + 6), yMax: t2.getInt16(e2 + 8) })];
  }
  getSize() {
    return 10;
  }
  write(e2, t2) {
    t2.setInt16(e2, this.numberOfContours);
    t2.setInt16(e2 + 2, this.xMin);
    t2.setInt16(e2 + 4, this.yMin);
    t2.setInt16(e2 + 6, this.xMax);
    t2.setInt16(e2 + 8, this.yMax);
    return 10;
  }
  scale(e2, t2) {
    this.xMin = Math.round(e2 + (this.xMin - e2) * t2);
    this.xMax = Math.round(e2 + (this.xMax - e2) * t2);
  }
};
var Contour = class {
  constructor({ flags: e2, xCoordinates: t2, yCoordinates: i2 }) {
    this.xCoordinates = t2;
    this.yCoordinates = i2;
    this.flags = e2;
  }
};
var SimpleGlyph = class _SimpleGlyph {
  constructor({ contours: e2, instructions: t2 }) {
    this.contours = e2;
    this.instructions = t2;
  }
  static parse(e2, t2, i2) {
    const a2 = [];
    for (let s3 = 0; s3 < i2; s3++) {
      const i3 = t2.getUint16(e2);
      e2 += 2;
      a2.push(i3);
    }
    const s2 = a2[i2 - 1] + 1, r2 = t2.getUint16(e2);
    e2 += 2;
    const n2 = new Uint8Array(t2).slice(e2, e2 + r2);
    e2 += r2;
    const g2 = [];
    for (let i3 = 0; i3 < s2; e2++, i3++) {
      let a3 = t2.getUint8(e2);
      g2.push(a3);
      if (8 & a3) {
        const s3 = t2.getUint8(++e2);
        a3 ^= 8;
        for (let e3 = 0; e3 < s3; e3++)
          g2.push(a3);
        i3 += s3;
      }
    }
    const o2 = [];
    let c2 = [], C2 = [], h2 = [];
    const l2 = [];
    let Q2 = 0, E2 = 0;
    for (let i3 = 0; i3 < s2; i3++) {
      const s3 = g2[i3];
      if (2 & s3) {
        const i4 = t2.getUint8(e2++);
        E2 += 16 & s3 ? i4 : -i4;
        c2.push(E2);
      } else if (16 & s3)
        c2.push(E2);
      else {
        E2 += t2.getInt16(e2);
        e2 += 2;
        c2.push(E2);
      }
      if (a2[Q2] === i3) {
        Q2++;
        o2.push(c2);
        c2 = [];
      }
    }
    E2 = 0;
    Q2 = 0;
    for (let i3 = 0; i3 < s2; i3++) {
      const s3 = g2[i3];
      if (4 & s3) {
        const i4 = t2.getUint8(e2++);
        E2 += 32 & s3 ? i4 : -i4;
        C2.push(E2);
      } else if (32 & s3)
        C2.push(E2);
      else {
        E2 += t2.getInt16(e2);
        e2 += 2;
        C2.push(E2);
      }
      h2.push(1 & s3 | 64 & s3);
      if (a2[Q2] === i3) {
        c2 = o2[Q2];
        Q2++;
        l2.push(new Contour({ flags: h2, xCoordinates: c2, yCoordinates: C2 }));
        C2 = [];
        h2 = [];
      }
    }
    return new _SimpleGlyph({ contours: l2, instructions: n2 });
  }
  getSize() {
    let e2 = 2 * this.contours.length + 2 + this.instructions.length, t2 = 0, i2 = 0;
    for (const a2 of this.contours) {
      e2 += a2.flags.length;
      for (let s2 = 0, r2 = a2.xCoordinates.length; s2 < r2; s2++) {
        const r3 = a2.xCoordinates[s2], n2 = a2.yCoordinates[s2];
        let g2 = Math.abs(r3 - t2);
        g2 > 255 ? e2 += 2 : g2 > 0 && (e2 += 1);
        t2 = r3;
        g2 = Math.abs(n2 - i2);
        g2 > 255 ? e2 += 2 : g2 > 0 && (e2 += 1);
        i2 = n2;
      }
    }
    return e2;
  }
  write(e2, t2) {
    const i2 = e2, a2 = [], s2 = [], r2 = [];
    let n2 = 0, g2 = 0;
    for (const i3 of this.contours) {
      for (let e3 = 0, t3 = i3.xCoordinates.length; e3 < t3; e3++) {
        let t4 = i3.flags[e3];
        const o2 = i3.xCoordinates[e3];
        let c2 = o2 - n2;
        if (0 === c2) {
          t4 |= 16;
          a2.push(0);
        } else {
          const e4 = Math.abs(c2);
          if (e4 <= 255) {
            t4 |= c2 >= 0 ? 18 : 2;
            a2.push(e4);
          } else
            a2.push(c2);
        }
        n2 = o2;
        const C2 = i3.yCoordinates[e3];
        c2 = C2 - g2;
        if (0 === c2) {
          t4 |= 32;
          s2.push(0);
        } else {
          const e4 = Math.abs(c2);
          if (e4 <= 255) {
            t4 |= c2 >= 0 ? 36 : 4;
            s2.push(e4);
          } else
            s2.push(c2);
        }
        g2 = C2;
        r2.push(t4);
      }
      t2.setUint16(e2, a2.length - 1);
      e2 += 2;
    }
    t2.setUint16(e2, this.instructions.length);
    e2 += 2;
    if (this.instructions.length) {
      new Uint8Array(t2.buffer, 0, t2.buffer.byteLength).set(this.instructions, e2);
      e2 += this.instructions.length;
    }
    for (const i3 of r2)
      t2.setUint8(e2++, i3);
    for (let i3 = 0, s3 = a2.length; i3 < s3; i3++) {
      const s4 = a2[i3], n3 = r2[i3];
      if (2 & n3)
        t2.setUint8(e2++, s4);
      else if (!(16 & n3)) {
        t2.setInt16(e2, s4);
        e2 += 2;
      }
    }
    for (let i3 = 0, a3 = s2.length; i3 < a3; i3++) {
      const a4 = s2[i3], n3 = r2[i3];
      if (4 & n3)
        t2.setUint8(e2++, a4);
      else if (!(32 & n3)) {
        t2.setInt16(e2, a4);
        e2 += 2;
      }
    }
    return e2 - i2;
  }
  scale(e2, t2) {
    for (const i2 of this.contours)
      if (0 !== i2.xCoordinates.length)
        for (let a2 = 0, s2 = i2.xCoordinates.length; a2 < s2; a2++)
          i2.xCoordinates[a2] = Math.round(e2 + (i2.xCoordinates[a2] - e2) * t2);
  }
};
var CompositeGlyph = class _CompositeGlyph {
  constructor({ flags: e2, glyphIndex: t2, argument1: i2, argument2: a2, transf: s2, instructions: r2 }) {
    this.flags = e2;
    this.glyphIndex = t2;
    this.argument1 = i2;
    this.argument2 = a2;
    this.transf = s2;
    this.instructions = r2;
  }
  static parse(e2, t2) {
    const i2 = e2, a2 = [];
    let s2 = t2.getUint16(e2);
    const r2 = t2.getUint16(e2 + 2);
    e2 += 4;
    let n2, g2;
    if (1 & s2) {
      if (2 & s2) {
        n2 = t2.getInt16(e2);
        g2 = t2.getInt16(e2 + 2);
      } else {
        n2 = t2.getUint16(e2);
        g2 = t2.getUint16(e2 + 2);
      }
      e2 += 4;
      s2 ^= 1;
    } else {
      if (2 & s2) {
        n2 = t2.getInt8(e2);
        g2 = t2.getInt8(e2 + 1);
      } else {
        n2 = t2.getUint8(e2);
        g2 = t2.getUint8(e2 + 1);
      }
      e2 += 2;
    }
    if (8 & s2) {
      a2.push(t2.getUint16(e2));
      e2 += 2;
    } else if (64 & s2) {
      a2.push(t2.getUint16(e2), t2.getUint16(e2 + 2));
      e2 += 4;
    } else if (128 & s2) {
      a2.push(t2.getUint16(e2), t2.getUint16(e2 + 2), t2.getUint16(e2 + 4), t2.getUint16(e2 + 6));
      e2 += 8;
    }
    let o2 = null;
    if (256 & s2) {
      const i3 = t2.getUint16(e2);
      e2 += 2;
      o2 = new Uint8Array(t2).slice(e2, e2 + i3);
      e2 += i3;
    }
    return [e2 - i2, new _CompositeGlyph({ flags: s2, glyphIndex: r2, argument1: n2, argument2: g2, transf: a2, instructions: o2 })];
  }
  getSize() {
    let e2 = 4 + 2 * this.transf.length;
    256 & this.flags && (e2 += 2 + this.instructions.length);
    e2 += 2;
    2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e2 += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e2 += 2);
    return e2;
  }
  write(e2, t2) {
    const i2 = e2;
    2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1);
    t2.setUint16(e2, this.flags);
    t2.setUint16(e2 + 2, this.glyphIndex);
    e2 += 4;
    if (1 & this.flags) {
      if (2 & this.flags) {
        t2.setInt16(e2, this.argument1);
        t2.setInt16(e2 + 2, this.argument2);
      } else {
        t2.setUint16(e2, this.argument1);
        t2.setUint16(e2 + 2, this.argument2);
      }
      e2 += 4;
    } else {
      t2.setUint8(e2, this.argument1);
      t2.setUint8(e2 + 1, this.argument2);
      e2 += 2;
    }
    if (256 & this.flags) {
      t2.setUint16(e2, this.instructions.length);
      e2 += 2;
      if (this.instructions.length) {
        new Uint8Array(t2.buffer, 0, t2.buffer.byteLength).set(this.instructions, e2);
        e2 += this.instructions.length;
      }
    }
    return e2 - i2;
  }
  scale(e2, t2) {
  }
};
function writeInt16(e2, t2, i2) {
  e2[t2] = i2 >> 8 & 255;
  e2[t2 + 1] = 255 & i2;
}
function writeInt32(e2, t2, i2) {
  e2[t2] = i2 >> 24 & 255;
  e2[t2 + 1] = i2 >> 16 & 255;
  e2[t2 + 2] = i2 >> 8 & 255;
  e2[t2 + 3] = 255 & i2;
}
function writeData(e2, t2, i2) {
  if (i2 instanceof Uint8Array)
    e2.set(i2, t2);
  else if ("string" == typeof i2)
    for (let a2 = 0, s2 = i2.length; a2 < s2; a2++)
      e2[t2++] = 255 & i2.charCodeAt(a2);
  else
    for (const a2 of i2)
      e2[t2++] = 255 & a2;
}
var OpenTypeFileBuilder = class _OpenTypeFileBuilder {
  constructor(e2) {
    this.sfnt = e2;
    this.tables = /* @__PURE__ */ Object.create(null);
  }
  static getSearchParams(e2, t2) {
    let i2 = 1, a2 = 0;
    for (; (i2 ^ e2) > i2; ) {
      i2 <<= 1;
      a2++;
    }
    const s2 = i2 * t2;
    return { range: s2, entry: a2, rangeShift: t2 * e2 - s2 };
  }
  toArray() {
    let e2 = this.sfnt;
    const t2 = this.tables, i2 = Object.keys(t2);
    i2.sort();
    const a2 = i2.length;
    let s2, r2, n2, g2, o2, c2 = 12 + 16 * a2;
    const C2 = [c2];
    for (s2 = 0; s2 < a2; s2++) {
      g2 = t2[i2[s2]];
      c2 += (g2.length + 3 & -4) >>> 0;
      C2.push(c2);
    }
    const h2 = new Uint8Array(c2);
    for (s2 = 0; s2 < a2; s2++) {
      g2 = t2[i2[s2]];
      writeData(h2, C2[s2], g2);
    }
    "true" === e2 && (e2 = string32(65536));
    h2[0] = 255 & e2.charCodeAt(0);
    h2[1] = 255 & e2.charCodeAt(1);
    h2[2] = 255 & e2.charCodeAt(2);
    h2[3] = 255 & e2.charCodeAt(3);
    writeInt16(h2, 4, a2);
    const l2 = _OpenTypeFileBuilder.getSearchParams(a2, 16);
    writeInt16(h2, 6, l2.range);
    writeInt16(h2, 8, l2.entry);
    writeInt16(h2, 10, l2.rangeShift);
    c2 = 12;
    for (s2 = 0; s2 < a2; s2++) {
      o2 = i2[s2];
      h2[c2] = 255 & o2.charCodeAt(0);
      h2[c2 + 1] = 255 & o2.charCodeAt(1);
      h2[c2 + 2] = 255 & o2.charCodeAt(2);
      h2[c2 + 3] = 255 & o2.charCodeAt(3);
      let e3 = 0;
      for (r2 = C2[s2], n2 = C2[s2 + 1]; r2 < n2; r2 += 4) {
        e3 = e3 + readUint32(h2, r2) >>> 0;
      }
      writeInt32(h2, c2 + 4, e3);
      writeInt32(h2, c2 + 8, C2[s2]);
      writeInt32(h2, c2 + 12, t2[o2].length);
      c2 += 16;
    }
    return h2;
  }
  addTable(e2, t2) {
    if (e2 in this.tables)
      throw new Error("Table " + e2 + " already exists");
    this.tables[e2] = t2;
  }
};
var ra = [4];
var na = [5];
var ga = [6];
var oa = [7];
var Ia = [8];
var ca = [12, 35];
var Ca = [14];
var ha = [21];
var Ba = [22];
var la = [30];
var Qa = [31];
var Type1CharString = class {
  constructor() {
    this.width = 0;
    this.lsb = 0;
    this.flexing = false;
    this.output = [];
    this.stack = [];
  }
  convert(e2, t2, i2) {
    const a2 = e2.length;
    let s2, r2, n2, g2 = false;
    for (let o2 = 0; o2 < a2; o2++) {
      let a3 = e2[o2];
      if (a3 < 32) {
        12 === a3 && (a3 = (a3 << 8) + e2[++o2]);
        switch (a3) {
          case 1:
          case 3:
          case 9:
          case 3072:
          case 3073:
          case 3074:
          case 3105:
            this.stack = [];
            break;
          case 4:
            if (this.flexing) {
              if (this.stack.length < 1) {
                g2 = true;
                break;
              }
              const e4 = this.stack.pop();
              this.stack.push(0, e4);
              break;
            }
            g2 = this.executeCommand(1, ra);
            break;
          case 5:
            g2 = this.executeCommand(2, na);
            break;
          case 6:
            g2 = this.executeCommand(1, ga);
            break;
          case 7:
            g2 = this.executeCommand(1, oa);
            break;
          case 8:
            g2 = this.executeCommand(6, Ia);
            break;
          case 10:
            if (this.stack.length < 1) {
              g2 = true;
              break;
            }
            n2 = this.stack.pop();
            if (!t2[n2]) {
              g2 = true;
              break;
            }
            g2 = this.convert(t2[n2], t2, i2);
            break;
          case 11:
            return g2;
          case 13:
            if (this.stack.length < 2) {
              g2 = true;
              break;
            }
            s2 = this.stack.pop();
            r2 = this.stack.pop();
            this.lsb = r2;
            this.width = s2;
            this.stack.push(s2, r2);
            g2 = this.executeCommand(2, Ba);
            break;
          case 14:
            this.output.push(Ca[0]);
            break;
          case 21:
            if (this.flexing)
              break;
            g2 = this.executeCommand(2, ha);
            break;
          case 22:
            if (this.flexing) {
              this.stack.push(0);
              break;
            }
            g2 = this.executeCommand(1, Ba);
            break;
          case 30:
            g2 = this.executeCommand(4, la);
            break;
          case 31:
            g2 = this.executeCommand(4, Qa);
            break;
          case 3078:
            if (i2) {
              const e4 = this.stack.at(-5);
              this.seac = this.stack.splice(-4, 4);
              this.seac[0] += this.lsb - e4;
              g2 = this.executeCommand(0, Ca);
            } else
              g2 = this.executeCommand(4, Ca);
            break;
          case 3079:
            if (this.stack.length < 4) {
              g2 = true;
              break;
            }
            this.stack.pop();
            s2 = this.stack.pop();
            const e3 = this.stack.pop();
            r2 = this.stack.pop();
            this.lsb = r2;
            this.width = s2;
            this.stack.push(s2, r2, e3);
            g2 = this.executeCommand(3, ha);
            break;
          case 3084:
            if (this.stack.length < 2) {
              g2 = true;
              break;
            }
            const o3 = this.stack.pop(), c2 = this.stack.pop();
            this.stack.push(c2 / o3);
            break;
          case 3088:
            if (this.stack.length < 2) {
              g2 = true;
              break;
            }
            n2 = this.stack.pop();
            const C2 = this.stack.pop();
            if (0 === n2 && 3 === C2) {
              const e4 = this.stack.splice(-17, 17);
              this.stack.push(e4[2] + e4[0], e4[3] + e4[1], e4[4], e4[5], e4[6], e4[7], e4[8], e4[9], e4[10], e4[11], e4[12], e4[13], e4[14]);
              g2 = this.executeCommand(13, ca, true);
              this.flexing = false;
              this.stack.push(e4[15], e4[16]);
            } else
              1 === n2 && 0 === C2 && (this.flexing = true);
            break;
          case 3089:
            break;
          default:
            warn('Unknown type 1 charstring command of "' + a3 + '"');
        }
        if (g2)
          break;
      } else {
        a3 <= 246 ? a3 -= 139 : a3 = a3 <= 250 ? 256 * (a3 - 247) + e2[++o2] + 108 : a3 <= 254 ? -256 * (a3 - 251) - e2[++o2] - 108 : (255 & e2[++o2]) << 24 | (255 & e2[++o2]) << 16 | (255 & e2[++o2]) << 8 | (255 & e2[++o2]) << 0;
        this.stack.push(a3);
      }
    }
    return g2;
  }
  executeCommand(e2, t2, i2) {
    const a2 = this.stack.length;
    if (e2 > a2)
      return true;
    const s2 = a2 - e2;
    for (let e3 = s2; e3 < a2; e3++) {
      let t3 = this.stack[e3];
      if (Number.isInteger(t3))
        this.output.push(28, t3 >> 8 & 255, 255 & t3);
      else {
        t3 = 65536 * t3 | 0;
        this.output.push(255, t3 >> 24 & 255, t3 >> 16 & 255, t3 >> 8 & 255, 255 & t3);
      }
    }
    this.output.push(...t2);
    i2 ? this.stack.splice(s2, e2) : this.stack.length = 0;
    return false;
  }
};
function isHexDigit(e2) {
  return e2 >= 48 && e2 <= 57 || e2 >= 65 && e2 <= 70 || e2 >= 97 && e2 <= 102;
}
function decrypt(e2, t2, i2) {
  if (i2 >= e2.length)
    return new Uint8Array(0);
  let a2, s2, r2 = 0 | t2;
  for (a2 = 0; a2 < i2; a2++)
    r2 = 52845 * (e2[a2] + r2) + 22719 & 65535;
  const n2 = e2.length - i2, g2 = new Uint8Array(n2);
  for (a2 = i2, s2 = 0; s2 < n2; a2++, s2++) {
    const t3 = e2[a2];
    g2[s2] = t3 ^ r2 >> 8;
    r2 = 52845 * (t3 + r2) + 22719 & 65535;
  }
  return g2;
}
function isSpecial(e2) {
  return 47 === e2 || 91 === e2 || 93 === e2 || 123 === e2 || 125 === e2 || 40 === e2 || 41 === e2;
}
var Type1Parser = class {
  constructor(e2, t2, i2) {
    if (t2) {
      const t3 = e2.getBytes(), i3 = !((isHexDigit(t3[0]) || isWhiteSpace(t3[0])) && isHexDigit(t3[1]) && isHexDigit(t3[2]) && isHexDigit(t3[3]) && isHexDigit(t3[4]) && isHexDigit(t3[5]) && isHexDigit(t3[6]) && isHexDigit(t3[7]));
      e2 = new Stream(i3 ? decrypt(t3, 55665, 4) : function decryptAscii(e3, t4, i4) {
        let a2 = 0 | t4;
        const s2 = e3.length, r2 = new Uint8Array(s2 >>> 1);
        let n2, g2;
        for (n2 = 0, g2 = 0; n2 < s2; n2++) {
          const t5 = e3[n2];
          if (!isHexDigit(t5))
            continue;
          n2++;
          let i5;
          for (; n2 < s2 && !isHexDigit(i5 = e3[n2]); )
            n2++;
          if (n2 < s2) {
            const e4 = parseInt(String.fromCharCode(t5, i5), 16);
            r2[g2++] = e4 ^ a2 >> 8;
            a2 = 52845 * (e4 + a2) + 22719 & 65535;
          }
        }
        return r2.slice(i4, g2);
      }(t3, 55665, 4));
    }
    this.seacAnalysisEnabled = !!i2;
    this.stream = e2;
    this.nextChar();
  }
  readNumberArray() {
    this.getToken();
    const e2 = [];
    for (; ; ) {
      const t2 = this.getToken();
      if (null === t2 || "]" === t2 || "}" === t2)
        break;
      e2.push(parseFloat(t2 || 0));
    }
    return e2;
  }
  readNumber() {
    const e2 = this.getToken();
    return parseFloat(e2 || 0);
  }
  readInt() {
    const e2 = this.getToken();
    return 0 | parseInt(e2 || 0, 10);
  }
  readBoolean() {
    return "true" === this.getToken() ? 1 : 0;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  prevChar() {
    this.stream.skip(-2);
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let e2 = false, t2 = this.currentChar;
    for (; ; ) {
      if (-1 === t2)
        return null;
      if (e2)
        10 !== t2 && 13 !== t2 || (e2 = false);
      else if (37 === t2)
        e2 = true;
      else if (!isWhiteSpace(t2))
        break;
      t2 = this.nextChar();
    }
    if (isSpecial(t2)) {
      this.nextChar();
      return String.fromCharCode(t2);
    }
    let i2 = "";
    do {
      i2 += String.fromCharCode(t2);
      t2 = this.nextChar();
    } while (t2 >= 0 && !isWhiteSpace(t2) && !isSpecial(t2));
    return i2;
  }
  readCharStrings(e2, t2) {
    return -1 === t2 ? e2 : decrypt(e2, 4330, t2);
  }
  extractFontProgram(e2) {
    const t2 = this.stream, i2 = [], a2 = [], s2 = /* @__PURE__ */ Object.create(null);
    s2.lenIV = 4;
    const r2 = { subrs: [], charstrings: [], properties: { privateData: s2 } };
    let n2, g2, o2, c2;
    for (; null !== (n2 = this.getToken()); )
      if ("/" === n2) {
        n2 = this.getToken();
        switch (n2) {
          case "CharStrings":
            this.getToken();
            this.getToken();
            this.getToken();
            this.getToken();
            for (; ; ) {
              n2 = this.getToken();
              if (null === n2 || "end" === n2)
                break;
              if ("/" !== n2)
                continue;
              const e4 = this.getToken();
              g2 = this.readInt();
              this.getToken();
              o2 = g2 > 0 ? t2.getBytes(g2) : new Uint8Array(0);
              c2 = r2.properties.privateData.lenIV;
              const i3 = this.readCharStrings(o2, c2);
              this.nextChar();
              n2 = this.getToken();
              "noaccess" === n2 ? this.getToken() : "/" === n2 && this.prevChar();
              a2.push({ glyph: e4, encoded: i3 });
            }
            break;
          case "Subrs":
            this.readInt();
            this.getToken();
            for (; "dup" === this.getToken(); ) {
              const e4 = this.readInt();
              g2 = this.readInt();
              this.getToken();
              o2 = g2 > 0 ? t2.getBytes(g2) : new Uint8Array(0);
              c2 = r2.properties.privateData.lenIV;
              const a3 = this.readCharStrings(o2, c2);
              this.nextChar();
              n2 = this.getToken();
              "noaccess" === n2 && this.getToken();
              i2[e4] = a3;
            }
            break;
          case "BlueValues":
          case "OtherBlues":
          case "FamilyBlues":
          case "FamilyOtherBlues":
            const e3 = this.readNumberArray();
            e3.length > 0 && e3.length, 0;
            break;
          case "StemSnapH":
          case "StemSnapV":
            r2.properties.privateData[n2] = this.readNumberArray();
            break;
          case "StdHW":
          case "StdVW":
            r2.properties.privateData[n2] = this.readNumberArray()[0];
            break;
          case "BlueShift":
          case "lenIV":
          case "BlueFuzz":
          case "BlueScale":
          case "LanguageGroup":
            r2.properties.privateData[n2] = this.readNumber();
            break;
          case "ExpansionFactor":
            r2.properties.privateData[n2] = this.readNumber() || 0.06;
            break;
          case "ForceBold":
            r2.properties.privateData[n2] = this.readBoolean();
        }
      }
    for (const { encoded: t3, glyph: s3 } of a2) {
      const a3 = new Type1CharString(), n3 = a3.convert(t3, i2, this.seacAnalysisEnabled);
      let g3 = a3.output;
      n3 && (g3 = [14]);
      const o3 = { glyphName: s3, charstring: g3, width: a3.width, lsb: a3.lsb, seac: a3.seac };
      ".notdef" === s3 ? r2.charstrings.unshift(o3) : r2.charstrings.push(o3);
      if (e2.builtInEncoding) {
        const t4 = e2.builtInEncoding.indexOf(s3);
        t4 > -1 && void 0 === e2.widths[t4] && t4 >= e2.firstChar && t4 <= e2.lastChar && (e2.widths[t4] = a3.width);
      }
    }
    return r2;
  }
  extractFontHeader(e2) {
    let t2;
    for (; null !== (t2 = this.getToken()); )
      if ("/" === t2) {
        t2 = this.getToken();
        switch (t2) {
          case "FontMatrix":
            const i2 = this.readNumberArray();
            e2.fontMatrix = i2;
            break;
          case "Encoding":
            const a2 = this.getToken();
            let s2;
            if (/^\d+$/.test(a2)) {
              s2 = [];
              const e3 = 0 | parseInt(a2, 10);
              this.getToken();
              for (let i3 = 0; i3 < e3; i3++) {
                t2 = this.getToken();
                for (; "dup" !== t2 && "def" !== t2; ) {
                  t2 = this.getToken();
                  if (null === t2)
                    return;
                }
                if ("def" === t2)
                  break;
                const e4 = this.readInt();
                this.getToken();
                const i4 = this.getToken();
                s2[e4] = i4;
                this.getToken();
              }
            } else
              s2 = getEncoding(a2);
            e2.builtInEncoding = s2;
            break;
          case "FontBBox":
            const r2 = this.readNumberArray();
            e2.ascent = Math.max(r2[3], r2[1]);
            e2.descent = Math.min(r2[1], r2[3]);
            e2.ascentScaled = true;
        }
      }
  }
};
function findBlock(e2, t2, i2) {
  const a2 = e2.length, s2 = t2.length, r2 = a2 - s2;
  let n2 = i2, g2 = false;
  for (; n2 < r2; ) {
    let i3 = 0;
    for (; i3 < s2 && e2[n2 + i3] === t2[i3]; )
      i3++;
    if (i3 >= s2) {
      n2 += i3;
      for (; n2 < a2 && isWhiteSpace(e2[n2]); )
        n2++;
      g2 = true;
      break;
    }
    n2++;
  }
  return { found: g2, length: n2 };
}
var Type1Font = class {
  constructor(e2, t2, i2) {
    let a2 = i2.length1, s2 = i2.length2, r2 = t2.peekBytes(6);
    const n2 = 128 === r2[0] && 1 === r2[1];
    if (n2) {
      t2.skip(6);
      a2 = r2[5] << 24 | r2[4] << 16 | r2[3] << 8 | r2[2];
    }
    const g2 = function getHeaderBlock(e3, t3) {
      const i3 = [101, 101, 120, 101, 99], a3 = e3.pos;
      let s3, r3, n3, g3;
      try {
        s3 = e3.getBytes(t3);
        r3 = s3.length;
      } catch {
      }
      if (r3 === t3) {
        n3 = findBlock(s3, i3, t3 - 2 * i3.length);
        if (n3.found && n3.length === t3)
          return { stream: new Stream(s3), length: t3 };
      }
      warn('Invalid "Length1" property in Type1 font -- trying to recover.');
      e3.pos = a3;
      for (; ; ) {
        n3 = findBlock(e3.peekBytes(2048), i3, 0);
        if (0 === n3.length)
          break;
        e3.pos += n3.length;
        if (n3.found) {
          g3 = e3.pos - a3;
          break;
        }
      }
      e3.pos = a3;
      if (g3)
        return { stream: new Stream(e3.getBytes(g3)), length: g3 };
      warn('Unable to recover "Length1" property in Type1 font -- using as is.');
      return { stream: new Stream(e3.getBytes(t3)), length: t3 };
    }(t2, a2);
    new Type1Parser(g2.stream, false, Ti).extractFontHeader(i2);
    if (n2) {
      r2 = t2.getBytes(6);
      s2 = r2[5] << 24 | r2[4] << 16 | r2[3] << 8 | r2[2];
    }
    const o2 = function getEexecBlock(e3, t3) {
      const i3 = e3.getBytes();
      if (0 === i3.length)
        throw new FormatError("getEexecBlock - no font program found.");
      return { stream: new Stream(i3), length: i3.length };
    }(t2), c2 = new Type1Parser(o2.stream, true, Ti).extractFontProgram(i2);
    for (const e3 in c2.properties)
      i2[e3] = c2.properties[e3];
    const C2 = c2.charstrings, h2 = this.getType2Charstrings(C2), l2 = this.getType2Subrs(c2.subrs);
    this.charstrings = C2;
    this.data = this.wrap(e2, h2, this.charstrings, l2, i2);
    this.seacs = this.getSeacs(c2.charstrings);
  }
  get numGlyphs() {
    return this.charstrings.length + 1;
  }
  getCharset() {
    const e2 = [".notdef"];
    for (const { glyphName: t2 } of this.charstrings)
      e2.push(t2);
    return e2;
  }
  getGlyphMapping(e2) {
    const t2 = this.charstrings;
    if (e2.composite) {
      const i3 = /* @__PURE__ */ Object.create(null);
      for (let a3 = 0, s3 = t2.length; a3 < s3; a3++) {
        i3[e2.cMap.charCodeOf(a3)] = a3 + 1;
      }
      return i3;
    }
    const i2 = [".notdef"];
    let a2, s2;
    for (s2 = 0; s2 < t2.length; s2++)
      i2.push(t2[s2].glyphName);
    const r2 = e2.builtInEncoding;
    if (r2) {
      a2 = /* @__PURE__ */ Object.create(null);
      for (const e3 in r2) {
        s2 = i2.indexOf(r2[e3]);
        s2 >= 0 && (a2[e3] = s2);
      }
    }
    return type1FontGlyphMapping(e2, a2, i2);
  }
  hasGlyphId(e2) {
    if (e2 < 0 || e2 >= this.numGlyphs)
      return false;
    if (0 === e2)
      return true;
    return this.charstrings[e2 - 1].charstring.length > 0;
  }
  getSeacs(e2) {
    const t2 = [];
    for (let i2 = 0, a2 = e2.length; i2 < a2; i2++) {
      const a3 = e2[i2];
      a3.seac && (t2[i2 + 1] = a3.seac);
    }
    return t2;
  }
  getType2Charstrings(e2) {
    const t2 = [];
    for (const i2 of e2)
      t2.push(i2.charstring);
    return t2;
  }
  getType2Subrs(e2) {
    let t2 = 0;
    const i2 = e2.length;
    t2 = i2 < 1133 ? 107 : i2 < 33769 ? 1131 : 32768;
    const a2 = [];
    let s2;
    for (s2 = 0; s2 < t2; s2++)
      a2.push([11]);
    for (s2 = 0; s2 < i2; s2++)
      a2.push(e2[s2]);
    return a2;
  }
  wrap(e2, t2, i2, a2, s2) {
    const r2 = new CFF();
    r2.header = new CFFHeader(1, 0, 4, 4);
    r2.names = [e2];
    const n2 = new CFFTopDict();
    n2.setByName("version", 391);
    n2.setByName("Notice", 392);
    n2.setByName("FullName", 393);
    n2.setByName("FamilyName", 394);
    n2.setByName("Weight", 395);
    n2.setByName("Encoding", null);
    n2.setByName("FontMatrix", s2.fontMatrix);
    n2.setByName("FontBBox", s2.bbox);
    n2.setByName("charset", null);
    n2.setByName("CharStrings", null);
    n2.setByName("Private", null);
    r2.topDict = n2;
    const g2 = new CFFStrings();
    g2.add("Version 0.11");
    g2.add("See original notice");
    g2.add(e2);
    g2.add(e2);
    g2.add("Medium");
    r2.strings = g2;
    r2.globalSubrIndex = new CFFIndex();
    const o2 = t2.length, c2 = [".notdef"];
    let C2, h2;
    for (C2 = 0; C2 < o2; C2++) {
      const e3 = i2[C2].glyphName;
      -1 === Fi.indexOf(e3) && g2.add(e3);
      c2.push(e3);
    }
    r2.charset = new CFFCharset(false, 0, c2);
    const l2 = new CFFIndex();
    l2.add([139, 14]);
    for (C2 = 0; C2 < o2; C2++)
      l2.add(t2[C2]);
    r2.charStrings = l2;
    const Q2 = new CFFPrivateDict();
    Q2.setByName("Subrs", null);
    const E2 = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
    for (C2 = 0, h2 = E2.length; C2 < h2; C2++) {
      const e3 = E2[C2];
      if (!(e3 in s2.privateData))
        continue;
      const t3 = s2.privateData[e3];
      if (Array.isArray(t3))
        for (let e4 = t3.length - 1; e4 > 0; e4--)
          t3[e4] -= t3[e4 - 1];
      Q2.setByName(e3, t3);
    }
    r2.topDict.privateDict = Q2;
    const u2 = new CFFIndex();
    for (C2 = 0, h2 = a2.length; C2 < h2; C2++)
      u2.add(a2[C2]);
    Q2.subrsIndex = u2;
    return new CFFCompiler(r2).compile();
  }
};
var Ea = [[57344, 63743], [1048576, 1114109]];
var ua = 1e3;
var da = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "systemFontInfo", "type", "vertical"];
var fa = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
function adjustWidths(e2) {
  if (!e2.fontMatrix)
    return;
  if (e2.fontMatrix[0] === a[0])
    return;
  const t2 = 1e-3 / e2.fontMatrix[0], i2 = e2.widths;
  for (const e3 in i2)
    i2[e3] *= t2;
  e2.defaultWidth *= t2;
}
function amendFallbackToUnicode(e2) {
  if (!e2.fallbackToUnicode)
    return;
  if (e2.toUnicode instanceof IdentityToUnicodeMap)
    return;
  const t2 = [];
  for (const i2 in e2.fallbackToUnicode)
    e2.toUnicode.has(i2) || (t2[i2] = e2.fallbackToUnicode[i2]);
  t2.length > 0 && e2.toUnicode.amend(t2);
}
var fonts_Glyph = class {
  constructor(e2, t2, i2, a2, s2, r2, n2, g2, o2) {
    this.originalCharCode = e2;
    this.fontChar = t2;
    this.unicode = i2;
    this.accent = a2;
    this.width = s2;
    this.vmetric = r2;
    this.operatorListId = n2;
    this.isSpace = g2;
    this.isInFont = o2;
  }
  get category() {
    return shadow(this, "category", function getCharUnicodeCategory(e2) {
      const t2 = Ki.get(e2);
      if (t2)
        return t2;
      const i2 = e2.match(vi), a2 = { isWhitespace: !!(i2 == null ? void 0 : i2[1]), isZeroWidthDiacritic: !!(i2 == null ? void 0 : i2[2]), isInvisibleFormatMark: !!(i2 == null ? void 0 : i2[3]) };
      Ki.set(e2, a2);
      return a2;
    }(this.unicode), true);
  }
};
function int16(e2, t2) {
  return (e2 << 8) + t2;
}
function writeSignedInt16(e2, t2, i2) {
  e2[t2 + 1] = i2;
  e2[t2] = i2 >>> 8;
}
function signedInt16(e2, t2) {
  const i2 = (e2 << 8) + t2;
  return 32768 & i2 ? i2 - 65536 : i2;
}
function string16(e2) {
  return String.fromCharCode(e2 >> 8 & 255, 255 & e2);
}
function safeString16(e2) {
  e2 > 32767 ? e2 = 32767 : e2 < -32768 && (e2 = -32768);
  return String.fromCharCode(e2 >> 8 & 255, 255 & e2);
}
function isTrueTypeCollectionFile(e2) {
  return "ttcf" === bytesToString(e2.peekBytes(4));
}
function getFontFileType(e2, { type: t2, subtype: i2, composite: a2 }) {
  let s2, r2;
  if (function isTrueTypeFile(e3) {
    const t3 = e3.peekBytes(4);
    return 65536 === readUint32(t3, 0) || "true" === bytesToString(t3);
  }(e2) || isTrueTypeCollectionFile(e2))
    s2 = a2 ? "CIDFontType2" : "TrueType";
  else if (function isOpenTypeFile(e3) {
    return "OTTO" === bytesToString(e3.peekBytes(4));
  }(e2))
    s2 = a2 ? "CIDFontType2" : "OpenType";
  else if (function isType1File(e3) {
    const t3 = e3.peekBytes(2);
    return 37 === t3[0] && 33 === t3[1] || 128 === t3[0] && 1 === t3[1];
  }(e2))
    s2 = a2 ? "CIDFontType0" : "MMType1" === t2 ? "MMType1" : "Type1";
  else if (function isCFFFile(e3) {
    const t3 = e3.peekBytes(4);
    return t3[0] >= 1 && t3[3] >= 1 && t3[3] <= 4;
  }(e2))
    if (a2) {
      s2 = "CIDFontType0";
      r2 = "CIDFontType0C";
    } else {
      s2 = "MMType1" === t2 ? "MMType1" : "Type1";
      r2 = "Type1C";
    }
  else {
    warn("getFontFileType: Unable to detect correct font file Type/Subtype.");
    s2 = t2;
    r2 = i2;
  }
  return [s2, r2];
}
function applyStandardFontGlyphMap(e2, t2) {
  for (const i2 in t2)
    e2[+i2] = t2[i2];
}
function buildToFontChar(e2, t2, i2) {
  const a2 = [];
  let s2;
  for (let i3 = 0, r2 = e2.length; i3 < r2; i3++) {
    s2 = getUnicodeForGlyph(e2[i3], t2);
    -1 !== s2 && (a2[i3] = s2);
  }
  for (const e3 in i2) {
    s2 = getUnicodeForGlyph(i2[e3], t2);
    -1 !== s2 && (a2[+e3] = s2);
  }
  return a2;
}
function isMacNameRecord(e2) {
  return 1 === e2.platform && 0 === e2.encoding && 0 === e2.language;
}
function isWinNameRecord(e2) {
  return 3 === e2.platform && 1 === e2.encoding && 1033 === e2.language;
}
function convertCidString(e2, t2, i2 = false) {
  switch (t2.length) {
    case 1:
      return t2.charCodeAt(0);
    case 2:
      return t2.charCodeAt(0) << 8 | t2.charCodeAt(1);
  }
  const a2 = `Unsupported CID string (charCode ${e2}): "${t2}".`;
  if (i2)
    throw new FormatError(a2);
  warn(a2);
  return t2;
}
function adjustMapping(e2, t2, i2, a2) {
  const s2 = /* @__PURE__ */ Object.create(null), r2 = /* @__PURE__ */ new Map(), n2 = [], g2 = /* @__PURE__ */ new Set();
  let o2 = 0;
  let c2 = Ea[o2][0], C2 = Ea[o2][1];
  for (const l2 in e2) {
    let Q2 = e2[l2];
    if (!t2(Q2))
      continue;
    if (c2 > C2) {
      o2++;
      if (o2 >= Ea.length) {
        warn("Ran out of space in font private use area.");
        break;
      }
      c2 = Ea[o2][0];
      C2 = Ea[o2][1];
    }
    const E2 = c2++;
    0 === Q2 && (Q2 = i2);
    let u2 = a2.get(l2);
    "string" == typeof u2 && (u2 = u2.codePointAt(0));
    if (u2 && !(h2 = u2, Ea[0][0] <= h2 && h2 <= Ea[0][1] || Ea[1][0] <= h2 && h2 <= Ea[1][1]) && !g2.has(Q2)) {
      r2.set(u2, Q2);
      g2.add(Q2);
    }
    s2[E2] = Q2;
    n2[l2] = E2;
  }
  var h2;
  return { toFontChar: n2, charCodeToGlyphId: s2, toUnicodeExtraMap: r2, nextAvailableFontCharCode: c2 };
}
function createCmapTable(e2, t2, i2) {
  const a2 = function getRanges(e3, t3, i3) {
    const a3 = [];
    for (const t4 in e3)
      e3[t4] >= i3 || a3.push({ fontCharCode: 0 | t4, glyphId: e3[t4] });
    if (t3)
      for (const [e4, s4] of t3)
        s4 >= i3 || a3.push({ fontCharCode: e4, glyphId: s4 });
    0 === a3.length && a3.push({ fontCharCode: 0, glyphId: 0 });
    a3.sort(function fontGetRangesSort(e4, t4) {
      return e4.fontCharCode - t4.fontCharCode;
    });
    const s3 = [], r3 = a3.length;
    for (let e4 = 0; e4 < r3; ) {
      const t4 = a3[e4].fontCharCode, i4 = [a3[e4].glyphId];
      ++e4;
      let n3 = t4;
      for (; e4 < r3 && n3 + 1 === a3[e4].fontCharCode; ) {
        i4.push(a3[e4].glyphId);
        ++n3;
        ++e4;
        if (65535 === n3)
          break;
      }
      s3.push([t4, n3, i4]);
    }
    return s3;
  }(e2, t2, i2), s2 = a2.at(-1)[1] > 65535 ? 2 : 1;
  let r2, n2, g2, o2, c2 = "\0\0" + string16(s2) + "\0\0" + string32(4 + 8 * s2);
  for (r2 = a2.length - 1; r2 >= 0 && !(a2[r2][0] <= 65535); --r2)
    ;
  const C2 = r2 + 1;
  a2[r2][0] < 65535 && 65535 === a2[r2][1] && (a2[r2][1] = 65534);
  const h2 = a2[r2][1] < 65535 ? 1 : 0, l2 = C2 + h2, Q2 = OpenTypeFileBuilder.getSearchParams(l2, 2);
  let E2, u2, d2, f2, p2 = "", m2 = "", y2 = "", w2 = "", D2 = "", b2 = 0;
  for (r2 = 0, n2 = C2; r2 < n2; r2++) {
    E2 = a2[r2];
    u2 = E2[0];
    d2 = E2[1];
    p2 += string16(u2);
    m2 += string16(d2);
    f2 = E2[2];
    let e3 = true;
    for (g2 = 1, o2 = f2.length; g2 < o2; ++g2)
      if (f2[g2] !== f2[g2 - 1] + 1) {
        e3 = false;
        break;
      }
    if (e3) {
      y2 += string16(f2[0] - u2 & 65535);
      w2 += string16(0);
    } else {
      const e4 = 2 * (l2 - r2) + 2 * b2;
      b2 += d2 - u2 + 1;
      y2 += string16(0);
      w2 += string16(e4);
      for (g2 = 0, o2 = f2.length; g2 < o2; ++g2)
        D2 += string16(f2[g2]);
    }
  }
  if (h2 > 0) {
    m2 += "ÿÿ";
    p2 += "ÿÿ";
    y2 += "\0";
    w2 += "\0\0";
  }
  const F2 = "\0\0" + string16(2 * l2) + string16(Q2.range) + string16(Q2.entry) + string16(Q2.rangeShift) + m2 + "\0\0" + p2 + y2 + w2 + D2;
  let S2 = "", k2 = "";
  if (s2 > 1) {
    c2 += "\0\0\n" + string32(4 + 8 * s2 + 4 + F2.length);
    S2 = "";
    for (r2 = 0, n2 = a2.length; r2 < n2; r2++) {
      E2 = a2[r2];
      u2 = E2[0];
      f2 = E2[2];
      let e3 = f2[0];
      for (g2 = 1, o2 = f2.length; g2 < o2; ++g2)
        if (f2[g2] !== f2[g2 - 1] + 1) {
          d2 = E2[0] + g2 - 1;
          S2 += string32(u2) + string32(d2) + string32(e3);
          u2 = d2 + 1;
          e3 = f2[g2];
        }
      S2 += string32(u2) + string32(E2[1]) + string32(e3);
    }
    k2 = "\0\f\0\0" + string32(S2.length + 16) + "\0\0\0\0" + string32(S2.length / 12);
  }
  return c2 + "\0" + string16(F2.length + 4) + F2 + k2 + S2;
}
function createOS2Table(e2, t2, i2) {
  i2 || (i2 = { unitsPerEm: 0, yMax: 0, yMin: 0, ascent: 0, descent: 0 });
  let a2 = 0, s2 = 0, r2 = 0, n2 = 0, g2 = null, o2 = 0, c2 = -1;
  if (t2) {
    for (let e3 in t2) {
      e3 |= 0;
      (g2 > e3 || !g2) && (g2 = e3);
      o2 < e3 && (o2 = e3);
      c2 = getUnicodeRangeFor(e3, c2);
      if (c2 < 32)
        a2 |= 1 << c2;
      else if (c2 < 64)
        s2 |= 1 << c2 - 32;
      else if (c2 < 96)
        r2 |= 1 << c2 - 64;
      else {
        if (!(c2 < 123))
          throw new FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
        n2 |= 1 << c2 - 96;
      }
    }
    o2 > 65535 && (o2 = 65535);
  } else {
    g2 = 0;
    o2 = 255;
  }
  const C2 = e2.bbox || [0, 0, 0, 0], h2 = i2.unitsPerEm || (e2.fontMatrix ? 1 / Math.max(...e2.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3), l2 = e2.ascentScaled ? 1 : h2 / ua, Q2 = i2.ascent || Math.round(l2 * (e2.ascent || C2[3]));
  let E2 = i2.descent || Math.round(l2 * (e2.descent || C2[1]));
  E2 > 0 && e2.descent > 0 && C2[1] < 0 && (E2 = -E2);
  const u2 = i2.yMax || Q2, d2 = -i2.yMin || -E2;
  return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(e2.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + string32(a2) + string32(s2) + string32(r2) + string32(n2) + "*21*" + string16(e2.italicAngle ? 1 : 0) + string16(g2 || e2.firstChar) + string16(o2 || e2.lastChar) + string16(Q2) + string16(E2) + "\0d" + string16(u2) + string16(d2) + "\0\0\0\0\0\0\0\0" + string16(e2.xHeight) + string16(e2.capHeight) + string16(0) + string16(g2 || e2.firstChar) + "\0";
}
function createPostTable(e2) {
  return "\0\0\0" + string32(Math.floor(65536 * e2.italicAngle)) + "\0\0\0\0" + string32(e2.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function createPostscriptName(e2) {
  return e2.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function createNameTable(e2, t2) {
  t2 || (t2 = [[], []]);
  const i2 = [t2[0][0] || "Original licence", t2[0][1] || e2, t2[0][2] || "Unknown", t2[0][3] || "uniqueID", t2[0][4] || e2, t2[0][5] || "Version 0.11", t2[0][6] || createPostscriptName(e2), t2[0][7] || "Unknown", t2[0][8] || "Unknown", t2[0][9] || "Unknown"], a2 = [];
  let s2, r2, n2, g2, o2;
  for (s2 = 0, r2 = i2.length; s2 < r2; s2++) {
    o2 = t2[1][s2] || i2[s2];
    const e3 = [];
    for (n2 = 0, g2 = o2.length; n2 < g2; n2++)
      e3.push(string16(o2.charCodeAt(n2)));
    a2.push(e3.join(""));
  }
  const c2 = [i2, a2], C2 = ["\0", "\0"], h2 = ["\0\0", "\0"], l2 = ["\0\0", "	"], Q2 = i2.length * C2.length;
  let E2 = "\0\0" + string16(Q2) + string16(12 * Q2 + 6), u2 = 0;
  for (s2 = 0, r2 = C2.length; s2 < r2; s2++) {
    const e3 = c2[s2];
    for (n2 = 0, g2 = e3.length; n2 < g2; n2++) {
      o2 = e3[n2];
      E2 += C2[s2] + h2[s2] + l2[s2] + string16(n2) + string16(o2.length) + string16(u2);
      u2 += o2.length;
    }
  }
  E2 += i2.join("") + a2.join("");
  return E2;
}
var Font = class {
  constructor(e2, t2, i2) {
    var _a4;
    this.name = e2;
    this.psName = null;
    this.mimetype = null;
    this.disableFontFace = false;
    this.loadedName = i2.loadedName;
    this.isType3Font = i2.isType3Font;
    this.missingFile = false;
    this.cssFontInfo = i2.cssFontInfo;
    this._charsCache = /* @__PURE__ */ Object.create(null);
    this._glyphCache = /* @__PURE__ */ Object.create(null);
    let a2 = !!(i2.flags & Oi);
    if (!a2 && !i2.isSimulatedFlags) {
      const t3 = e2.replaceAll(/[,_]/g, "-").split("-", 1)[0], i3 = _i2();
      for (const e3 of t3.split("+"))
        if (i3[e3]) {
          a2 = true;
          break;
        }
    }
    this.isSerifFont = a2;
    this.isSymbolicFont = !!(i2.flags & Pi);
    this.isMonospace = !!(i2.flags & qi);
    let { type: s2, subtype: r2 } = i2;
    this.type = s2;
    this.subtype = r2;
    this.systemFontInfo = i2.systemFontInfo;
    const n2 = e2.match(/^InvalidPDFjsFont_(.*)_\d+$/);
    this.isInvalidPDFjsFont = !!n2;
    this.isInvalidPDFjsFont ? this.fallbackName = n2[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif";
    if ((_a4 = this.systemFontInfo) == null ? void 0 : _a4.guessFallback) {
      this.systemFontInfo.guessFallback = false;
      this.systemFontInfo.css += `,${this.fallbackName}`;
    }
    this.differences = i2.differences;
    this.widths = i2.widths;
    this.defaultWidth = i2.defaultWidth;
    this.composite = i2.composite;
    this.cMap = i2.cMap;
    this.capHeight = i2.capHeight / ua;
    this.ascent = i2.ascent / ua;
    this.descent = i2.descent / ua;
    this.lineHeight = this.ascent - this.descent;
    this.fontMatrix = i2.fontMatrix;
    this.bbox = i2.bbox;
    this.defaultEncoding = i2.defaultEncoding;
    this.toUnicode = i2.toUnicode;
    this.toFontChar = [];
    if ("Type3" === i2.type) {
      for (let e3 = 0; e3 < 256; e3++)
        this.toFontChar[e3] = this.differences[e3] || i2.defaultEncoding[e3];
      return;
    }
    this.cidEncoding = i2.cidEncoding || "";
    this.vertical = !!i2.vertical;
    if (this.vertical) {
      this.vmetrics = i2.vmetrics;
      this.defaultVMetrics = i2.defaultVMetrics;
    }
    if (!t2 || t2.isEmpty) {
      t2 && warn('Font file is empty in "' + e2 + '" (' + this.loadedName + ")");
      this.fallbackToSystemFont(i2);
      return;
    }
    [s2, r2] = getFontFileType(t2, i2);
    s2 === this.type && r2 === this.subtype || info(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${s2}/${r2}.`);
    let g2;
    try {
      switch (s2) {
        case "MMType1":
          info("MMType1 font (" + e2 + "), falling back to Type1.");
        case "Type1":
        case "CIDFontType0":
          this.mimetype = "font/opentype";
          const a3 = "Type1C" === r2 || "CIDFontType0C" === r2 ? new CFFFont(t2, i2) : new Type1Font(e2, t2, i2);
          adjustWidths(i2);
          g2 = this.convert(e2, a3, i2);
          break;
        case "OpenType":
        case "TrueType":
        case "CIDFontType2":
          this.mimetype = "font/opentype";
          g2 = this.checkAndRepair(e2, t2, i2);
          if (this.isOpenType) {
            adjustWidths(i2);
            s2 = "OpenType";
          }
          break;
        default:
          throw new FormatError(`Font ${s2} is not supported`);
      }
    } catch (e3) {
      warn(e3);
      this.fallbackToSystemFont(i2);
      return;
    }
    amendFallbackToUnicode(i2);
    this.data = g2;
    this.type = s2;
    this.subtype = r2;
    this.fontMatrix = i2.fontMatrix;
    this.widths = i2.widths;
    this.defaultWidth = i2.defaultWidth;
    this.toUnicode = i2.toUnicode;
    this.seacMap = i2.seacMap;
  }
  get renderer() {
    return shadow(this, "renderer", FontRendererFactory.create(this, Ti));
  }
  exportData(e2 = false) {
    const t2 = e2 ? [...da, ...fa] : da, i2 = /* @__PURE__ */ Object.create(null);
    let a2, s2;
    for (a2 of t2) {
      s2 = this[a2];
      void 0 !== s2 && (i2[a2] = s2);
    }
    return i2;
  }
  fallbackToSystemFont(e2) {
    this.missingFile = true;
    const { name: t2, type: i2 } = this;
    let a2 = normalizeFontName(t2);
    const s2 = Zi(), r2 = zi(), n2 = !!s2[a2], g2 = !(!r2[a2] || !s2[r2[a2]]);
    a2 = s2[a2] || r2[a2] || a2;
    const o2 = sa()[a2];
    if (o2) {
      isNaN(this.ascent) && (this.ascent = o2.ascent / ua);
      isNaN(this.descent) && (this.descent = o2.descent / ua);
      isNaN(this.capHeight) && (this.capHeight = o2.capHeight / ua);
    }
    this.bold = /bold/gi.test(a2);
    this.italic = /oblique|italic/gi.test(a2);
    this.black = /Black/g.test(t2);
    const c2 = /Narrow/g.test(t2);
    this.remeasure = (!n2 || c2) && Object.keys(this.widths).length > 0;
    if ((n2 || g2) && "CIDFontType2" === i2 && this.cidEncoding.startsWith("Identity-")) {
      const i3 = e2.cidToGidMap, a3 = [];
      applyStandardFontGlyphMap(a3, Aa());
      /Arial-?Black/i.test(t2) ? applyStandardFontGlyphMap(a3, ea()) : /Calibri/i.test(t2) && applyStandardFontGlyphMap(a3, ta());
      if (i3) {
        for (const e3 in a3) {
          const t3 = a3[e3];
          void 0 !== i3[t3] && (a3[+e3] = i3[t3]);
        }
        i3.length !== this.toUnicode.length && e2.hasIncludedToUnicodeMap && this.toUnicode instanceof IdentityToUnicodeMap && this.toUnicode.forEach(function(e3, t3) {
          const s3 = a3[e3];
          void 0 === i3[s3] && (a3[+e3] = t3);
        });
      }
      this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(e3, t3) {
        a3[+e3] = t3;
      });
      this.toFontChar = a3;
      this.toUnicode = new ToUnicodeMap(a3);
    } else if (/Symbol/i.test(a2))
      this.toFontChar = buildToFontChar(Di, Mi(), this.differences);
    else if (/Dingbats/i.test(a2))
      this.toFontChar = buildToFontChar(bi, Hi(), this.differences);
    else if (n2) {
      const e3 = buildToFontChar(this.defaultEncoding, Mi(), this.differences);
      "CIDFontType2" !== i2 || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(t3, i3) {
        e3[+t3] = i3;
      });
      this.toFontChar = e3;
    } else {
      const e3 = Mi(), i3 = [];
      this.toUnicode.forEach((t3, a3) => {
        if (!this.composite) {
          const i4 = getUnicodeForGlyph(this.differences[t3] || this.defaultEncoding[t3], e3);
          -1 !== i4 && (a3 = i4);
        }
        i3[+t3] = a3;
      });
      this.composite && this.toUnicode instanceof IdentityToUnicodeMap && /Tahoma|Verdana/i.test(t2) && applyStandardFontGlyphMap(i3, Aa());
      this.toFontChar = i3;
    }
    amendFallbackToUnicode(e2);
    this.loadedName = a2.split("-", 1)[0];
  }
  checkAndRepair(e2, t2, i2) {
    var _a4, _b2, _c2;
    const a2 = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
    function readTables(e3, t3) {
      const i3 = /* @__PURE__ */ Object.create(null);
      i3["OS/2"] = null;
      i3.cmap = null;
      i3.head = null;
      i3.hhea = null;
      i3.hmtx = null;
      i3.maxp = null;
      i3.name = null;
      i3.post = null;
      for (let s3 = 0; s3 < t3; s3++) {
        const t4 = readTableEntry(e3);
        a2.includes(t4.tag) && (0 !== t4.length && (i3[t4.tag] = t4));
      }
      return i3;
    }
    function readTableEntry(e3) {
      const t3 = e3.getString(4), i3 = e3.getInt32() >>> 0, a3 = e3.getInt32() >>> 0, s3 = e3.getInt32() >>> 0, r3 = e3.pos;
      e3.pos = e3.start || 0;
      e3.skip(a3);
      const n3 = e3.getBytes(s3);
      e3.pos = r3;
      if ("head" === t3) {
        n3[8] = n3[9] = n3[10] = n3[11] = 0;
        n3[17] |= 32;
      }
      return { tag: t3, checksum: i3, length: s3, offset: a3, data: n3 };
    }
    function readOpenTypeHeader(e3) {
      return { version: e3.getString(4), numTables: e3.getUint16(), searchRange: e3.getUint16(), entrySelector: e3.getUint16(), rangeShift: e3.getUint16() };
    }
    function sanitizeGlyph(e3, t3, i3, a3, s3, r3) {
      const n3 = { length: 0, sizeOfInstructions: 0 };
      if (t3 < 0 || t3 >= e3.length || i3 > e3.length || i3 - t3 <= 12)
        return n3;
      const g3 = e3.subarray(t3, i3), o3 = signedInt16(g3[2], g3[3]), c3 = signedInt16(g3[4], g3[5]), C3 = signedInt16(g3[6], g3[7]), h3 = signedInt16(g3[8], g3[9]);
      if (o3 > C3) {
        writeSignedInt16(g3, 2, C3);
        writeSignedInt16(g3, 6, o3);
      }
      if (c3 > h3) {
        writeSignedInt16(g3, 4, h3);
        writeSignedInt16(g3, 8, c3);
      }
      const l3 = signedInt16(g3[0], g3[1]);
      if (l3 < 0) {
        if (l3 < -1)
          return n3;
        a3.set(g3, s3);
        n3.length = g3.length;
        return n3;
      }
      let Q3, E3 = 10, u3 = 0;
      for (Q3 = 0; Q3 < l3; Q3++) {
        u3 = (g3[E3] << 8 | g3[E3 + 1]) + 1;
        E3 += 2;
      }
      const d3 = E3, f3 = g3[E3] << 8 | g3[E3 + 1];
      n3.sizeOfInstructions = f3;
      E3 += 2 + f3;
      const p3 = E3;
      let m3 = 0;
      for (Q3 = 0; Q3 < u3; Q3++) {
        const e4 = g3[E3++];
        192 & e4 && (g3[E3 - 1] = 63 & e4);
        let t4 = 2;
        2 & e4 ? t4 = 1 : 16 & e4 && (t4 = 0);
        let i4 = 2;
        4 & e4 ? i4 = 1 : 32 & e4 && (i4 = 0);
        const a4 = t4 + i4;
        m3 += a4;
        if (8 & e4) {
          const e5 = g3[E3++];
          0 === e5 && (g3[E3 - 1] ^= 8);
          Q3 += e5;
          m3 += e5 * a4;
        }
      }
      if (0 === m3)
        return n3;
      let y3 = E3 + m3;
      if (y3 > g3.length)
        return n3;
      if (!r3 && f3 > 0) {
        a3.set(g3.subarray(0, d3), s3);
        a3.set([0, 0], s3 + d3);
        a3.set(g3.subarray(p3, y3), s3 + d3 + 2);
        y3 -= f3;
        g3.length - y3 > 3 && (y3 = y3 + 3 & -4);
        n3.length = y3;
        return n3;
      }
      if (g3.length - y3 > 3) {
        y3 = y3 + 3 & -4;
        a3.set(g3.subarray(0, y3), s3);
        n3.length = y3;
        return n3;
      }
      a3.set(g3, s3);
      n3.length = g3.length;
      return n3;
    }
    function readNameTable(e3) {
      const i3 = (t2.start || 0) + e3.offset;
      t2.pos = i3;
      const a3 = [[], []], s3 = [], r3 = e3.length, n3 = i3 + r3;
      if (0 !== t2.getUint16() || r3 < 6)
        return [a3, s3];
      const g3 = t2.getUint16(), o3 = t2.getUint16();
      let c3, C3;
      for (c3 = 0; c3 < g3 && t2.pos + 12 <= n3; c3++) {
        const e4 = { platform: t2.getUint16(), encoding: t2.getUint16(), language: t2.getUint16(), name: t2.getUint16(), length: t2.getUint16(), offset: t2.getUint16() };
        (isMacNameRecord(e4) || isWinNameRecord(e4)) && s3.push(e4);
      }
      for (c3 = 0, C3 = s3.length; c3 < C3; c3++) {
        const e4 = s3[c3];
        if (e4.length <= 0)
          continue;
        const r4 = i3 + o3 + e4.offset;
        if (r4 + e4.length > n3)
          continue;
        t2.pos = r4;
        const g4 = e4.name;
        if (e4.encoding) {
          let i4 = "";
          for (let a4 = 0, s4 = e4.length; a4 < s4; a4 += 2)
            i4 += String.fromCharCode(t2.getUint16());
          a3[1][g4] = i4;
        } else
          a3[0][g4] = t2.getString(e4.length);
      }
      return [a3, s3];
    }
    const s2 = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
    function sanitizeTTProgram(e3, t3) {
      let i3, a3, r3, n3, g3, o3 = e3.data, c3 = 0, C3 = 0, h3 = 0;
      const l3 = [], Q3 = [], E3 = [];
      let u3 = t3.tooComplexToFollowFunctions, d3 = false, f3 = 0, p3 = 0;
      for (let e4 = o3.length; c3 < e4; ) {
        const e5 = o3[c3++];
        if (64 === e5) {
          a3 = o3[c3++];
          if (d3 || p3)
            c3 += a3;
          else
            for (i3 = 0; i3 < a3; i3++)
              l3.push(o3[c3++]);
        } else if (65 === e5) {
          a3 = o3[c3++];
          if (d3 || p3)
            c3 += 2 * a3;
          else
            for (i3 = 0; i3 < a3; i3++) {
              r3 = o3[c3++];
              l3.push(r3 << 8 | o3[c3++]);
            }
        } else if (176 == (248 & e5)) {
          a3 = e5 - 176 + 1;
          if (d3 || p3)
            c3 += a3;
          else
            for (i3 = 0; i3 < a3; i3++)
              l3.push(o3[c3++]);
        } else if (184 == (248 & e5)) {
          a3 = e5 - 184 + 1;
          if (d3 || p3)
            c3 += 2 * a3;
          else
            for (i3 = 0; i3 < a3; i3++) {
              r3 = o3[c3++];
              l3.push(r3 << 8 | o3[c3++]);
            }
        } else if (43 !== e5 || u3)
          if (44 !== e5 || u3) {
            if (45 === e5)
              if (d3) {
                d3 = false;
                C3 = c3;
              } else {
                g3 = Q3.pop();
                if (!g3) {
                  warn("TT: ENDF bad stack");
                  t3.hintsValid = false;
                  return;
                }
                n3 = E3.pop();
                o3 = g3.data;
                c3 = g3.i;
                t3.functionsStackDeltas[n3] = l3.length - g3.stackTop;
              }
            else if (137 === e5) {
              if (d3 || p3) {
                warn("TT: nested IDEFs not allowed");
                u3 = true;
              }
              d3 = true;
              h3 = c3;
            } else if (88 === e5)
              ++f3;
            else if (27 === e5)
              p3 = f3;
            else if (89 === e5) {
              p3 === f3 && (p3 = 0);
              --f3;
            } else if (28 === e5 && !d3 && !p3) {
              const e6 = l3.at(-1);
              e6 > 0 && (c3 += e6 - 1);
            }
          } else {
            if (d3 || p3) {
              warn("TT: nested FDEFs not allowed");
              u3 = true;
            }
            d3 = true;
            h3 = c3;
            n3 = l3.pop();
            t3.functionsDefined[n3] = { data: o3, i: c3 };
          }
        else if (!d3 && !p3) {
          n3 = l3.at(-1);
          if (isNaN(n3))
            info("TT: CALL empty stack (or invalid entry).");
          else {
            t3.functionsUsed[n3] = true;
            if (n3 in t3.functionsStackDeltas) {
              const e6 = l3.length + t3.functionsStackDeltas[n3];
              if (e6 < 0) {
                warn("TT: CALL invalid functions stack delta.");
                t3.hintsValid = false;
                return;
              }
              l3.length = e6;
            } else if (n3 in t3.functionsDefined && !E3.includes(n3)) {
              Q3.push({ data: o3, i: c3, stackTop: l3.length - 1 });
              E3.push(n3);
              g3 = t3.functionsDefined[n3];
              if (!g3) {
                warn("TT: CALL non-existent function");
                t3.hintsValid = false;
                return;
              }
              o3 = g3.data;
              c3 = g3.i;
            }
          }
        }
        if (!d3 && !p3) {
          let t4 = 0;
          e5 <= 142 ? t4 = s2[e5] : e5 >= 192 && e5 <= 223 ? t4 = -1 : e5 >= 224 && (t4 = -2);
          if (e5 >= 113 && e5 <= 117) {
            a3 = l3.pop();
            isNaN(a3) || (t4 = 2 * -a3);
          }
          for (; t4 < 0 && l3.length > 0; ) {
            l3.pop();
            t4++;
          }
          for (; t4 > 0; ) {
            l3.push(NaN);
            t4--;
          }
        }
      }
      t3.tooComplexToFollowFunctions = u3;
      const m3 = [o3];
      c3 > o3.length && m3.push(new Uint8Array(c3 - o3.length));
      if (h3 > C3) {
        warn("TT: complementing a missing function tail");
        m3.push(new Uint8Array([34, 45]));
      }
      !function foldTTTable(e4, t4) {
        if (t4.length > 1) {
          let i4, a4, s3 = 0;
          for (i4 = 0, a4 = t4.length; i4 < a4; i4++)
            s3 += t4[i4].length;
          s3 = s3 + 3 & -4;
          const r4 = new Uint8Array(s3);
          let n4 = 0;
          for (i4 = 0, a4 = t4.length; i4 < a4; i4++) {
            r4.set(t4[i4], n4);
            n4 += t4[i4].length;
          }
          e4.data = r4;
          e4.length = s3;
        }
      }(e3, m3);
    }
    let r2, n2, g2, o2;
    if (isTrueTypeCollectionFile(t2 = new Stream(new Uint8Array(t2.getBytes())))) {
      const e3 = function readTrueTypeCollectionData(e4, t3) {
        var _a5;
        const { numFonts: i3, offsetTable: a3 } = function readTrueTypeCollectionHeader(e5) {
          const t4 = e5.getString(4);
          assert("ttcf" === t4, "Must be a TrueType Collection font.");
          const i4 = e5.getUint16(), a4 = e5.getUint16(), s4 = e5.getInt32() >>> 0, r4 = [];
          for (let t5 = 0; t5 < s4; t5++)
            r4.push(e5.getInt32() >>> 0);
          const n3 = { ttcTag: t4, majorVersion: i4, minorVersion: a4, numFonts: s4, offsetTable: r4 };
          switch (i4) {
            case 1:
              return n3;
            case 2:
              n3.dsigTag = e5.getInt32() >>> 0;
              n3.dsigLength = e5.getInt32() >>> 0;
              n3.dsigOffset = e5.getInt32() >>> 0;
              return n3;
          }
          throw new FormatError(`Invalid TrueType Collection majorVersion: ${i4}.`);
        }(e4), s3 = t3.split("+");
        let r3;
        for (let n3 = 0; n3 < i3; n3++) {
          e4.pos = (e4.start || 0) + a3[n3];
          const i4 = readOpenTypeHeader(e4), g3 = readTables(e4, i4.numTables);
          if (!g3.name)
            throw new FormatError('TrueType Collection font must contain a "name" table.');
          const [o3] = readNameTable(g3.name);
          for (let e5 = 0, a4 = o3.length; e5 < a4; e5++)
            for (let a5 = 0, n4 = o3[e5].length; a5 < n4; a5++) {
              const n5 = (_a5 = o3[e5][a5]) == null ? void 0 : _a5.replaceAll(/\s/g, "");
              if (n5) {
                if (n5 === t3)
                  return { header: i4, tables: g3 };
                if (!(s3.length < 2))
                  for (const e6 of s3)
                    n5 === e6 && (r3 = { name: e6, header: i4, tables: g3 });
              }
            }
        }
        if (r3) {
          warn(`TrueType Collection does not contain "${t3}" font, falling back to "${r3.name}" font instead.`);
          return { header: r3.header, tables: r3.tables };
        }
        throw new FormatError(`TrueType Collection does not contain "${t3}" font.`);
      }(t2, this.name);
      r2 = e3.header;
      n2 = e3.tables;
    } else {
      r2 = readOpenTypeHeader(t2);
      n2 = readTables(t2, r2.numTables);
    }
    const c2 = !n2["CFF "];
    if (c2) {
      if (!n2.loca)
        throw new FormatError('Required "loca" table is not found');
      if (!n2.glyf) {
        warn('Required "glyf" table is not found -- trying to recover.');
        n2.glyf = { tag: "glyf", data: new Uint8Array(0) };
      }
      this.isOpenType = false;
    } else {
      const t3 = i2.composite && (((_a4 = i2.cidToGidMap) == null ? void 0 : _a4.length) > 0 || !(i2.cMap instanceof IdentityCMap));
      if ("OTTO" === r2.version && !t3 || !n2.head || !n2.hhea || !n2.maxp || !n2.post) {
        o2 = new Stream(n2["CFF "].data);
        g2 = new CFFFont(o2, i2);
        adjustWidths(i2);
        return this.convert(e2, g2, i2);
      }
      delete n2.glyf;
      delete n2.loca;
      delete n2.fpgm;
      delete n2.prep;
      delete n2["cvt "];
      this.isOpenType = true;
    }
    if (!n2.maxp)
      throw new FormatError('Required "maxp" table is not found');
    t2.pos = (t2.start || 0) + n2.maxp.offset;
    let C2 = t2.getInt32();
    const h2 = t2.getUint16();
    if (65536 !== C2 && 20480 !== C2) {
      if (6 === n2.maxp.length)
        C2 = 20480;
      else {
        if (!(n2.maxp.length >= 32))
          throw new FormatError('"maxp" table has a wrong version number');
        C2 = 65536;
      }
      !function writeUint32(e3, t3, i3) {
        e3[t3 + 3] = 255 & i3;
        e3[t3 + 2] = i3 >>> 8;
        e3[t3 + 1] = i3 >>> 16;
        e3[t3] = i3 >>> 24;
      }(n2.maxp.data, 0, C2);
    }
    if (((_b2 = i2.scaleFactors) == null ? void 0 : _b2.length) === h2 && c2) {
      const { scaleFactors: e3 } = i2, t3 = int16(n2.head.data[50], n2.head.data[51]), a3 = new GlyfTable({ glyfTable: n2.glyf.data, isGlyphLocationsLong: t3, locaTable: n2.loca.data, numGlyphs: h2 });
      a3.scale(e3);
      const { glyf: s3, loca: r3, isLocationLong: g3 } = a3.write();
      n2.glyf.data = s3;
      n2.loca.data = r3;
      if (g3 !== !!t3) {
        n2.head.data[50] = 0;
        n2.head.data[51] = g3 ? 1 : 0;
      }
      const o3 = n2.hmtx.data;
      for (let t4 = 0; t4 < h2; t4++) {
        const i3 = 4 * t4, a4 = Math.round(e3[t4] * int16(o3[i3], o3[i3 + 1]));
        o3[i3] = a4 >> 8 & 255;
        o3[i3 + 1] = 255 & a4;
        writeSignedInt16(o3, i3 + 2, Math.round(e3[t4] * signedInt16(o3[i3 + 2], o3[i3 + 3])));
      }
    }
    let l2 = h2 + 1, Q2 = true;
    if (l2 > 65535) {
      Q2 = false;
      l2 = h2;
      warn("Not enough space in glyfs to duplicate first glyph.");
    }
    let E2 = 0, u2 = 0;
    if (C2 >= 65536 && n2.maxp.length >= 32) {
      t2.pos += 8;
      if (t2.getUint16() > 2) {
        n2.maxp.data[14] = 0;
        n2.maxp.data[15] = 2;
      }
      t2.pos += 4;
      E2 = t2.getUint16();
      t2.pos += 4;
      u2 = t2.getUint16();
    }
    n2.maxp.data[4] = l2 >> 8;
    n2.maxp.data[5] = 255 & l2;
    const d2 = function sanitizeTTPrograms(e3, t3, i3, a3) {
      const s3 = { functionsDefined: [], functionsUsed: [], functionsStackDeltas: [], tooComplexToFollowFunctions: false, hintsValid: true };
      e3 && sanitizeTTProgram(e3, s3);
      t3 && sanitizeTTProgram(t3, s3);
      e3 && function checkInvalidFunctions(e4, t4) {
        if (!e4.tooComplexToFollowFunctions)
          if (e4.functionsDefined.length > t4) {
            warn("TT: more functions defined than expected");
            e4.hintsValid = false;
          } else
            for (let i4 = 0, a4 = e4.functionsUsed.length; i4 < a4; i4++) {
              if (i4 > t4) {
                warn("TT: invalid function id: " + i4);
                e4.hintsValid = false;
                return;
              }
              if (e4.functionsUsed[i4] && !e4.functionsDefined[i4]) {
                warn("TT: undefined function: " + i4);
                e4.hintsValid = false;
                return;
              }
            }
      }(s3, a3);
      if (i3 && 1 & i3.length) {
        const e4 = new Uint8Array(i3.length + 1);
        e4.set(i3.data);
        i3.data = e4;
      }
      return s3.hintsValid;
    }(n2.fpgm, n2.prep, n2["cvt "], E2);
    if (!d2) {
      delete n2.fpgm;
      delete n2.prep;
      delete n2["cvt "];
    }
    !function sanitizeMetrics(e3, t3, i3, a3, s3, r3) {
      if (!t3) {
        i3 && (i3.data = null);
        return;
      }
      e3.pos = (e3.start || 0) + t3.offset;
      e3.pos += 4;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      const n3 = e3.getUint16();
      e3.pos += 8;
      e3.pos += 2;
      let g3 = e3.getUint16();
      if (0 !== n3) {
        if (!(2 & int16(a3.data[44], a3.data[45]))) {
          t3.data[22] = 0;
          t3.data[23] = 0;
        }
      }
      if (g3 > s3) {
        info(`The numOfMetrics (${g3}) should not be greater than the numGlyphs (${s3}).`);
        g3 = s3;
        t3.data[34] = (65280 & g3) >> 8;
        t3.data[35] = 255 & g3;
      }
      const o3 = s3 - g3 - (i3.length - 4 * g3 >> 1);
      if (o3 > 0) {
        const e4 = new Uint8Array(i3.length + 2 * o3);
        e4.set(i3.data);
        if (r3) {
          e4[i3.length] = i3.data[2];
          e4[i3.length + 1] = i3.data[3];
        }
        i3.data = e4;
      }
    }(t2, n2.hhea, n2.hmtx, n2.head, l2, Q2);
    if (!n2.head)
      throw new FormatError('Required "head" table is not found');
    !function sanitizeHead(e3, t3, i3) {
      const a3 = e3.data, s3 = function int32(e4, t4, i4, a4) {
        return (e4 << 24) + (t4 << 16) + (i4 << 8) + a4;
      }(a3[0], a3[1], a3[2], a3[3]);
      if (s3 >> 16 != 1) {
        info("Attempting to fix invalid version in head table: " + s3);
        a3[0] = 0;
        a3[1] = 1;
        a3[2] = 0;
        a3[3] = 0;
      }
      const r3 = int16(a3[50], a3[51]);
      if (r3 < 0 || r3 > 1) {
        info("Attempting to fix invalid indexToLocFormat in head table: " + r3);
        const e4 = t3 + 1;
        if (i3 === e4 << 1) {
          a3[50] = 0;
          a3[51] = 0;
        } else {
          if (i3 !== e4 << 2)
            throw new FormatError("Could not fix indexToLocFormat: " + r3);
          a3[50] = 0;
          a3[51] = 1;
        }
      }
    }(n2.head, h2, c2 ? n2.loca.length : 0);
    let f2 = /* @__PURE__ */ Object.create(null);
    if (c2) {
      const e3 = int16(n2.head.data[50], n2.head.data[51]), t3 = function sanitizeGlyphLocations(e4, t4, i3, a3, s3, r3, n3) {
        let g3, o3, c3;
        if (a3) {
          g3 = 4;
          o3 = function fontItemDecodeLong(e5, t5) {
            return e5[t5] << 24 | e5[t5 + 1] << 16 | e5[t5 + 2] << 8 | e5[t5 + 3];
          };
          c3 = function fontItemEncodeLong(e5, t5, i4) {
            e5[t5] = i4 >>> 24 & 255;
            e5[t5 + 1] = i4 >> 16 & 255;
            e5[t5 + 2] = i4 >> 8 & 255;
            e5[t5 + 3] = 255 & i4;
          };
        } else {
          g3 = 2;
          o3 = function fontItemDecode(e5, t5) {
            return e5[t5] << 9 | e5[t5 + 1] << 1;
          };
          c3 = function fontItemEncode(e5, t5, i4) {
            e5[t5] = i4 >> 9 & 255;
            e5[t5 + 1] = i4 >> 1 & 255;
          };
        }
        const C3 = r3 ? i3 + 1 : i3, h3 = g3 * (1 + C3), l3 = new Uint8Array(h3);
        l3.set(e4.data.subarray(0, h3));
        e4.data = l3;
        const Q3 = t4.data, E3 = Q3.length, u3 = new Uint8Array(E3);
        let d3, f3;
        const p3 = [];
        for (d3 = 0, f3 = 0; d3 < i3 + 1; d3++, f3 += g3) {
          let e5 = o3(l3, f3);
          e5 > E3 && (e5 = E3);
          p3.push({ index: d3, offset: e5, endOffset: 0 });
        }
        p3.sort((e5, t5) => e5.offset - t5.offset);
        for (d3 = 0; d3 < i3; d3++)
          p3[d3].endOffset = p3[d3 + 1].offset;
        p3.sort((e5, t5) => e5.index - t5.index);
        for (d3 = 0; d3 < i3; d3++) {
          const { offset: e5, endOffset: t5 } = p3[d3];
          if (0 !== e5 || 0 !== t5)
            break;
          const i4 = p3[d3 + 1].offset;
          if (0 !== i4) {
            p3[d3].endOffset = i4;
            break;
          }
        }
        const m3 = p3.at(-2);
        0 !== m3.offset && 0 === m3.endOffset && (m3.endOffset = E3);
        const y3 = /* @__PURE__ */ Object.create(null);
        let w3 = 0;
        c3(l3, 0, w3);
        for (d3 = 0, f3 = g3; d3 < i3; d3++, f3 += g3) {
          const e5 = sanitizeGlyph(Q3, p3[d3].offset, p3[d3].endOffset, u3, w3, s3), t5 = e5.length;
          0 === t5 && (y3[d3] = true);
          e5.sizeOfInstructions > n3 && (n3 = e5.sizeOfInstructions);
          w3 += t5;
          c3(l3, f3, w3);
        }
        if (0 === w3) {
          const e5 = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
          for (d3 = 0, f3 = g3; d3 < C3; d3++, f3 += g3)
            c3(l3, f3, e5.length);
          t4.data = e5;
        } else if (r3) {
          const i4 = o3(l3, g3);
          if (u3.length > i4 + w3)
            t4.data = u3.subarray(0, i4 + w3);
          else {
            t4.data = new Uint8Array(i4 + w3);
            t4.data.set(u3.subarray(0, w3));
          }
          t4.data.set(u3.subarray(0, i4), w3);
          c3(e4.data, l3.length - g3, w3 + i4);
        } else
          t4.data = u3.subarray(0, w3);
        return { missingGlyphs: y3, maxSizeOfInstructions: n3 };
      }(n2.loca, n2.glyf, h2, e3, d2, Q2, u2);
      f2 = t3.missingGlyphs;
      if (C2 >= 65536 && n2.maxp.length >= 32) {
        n2.maxp.data[26] = t3.maxSizeOfInstructions >> 8;
        n2.maxp.data[27] = 255 & t3.maxSizeOfInstructions;
      }
    }
    if (!n2.hhea)
      throw new FormatError('Required "hhea" table is not found');
    if (0 === n2.hhea.data[10] && 0 === n2.hhea.data[11]) {
      n2.hhea.data[10] = 255;
      n2.hhea.data[11] = 255;
    }
    const p2 = { unitsPerEm: int16(n2.head.data[18], n2.head.data[19]), yMax: signedInt16(n2.head.data[42], n2.head.data[43]), yMin: signedInt16(n2.head.data[38], n2.head.data[39]), ascent: signedInt16(n2.hhea.data[4], n2.hhea.data[5]), descent: signedInt16(n2.hhea.data[6], n2.hhea.data[7]), lineGap: signedInt16(n2.hhea.data[8], n2.hhea.data[9]) };
    this.ascent = p2.ascent / p2.unitsPerEm;
    this.descent = p2.descent / p2.unitsPerEm;
    this.lineGap = p2.lineGap / p2.unitsPerEm;
    if ((_c2 = this.cssFontInfo) == null ? void 0 : _c2.lineHeight) {
      this.lineHeight = this.cssFontInfo.metrics.lineHeight;
      this.lineGap = this.cssFontInfo.metrics.lineGap;
    } else
      this.lineHeight = this.ascent - this.descent + this.lineGap;
    n2.post && function readPostScriptTable(e3, i3, a3) {
      const s3 = (t2.start || 0) + e3.offset;
      t2.pos = s3;
      const r3 = s3 + e3.length, n3 = t2.getInt32();
      t2.skip(28);
      let g3, o3, c3 = true;
      switch (n3) {
        case 65536:
          g3 = ji;
          break;
        case 131072:
          const e4 = t2.getUint16();
          if (e4 !== a3) {
            c3 = false;
            break;
          }
          const s4 = [];
          for (o3 = 0; o3 < e4; ++o3) {
            const e5 = t2.getUint16();
            if (e5 >= 32768) {
              c3 = false;
              break;
            }
            s4.push(e5);
          }
          if (!c3)
            break;
          const C3 = [], h3 = [];
          for (; t2.pos < r3; ) {
            const e5 = t2.getByte();
            h3.length = e5;
            for (o3 = 0; o3 < e5; ++o3)
              h3[o3] = String.fromCharCode(t2.getByte());
            C3.push(h3.join(""));
          }
          g3 = [];
          for (o3 = 0; o3 < e4; ++o3) {
            const e5 = s4[o3];
            e5 < 258 ? g3.push(ji[e5]) : g3.push(C3[e5 - 258]);
          }
          break;
        case 196608:
          break;
        default:
          warn("Unknown/unsupported post table version " + n3);
          c3 = false;
          i3.defaultEncoding && (g3 = i3.defaultEncoding);
      }
      i3.glyphNames = g3;
      return c3;
    }(n2.post, i2, h2);
    n2.post = { tag: "post", data: createPostTable(i2) };
    const m2 = /* @__PURE__ */ Object.create(null);
    function hasGlyph(e3) {
      return !f2[e3];
    }
    if (i2.composite) {
      const e3 = i2.cidToGidMap || [], t3 = 0 === e3.length;
      i2.cMap.forEach(function(i3, a3) {
        "string" == typeof a3 && (a3 = convertCidString(i3, a3, true));
        if (a3 > 65535)
          throw new FormatError("Max size of CID is 65,535");
        let s3 = -1;
        t3 ? s3 = a3 : void 0 !== e3[a3] && (s3 = e3[a3]);
        s3 >= 0 && s3 < h2 && hasGlyph(s3) && (m2[i3] = s3);
      });
    } else {
      const e3 = function readCmapTable(e4, t3, i3, a4) {
        if (!e4) {
          warn("No cmap table available.");
          return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
        }
        let s4, r4 = (t3.start || 0) + e4.offset;
        t3.pos = r4;
        t3.skip(2);
        const n3 = t3.getUint16();
        let g4, o4 = false;
        for (let e5 = 0; e5 < n3; e5++) {
          const s5 = t3.getUint16(), r5 = t3.getUint16(), c4 = t3.getInt32() >>> 0;
          let C4 = false;
          if ((g4 == null ? void 0 : g4.platformId) !== s5 || (g4 == null ? void 0 : g4.encodingId) !== r5) {
            if (0 !== s5 || 0 !== r5 && 1 !== r5 && 3 !== r5)
              if (1 === s5 && 0 === r5)
                C4 = true;
              else if (3 !== s5 || 1 !== r5 || !a4 && g4) {
                if (i3 && 3 === s5 && 0 === r5) {
                  C4 = true;
                  let i4 = true;
                  if (e5 < n3 - 1) {
                    const e6 = t3.peekBytes(2);
                    int16(e6[0], e6[1]) < s5 && (i4 = false);
                  }
                  i4 && (o4 = true);
                }
              } else {
                C4 = true;
                i3 || (o4 = true);
              }
            else
              C4 = true;
            C4 && (g4 = { platformId: s5, encodingId: r5, offset: c4 });
            if (o4)
              break;
          }
        }
        g4 && (t3.pos = r4 + g4.offset);
        if (!g4 || -1 === t3.peekByte()) {
          warn("Could not find a preferred cmap table.");
          return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
        }
        const c3 = t3.getUint16();
        let C3 = false;
        const h3 = [];
        let l3, Q3;
        if (0 === c3) {
          t3.skip(4);
          for (l3 = 0; l3 < 256; l3++) {
            const e5 = t3.getByte();
            e5 && h3.push({ charCode: l3, glyphId: e5 });
          }
          C3 = true;
        } else if (2 === c3) {
          t3.skip(4);
          const e5 = [];
          let i4 = 0;
          for (let a6 = 0; a6 < 256; a6++) {
            const a7 = t3.getUint16() >> 3;
            e5.push(a7);
            i4 = Math.max(a7, i4);
          }
          const a5 = [];
          for (let e6 = 0; e6 <= i4; e6++)
            a5.push({ firstCode: t3.getUint16(), entryCount: t3.getUint16(), idDelta: signedInt16(t3.getByte(), t3.getByte()), idRangePos: t3.pos + t3.getUint16() });
          for (let i5 = 0; i5 < 256; i5++)
            if (0 === e5[i5]) {
              t3.pos = a5[0].idRangePos + 2 * i5;
              Q3 = t3.getUint16();
              h3.push({ charCode: i5, glyphId: Q3 });
            } else {
              const s5 = a5[e5[i5]];
              for (l3 = 0; l3 < s5.entryCount; l3++) {
                const e6 = (i5 << 8) + l3 + s5.firstCode;
                t3.pos = s5.idRangePos + 2 * l3;
                Q3 = t3.getUint16();
                0 !== Q3 && (Q3 = (Q3 + s5.idDelta) % 65536);
                h3.push({ charCode: e6, glyphId: Q3 });
              }
            }
        } else if (4 === c3) {
          t3.skip(4);
          const e5 = t3.getUint16() >> 1;
          t3.skip(6);
          const i4 = [];
          let a5;
          for (a5 = 0; a5 < e5; a5++)
            i4.push({ end: t3.getUint16() });
          t3.skip(2);
          for (a5 = 0; a5 < e5; a5++)
            i4[a5].start = t3.getUint16();
          for (a5 = 0; a5 < e5; a5++)
            i4[a5].delta = t3.getUint16();
          let n4, g5 = 0;
          for (a5 = 0; a5 < e5; a5++) {
            s4 = i4[a5];
            const r5 = t3.getUint16();
            if (r5) {
              n4 = (r5 >> 1) - (e5 - a5);
              s4.offsetIndex = n4;
              g5 = Math.max(g5, n4 + s4.end - s4.start + 1);
            } else
              s4.offsetIndex = -1;
          }
          const o5 = [];
          for (l3 = 0; l3 < g5; l3++)
            o5.push(t3.getUint16());
          for (a5 = 0; a5 < e5; a5++) {
            s4 = i4[a5];
            r4 = s4.start;
            const e6 = s4.end, t4 = s4.delta;
            n4 = s4.offsetIndex;
            for (l3 = r4; l3 <= e6; l3++)
              if (65535 !== l3) {
                Q3 = n4 < 0 ? l3 : o5[n4 + l3 - r4];
                Q3 = Q3 + t4 & 65535;
                h3.push({ charCode: l3, glyphId: Q3 });
              }
          }
        } else if (6 === c3) {
          t3.skip(4);
          const e5 = t3.getUint16(), i4 = t3.getUint16();
          for (l3 = 0; l3 < i4; l3++) {
            Q3 = t3.getUint16();
            const i5 = e5 + l3;
            h3.push({ charCode: i5, glyphId: Q3 });
          }
        } else {
          if (12 !== c3) {
            warn("cmap table has unsupported format: " + c3);
            return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
          }
          {
            t3.skip(10);
            const e5 = t3.getInt32() >>> 0;
            for (l3 = 0; l3 < e5; l3++) {
              const e6 = t3.getInt32() >>> 0, i4 = t3.getInt32() >>> 0;
              let a5 = t3.getInt32() >>> 0;
              for (let t4 = e6; t4 <= i4; t4++)
                h3.push({ charCode: t4, glyphId: a5++ });
            }
          }
        }
        h3.sort(function(e5, t4) {
          return e5.charCode - t4.charCode;
        });
        for (let e5 = 1; e5 < h3.length; e5++)
          if (h3[e5 - 1].charCode === h3[e5].charCode) {
            h3.splice(e5, 1);
            e5--;
          }
        return { platformId: g4.platformId, encodingId: g4.encodingId, mappings: h3, hasShortCmap: C3 };
      }(n2.cmap, t2, this.isSymbolicFont, i2.hasEncoding), a3 = e3.platformId, s3 = e3.encodingId, r3 = e3.mappings;
      let g3 = [], o3 = false;
      !i2.hasEncoding || "MacRomanEncoding" !== i2.baseEncodingName && "WinAnsiEncoding" !== i2.baseEncodingName || (g3 = getEncoding(i2.baseEncodingName));
      if (i2.hasEncoding && !this.isSymbolicFont && (3 === a3 && 1 === s3 || 1 === a3 && 0 === s3)) {
        const e4 = Mi();
        for (let t3 = 0; t3 < 256; t3++) {
          let n3;
          n3 = void 0 !== this.differences[t3] ? this.differences[t3] : g3.length && "" !== g3[t3] ? g3[t3] : yi[t3];
          if (!n3)
            continue;
          const o4 = recoverGlyphName(n3, e4);
          let c3;
          3 === a3 && 1 === s3 ? c3 = e4[o4] : 1 === a3 && 0 === s3 && (c3 = mi.indexOf(o4));
          if (void 0 === c3) {
            if (!i2.glyphNames && i2.hasIncludedToUnicodeMap && !(this.toUnicode instanceof IdentityToUnicodeMap)) {
              const e5 = this.toUnicode.get(t3);
              e5 && (c3 = e5.codePointAt(0));
            }
            if (void 0 === c3)
              continue;
          }
          for (const e5 of r3)
            if (e5.charCode === c3) {
              m2[t3] = e5.glyphId;
              break;
            }
        }
      } else if (0 === a3) {
        for (const e4 of r3)
          m2[e4.charCode] = e4.glyphId;
        o3 = true;
      } else if (3 === a3 && 0 === s3)
        for (const e4 of r3) {
          let t3 = e4.charCode;
          t3 >= 61440 && t3 <= 61695 && (t3 &= 255);
          m2[t3] = e4.glyphId;
        }
      else
        for (const e4 of r3)
          m2[e4.charCode] = e4.glyphId;
      if (i2.glyphNames && (g3.length || this.differences.length))
        for (let e4 = 0; e4 < 256; ++e4) {
          if (!o3 && void 0 !== m2[e4])
            continue;
          const t3 = this.differences[e4] || g3[e4];
          if (!t3)
            continue;
          const a4 = i2.glyphNames.indexOf(t3);
          a4 > 0 && hasGlyph(a4) && (m2[e4] = a4);
        }
    }
    0 === m2.length && (m2[0] = 0);
    let y2 = l2 - 1;
    Q2 || (y2 = 0);
    if (!i2.cssFontInfo) {
      const e3 = adjustMapping(m2, hasGlyph, y2, this.toUnicode);
      this.toFontChar = e3.toFontChar;
      n2.cmap = { tag: "cmap", data: createCmapTable(e3.charCodeToGlyphId, e3.toUnicodeExtraMap, l2) };
      n2["OS/2"] && function validateOS2Table(e4, t3) {
        t3.pos = (t3.start || 0) + e4.offset;
        const i3 = t3.getUint16();
        t3.skip(60);
        const a3 = t3.getUint16();
        if (i3 < 4 && 768 & a3)
          return false;
        if (t3.getUint16() > t3.getUint16())
          return false;
        t3.skip(6);
        if (0 === t3.getUint16())
          return false;
        e4.data[8] = e4.data[9] = 0;
        return true;
      }(n2["OS/2"], t2) || (n2["OS/2"] = { tag: "OS/2", data: createOS2Table(i2, e3.charCodeToGlyphId, p2) });
    }
    if (!c2)
      try {
        o2 = new Stream(n2["CFF "].data);
        g2 = new CFFParser(o2, i2, Ti).parse();
        g2.duplicateFirstGlyph();
        const e3 = new CFFCompiler(g2);
        n2["CFF "].data = e3.compile();
      } catch {
        warn("Failed to compile font " + i2.loadedName);
      }
    if (n2.name) {
      const [t3, a3] = readNameTable(n2.name);
      n2.name.data = createNameTable(e2, t3);
      this.psName = t3[0][6] || null;
      i2.composite || function adjustTrueTypeToUnicode(e3, t4, i3) {
        if (e3.isInternalFont)
          return;
        if (e3.hasIncludedToUnicodeMap)
          return;
        if (e3.hasEncoding)
          return;
        if (e3.toUnicode instanceof IdentityToUnicodeMap)
          return;
        if (!t4)
          return;
        if (0 === i3.length)
          return;
        if (e3.defaultEncoding === wi)
          return;
        for (const e4 of i3)
          if (!isWinNameRecord(e4))
            return;
        const a4 = wi, s3 = [], r3 = Mi();
        for (const e4 in a4) {
          const t5 = a4[e4];
          if ("" === t5)
            continue;
          const i4 = r3[t5];
          void 0 !== i4 && (s3[e4] = String.fromCharCode(i4));
        }
        s3.length > 0 && e3.toUnicode.amend(s3);
      }(i2, this.isSymbolicFont, a3);
    } else
      n2.name = { tag: "name", data: createNameTable(this.name) };
    const w2 = new OpenTypeFileBuilder(r2.version);
    for (const e3 in n2)
      w2.addTable(e3, n2[e3].data);
    return w2.toArray();
  }
  convert(e2, t2, i2) {
    i2.fixedPitch = false;
    i2.builtInEncoding && function adjustType1ToUnicode(e3, t3) {
      if (e3.isInternalFont)
        return;
      if (e3.hasIncludedToUnicodeMap)
        return;
      if (t3 === e3.defaultEncoding)
        return;
      if (e3.toUnicode instanceof IdentityToUnicodeMap)
        return;
      const i3 = [], a2 = Mi();
      for (const s3 in t3) {
        if (e3.hasEncoding && (e3.baseEncodingName || void 0 !== e3.differences[s3]))
          continue;
        const r3 = getUnicodeForGlyph(t3[s3], a2);
        -1 !== r3 && (i3[s3] = String.fromCharCode(r3));
      }
      i3.length > 0 && e3.toUnicode.amend(i3);
    }(i2, i2.builtInEncoding);
    let s2 = 1;
    t2 instanceof CFFFont && (s2 = t2.numGlyphs - 1);
    const r2 = t2.getGlyphMapping(i2);
    let n2 = null, g2 = r2, o2 = null;
    if (!i2.cssFontInfo) {
      n2 = adjustMapping(r2, t2.hasGlyphId.bind(t2), s2, this.toUnicode);
      this.toFontChar = n2.toFontChar;
      g2 = n2.charCodeToGlyphId;
      o2 = n2.toUnicodeExtraMap;
    }
    const c2 = t2.numGlyphs;
    function getCharCodes(e3, t3) {
      let i3 = null;
      for (const a2 in e3)
        t3 === e3[a2] && (i3 || (i3 = [])).push(0 | a2);
      return i3;
    }
    function createCharCode(e3, t3) {
      for (const i3 in e3)
        if (t3 === e3[i3])
          return 0 | i3;
      n2.charCodeToGlyphId[n2.nextAvailableFontCharCode] = t3;
      return n2.nextAvailableFontCharCode++;
    }
    const C2 = t2.seacs;
    if (n2 && (C2 == null ? void 0 : C2.length)) {
      const e3 = i2.fontMatrix || a, s3 = t2.getCharset(), g3 = /* @__PURE__ */ Object.create(null);
      for (let t3 in C2) {
        t3 |= 0;
        const i3 = C2[t3], a2 = yi[i3[2]], o3 = yi[i3[3]], c3 = s3.indexOf(a2), h3 = s3.indexOf(o3);
        if (c3 < 0 || h3 < 0)
          continue;
        const l3 = { x: i3[0] * e3[0] + i3[1] * e3[2] + e3[4], y: i3[0] * e3[1] + i3[1] * e3[3] + e3[5] }, Q2 = getCharCodes(r2, t3);
        if (Q2)
          for (const e4 of Q2) {
            const t4 = n2.charCodeToGlyphId, i4 = createCharCode(t4, c3), a3 = createCharCode(t4, h3);
            g3[e4] = { baseFontCharCode: i4, accentFontCharCode: a3, accentOffset: l3 };
          }
      }
      i2.seacMap = g3;
    }
    const h2 = i2.fontMatrix ? 1 / Math.max(...i2.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3, l2 = new OpenTypeFileBuilder("OTTO");
    l2.addTable("CFF ", t2.data);
    l2.addTable("OS/2", createOS2Table(i2, g2));
    l2.addTable("cmap", createCmapTable(g2, o2, c2));
    l2.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + safeString16(h2) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + safeString16(i2.descent) + "ÿ" + safeString16(i2.ascent) + string16(i2.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0");
    l2.addTable("hhea", "\0\0\0" + safeString16(i2.ascent) + safeString16(i2.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + safeString16(i2.capHeight) + safeString16(Math.tan(i2.italicAngle) * i2.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(c2));
    l2.addTable("hmtx", function fontFieldsHmtx() {
      const e3 = t2.charstrings, i3 = t2.cff ? t2.cff.widths : null;
      let a2 = "\0\0\0\0";
      for (let t3 = 1, s3 = c2; t3 < s3; t3++) {
        let s4 = 0;
        if (e3) {
          const i4 = e3[t3 - 1];
          s4 = "width" in i4 ? i4.width : 0;
        } else
          i3 && (s4 = Math.ceil(i3[t3] || 0));
        a2 += string16(s4) + string16(0);
      }
      return a2;
    }());
    l2.addTable("maxp", "\0\0P\0" + string16(c2));
    l2.addTable("name", createNameTable(e2));
    l2.addTable("post", createPostTable(i2));
    return l2.toArray();
  }
  get _spaceWidth() {
    const e2 = ["space", "minus", "one", "i", "I"];
    let t2;
    for (const i2 of e2) {
      if (i2 in this.widths) {
        t2 = this.widths[i2];
        break;
      }
      const e3 = Mi()[i2];
      let a2 = 0;
      if (this.composite && this.cMap.contains(e3)) {
        a2 = this.cMap.lookup(e3);
        "string" == typeof a2 && (a2 = convertCidString(e3, a2));
      }
      !a2 && this.toUnicode && (a2 = this.toUnicode.charCodeOf(e3));
      a2 <= 0 && (a2 = e3);
      t2 = this.widths[a2];
      if (t2)
        break;
    }
    return shadow(this, "_spaceWidth", t2 || this.defaultWidth);
  }
  _charToGlyph(e2, t2 = false) {
    var _a4, _b2, _c2;
    let i2, a2, s2, r2 = this._glyphCache[e2];
    if ((r2 == null ? void 0 : r2.isSpace) === t2)
      return r2;
    let n2 = e2;
    if ((_a4 = this.cMap) == null ? void 0 : _a4.contains(e2)) {
      n2 = this.cMap.lookup(e2);
      "string" == typeof n2 && (n2 = convertCidString(e2, n2));
    }
    a2 = this.widths[n2];
    "number" != typeof a2 && (a2 = this.defaultWidth);
    const g2 = (_b2 = this.vmetrics) == null ? void 0 : _b2[n2];
    let o2 = this.toUnicode.get(e2) || e2;
    "number" == typeof o2 && (o2 = String.fromCharCode(o2));
    let c2 = void 0 !== this.toFontChar[e2];
    i2 = this.toFontChar[e2] || e2;
    if (this.missingFile) {
      const t3 = this.differences[e2] || this.defaultEncoding[e2];
      if ((".notdef" === t3 || "" === t3) && "Type1" === this.type) {
        i2 = 32;
        if ("" === t3) {
          a2 || (a2 = this._spaceWidth);
          o2 = String.fromCharCode(i2);
        }
      }
      i2 = function mapSpecialUnicodeValues(e3) {
        return e3 >= 65520 && e3 <= 65535 ? 0 : e3 >= 62976 && e3 <= 63743 ? Ji()[e3] || e3 : 173 === e3 ? 45 : e3;
      }(i2);
    }
    this.isType3Font && (s2 = i2);
    let C2 = null;
    if ((_c2 = this.seacMap) == null ? void 0 : _c2[e2]) {
      c2 = true;
      const t3 = this.seacMap[e2];
      i2 = t3.baseFontCharCode;
      C2 = { fontChar: String.fromCodePoint(t3.accentFontCharCode), offset: t3.accentOffset };
    }
    let h2 = "";
    "number" == typeof i2 && (i2 <= 1114111 ? h2 = String.fromCodePoint(i2) : warn(`charToGlyph - invalid fontCharCode: ${i2}`));
    if (this.missingFile && this.vertical && 1 === h2.length) {
      const e3 = Xi()[h2.charCodeAt(0)];
      e3 && (h2 = o2 = String.fromCharCode(e3));
    }
    r2 = new fonts_Glyph(e2, h2, o2, C2, a2, g2, s2, t2, c2);
    return this._glyphCache[e2] = r2;
  }
  charsToGlyphs(e2) {
    let t2 = this._charsCache[e2];
    if (t2)
      return t2;
    t2 = [];
    if (this.cMap) {
      const i2 = /* @__PURE__ */ Object.create(null), a2 = e2.length;
      let s2 = 0;
      for (; s2 < a2; ) {
        this.cMap.readCharCode(e2, s2, i2);
        const { charcode: a3, length: r2 } = i2;
        s2 += r2;
        const n2 = this._charToGlyph(a3, 1 === r2 && 32 === e2.charCodeAt(s2 - 1));
        t2.push(n2);
      }
    } else
      for (let i2 = 0, a2 = e2.length; i2 < a2; ++i2) {
        const a3 = e2.charCodeAt(i2), s2 = this._charToGlyph(a3, 32 === a3);
        t2.push(s2);
      }
    return this._charsCache[e2] = t2;
  }
  getCharPositions(e2) {
    const t2 = [];
    if (this.cMap) {
      const i2 = /* @__PURE__ */ Object.create(null);
      let a2 = 0;
      for (; a2 < e2.length; ) {
        this.cMap.readCharCode(e2, a2, i2);
        const s2 = i2.length;
        t2.push([a2, a2 + s2]);
        a2 += s2;
      }
    } else
      for (let i2 = 0, a2 = e2.length; i2 < a2; ++i2)
        t2.push([i2, i2 + 1]);
    return t2;
  }
  get glyphCacheValues() {
    return Object.values(this._glyphCache);
  }
  encodeString(e2) {
    const t2 = [], i2 = [], hasCurrentBufErrors = () => t2.length % 2 == 1, a2 = this.toUnicode instanceof IdentityToUnicodeMap ? (e3) => this.toUnicode.charCodeOf(e3) : (e3) => this.toUnicode.charCodeOf(String.fromCodePoint(e3));
    for (let s2 = 0, r2 = e2.length; s2 < r2; s2++) {
      const r3 = e2.codePointAt(s2);
      r3 > 55295 && (r3 < 57344 || r3 > 65533) && s2++;
      if (this.toUnicode) {
        const e3 = a2(r3);
        if (-1 !== e3) {
          if (hasCurrentBufErrors()) {
            t2.push(i2.join(""));
            i2.length = 0;
          }
          for (let t3 = (this.cMap ? this.cMap.getCharCodeLength(e3) : 1) - 1; t3 >= 0; t3--)
            i2.push(String.fromCharCode(e3 >> 8 * t3 & 255));
          continue;
        }
      }
      if (!hasCurrentBufErrors()) {
        t2.push(i2.join(""));
        i2.length = 0;
      }
      i2.push(String.fromCodePoint(r3));
    }
    t2.push(i2.join(""));
    return t2;
  }
};
var ErrorFont = class {
  constructor(e2) {
    this.error = e2;
    this.loadedName = "g_font_error";
    this.missingFile = true;
  }
  charsToGlyphs() {
    return [];
  }
  encodeString(e2) {
    return [e2];
  }
  exportData(e2 = false) {
    return { error: this.error };
  }
};
var pa = 2;
var ma = 3;
var ya = 4;
var wa = 5;
var Da = 6;
var ba = 7;
var Pattern = class {
  constructor() {
    unreachable("Cannot initialize Pattern.");
  }
  static parseShading(e2, t2, i2, a2, s2) {
    const r2 = e2 instanceof BaseStream ? e2.dict : e2, n2 = r2.get("ShadingType");
    try {
      switch (n2) {
        case pa:
        case ma:
          return new RadialAxialShading(r2, t2, i2, a2, s2);
        case ya:
        case wa:
        case Da:
        case ba:
          return new MeshShading(e2, t2, i2, a2, s2);
        default:
          throw new FormatError("Unsupported ShadingType: " + n2);
      }
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      warn(e3);
      return new DummyShading();
    }
  }
};
var _BaseShading = class _BaseShading {
  constructor() {
    this.constructor === _BaseShading && unreachable("Cannot initialize BaseShading.");
  }
  getIR() {
    unreachable("Abstract method `getIR` called.");
  }
};
__publicField(_BaseShading, "SMALL_NUMBER", 1e-6);
var BaseShading = _BaseShading;
var RadialAxialShading = class extends BaseShading {
  constructor(e2, t2, i2, a2, s2) {
    super();
    this.shadingType = e2.get("ShadingType");
    let r2 = 0;
    this.shadingType === pa ? r2 = 4 : this.shadingType === ma && (r2 = 6);
    this.coordsArr = e2.getArray("Coords");
    if (!isNumberArray(this.coordsArr, r2))
      throw new FormatError("RadialAxialShading: Invalid /Coords array.");
    const n2 = ColorSpace.parse({ cs: e2.getRaw("CS") || e2.getRaw("ColorSpace"), xref: t2, resources: i2, pdfFunctionFactory: a2, localColorSpaceCache: s2 });
    this.bbox = lookupNormalRect(e2.getArray("BBox"), null);
    let g2 = 0, o2 = 1;
    const c2 = e2.getArray("Domain");
    isNumberArray(c2, 2) && ([g2, o2] = c2);
    let C2 = false, h2 = false;
    const l2 = e2.getArray("Extend");
    (function isBooleanArray(e3, t3) {
      return Array.isArray(e3) && (null === t3 || e3.length === t3) && e3.every((e4) => "boolean" == typeof e4);
    })(l2, 2) && ([C2, h2] = l2);
    if (!(this.shadingType !== ma || C2 && h2)) {
      const [e3, t3, i3, a3, s3, r3] = this.coordsArr, n3 = Math.hypot(e3 - a3, t3 - s3);
      i3 <= r3 + n3 && r3 <= i3 + n3 && warn("Unsupported radial gradient.");
    }
    this.extendStart = C2;
    this.extendEnd = h2;
    const Q2 = e2.getRaw("Function"), E2 = a2.createFromArray(Q2), u2 = (o2 - g2) / 840, d2 = this.colorStops = [];
    if (g2 >= o2 || u2 <= 0) {
      info("Bad shading domain.");
      return;
    }
    const f2 = new Float32Array(n2.numComps), p2 = new Float32Array(1);
    let m2, y2 = 0;
    p2[0] = g2;
    E2(p2, 0, f2, 0);
    let w2 = n2.getRgb(f2, 0);
    const D2 = Util.makeHexColor(w2[0], w2[1], w2[2]);
    d2.push([0, D2]);
    let b2 = 1;
    p2[0] = g2 + u2;
    E2(p2, 0, f2, 0);
    let F2 = n2.getRgb(f2, 0), S2 = F2[0] - w2[0] + 1, k2 = F2[1] - w2[1] + 1, R2 = F2[2] - w2[2] + 1, N2 = F2[0] - w2[0] - 1, G2 = F2[1] - w2[1] - 1, x2 = F2[2] - w2[2] - 1;
    for (let e3 = 2; e3 < 840; e3++) {
      p2[0] = g2 + e3 * u2;
      E2(p2, 0, f2, 0);
      m2 = n2.getRgb(f2, 0);
      const t3 = e3 - y2;
      S2 = Math.min(S2, (m2[0] - w2[0] + 1) / t3);
      k2 = Math.min(k2, (m2[1] - w2[1] + 1) / t3);
      R2 = Math.min(R2, (m2[2] - w2[2] + 1) / t3);
      N2 = Math.max(N2, (m2[0] - w2[0] - 1) / t3);
      G2 = Math.max(G2, (m2[1] - w2[1] - 1) / t3);
      x2 = Math.max(x2, (m2[2] - w2[2] - 1) / t3);
      if (!(N2 <= S2 && G2 <= k2 && x2 <= R2)) {
        const e4 = Util.makeHexColor(F2[0], F2[1], F2[2]);
        d2.push([b2 / 840, e4]);
        S2 = m2[0] - F2[0] + 1;
        k2 = m2[1] - F2[1] + 1;
        R2 = m2[2] - F2[2] + 1;
        N2 = m2[0] - F2[0] - 1;
        G2 = m2[1] - F2[1] - 1;
        x2 = m2[2] - F2[2] - 1;
        y2 = b2;
        w2 = F2;
      }
      b2 = e3;
      F2 = m2;
    }
    const U2 = Util.makeHexColor(F2[0], F2[1], F2[2]);
    d2.push([1, U2]);
    let M2 = "transparent";
    if (e2.has("Background")) {
      m2 = n2.getRgb(e2.get("Background"), 0);
      M2 = Util.makeHexColor(m2[0], m2[1], m2[2]);
    }
    if (!C2) {
      d2.unshift([0, M2]);
      d2[1][0] += BaseShading.SMALL_NUMBER;
    }
    if (!h2) {
      d2.at(-1)[0] -= BaseShading.SMALL_NUMBER;
      d2.push([1, M2]);
    }
    this.colorStops = d2;
  }
  getIR() {
    const { coordsArr: e2, shadingType: t2 } = this;
    let i2, a2, s2, r2, n2;
    if (t2 === pa) {
      a2 = [e2[0], e2[1]];
      s2 = [e2[2], e2[3]];
      r2 = null;
      n2 = null;
      i2 = "axial";
    } else if (t2 === ma) {
      a2 = [e2[0], e2[1]];
      s2 = [e2[3], e2[4]];
      r2 = e2[2];
      n2 = e2[5];
      i2 = "radial";
    } else
      unreachable(`getPattern type unknown: ${t2}`);
    return ["RadialAxial", i2, this.bbox, this.colorStops, a2, s2, r2, n2];
  }
};
var MeshStreamReader = class {
  constructor(e2, t2) {
    this.stream = e2;
    this.context = t2;
    this.buffer = 0;
    this.bufferLength = 0;
    const i2 = t2.numComps;
    this.tmpCompsBuf = new Float32Array(i2);
    const a2 = t2.colorSpace.numComps;
    this.tmpCsCompsBuf = t2.colorFn ? new Float32Array(a2) : this.tmpCompsBuf;
  }
  get hasData() {
    if (this.stream.end)
      return this.stream.pos < this.stream.end;
    if (this.bufferLength > 0)
      return true;
    const e2 = this.stream.getByte();
    if (e2 < 0)
      return false;
    this.buffer = e2;
    this.bufferLength = 8;
    return true;
  }
  readBits(e2) {
    let t2 = this.buffer, i2 = this.bufferLength;
    if (32 === e2) {
      if (0 === i2)
        return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
      t2 = t2 << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
      const e3 = this.stream.getByte();
      this.buffer = e3 & (1 << i2) - 1;
      return (t2 << 8 - i2 | (255 & e3) >> i2) >>> 0;
    }
    if (8 === e2 && 0 === i2)
      return this.stream.getByte();
    for (; i2 < e2; ) {
      t2 = t2 << 8 | this.stream.getByte();
      i2 += 8;
    }
    i2 -= e2;
    this.bufferLength = i2;
    this.buffer = t2 & (1 << i2) - 1;
    return t2 >> i2;
  }
  align() {
    this.buffer = 0;
    this.bufferLength = 0;
  }
  readFlag() {
    return this.readBits(this.context.bitsPerFlag);
  }
  readCoordinate() {
    const e2 = this.context.bitsPerCoordinate, t2 = this.readBits(e2), i2 = this.readBits(e2), a2 = this.context.decode, s2 = e2 < 32 ? 1 / ((1 << e2) - 1) : 23283064365386963e-26;
    return [t2 * s2 * (a2[1] - a2[0]) + a2[0], i2 * s2 * (a2[3] - a2[2]) + a2[2]];
  }
  readComponents() {
    const e2 = this.context.numComps, t2 = this.context.bitsPerComponent, i2 = t2 < 32 ? 1 / ((1 << t2) - 1) : 23283064365386963e-26, a2 = this.context.decode, s2 = this.tmpCompsBuf;
    for (let r3 = 0, n2 = 4; r3 < e2; r3++, n2 += 2) {
      const e3 = this.readBits(t2);
      s2[r3] = e3 * i2 * (a2[n2 + 1] - a2[n2]) + a2[n2];
    }
    const r2 = this.tmpCsCompsBuf;
    this.context.colorFn && this.context.colorFn(s2, 0, r2, 0);
    return this.context.colorSpace.getRgb(r2, 0);
  }
};
var Fa = /* @__PURE__ */ Object.create(null);
function getB(e2) {
  return Fa[e2] || (Fa[e2] = function buildB(e3) {
    const t2 = [];
    for (let i2 = 0; i2 <= e3; i2++) {
      const a2 = i2 / e3, s2 = 1 - a2;
      t2.push(new Float32Array([s2 ** 3, 3 * a2 * s2 ** 2, 3 * a2 ** 2 * s2, a2 ** 3]));
    }
    return t2;
  }(e2));
}
var _MeshShading = class _MeshShading extends BaseShading {
  constructor(e2, t2, i2, a2, s2) {
    super();
    if (!(e2 instanceof BaseStream))
      throw new FormatError("Mesh data is not a stream");
    const r2 = e2.dict;
    this.shadingType = r2.get("ShadingType");
    this.bbox = lookupNormalRect(r2.getArray("BBox"), null);
    const n2 = ColorSpace.parse({ cs: r2.getRaw("CS") || r2.getRaw("ColorSpace"), xref: t2, resources: i2, pdfFunctionFactory: a2, localColorSpaceCache: s2 });
    this.background = r2.has("Background") ? n2.getRgb(r2.get("Background"), 0) : null;
    const g2 = r2.getRaw("Function"), o2 = g2 ? a2.createFromArray(g2) : null;
    this.coords = [];
    this.colors = [];
    this.figures = [];
    const c2 = { bitsPerCoordinate: r2.get("BitsPerCoordinate"), bitsPerComponent: r2.get("BitsPerComponent"), bitsPerFlag: r2.get("BitsPerFlag"), decode: r2.getArray("Decode"), colorFn: o2, colorSpace: n2, numComps: o2 ? 1 : n2.numComps }, C2 = new MeshStreamReader(e2, c2);
    let h2 = false;
    switch (this.shadingType) {
      case ya:
        this._decodeType4Shading(C2);
        break;
      case wa:
        const e3 = 0 | r2.get("VerticesPerRow");
        if (e3 < 2)
          throw new FormatError("Invalid VerticesPerRow");
        this._decodeType5Shading(C2, e3);
        break;
      case Da:
        this._decodeType6Shading(C2);
        h2 = true;
        break;
      case ba:
        this._decodeType7Shading(C2);
        h2 = true;
        break;
      default:
        unreachable("Unsupported mesh type.");
    }
    if (h2) {
      this._updateBounds();
      for (let e3 = 0, t3 = this.figures.length; e3 < t3; e3++)
        this._buildFigureFromPatch(e3);
    }
    this._updateBounds();
    this._packData();
  }
  _decodeType4Shading(e2) {
    const t2 = this.coords, i2 = this.colors, a2 = [], s2 = [];
    let r2 = 0;
    for (; e2.hasData; ) {
      const n2 = e2.readFlag(), g2 = e2.readCoordinate(), o2 = e2.readComponents();
      if (0 === r2) {
        if (!(0 <= n2 && n2 <= 2))
          throw new FormatError("Unknown type4 flag");
        switch (n2) {
          case 0:
            r2 = 3;
            break;
          case 1:
            s2.push(s2.at(-2), s2.at(-1));
            r2 = 1;
            break;
          case 2:
            s2.push(s2.at(-3), s2.at(-1));
            r2 = 1;
        }
        a2.push(n2);
      }
      s2.push(t2.length);
      t2.push(g2);
      i2.push(o2);
      r2--;
      e2.align();
    }
    this.figures.push({ type: "triangles", coords: new Int32Array(s2), colors: new Int32Array(s2) });
  }
  _decodeType5Shading(e2, t2) {
    const i2 = this.coords, a2 = this.colors, s2 = [];
    for (; e2.hasData; ) {
      const t3 = e2.readCoordinate(), r2 = e2.readComponents();
      s2.push(i2.length);
      i2.push(t3);
      a2.push(r2);
    }
    this.figures.push({ type: "lattice", coords: new Int32Array(s2), colors: new Int32Array(s2), verticesPerRow: t2 });
  }
  _decodeType6Shading(e2) {
    const t2 = this.coords, i2 = this.colors, a2 = new Int32Array(16), s2 = new Int32Array(4);
    for (; e2.hasData; ) {
      const r2 = e2.readFlag();
      if (!(0 <= r2 && r2 <= 3))
        throw new FormatError("Unknown type6 flag");
      const n2 = t2.length;
      for (let i3 = 0, a3 = 0 !== r2 ? 8 : 12; i3 < a3; i3++)
        t2.push(e2.readCoordinate());
      const g2 = i2.length;
      for (let t3 = 0, a3 = 0 !== r2 ? 2 : 4; t3 < a3; t3++)
        i2.push(e2.readComponents());
      let o2, c2, C2, h2;
      switch (r2) {
        case 0:
          a2[12] = n2 + 3;
          a2[13] = n2 + 4;
          a2[14] = n2 + 5;
          a2[15] = n2 + 6;
          a2[8] = n2 + 2;
          a2[11] = n2 + 7;
          a2[4] = n2 + 1;
          a2[7] = n2 + 8;
          a2[0] = n2;
          a2[1] = n2 + 11;
          a2[2] = n2 + 10;
          a2[3] = n2 + 9;
          s2[2] = g2 + 1;
          s2[3] = g2 + 2;
          s2[0] = g2;
          s2[1] = g2 + 3;
          break;
        case 1:
          o2 = a2[12];
          c2 = a2[13];
          C2 = a2[14];
          h2 = a2[15];
          a2[12] = h2;
          a2[13] = n2 + 0;
          a2[14] = n2 + 1;
          a2[15] = n2 + 2;
          a2[8] = C2;
          a2[11] = n2 + 3;
          a2[4] = c2;
          a2[7] = n2 + 4;
          a2[0] = o2;
          a2[1] = n2 + 7;
          a2[2] = n2 + 6;
          a2[3] = n2 + 5;
          o2 = s2[2];
          c2 = s2[3];
          s2[2] = c2;
          s2[3] = g2;
          s2[0] = o2;
          s2[1] = g2 + 1;
          break;
        case 2:
          o2 = a2[15];
          c2 = a2[11];
          a2[12] = a2[3];
          a2[13] = n2 + 0;
          a2[14] = n2 + 1;
          a2[15] = n2 + 2;
          a2[8] = a2[7];
          a2[11] = n2 + 3;
          a2[4] = c2;
          a2[7] = n2 + 4;
          a2[0] = o2;
          a2[1] = n2 + 7;
          a2[2] = n2 + 6;
          a2[3] = n2 + 5;
          o2 = s2[3];
          s2[2] = s2[1];
          s2[3] = g2;
          s2[0] = o2;
          s2[1] = g2 + 1;
          break;
        case 3:
          a2[12] = a2[0];
          a2[13] = n2 + 0;
          a2[14] = n2 + 1;
          a2[15] = n2 + 2;
          a2[8] = a2[1];
          a2[11] = n2 + 3;
          a2[4] = a2[2];
          a2[7] = n2 + 4;
          a2[0] = a2[3];
          a2[1] = n2 + 7;
          a2[2] = n2 + 6;
          a2[3] = n2 + 5;
          s2[2] = s2[0];
          s2[3] = g2;
          s2[0] = s2[1];
          s2[1] = g2 + 1;
      }
      a2[5] = t2.length;
      t2.push([(-4 * t2[a2[0]][0] - t2[a2[15]][0] + 6 * (t2[a2[4]][0] + t2[a2[1]][0]) - 2 * (t2[a2[12]][0] + t2[a2[3]][0]) + 3 * (t2[a2[13]][0] + t2[a2[7]][0])) / 9, (-4 * t2[a2[0]][1] - t2[a2[15]][1] + 6 * (t2[a2[4]][1] + t2[a2[1]][1]) - 2 * (t2[a2[12]][1] + t2[a2[3]][1]) + 3 * (t2[a2[13]][1] + t2[a2[7]][1])) / 9]);
      a2[6] = t2.length;
      t2.push([(-4 * t2[a2[3]][0] - t2[a2[12]][0] + 6 * (t2[a2[2]][0] + t2[a2[7]][0]) - 2 * (t2[a2[0]][0] + t2[a2[15]][0]) + 3 * (t2[a2[4]][0] + t2[a2[14]][0])) / 9, (-4 * t2[a2[3]][1] - t2[a2[12]][1] + 6 * (t2[a2[2]][1] + t2[a2[7]][1]) - 2 * (t2[a2[0]][1] + t2[a2[15]][1]) + 3 * (t2[a2[4]][1] + t2[a2[14]][1])) / 9]);
      a2[9] = t2.length;
      t2.push([(-4 * t2[a2[12]][0] - t2[a2[3]][0] + 6 * (t2[a2[8]][0] + t2[a2[13]][0]) - 2 * (t2[a2[0]][0] + t2[a2[15]][0]) + 3 * (t2[a2[11]][0] + t2[a2[1]][0])) / 9, (-4 * t2[a2[12]][1] - t2[a2[3]][1] + 6 * (t2[a2[8]][1] + t2[a2[13]][1]) - 2 * (t2[a2[0]][1] + t2[a2[15]][1]) + 3 * (t2[a2[11]][1] + t2[a2[1]][1])) / 9]);
      a2[10] = t2.length;
      t2.push([(-4 * t2[a2[15]][0] - t2[a2[0]][0] + 6 * (t2[a2[11]][0] + t2[a2[14]][0]) - 2 * (t2[a2[12]][0] + t2[a2[3]][0]) + 3 * (t2[a2[2]][0] + t2[a2[8]][0])) / 9, (-4 * t2[a2[15]][1] - t2[a2[0]][1] + 6 * (t2[a2[11]][1] + t2[a2[14]][1]) - 2 * (t2[a2[12]][1] + t2[a2[3]][1]) + 3 * (t2[a2[2]][1] + t2[a2[8]][1])) / 9]);
      this.figures.push({ type: "patch", coords: new Int32Array(a2), colors: new Int32Array(s2) });
    }
  }
  _decodeType7Shading(e2) {
    const t2 = this.coords, i2 = this.colors, a2 = new Int32Array(16), s2 = new Int32Array(4);
    for (; e2.hasData; ) {
      const r2 = e2.readFlag();
      if (!(0 <= r2 && r2 <= 3))
        throw new FormatError("Unknown type7 flag");
      const n2 = t2.length;
      for (let i3 = 0, a3 = 0 !== r2 ? 12 : 16; i3 < a3; i3++)
        t2.push(e2.readCoordinate());
      const g2 = i2.length;
      for (let t3 = 0, a3 = 0 !== r2 ? 2 : 4; t3 < a3; t3++)
        i2.push(e2.readComponents());
      let o2, c2, C2, h2;
      switch (r2) {
        case 0:
          a2[12] = n2 + 3;
          a2[13] = n2 + 4;
          a2[14] = n2 + 5;
          a2[15] = n2 + 6;
          a2[8] = n2 + 2;
          a2[9] = n2 + 13;
          a2[10] = n2 + 14;
          a2[11] = n2 + 7;
          a2[4] = n2 + 1;
          a2[5] = n2 + 12;
          a2[6] = n2 + 15;
          a2[7] = n2 + 8;
          a2[0] = n2;
          a2[1] = n2 + 11;
          a2[2] = n2 + 10;
          a2[3] = n2 + 9;
          s2[2] = g2 + 1;
          s2[3] = g2 + 2;
          s2[0] = g2;
          s2[1] = g2 + 3;
          break;
        case 1:
          o2 = a2[12];
          c2 = a2[13];
          C2 = a2[14];
          h2 = a2[15];
          a2[12] = h2;
          a2[13] = n2 + 0;
          a2[14] = n2 + 1;
          a2[15] = n2 + 2;
          a2[8] = C2;
          a2[9] = n2 + 9;
          a2[10] = n2 + 10;
          a2[11] = n2 + 3;
          a2[4] = c2;
          a2[5] = n2 + 8;
          a2[6] = n2 + 11;
          a2[7] = n2 + 4;
          a2[0] = o2;
          a2[1] = n2 + 7;
          a2[2] = n2 + 6;
          a2[3] = n2 + 5;
          o2 = s2[2];
          c2 = s2[3];
          s2[2] = c2;
          s2[3] = g2;
          s2[0] = o2;
          s2[1] = g2 + 1;
          break;
        case 2:
          o2 = a2[15];
          c2 = a2[11];
          a2[12] = a2[3];
          a2[13] = n2 + 0;
          a2[14] = n2 + 1;
          a2[15] = n2 + 2;
          a2[8] = a2[7];
          a2[9] = n2 + 9;
          a2[10] = n2 + 10;
          a2[11] = n2 + 3;
          a2[4] = c2;
          a2[5] = n2 + 8;
          a2[6] = n2 + 11;
          a2[7] = n2 + 4;
          a2[0] = o2;
          a2[1] = n2 + 7;
          a2[2] = n2 + 6;
          a2[3] = n2 + 5;
          o2 = s2[3];
          s2[2] = s2[1];
          s2[3] = g2;
          s2[0] = o2;
          s2[1] = g2 + 1;
          break;
        case 3:
          a2[12] = a2[0];
          a2[13] = n2 + 0;
          a2[14] = n2 + 1;
          a2[15] = n2 + 2;
          a2[8] = a2[1];
          a2[9] = n2 + 9;
          a2[10] = n2 + 10;
          a2[11] = n2 + 3;
          a2[4] = a2[2];
          a2[5] = n2 + 8;
          a2[6] = n2 + 11;
          a2[7] = n2 + 4;
          a2[0] = a2[3];
          a2[1] = n2 + 7;
          a2[2] = n2 + 6;
          a2[3] = n2 + 5;
          s2[2] = s2[0];
          s2[3] = g2;
          s2[0] = s2[1];
          s2[1] = g2 + 1;
      }
      this.figures.push({ type: "patch", coords: new Int32Array(a2), colors: new Int32Array(s2) });
    }
  }
  _buildFigureFromPatch(e2) {
    const t2 = this.figures[e2];
    assert("patch" === t2.type, "Unexpected patch mesh figure");
    const i2 = this.coords, a2 = this.colors, s2 = t2.coords, r2 = t2.colors, n2 = Math.min(i2[s2[0]][0], i2[s2[3]][0], i2[s2[12]][0], i2[s2[15]][0]), g2 = Math.min(i2[s2[0]][1], i2[s2[3]][1], i2[s2[12]][1], i2[s2[15]][1]), o2 = Math.max(i2[s2[0]][0], i2[s2[3]][0], i2[s2[12]][0], i2[s2[15]][0]), c2 = Math.max(i2[s2[0]][1], i2[s2[3]][1], i2[s2[12]][1], i2[s2[15]][1]);
    let C2 = Math.ceil((o2 - n2) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
    C2 = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, C2));
    let h2 = Math.ceil((c2 - g2) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
    h2 = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, h2));
    const l2 = C2 + 1, Q2 = new Int32Array((h2 + 1) * l2), E2 = new Int32Array((h2 + 1) * l2);
    let u2 = 0;
    const d2 = new Uint8Array(3), f2 = new Uint8Array(3), p2 = a2[r2[0]], m2 = a2[r2[1]], y2 = a2[r2[2]], w2 = a2[r2[3]], D2 = getB(h2), b2 = getB(C2);
    for (let e3 = 0; e3 <= h2; e3++) {
      d2[0] = (p2[0] * (h2 - e3) + y2[0] * e3) / h2 | 0;
      d2[1] = (p2[1] * (h2 - e3) + y2[1] * e3) / h2 | 0;
      d2[2] = (p2[2] * (h2 - e3) + y2[2] * e3) / h2 | 0;
      f2[0] = (m2[0] * (h2 - e3) + w2[0] * e3) / h2 | 0;
      f2[1] = (m2[1] * (h2 - e3) + w2[1] * e3) / h2 | 0;
      f2[2] = (m2[2] * (h2 - e3) + w2[2] * e3) / h2 | 0;
      for (let t3 = 0; t3 <= C2; t3++, u2++) {
        if (!(0 !== e3 && e3 !== h2 || 0 !== t3 && t3 !== C2))
          continue;
        let r3 = 0, n3 = 0, g3 = 0;
        for (let a3 = 0; a3 <= 3; a3++)
          for (let o4 = 0; o4 <= 3; o4++, g3++) {
            const c3 = D2[e3][a3] * b2[t3][o4];
            r3 += i2[s2[g3]][0] * c3;
            n3 += i2[s2[g3]][1] * c3;
          }
        Q2[u2] = i2.length;
        i2.push([r3, n3]);
        E2[u2] = a2.length;
        const o3 = new Uint8Array(3);
        o3[0] = (d2[0] * (C2 - t3) + f2[0] * t3) / C2 | 0;
        o3[1] = (d2[1] * (C2 - t3) + f2[1] * t3) / C2 | 0;
        o3[2] = (d2[2] * (C2 - t3) + f2[2] * t3) / C2 | 0;
        a2.push(o3);
      }
    }
    Q2[0] = s2[0];
    E2[0] = r2[0];
    Q2[C2] = s2[3];
    E2[C2] = r2[1];
    Q2[l2 * h2] = s2[12];
    E2[l2 * h2] = r2[2];
    Q2[l2 * h2 + C2] = s2[15];
    E2[l2 * h2 + C2] = r2[3];
    this.figures[e2] = { type: "lattice", coords: Q2, colors: E2, verticesPerRow: l2 };
  }
  _updateBounds() {
    let e2 = this.coords[0][0], t2 = this.coords[0][1], i2 = e2, a2 = t2;
    for (let s2 = 1, r2 = this.coords.length; s2 < r2; s2++) {
      const r3 = this.coords[s2][0], n2 = this.coords[s2][1];
      e2 = e2 > r3 ? r3 : e2;
      t2 = t2 > n2 ? n2 : t2;
      i2 = i2 < r3 ? r3 : i2;
      a2 = a2 < n2 ? n2 : a2;
    }
    this.bounds = [e2, t2, i2, a2];
  }
  _packData() {
    let e2, t2, i2, a2;
    const s2 = this.coords, r2 = new Float32Array(2 * s2.length);
    for (e2 = 0, i2 = 0, t2 = s2.length; e2 < t2; e2++) {
      const t3 = s2[e2];
      r2[i2++] = t3[0];
      r2[i2++] = t3[1];
    }
    this.coords = r2;
    const n2 = this.colors, g2 = new Uint8Array(3 * n2.length);
    for (e2 = 0, i2 = 0, t2 = n2.length; e2 < t2; e2++) {
      const t3 = n2[e2];
      g2[i2++] = t3[0];
      g2[i2++] = t3[1];
      g2[i2++] = t3[2];
    }
    this.colors = g2;
    const o2 = this.figures;
    for (e2 = 0, t2 = o2.length; e2 < t2; e2++) {
      const t3 = o2[e2], s3 = t3.coords, r3 = t3.colors;
      for (i2 = 0, a2 = s3.length; i2 < a2; i2++) {
        s3[i2] *= 2;
        r3[i2] *= 3;
      }
    }
  }
  getIR() {
    const { bounds: e2 } = this;
    if (e2[2] - e2[0] == 0 || e2[3] - e2[1] == 0)
      throw new FormatError(`Invalid MeshShading bounds: [${e2}].`);
    return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, e2, this.bbox, this.background];
  }
};
__publicField(_MeshShading, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
__publicField(_MeshShading, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
__publicField(_MeshShading, "TRIANGLE_DENSITY", 20);
var MeshShading = _MeshShading;
var DummyShading = class extends BaseShading {
  getIR() {
    return ["Dummy"];
  }
};
function getTilingPatternIR(e2, t2, a2) {
  const s2 = lookupMatrix(t2.getArray("Matrix"), i), r2 = lookupNormalRect(t2.getArray("BBox"), null);
  if (!r2 || r2[2] - r2[0] == 0 || r2[3] - r2[1] == 0)
    throw new FormatError("Invalid getTilingPatternIR /BBox array.");
  const n2 = t2.get("XStep");
  if ("number" != typeof n2)
    throw new FormatError("Invalid getTilingPatternIR /XStep value.");
  const g2 = t2.get("YStep");
  if ("number" != typeof g2)
    throw new FormatError("Invalid getTilingPatternIR /YStep value.");
  const o2 = t2.get("PaintType");
  if (!Number.isInteger(o2))
    throw new FormatError("Invalid getTilingPatternIR /PaintType value.");
  const c2 = t2.get("TilingType");
  if (!Number.isInteger(c2))
    throw new FormatError("Invalid getTilingPatternIR /TilingType value.");
  return ["TilingPattern", a2, e2, s2, r2, n2, g2, o2, c2];
}
var Sa = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var ka = { lineHeight: 1.2207, lineGap: 0.2207 };
var Ra = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var Na = { lineHeight: 1.2207, lineGap: 0.2207 };
var Ga = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var xa = { lineHeight: 1.2207, lineGap: 0.2207 };
var Ua = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var Ma = { lineHeight: 1.2207, lineGap: 0.2207 };
var La = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var Ha = { lineHeight: 1.2, lineGap: 0.2 };
var Ja = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var Ya = { lineHeight: 1.35, lineGap: 0.2 };
var va = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var Ka = { lineHeight: 1.35, lineGap: 0.2 };
var Ta = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var qa = { lineHeight: 1.2, lineGap: 0.2 };
var Oa = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
var Pa = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
var Wa = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
var ja = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
var Xa = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
var Za = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
var Va = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
var za = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
var _a3 = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var $a = { lineHeight: 1.2, lineGap: 0.2 };
var As = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var es = { lineHeight: 1.2, lineGap: 0.2 };
var ts = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var is = { lineHeight: 1.2, lineGap: 0.2 };
var as = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var ss = { lineHeight: 1.2, lineGap: 0.2 };
var rs = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var ns = { lineHeight: 1.33008, lineGap: 0 };
var gs = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var os = { lineHeight: 1.33008, lineGap: 0 };
var Is = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var cs = { lineHeight: 1.33008, lineGap: 0 };
var Cs = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var hs = { lineHeight: 1.33008, lineGap: 0 };
var Bs = getLookupTableFactory(function(e2) {
  e2["MyriadPro-Regular"] = e2["PdfJS-Fallback-Regular"] = { name: "LiberationSans-Regular", factors: as, baseWidths: Va, baseMapping: za, metrics: ss };
  e2["MyriadPro-Bold"] = e2["PdfJS-Fallback-Bold"] = { name: "LiberationSans-Bold", factors: _a3, baseWidths: Oa, baseMapping: Pa, metrics: $a };
  e2["MyriadPro-It"] = e2["MyriadPro-Italic"] = e2["PdfJS-Fallback-Italic"] = { name: "LiberationSans-Italic", factors: ts, baseWidths: Xa, baseMapping: Za, metrics: is };
  e2["MyriadPro-BoldIt"] = e2["MyriadPro-BoldItalic"] = e2["PdfJS-Fallback-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: As, baseWidths: Wa, baseMapping: ja, metrics: es };
  e2.ArialMT = e2.Arial = e2["Arial-Regular"] = { name: "LiberationSans-Regular", baseWidths: Va, baseMapping: za };
  e2["Arial-BoldMT"] = e2["Arial-Bold"] = { name: "LiberationSans-Bold", baseWidths: Oa, baseMapping: Pa };
  e2["Arial-ItalicMT"] = e2["Arial-Italic"] = { name: "LiberationSans-Italic", baseWidths: Xa, baseMapping: Za };
  e2["Arial-BoldItalicMT"] = e2["Arial-BoldItalic"] = { name: "LiberationSans-BoldItalic", baseWidths: Wa, baseMapping: ja };
  e2["Calibri-Regular"] = { name: "LiberationSans-Regular", factors: Ua, baseWidths: Va, baseMapping: za, metrics: Ma };
  e2["Calibri-Bold"] = { name: "LiberationSans-Bold", factors: Sa, baseWidths: Oa, baseMapping: Pa, metrics: ka };
  e2["Calibri-Italic"] = { name: "LiberationSans-Italic", factors: Ga, baseWidths: Xa, baseMapping: Za, metrics: xa };
  e2["Calibri-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: Ra, baseWidths: Wa, baseMapping: ja, metrics: Na };
  e2["Segoeui-Regular"] = { name: "LiberationSans-Regular", factors: Cs, baseWidths: Va, baseMapping: za, metrics: hs };
  e2["Segoeui-Bold"] = { name: "LiberationSans-Bold", factors: rs, baseWidths: Oa, baseMapping: Pa, metrics: ns };
  e2["Segoeui-Italic"] = { name: "LiberationSans-Italic", factors: Is, baseWidths: Xa, baseMapping: Za, metrics: cs };
  e2["Segoeui-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: gs, baseWidths: Wa, baseMapping: ja, metrics: os };
  e2["Helvetica-Regular"] = e2.Helvetica = { name: "LiberationSans-Regular", factors: Ta, baseWidths: Va, baseMapping: za, metrics: qa };
  e2["Helvetica-Bold"] = { name: "LiberationSans-Bold", factors: La, baseWidths: Oa, baseMapping: Pa, metrics: Ha };
  e2["Helvetica-Italic"] = { name: "LiberationSans-Italic", factors: va, baseWidths: Xa, baseMapping: Za, metrics: Ka };
  e2["Helvetica-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: Ja, baseWidths: Wa, baseMapping: ja, metrics: Ya };
});
function getXfaFontName(e2) {
  const t2 = normalizeFontName(e2);
  return Bs()[t2];
}
function getXfaFontDict(e2) {
  const t2 = function getXfaFontWidths(e3) {
    const t3 = getXfaFontName(e3);
    if (!t3)
      return null;
    const { baseWidths: i3, baseMapping: a3, factors: s3 } = t3, r2 = s3 ? i3.map((e4, t4) => e4 * s3[t4]) : i3;
    let n2, g2 = -2;
    const o2 = [];
    for (const [e4, t4] of a3.map((e5, t5) => [e5, t5]).sort(([e5], [t5]) => e5 - t5))
      if (-1 !== e4)
        if (e4 === g2 + 1) {
          n2.push(r2[t4]);
          g2 += 1;
        } else {
          g2 = e4;
          n2 = [r2[t4]];
          o2.push(e4, n2);
        }
    return o2;
  }(e2), i2 = new Dict(null);
  i2.set("BaseFont", Name.get(e2));
  i2.set("Type", Name.get("Font"));
  i2.set("Subtype", Name.get("CIDFontType2"));
  i2.set("Encoding", Name.get("Identity-H"));
  i2.set("CIDToGIDMap", Name.get("Identity"));
  i2.set("W", t2);
  i2.set("FirstChar", t2[0]);
  i2.set("LastChar", t2.at(-2) + t2.at(-1).length - 1);
  const a2 = new Dict(null);
  i2.set("FontDescriptor", a2);
  const s2 = new Dict(null);
  s2.set("Ordering", "Identity");
  s2.set("Registry", "Adobe");
  s2.set("Supplement", 0);
  i2.set("CIDSystemInfo", s2);
  return i2;
}
var PostScriptParser = class {
  constructor(e2) {
    this.lexer = e2;
    this.operators = [];
    this.token = null;
    this.prev = null;
  }
  nextToken() {
    this.prev = this.token;
    this.token = this.lexer.getToken();
  }
  accept(e2) {
    if (this.token.type === e2) {
      this.nextToken();
      return true;
    }
    return false;
  }
  expect(e2) {
    if (this.accept(e2))
      return true;
    throw new FormatError(`Unexpected symbol: found ${this.token.type} expected ${e2}.`);
  }
  parse() {
    this.nextToken();
    this.expect(ls.LBRACE);
    this.parseBlock();
    this.expect(ls.RBRACE);
    return this.operators;
  }
  parseBlock() {
    for (; ; )
      if (this.accept(ls.NUMBER))
        this.operators.push(this.prev.value);
      else if (this.accept(ls.OPERATOR))
        this.operators.push(this.prev.value);
      else {
        if (!this.accept(ls.LBRACE))
          return;
        this.parseCondition();
      }
  }
  parseCondition() {
    const e2 = this.operators.length;
    this.operators.push(null, null);
    this.parseBlock();
    this.expect(ls.RBRACE);
    if (this.accept(ls.IF)) {
      this.operators[e2] = this.operators.length;
      this.operators[e2 + 1] = "jz";
    } else {
      if (!this.accept(ls.LBRACE))
        throw new FormatError("PS Function: error parsing conditional.");
      {
        const t2 = this.operators.length;
        this.operators.push(null, null);
        const i2 = this.operators.length;
        this.parseBlock();
        this.expect(ls.RBRACE);
        this.expect(ls.IFELSE);
        this.operators[t2] = this.operators.length;
        this.operators[t2 + 1] = "j";
        this.operators[e2] = i2;
        this.operators[e2 + 1] = "jz";
      }
    }
  }
};
var ls = { LBRACE: 0, RBRACE: 1, NUMBER: 2, OPERATOR: 3, IF: 4, IFELSE: 5 };
var PostScriptToken = class _PostScriptToken {
  static get opCache() {
    return shadow(this, "opCache", /* @__PURE__ */ Object.create(null));
  }
  constructor(e2, t2) {
    this.type = e2;
    this.value = t2;
  }
  static getOperator(e2) {
    var _a4;
    return (_a4 = _PostScriptToken.opCache)[e2] || (_a4[e2] = new _PostScriptToken(ls.OPERATOR, e2));
  }
  static get LBRACE() {
    return shadow(this, "LBRACE", new _PostScriptToken(ls.LBRACE, "{"));
  }
  static get RBRACE() {
    return shadow(this, "RBRACE", new _PostScriptToken(ls.RBRACE, "}"));
  }
  static get IF() {
    return shadow(this, "IF", new _PostScriptToken(ls.IF, "IF"));
  }
  static get IFELSE() {
    return shadow(this, "IFELSE", new _PostScriptToken(ls.IFELSE, "IFELSE"));
  }
};
var PostScriptLexer = class {
  constructor(e2) {
    this.stream = e2;
    this.nextChar();
    this.strBuf = [];
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let e2 = false, t2 = this.currentChar;
    for (; ; ) {
      if (t2 < 0)
        return wt;
      if (e2)
        10 !== t2 && 13 !== t2 || (e2 = false);
      else if (37 === t2)
        e2 = true;
      else if (!isWhiteSpace(t2))
        break;
      t2 = this.nextChar();
    }
    switch (0 | t2) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return new PostScriptToken(ls.NUMBER, this.getNumber());
      case 123:
        this.nextChar();
        return PostScriptToken.LBRACE;
      case 125:
        this.nextChar();
        return PostScriptToken.RBRACE;
    }
    const i2 = this.strBuf;
    i2.length = 0;
    i2[0] = String.fromCharCode(t2);
    for (; (t2 = this.nextChar()) >= 0 && (t2 >= 65 && t2 <= 90 || t2 >= 97 && t2 <= 122); )
      i2.push(String.fromCharCode(t2));
    const a2 = i2.join("");
    switch (a2.toLowerCase()) {
      case "if":
        return PostScriptToken.IF;
      case "ifelse":
        return PostScriptToken.IFELSE;
      default:
        return PostScriptToken.getOperator(a2);
    }
  }
  getNumber() {
    let e2 = this.currentChar;
    const t2 = this.strBuf;
    t2.length = 0;
    t2[0] = String.fromCharCode(e2);
    for (; (e2 = this.nextChar()) >= 0 && (e2 >= 48 && e2 <= 57 || 45 === e2 || 46 === e2); )
      t2.push(String.fromCharCode(e2));
    const i2 = parseFloat(t2.join(""));
    if (isNaN(i2))
      throw new FormatError(`Invalid floating point number: ${i2}`);
    return i2;
  }
};
var BaseLocalCache = class _BaseLocalCache {
  constructor(e2) {
    this.constructor === _BaseLocalCache && unreachable("Cannot initialize BaseLocalCache.");
    this._onlyRefs = true === (e2 == null ? void 0 : e2.onlyRefs);
    if (!this._onlyRefs) {
      this._nameRefMap = /* @__PURE__ */ new Map();
      this._imageMap = /* @__PURE__ */ new Map();
    }
    this._imageCache = new RefSetCache();
  }
  getByName(e2) {
    this._onlyRefs && unreachable("Should not call `getByName` method.");
    const t2 = this._nameRefMap.get(e2);
    return t2 ? this.getByRef(t2) : this._imageMap.get(e2) || null;
  }
  getByRef(e2) {
    return this._imageCache.get(e2) || null;
  }
  set(e2, t2, i2) {
    unreachable("Abstract method `set` called.");
  }
};
var LocalImageCache = class extends BaseLocalCache {
  set(e2, t2 = null, i2) {
    if ("string" != typeof e2)
      throw new Error('LocalImageCache.set - expected "name" argument.');
    if (t2) {
      if (this._imageCache.has(t2))
        return;
      this._nameRefMap.set(e2, t2);
      this._imageCache.put(t2, i2);
    } else
      this._imageMap.has(e2) || this._imageMap.set(e2, i2);
  }
};
var LocalColorSpaceCache = class extends BaseLocalCache {
  set(e2 = null, t2 = null, i2) {
    if ("string" != typeof e2 && !t2)
      throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
    if (t2) {
      if (this._imageCache.has(t2))
        return;
      null !== e2 && this._nameRefMap.set(e2, t2);
      this._imageCache.put(t2, i2);
    } else
      this._imageMap.has(e2) || this._imageMap.set(e2, i2);
  }
};
var LocalFunctionCache = class extends BaseLocalCache {
  constructor(e2) {
    super({ onlyRefs: true });
  }
  set(e2 = null, t2, i2) {
    if (!t2)
      throw new Error('LocalFunctionCache.set - expected "ref" argument.');
    this._imageCache.has(t2) || this._imageCache.put(t2, i2);
  }
};
var LocalGStateCache = class extends BaseLocalCache {
  set(e2, t2 = null, i2) {
    if ("string" != typeof e2)
      throw new Error('LocalGStateCache.set - expected "name" argument.');
    if (t2) {
      if (this._imageCache.has(t2))
        return;
      this._nameRefMap.set(e2, t2);
      this._imageCache.put(t2, i2);
    } else
      this._imageMap.has(e2) || this._imageMap.set(e2, i2);
  }
};
var LocalTilingPatternCache = class extends BaseLocalCache {
  constructor(e2) {
    super({ onlyRefs: true });
  }
  set(e2 = null, t2, i2) {
    if (!t2)
      throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
    this._imageCache.has(t2) || this._imageCache.put(t2, i2);
  }
};
var RegionalImageCache = class extends BaseLocalCache {
  constructor(e2) {
    super({ onlyRefs: true });
  }
  set(e2 = null, t2, i2) {
    if (!t2)
      throw new Error('RegionalImageCache.set - expected "ref" argument.');
    this._imageCache.has(t2) || this._imageCache.put(t2, i2);
  }
};
var _D, _b, b_get, _F, F_get;
var _GlobalImageCache = class _GlobalImageCache {
  constructor() {
    __privateAdd(this, _b);
    __privateAdd(this, _F);
    __privateAdd(this, _D, new RefSet());
    this._refCache = new RefSetCache();
    this._imageCache = new RefSetCache();
  }
  shouldCache(e2, t2) {
    let i2 = this._refCache.get(e2);
    if (!i2) {
      i2 = /* @__PURE__ */ new Set();
      this._refCache.put(e2, i2);
    }
    i2.add(t2);
    return !(i2.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(e2) && __privateGet(this, _F, F_get));
  }
  addDecodeFailed(e2) {
    __privateGet(this, _D).put(e2);
  }
  hasDecodeFailed(e2) {
    return __privateGet(this, _D).has(e2);
  }
  addByteSize(e2, t2) {
    const i2 = this._imageCache.get(e2);
    i2 && (i2.byteSize || (i2.byteSize = t2));
  }
  getData(e2, t2) {
    const i2 = this._refCache.get(e2);
    if (!i2)
      return null;
    if (i2.size < _GlobalImageCache.NUM_PAGES_THRESHOLD)
      return null;
    const a2 = this._imageCache.get(e2);
    if (!a2)
      return null;
    i2.add(t2);
    return a2;
  }
  setData(e2, t2) {
    if (!this._refCache.has(e2))
      throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
    this._imageCache.has(e2) || (__privateGet(this, _F, F_get) ? warn("GlobalImageCache.setData - cache limit reached.") : this._imageCache.put(e2, t2));
  }
  clear(e2 = false) {
    if (!e2) {
      __privateGet(this, _D).clear();
      this._refCache.clear();
    }
    this._imageCache.clear();
  }
};
_D = new WeakMap();
_b = new WeakSet();
b_get = function() {
  let e2 = 0;
  for (const t2 of this._imageCache)
    e2 += t2.byteSize;
  return e2;
};
_F = new WeakSet();
F_get = function() {
  return !(this._imageCache.size < _GlobalImageCache.MIN_IMAGES_TO_CACHE) && !(__privateGet(this, _b, b_get) < _GlobalImageCache.MAX_BYTE_SIZE);
};
__publicField(_GlobalImageCache, "NUM_PAGES_THRESHOLD", 2);
__publicField(_GlobalImageCache, "MIN_IMAGES_TO_CACHE", 10);
__publicField(_GlobalImageCache, "MAX_BYTE_SIZE", 5e7);
var GlobalImageCache = _GlobalImageCache;
var PDFFunctionFactory = class {
  constructor({ xref: e2, isEvalSupported: t2 = true }) {
    this.xref = e2;
    this.isEvalSupported = false !== t2;
  }
  create(e2) {
    const t2 = this.getCached(e2);
    if (t2)
      return t2;
    const i2 = PDFFunction.parse({ xref: this.xref, isEvalSupported: this.isEvalSupported, fn: e2 instanceof Ref ? this.xref.fetch(e2) : e2 });
    this._cache(e2, i2);
    return i2;
  }
  createFromArray(e2) {
    const t2 = this.getCached(e2);
    if (t2)
      return t2;
    const i2 = PDFFunction.parseArray({ xref: this.xref, isEvalSupported: this.isEvalSupported, fnObj: e2 instanceof Ref ? this.xref.fetch(e2) : e2 });
    this._cache(e2, i2);
    return i2;
  }
  getCached(e2) {
    var _a4;
    let t2;
    e2 instanceof Ref ? t2 = e2 : e2 instanceof Dict ? t2 = e2.objId : e2 instanceof BaseStream && (t2 = (_a4 = e2.dict) == null ? void 0 : _a4.objId);
    if (t2) {
      const e3 = this._localFunctionCache.getByRef(t2);
      if (e3)
        return e3;
    }
    return null;
  }
  _cache(e2, t2) {
    var _a4;
    if (!t2)
      throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
    let i2;
    e2 instanceof Ref ? i2 = e2 : e2 instanceof Dict ? i2 = e2.objId : e2 instanceof BaseStream && (i2 = (_a4 = e2.dict) == null ? void 0 : _a4.objId);
    i2 && this._localFunctionCache.set(null, i2, t2);
  }
  get _localFunctionCache() {
    return shadow(this, "_localFunctionCache", new LocalFunctionCache());
  }
};
function toNumberArray(e2) {
  return Array.isArray(e2) ? isNumberArray(e2, null) ? e2 : e2.map((e3) => +e3) : null;
}
var PDFFunction = class {
  static getSampleArray(e2, t2, i2, a2) {
    let s2, r2, n2 = 1;
    for (s2 = 0, r2 = e2.length; s2 < r2; s2++)
      n2 *= e2[s2];
    n2 *= t2;
    const g2 = new Array(n2);
    let o2 = 0, c2 = 0;
    const C2 = 1 / (2 ** i2 - 1), h2 = a2.getBytes((n2 * i2 + 7) / 8);
    let l2 = 0;
    for (s2 = 0; s2 < n2; s2++) {
      for (; o2 < i2; ) {
        c2 <<= 8;
        c2 |= h2[l2++];
        o2 += 8;
      }
      o2 -= i2;
      g2[s2] = (c2 >> o2) * C2;
      c2 &= (1 << o2) - 1;
    }
    return g2;
  }
  static parse({ xref: e2, isEvalSupported: t2, fn: i2 }) {
    const a2 = i2.dict || i2;
    switch (a2.get("FunctionType")) {
      case 0:
        return this.constructSampled({ xref: e2, isEvalSupported: t2, fn: i2, dict: a2 });
      case 1:
        break;
      case 2:
        return this.constructInterpolated({ xref: e2, isEvalSupported: t2, dict: a2 });
      case 3:
        return this.constructStiched({ xref: e2, isEvalSupported: t2, dict: a2 });
      case 4:
        return this.constructPostScript({ xref: e2, isEvalSupported: t2, fn: i2, dict: a2 });
    }
    throw new FormatError("Unknown type of function");
  }
  static parseArray({ xref: e2, isEvalSupported: t2, fnObj: i2 }) {
    if (!Array.isArray(i2))
      return this.parse({ xref: e2, isEvalSupported: t2, fn: i2 });
    const a2 = [];
    for (const s2 of i2)
      a2.push(this.parse({ xref: e2, isEvalSupported: t2, fn: e2.fetchIfRef(s2) }));
    return function(e3, t3, i3, s2) {
      for (let r2 = 0, n2 = a2.length; r2 < n2; r2++)
        a2[r2](e3, t3, i3, s2 + r2);
    };
  }
  static constructSampled({ xref: e2, isEvalSupported: t2, fn: i2, dict: a2 }) {
    function toMultiArray(e3) {
      const t3 = e3.length, i3 = [];
      let a3 = 0;
      for (let s3 = 0; s3 < t3; s3 += 2)
        i3[a3++] = [e3[s3], e3[s3 + 1]];
      return i3;
    }
    function interpolate(e3, t3, i3, a3, s3) {
      return a3 + (s3 - a3) / (i3 - t3) * (e3 - t3);
    }
    let s2 = toNumberArray(a2.getArray("Domain")), r2 = toNumberArray(a2.getArray("Range"));
    if (!s2 || !r2)
      throw new FormatError("No domain or range");
    const n2 = s2.length / 2, g2 = r2.length / 2;
    s2 = toMultiArray(s2);
    r2 = toMultiArray(r2);
    const o2 = toNumberArray(a2.getArray("Size")), c2 = a2.get("BitsPerSample"), C2 = a2.get("Order") || 1;
    1 !== C2 && info("No support for cubic spline interpolation: " + C2);
    let h2 = toNumberArray(a2.getArray("Encode"));
    if (h2)
      h2 = toMultiArray(h2);
    else {
      h2 = [];
      for (let e3 = 0; e3 < n2; ++e3)
        h2.push([0, o2[e3] - 1]);
    }
    let l2 = toNumberArray(a2.getArray("Decode"));
    l2 = l2 ? toMultiArray(l2) : r2;
    const Q2 = this.getSampleArray(o2, g2, c2, i2);
    return function constructSampledFn(e3, t3, i3, a3) {
      const c3 = 1 << n2, C3 = new Float64Array(c3), E2 = new Uint32Array(c3);
      let u2, d2;
      for (d2 = 0; d2 < c3; d2++)
        C3[d2] = 1;
      let f2 = g2, p2 = 1;
      for (u2 = 0; u2 < n2; ++u2) {
        const i4 = s2[u2][0], a4 = s2[u2][1];
        let r3 = interpolate(Math.min(Math.max(e3[t3 + u2], i4), a4), i4, a4, h2[u2][0], h2[u2][1]);
        const n3 = o2[u2];
        r3 = Math.min(Math.max(r3, 0), n3 - 1);
        const g3 = r3 < n3 - 1 ? Math.floor(r3) : r3 - 1, l3 = g3 + 1 - r3, Q3 = r3 - g3, m2 = g3 * f2, y2 = m2 + f2;
        for (d2 = 0; d2 < c3; d2++)
          if (d2 & p2) {
            C3[d2] *= Q3;
            E2[d2] += y2;
          } else {
            C3[d2] *= l3;
            E2[d2] += m2;
          }
        f2 *= n3;
        p2 <<= 1;
      }
      for (d2 = 0; d2 < g2; ++d2) {
        let e4 = 0;
        for (u2 = 0; u2 < c3; u2++)
          e4 += Q2[E2[u2] + d2] * C3[u2];
        e4 = interpolate(e4, 0, 1, l2[d2][0], l2[d2][1]);
        i3[a3 + d2] = Math.min(Math.max(e4, r2[d2][0]), r2[d2][1]);
      }
    };
  }
  static constructInterpolated({ xref: e2, isEvalSupported: t2, dict: i2 }) {
    const a2 = toNumberArray(i2.getArray("C0")) || [0], s2 = toNumberArray(i2.getArray("C1")) || [1], r2 = i2.get("N"), n2 = [];
    for (let e3 = 0, t3 = a2.length; e3 < t3; ++e3)
      n2.push(s2[e3] - a2[e3]);
    const g2 = n2.length;
    return function constructInterpolatedFn(e3, t3, i3, s3) {
      const o2 = 1 === r2 ? e3[t3] : e3[t3] ** r2;
      for (let e4 = 0; e4 < g2; ++e4)
        i3[s3 + e4] = a2[e4] + o2 * n2[e4];
    };
  }
  static constructStiched({ xref: e2, isEvalSupported: t2, dict: i2 }) {
    const a2 = toNumberArray(i2.getArray("Domain"));
    if (!a2)
      throw new FormatError("No domain");
    if (1 !== a2.length / 2)
      throw new FormatError("Bad domain for stiched function");
    const s2 = [];
    for (const a3 of i2.get("Functions"))
      s2.push(this.parse({ xref: e2, isEvalSupported: t2, fn: e2.fetchIfRef(a3) }));
    const r2 = toNumberArray(i2.getArray("Bounds")), n2 = toNumberArray(i2.getArray("Encode")), g2 = new Float32Array(1);
    return function constructStichedFn(e3, t3, i3, o2) {
      const c2 = function constructStichedFromIRClip(e4, t4, i4) {
        e4 > i4 ? e4 = i4 : e4 < t4 && (e4 = t4);
        return e4;
      }(e3[t3], a2[0], a2[1]), C2 = r2.length;
      let h2;
      for (h2 = 0; h2 < C2 && !(c2 < r2[h2]); ++h2)
        ;
      let l2 = a2[0];
      h2 > 0 && (l2 = r2[h2 - 1]);
      let Q2 = a2[1];
      h2 < r2.length && (Q2 = r2[h2]);
      const E2 = n2[2 * h2], u2 = n2[2 * h2 + 1];
      g2[0] = l2 === Q2 ? E2 : E2 + (c2 - l2) * (u2 - E2) / (Q2 - l2);
      s2[h2](g2, 0, i3, o2);
    };
  }
  static constructPostScript({ xref: e2, isEvalSupported: t2, fn: i2, dict: a2 }) {
    const s2 = toNumberArray(a2.getArray("Domain")), r2 = toNumberArray(a2.getArray("Range"));
    if (!s2)
      throw new FormatError("No domain.");
    if (!r2)
      throw new FormatError("No range.");
    const n2 = new PostScriptLexer(i2), g2 = new PostScriptParser(n2).parse();
    if (t2 && FeatureTest.isEvalSupported) {
      const e3 = new PostScriptCompiler().compile(g2, s2, r2);
      if (e3)
        return new Function("src", "srcOffset", "dest", "destOffset", e3);
    }
    info("Unable to compile PS function");
    const o2 = r2.length >> 1, c2 = s2.length >> 1, C2 = new PostScriptEvaluator(g2), h2 = /* @__PURE__ */ Object.create(null);
    let l2 = 8192;
    const Q2 = new Float32Array(c2);
    return function constructPostScriptFn(e3, t3, i3, a3) {
      let s3, n3, g3 = "";
      const E2 = Q2;
      for (s3 = 0; s3 < c2; s3++) {
        n3 = e3[t3 + s3];
        E2[s3] = n3;
        g3 += n3 + "_";
      }
      const u2 = h2[g3];
      if (void 0 !== u2) {
        i3.set(u2, a3);
        return;
      }
      const d2 = new Float32Array(o2), f2 = C2.execute(E2), p2 = f2.length - o2;
      for (s3 = 0; s3 < o2; s3++) {
        n3 = f2[p2 + s3];
        let e4 = r2[2 * s3];
        if (n3 < e4)
          n3 = e4;
        else {
          e4 = r2[2 * s3 + 1];
          n3 > e4 && (n3 = e4);
        }
        d2[s3] = n3;
      }
      if (l2 > 0) {
        l2--;
        h2[g3] = d2;
      }
      i3.set(d2, a3);
    };
  }
};
function isPDFFunction(e2) {
  let t2;
  if (e2 instanceof Dict)
    t2 = e2;
  else {
    if (!(e2 instanceof BaseStream))
      return false;
    t2 = e2.dict;
  }
  return t2.has("FunctionType");
}
var _PostScriptStack = class _PostScriptStack {
  constructor(e2) {
    this.stack = e2 ? Array.from(e2) : [];
  }
  push(e2) {
    if (this.stack.length >= _PostScriptStack.MAX_STACK_SIZE)
      throw new Error("PostScript function stack overflow.");
    this.stack.push(e2);
  }
  pop() {
    if (this.stack.length <= 0)
      throw new Error("PostScript function stack underflow.");
    return this.stack.pop();
  }
  copy(e2) {
    if (this.stack.length + e2 >= _PostScriptStack.MAX_STACK_SIZE)
      throw new Error("PostScript function stack overflow.");
    const t2 = this.stack;
    for (let i2 = t2.length - e2, a2 = e2 - 1; a2 >= 0; a2--, i2++)
      t2.push(t2[i2]);
  }
  index(e2) {
    this.push(this.stack[this.stack.length - e2 - 1]);
  }
  roll(e2, t2) {
    const i2 = this.stack, a2 = i2.length - e2, s2 = i2.length - 1, r2 = a2 + (t2 - Math.floor(t2 / e2) * e2);
    for (let e3 = a2, t3 = s2; e3 < t3; e3++, t3--) {
      const a3 = i2[e3];
      i2[e3] = i2[t3];
      i2[t3] = a3;
    }
    for (let e3 = a2, t3 = r2 - 1; e3 < t3; e3++, t3--) {
      const a3 = i2[e3];
      i2[e3] = i2[t3];
      i2[t3] = a3;
    }
    for (let e3 = r2, t3 = s2; e3 < t3; e3++, t3--) {
      const a3 = i2[e3];
      i2[e3] = i2[t3];
      i2[t3] = a3;
    }
  }
};
__publicField(_PostScriptStack, "MAX_STACK_SIZE", 100);
var PostScriptStack = _PostScriptStack;
var PostScriptEvaluator = class {
  constructor(e2) {
    this.operators = e2;
  }
  execute(e2) {
    const t2 = new PostScriptStack(e2);
    let i2 = 0;
    const a2 = this.operators, s2 = a2.length;
    let r2, n2, g2;
    for (; i2 < s2; ) {
      r2 = a2[i2++];
      if ("number" != typeof r2)
        switch (r2) {
          case "jz":
            g2 = t2.pop();
            n2 = t2.pop();
            n2 || (i2 = g2);
            break;
          case "j":
            n2 = t2.pop();
            i2 = n2;
            break;
          case "abs":
            n2 = t2.pop();
            t2.push(Math.abs(n2));
            break;
          case "add":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 + g2);
            break;
          case "and":
            g2 = t2.pop();
            n2 = t2.pop();
            "boolean" == typeof n2 && "boolean" == typeof g2 ? t2.push(n2 && g2) : t2.push(n2 & g2);
            break;
          case "atan":
            g2 = t2.pop();
            n2 = t2.pop();
            n2 = Math.atan2(n2, g2) / Math.PI * 180;
            n2 < 0 && (n2 += 360);
            t2.push(n2);
            break;
          case "bitshift":
            g2 = t2.pop();
            n2 = t2.pop();
            n2 > 0 ? t2.push(n2 << g2) : t2.push(n2 >> g2);
            break;
          case "ceiling":
            n2 = t2.pop();
            t2.push(Math.ceil(n2));
            break;
          case "copy":
            n2 = t2.pop();
            t2.copy(n2);
            break;
          case "cos":
            n2 = t2.pop();
            t2.push(Math.cos(n2 % 360 / 180 * Math.PI));
            break;
          case "cvi":
            n2 = 0 | t2.pop();
            t2.push(n2);
            break;
          case "cvr":
            break;
          case "div":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 / g2);
            break;
          case "dup":
            t2.copy(1);
            break;
          case "eq":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 === g2);
            break;
          case "exch":
            t2.roll(2, 1);
            break;
          case "exp":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 ** g2);
            break;
          case "false":
            t2.push(false);
            break;
          case "floor":
            n2 = t2.pop();
            t2.push(Math.floor(n2));
            break;
          case "ge":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 >= g2);
            break;
          case "gt":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 > g2);
            break;
          case "idiv":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 / g2 | 0);
            break;
          case "index":
            n2 = t2.pop();
            t2.index(n2);
            break;
          case "le":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 <= g2);
            break;
          case "ln":
            n2 = t2.pop();
            t2.push(Math.log(n2));
            break;
          case "log":
            n2 = t2.pop();
            t2.push(Math.log10(n2));
            break;
          case "lt":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 < g2);
            break;
          case "mod":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 % g2);
            break;
          case "mul":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 * g2);
            break;
          case "ne":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 !== g2);
            break;
          case "neg":
            n2 = t2.pop();
            t2.push(-n2);
            break;
          case "not":
            n2 = t2.pop();
            "boolean" == typeof n2 ? t2.push(!n2) : t2.push(~n2);
            break;
          case "or":
            g2 = t2.pop();
            n2 = t2.pop();
            "boolean" == typeof n2 && "boolean" == typeof g2 ? t2.push(n2 || g2) : t2.push(n2 | g2);
            break;
          case "pop":
            t2.pop();
            break;
          case "roll":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.roll(n2, g2);
            break;
          case "round":
            n2 = t2.pop();
            t2.push(Math.round(n2));
            break;
          case "sin":
            n2 = t2.pop();
            t2.push(Math.sin(n2 % 360 / 180 * Math.PI));
            break;
          case "sqrt":
            n2 = t2.pop();
            t2.push(Math.sqrt(n2));
            break;
          case "sub":
            g2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 - g2);
            break;
          case "true":
            t2.push(true);
            break;
          case "truncate":
            n2 = t2.pop();
            n2 = n2 < 0 ? Math.ceil(n2) : Math.floor(n2);
            t2.push(n2);
            break;
          case "xor":
            g2 = t2.pop();
            n2 = t2.pop();
            "boolean" == typeof n2 && "boolean" == typeof g2 ? t2.push(n2 !== g2) : t2.push(n2 ^ g2);
            break;
          default:
            throw new FormatError(`Unknown operator ${r2}`);
        }
      else
        t2.push(r2);
    }
    return t2.stack;
  }
};
var AstNode = class {
  constructor(e2) {
    this.type = e2;
  }
  visit(e2) {
    unreachable("abstract method");
  }
};
var AstArgument = class extends AstNode {
  constructor(e2, t2, i2) {
    super("args");
    this.index = e2;
    this.min = t2;
    this.max = i2;
  }
  visit(e2) {
    e2.visitArgument(this);
  }
};
var AstLiteral = class extends AstNode {
  constructor(e2) {
    super("literal");
    this.number = e2;
    this.min = e2;
    this.max = e2;
  }
  visit(e2) {
    e2.visitLiteral(this);
  }
};
var AstBinaryOperation = class extends AstNode {
  constructor(e2, t2, i2, a2, s2) {
    super("binary");
    this.op = e2;
    this.arg1 = t2;
    this.arg2 = i2;
    this.min = a2;
    this.max = s2;
  }
  visit(e2) {
    e2.visitBinaryOperation(this);
  }
};
var AstMin = class extends AstNode {
  constructor(e2, t2) {
    super("max");
    this.arg = e2;
    this.min = e2.min;
    this.max = t2;
  }
  visit(e2) {
    e2.visitMin(this);
  }
};
var AstVariable = class extends AstNode {
  constructor(e2, t2, i2) {
    super("var");
    this.index = e2;
    this.min = t2;
    this.max = i2;
  }
  visit(e2) {
    e2.visitVariable(this);
  }
};
var AstVariableDefinition = class extends AstNode {
  constructor(e2, t2) {
    super("definition");
    this.variable = e2;
    this.arg = t2;
  }
  visit(e2) {
    e2.visitVariableDefinition(this);
  }
};
var ExpressionBuilderVisitor = class {
  constructor() {
    this.parts = [];
  }
  visitArgument(e2) {
    this.parts.push("Math.max(", e2.min, ", Math.min(", e2.max, ", src[srcOffset + ", e2.index, "]))");
  }
  visitVariable(e2) {
    this.parts.push("v", e2.index);
  }
  visitLiteral(e2) {
    this.parts.push(e2.number);
  }
  visitBinaryOperation(e2) {
    this.parts.push("(");
    e2.arg1.visit(this);
    this.parts.push(" ", e2.op, " ");
    e2.arg2.visit(this);
    this.parts.push(")");
  }
  visitVariableDefinition(e2) {
    this.parts.push("var ");
    e2.variable.visit(this);
    this.parts.push(" = ");
    e2.arg.visit(this);
    this.parts.push(";");
  }
  visitMin(e2) {
    this.parts.push("Math.min(");
    e2.arg.visit(this);
    this.parts.push(", ", e2.max, ")");
  }
  toString() {
    return this.parts.join("");
  }
};
function buildAddOperation(e2, t2) {
  return "literal" === t2.type && 0 === t2.number ? e2 : "literal" === e2.type && 0 === e2.number ? t2 : "literal" === t2.type && "literal" === e2.type ? new AstLiteral(e2.number + t2.number) : new AstBinaryOperation("+", e2, t2, e2.min + t2.min, e2.max + t2.max);
}
function buildMulOperation(e2, t2) {
  if ("literal" === t2.type) {
    if (0 === t2.number)
      return new AstLiteral(0);
    if (1 === t2.number)
      return e2;
    if ("literal" === e2.type)
      return new AstLiteral(e2.number * t2.number);
  }
  if ("literal" === e2.type) {
    if (0 === e2.number)
      return new AstLiteral(0);
    if (1 === e2.number)
      return t2;
  }
  const i2 = Math.min(e2.min * t2.min, e2.min * t2.max, e2.max * t2.min, e2.max * t2.max), a2 = Math.max(e2.min * t2.min, e2.min * t2.max, e2.max * t2.min, e2.max * t2.max);
  return new AstBinaryOperation("*", e2, t2, i2, a2);
}
function buildSubOperation(e2, t2) {
  if ("literal" === t2.type) {
    if (0 === t2.number)
      return e2;
    if ("literal" === e2.type)
      return new AstLiteral(e2.number - t2.number);
  }
  return "binary" === t2.type && "-" === t2.op && "literal" === e2.type && 1 === e2.number && "literal" === t2.arg1.type && 1 === t2.arg1.number ? t2.arg2 : new AstBinaryOperation("-", e2, t2, e2.min - t2.max, e2.max - t2.min);
}
function buildMinOperation(e2, t2) {
  return e2.min >= t2 ? new AstLiteral(t2) : e2.max <= t2 ? e2 : new AstMin(e2, t2);
}
var PostScriptCompiler = class {
  compile(e2, t2, i2) {
    const a2 = [], s2 = [], r2 = t2.length >> 1, n2 = i2.length >> 1;
    let g2, o2, c2, C2, h2, l2, Q2, E2, u2 = 0;
    for (let e3 = 0; e3 < r2; e3++)
      a2.push(new AstArgument(e3, t2[2 * e3], t2[2 * e3 + 1]));
    for (let t3 = 0, i3 = e2.length; t3 < i3; t3++) {
      E2 = e2[t3];
      if ("number" != typeof E2)
        switch (E2) {
          case "add":
            if (a2.length < 2)
              return null;
            C2 = a2.pop();
            c2 = a2.pop();
            a2.push(buildAddOperation(c2, C2));
            break;
          case "cvr":
            if (a2.length < 1)
              return null;
            break;
          case "mul":
            if (a2.length < 2)
              return null;
            C2 = a2.pop();
            c2 = a2.pop();
            a2.push(buildMulOperation(c2, C2));
            break;
          case "sub":
            if (a2.length < 2)
              return null;
            C2 = a2.pop();
            c2 = a2.pop();
            a2.push(buildSubOperation(c2, C2));
            break;
          case "exch":
            if (a2.length < 2)
              return null;
            h2 = a2.pop();
            l2 = a2.pop();
            a2.push(h2, l2);
            break;
          case "pop":
            if (a2.length < 1)
              return null;
            a2.pop();
            break;
          case "index":
            if (a2.length < 1)
              return null;
            c2 = a2.pop();
            if ("literal" !== c2.type)
              return null;
            g2 = c2.number;
            if (g2 < 0 || !Number.isInteger(g2) || a2.length < g2)
              return null;
            h2 = a2[a2.length - g2 - 1];
            if ("literal" === h2.type || "var" === h2.type) {
              a2.push(h2);
              break;
            }
            Q2 = new AstVariable(u2++, h2.min, h2.max);
            a2[a2.length - g2 - 1] = Q2;
            a2.push(Q2);
            s2.push(new AstVariableDefinition(Q2, h2));
            break;
          case "dup":
            if (a2.length < 1)
              return null;
            if ("number" == typeof e2[t3 + 1] && "gt" === e2[t3 + 2] && e2[t3 + 3] === t3 + 7 && "jz" === e2[t3 + 4] && "pop" === e2[t3 + 5] && e2[t3 + 6] === e2[t3 + 1]) {
              c2 = a2.pop();
              a2.push(buildMinOperation(c2, e2[t3 + 1]));
              t3 += 6;
              break;
            }
            h2 = a2.at(-1);
            if ("literal" === h2.type || "var" === h2.type) {
              a2.push(h2);
              break;
            }
            Q2 = new AstVariable(u2++, h2.min, h2.max);
            a2[a2.length - 1] = Q2;
            a2.push(Q2);
            s2.push(new AstVariableDefinition(Q2, h2));
            break;
          case "roll":
            if (a2.length < 2)
              return null;
            C2 = a2.pop();
            c2 = a2.pop();
            if ("literal" !== C2.type || "literal" !== c2.type)
              return null;
            o2 = C2.number;
            g2 = c2.number;
            if (g2 <= 0 || !Number.isInteger(g2) || !Number.isInteger(o2) || a2.length < g2)
              return null;
            o2 = (o2 % g2 + g2) % g2;
            if (0 === o2)
              break;
            a2.push(...a2.splice(a2.length - g2, g2 - o2));
            break;
          default:
            return null;
        }
      else
        a2.push(new AstLiteral(E2));
    }
    if (a2.length !== n2)
      return null;
    const d2 = [];
    for (const e3 of s2) {
      const t3 = new ExpressionBuilderVisitor();
      e3.visit(t3);
      d2.push(t3.toString());
    }
    for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) {
      const t4 = a2[e3], s3 = new ExpressionBuilderVisitor();
      t4.visit(s3);
      const r3 = i2[2 * e3], n3 = i2[2 * e3 + 1], g3 = [s3.toString()];
      if (r3 > t4.min) {
        g3.unshift("Math.max(", r3, ", ");
        g3.push(")");
      }
      if (n3 < t4.max) {
        g3.unshift("Math.min(", n3, ", ");
        g3.push(")");
      }
      g3.unshift("dest[destOffset + ", e3, "] = ");
      g3.push(";");
      d2.push(g3.join(""));
    }
    return d2.join("\n");
  }
};
var Qs = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
var Es = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
function isOdd(e2) {
  return 0 != (1 & e2);
}
function isEven(e2) {
  return 0 == (1 & e2);
}
function findUnequal(e2, t2, i2) {
  let a2, s2;
  for (a2 = t2, s2 = e2.length; a2 < s2; ++a2)
    if (e2[a2] !== i2)
      return a2;
  return a2;
}
function setValues(e2, t2, i2, a2) {
  for (let s2 = t2; s2 < i2; ++s2)
    e2[s2] = a2;
}
function reverseValues(e2, t2, i2) {
  for (let a2 = t2, s2 = i2 - 1; a2 < s2; ++a2, --s2) {
    const t3 = e2[a2];
    e2[a2] = e2[s2];
    e2[s2] = t3;
  }
}
function createBidiText(e2, t2, i2 = false) {
  let a2 = "ltr";
  i2 ? a2 = "ttb" : t2 || (a2 = "rtl");
  return { str: e2, dir: a2 };
}
var us = [];
var ds = [];
function bidi(e2, t2 = -1, i2 = false) {
  let a2 = true;
  const s2 = e2.length;
  if (0 === s2 || i2)
    return createBidiText(e2, a2, i2);
  us.length = s2;
  ds.length = s2;
  let r2, n2, g2 = 0;
  for (r2 = 0; r2 < s2; ++r2) {
    us[r2] = e2.charAt(r2);
    const t3 = e2.charCodeAt(r2);
    let i3 = "L";
    if (t3 <= 255)
      i3 = Qs[t3];
    else if (1424 <= t3 && t3 <= 1524)
      i3 = "R";
    else if (1536 <= t3 && t3 <= 1791) {
      i3 = Es[255 & t3];
      i3 || warn("Bidi: invalid Unicode character " + t3.toString(16));
    } else
      (1792 <= t3 && t3 <= 2220 || 64336 <= t3 && t3 <= 65023 || 65136 <= t3 && t3 <= 65279) && (i3 = "AL");
    "R" !== i3 && "AL" !== i3 && "AN" !== i3 || g2++;
    ds[r2] = i3;
  }
  if (0 === g2) {
    a2 = true;
    return createBidiText(e2, a2);
  }
  if (-1 === t2)
    if (g2 / s2 < 0.3 && s2 > 4) {
      a2 = true;
      t2 = 0;
    } else {
      a2 = false;
      t2 = 1;
    }
  const o2 = [];
  for (r2 = 0; r2 < s2; ++r2)
    o2[r2] = t2;
  const c2 = isOdd(t2) ? "R" : "L", C2 = c2, h2 = C2;
  let l2, Q2 = C2;
  for (r2 = 0; r2 < s2; ++r2)
    "NSM" === ds[r2] ? ds[r2] = Q2 : Q2 = ds[r2];
  Q2 = C2;
  for (r2 = 0; r2 < s2; ++r2) {
    l2 = ds[r2];
    "EN" === l2 ? ds[r2] = "AL" === Q2 ? "AN" : "EN" : "R" !== l2 && "L" !== l2 && "AL" !== l2 || (Q2 = l2);
  }
  for (r2 = 0; r2 < s2; ++r2) {
    l2 = ds[r2];
    "AL" === l2 && (ds[r2] = "R");
  }
  for (r2 = 1; r2 < s2 - 1; ++r2) {
    "ES" === ds[r2] && "EN" === ds[r2 - 1] && "EN" === ds[r2 + 1] && (ds[r2] = "EN");
    "CS" !== ds[r2] || "EN" !== ds[r2 - 1] && "AN" !== ds[r2 - 1] || ds[r2 + 1] !== ds[r2 - 1] || (ds[r2] = ds[r2 - 1]);
  }
  for (r2 = 0; r2 < s2; ++r2)
    if ("EN" === ds[r2]) {
      for (let e3 = r2 - 1; e3 >= 0 && "ET" === ds[e3]; --e3)
        ds[e3] = "EN";
      for (let e3 = r2 + 1; e3 < s2 && "ET" === ds[e3]; ++e3)
        ds[e3] = "EN";
    }
  for (r2 = 0; r2 < s2; ++r2) {
    l2 = ds[r2];
    "WS" !== l2 && "ES" !== l2 && "ET" !== l2 && "CS" !== l2 || (ds[r2] = "ON");
  }
  Q2 = C2;
  for (r2 = 0; r2 < s2; ++r2) {
    l2 = ds[r2];
    "EN" === l2 ? ds[r2] = "L" === Q2 ? "L" : "EN" : "R" !== l2 && "L" !== l2 || (Q2 = l2);
  }
  for (r2 = 0; r2 < s2; ++r2)
    if ("ON" === ds[r2]) {
      const e3 = findUnequal(ds, r2 + 1, "ON");
      let t3 = C2;
      r2 > 0 && (t3 = ds[r2 - 1]);
      let i3 = h2;
      e3 + 1 < s2 && (i3 = ds[e3 + 1]);
      "L" !== t3 && (t3 = "R");
      "L" !== i3 && (i3 = "R");
      t3 === i3 && setValues(ds, r2, e3, t3);
      r2 = e3 - 1;
    }
  for (r2 = 0; r2 < s2; ++r2)
    "ON" === ds[r2] && (ds[r2] = c2);
  for (r2 = 0; r2 < s2; ++r2) {
    l2 = ds[r2];
    isEven(o2[r2]) ? "R" === l2 ? o2[r2] += 1 : "AN" !== l2 && "EN" !== l2 || (o2[r2] += 2) : "L" !== l2 && "AN" !== l2 && "EN" !== l2 || (o2[r2] += 1);
  }
  let E2, u2 = -1, d2 = 99;
  for (r2 = 0, n2 = o2.length; r2 < n2; ++r2) {
    E2 = o2[r2];
    u2 < E2 && (u2 = E2);
    d2 > E2 && isOdd(E2) && (d2 = E2);
  }
  for (E2 = u2; E2 >= d2; --E2) {
    let e3 = -1;
    for (r2 = 0, n2 = o2.length; r2 < n2; ++r2)
      if (o2[r2] < E2) {
        if (e3 >= 0) {
          reverseValues(us, e3, r2);
          e3 = -1;
        }
      } else
        e3 < 0 && (e3 = r2);
    e3 >= 0 && reverseValues(us, e3, o2.length);
  }
  for (r2 = 0, n2 = us.length; r2 < n2; ++r2) {
    const e3 = us[r2];
    "<" !== e3 && ">" !== e3 || (us[r2] = "");
  }
  return createBidiText(us.join(""), a2);
}
var fs = { style: "normal", weight: "normal" };
var ps = { style: "normal", weight: "bold" };
var ms = { style: "italic", weight: "normal" };
var ys = { style: "italic", weight: "bold" };
var ws = /* @__PURE__ */ new Map([["Times-Roman", { local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "Linux Libertine O", "Libertinus Serif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"], style: fs, ultimate: "serif" }], ["Times-Bold", { alias: "Times-Roman", style: ps, ultimate: "serif" }], ["Times-Italic", { alias: "Times-Roman", style: ms, ultimate: "serif" }], ["Times-BoldItalic", { alias: "Times-Roman", style: ys, ultimate: "serif" }], ["Helvetica", { local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"], path: "LiberationSans-Regular.ttf", style: fs, ultimate: "sans-serif" }], ["Helvetica-Bold", { alias: "Helvetica", path: "LiberationSans-Bold.ttf", style: ps, ultimate: "sans-serif" }], ["Helvetica-Oblique", { alias: "Helvetica", path: "LiberationSans-Italic.ttf", style: ms, ultimate: "sans-serif" }], ["Helvetica-BoldOblique", { alias: "Helvetica", path: "LiberationSans-BoldItalic.ttf", style: ys, ultimate: "sans-serif" }], ["Courier", { local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono", "Linux Libertine Mono O", "Libertinus Mono"], style: fs, ultimate: "monospace" }], ["Courier-Bold", { alias: "Courier", style: ps, ultimate: "monospace" }], ["Courier-Oblique", { alias: "Courier", style: ms, ultimate: "monospace" }], ["Courier-BoldOblique", { alias: "Courier", style: ys, ultimate: "monospace" }], ["ArialBlack", { local: ["Arial Black"], style: { style: "normal", weight: "900" }, fallback: "Helvetica-Bold" }], ["ArialBlack-Bold", { alias: "ArialBlack" }], ["ArialBlack-Italic", { alias: "ArialBlack", style: { style: "italic", weight: "900" }, fallback: "Helvetica-BoldOblique" }], ["ArialBlack-BoldItalic", { alias: "ArialBlack-Italic" }], ["ArialNarrow", { local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"], style: fs, fallback: "Helvetica" }], ["ArialNarrow-Bold", { alias: "ArialNarrow", style: ps, fallback: "Helvetica-Bold" }], ["ArialNarrow-Italic", { alias: "ArialNarrow", style: ms, fallback: "Helvetica-Oblique" }], ["ArialNarrow-BoldItalic", { alias: "ArialNarrow", style: ys, fallback: "Helvetica-BoldOblique" }], ["Calibri", { local: ["Calibri", "Carlito"], style: fs, fallback: "Helvetica" }], ["Calibri-Bold", { alias: "Calibri", style: ps, fallback: "Helvetica-Bold" }], ["Calibri-Italic", { alias: "Calibri", style: ms, fallback: "Helvetica-Oblique" }], ["Calibri-BoldItalic", { alias: "Calibri", style: ys, fallback: "Helvetica-BoldOblique" }], ["Wingdings", { local: ["Wingdings", "URW Dingbats"], style: fs }], ["Wingdings-Regular", { alias: "Wingdings" }], ["Wingdings-Bold", { alias: "Wingdings" }]]);
var Ds = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
function getFamilyName(e2) {
  const t2 = /* @__PURE__ */ new Set(["thin", "extralight", "ultralight", "demilight", "semilight", "light", "book", "regular", "normal", "medium", "demibold", "semibold", "bold", "extrabold", "ultrabold", "black", "heavy", "extrablack", "ultrablack", "roman", "italic", "oblique", "ultracondensed", "extracondensed", "condensed", "semicondensed", "normal", "semiexpanded", "expanded", "extraexpanded", "ultraexpanded", "bolditalic"]);
  return e2.split(/[- ,+]+/g).filter((e3) => !t2.has(e3.toLowerCase())).join(" ");
}
function generateFont({ alias: e2, local: t2, path: i2, fallback: a2, style: s2, ultimate: r2 }, n2, g2, o2 = true, c2 = true, C2 = "") {
  const h2 = { style: null, ultimate: null };
  if (t2) {
    const e3 = C2 ? ` ${C2}` : "";
    for (const i3 of t2)
      n2.push(`local(${i3}${e3})`);
  }
  if (e2) {
    const t3 = ws.get(e2), r3 = C2 || function getStyleToAppend(e3) {
      switch (e3) {
        case ps:
          return "Bold";
        case ms:
          return "Italic";
        case ys:
          return "Bold Italic";
        default:
          if ("bold" === (e3 == null ? void 0 : e3.weight))
            return "Bold";
          if ("italic" === (e3 == null ? void 0 : e3.style))
            return "Italic";
      }
      return "";
    }(s2);
    Object.assign(h2, generateFont(t3, n2, g2, o2 && !a2, c2 && !i2, r3));
  }
  s2 && (h2.style = s2);
  r2 && (h2.ultimate = r2);
  if (o2 && a2) {
    const e3 = ws.get(a2), { ultimate: t3 } = generateFont(e3, n2, g2, o2, c2 && !i2, C2);
    h2.ultimate || (h2.ultimate = t3);
  }
  c2 && i2 && g2 && n2.push(`url(${g2}${i2})`);
  return h2;
}
function getFontSubstitution(e2, t2, i2, a2, s2, r2) {
  if (a2.startsWith("InvalidPDFjsFont_"))
    return null;
  "TrueType" !== r2 && "Type1" !== r2 || !/^[A-Z]{6}\+/.test(a2) || (a2 = a2.slice(7));
  const n2 = a2 = normalizeFontName(a2);
  let g2 = e2.get(n2);
  if (g2)
    return g2;
  let o2 = ws.get(a2);
  if (!o2) {
    for (const [e3, t3] of Ds)
      if (a2.startsWith(e3)) {
        a2 = `${t3}${a2.substring(e3.length)}`;
        o2 = ws.get(a2);
        break;
      }
  }
  let c2 = false;
  if (!o2) {
    o2 = ws.get(s2);
    c2 = true;
  }
  const C2 = `${t2.getDocId()}_s${t2.createFontId()}`;
  if (!o2) {
    if (!validateFontName(a2)) {
      warn(`Cannot substitute the font because of its name: ${a2}`);
      e2.set(n2, null);
      return null;
    }
    const t3 = /bold/gi.test(a2), i3 = /oblique|italic/gi.test(a2), s3 = t3 && i3 && ys || t3 && ps || i3 && ms || fs;
    g2 = { css: `"${getFamilyName(a2)}",${C2}`, guessFallback: true, loadedName: C2, baseFontName: a2, src: `local(${a2})`, style: s3 };
    e2.set(n2, g2);
    return g2;
  }
  const h2 = [];
  c2 && validateFontName(a2) && h2.push(`local(${a2})`);
  const { style: l2, ultimate: Q2 } = generateFont(o2, h2, i2), E2 = null === Q2, u2 = E2 ? "" : `,${Q2}`;
  g2 = { css: `"${getFamilyName(a2)}",${C2}${u2}`, guessFallback: E2, loadedName: C2, baseFontName: a2, src: h2.join(","), style: l2 };
  e2.set(n2, g2);
  return g2;
}
var ImageResizer = class _ImageResizer {
  constructor(e2, t2) {
    this._imgData = e2;
    this._isMask = t2;
  }
  static needsToBeResized(e2, t2) {
    if (e2 <= this._goodSquareLength && t2 <= this._goodSquareLength)
      return false;
    const { MAX_DIM: i2 } = this;
    if (e2 > i2 || t2 > i2)
      return true;
    const a2 = e2 * t2;
    if (this._hasMaxArea)
      return a2 > this.MAX_AREA;
    if (a2 < this._goodSquareLength ** 2)
      return false;
    if (this._areGoodDims(e2, t2)) {
      this._goodSquareLength = Math.max(this._goodSquareLength, Math.floor(Math.sqrt(e2 * t2)));
      return false;
    }
    this._goodSquareLength = this._guessMax(this._goodSquareLength, i2, 128, 0);
    return a2 > (this.MAX_AREA = this._goodSquareLength ** 2);
  }
  static get MAX_DIM() {
    return shadow(this, "MAX_DIM", this._guessMax(2048, 65537, 0, 1));
  }
  static get MAX_AREA() {
    this._hasMaxArea = true;
    return shadow(this, "MAX_AREA", this._guessMax(_ImageResizer._goodSquareLength, this.MAX_DIM, 128, 0) ** 2);
  }
  static set MAX_AREA(e2) {
    if (e2 >= 0) {
      this._hasMaxArea = true;
      shadow(this, "MAX_AREA", e2);
    }
  }
  static setMaxArea(e2) {
    this._hasMaxArea || (this.MAX_AREA = e2 >> 2);
  }
  static _areGoodDims(e2, t2) {
    try {
      const i2 = new OffscreenCanvas(e2, t2), a2 = i2.getContext("2d");
      a2.fillRect(0, 0, 1, 1);
      const s2 = a2.getImageData(0, 0, 1, 1).data[3];
      i2.width = i2.height = 1;
      return 0 !== s2;
    } catch {
      return false;
    }
  }
  static _guessMax(e2, t2, i2, a2) {
    for (; e2 + i2 + 1 < t2; ) {
      const i3 = Math.floor((e2 + t2) / 2), s2 = a2 || i3;
      this._areGoodDims(i3, s2) ? e2 = i3 : t2 = i3;
    }
    return e2;
  }
  static async createImage(e2, t2 = false) {
    return new _ImageResizer(e2, t2)._createImage();
  }
  async _createImage() {
    const e2 = this._encodeBMP(), t2 = new Blob([e2.buffer], { type: "image/bmp" }), i2 = createImageBitmap(t2), { MAX_AREA: a2, MAX_DIM: s2 } = _ImageResizer, { _imgData: r2 } = this, { width: n2, height: g2 } = r2, o2 = Math.max(n2 / s2, g2 / s2, Math.sqrt(n2 * g2 / a2)), c2 = Math.max(o2, 2), C2 = Math.round(10 * (o2 + 1.25)) / 10 / c2, h2 = Math.floor(Math.log2(C2)), l2 = new Array(h2 + 2).fill(2);
    l2[0] = c2;
    l2.splice(-1, 1, C2 / (1 << h2));
    let Q2 = n2, E2 = g2, u2 = await i2;
    for (const e3 of l2) {
      const t3 = Q2, i3 = E2;
      Q2 = Math.floor(Q2 / e3) - 1;
      E2 = Math.floor(E2 / e3) - 1;
      const a3 = new OffscreenCanvas(Q2, E2);
      a3.getContext("2d").drawImage(u2, 0, 0, t3, i3, 0, 0, Q2, E2);
      u2 = a3.transferToImageBitmap();
    }
    r2.data = null;
    r2.bitmap = u2;
    r2.width = Q2;
    r2.height = E2;
    return r2;
  }
  _encodeBMP() {
    const { width: e2, height: t2, kind: i2 } = this._imgData;
    let a2, s2 = this._imgData.data, r2 = new Uint8Array(0), n2 = r2, g2 = 0;
    switch (i2) {
      case b: {
        a2 = 1;
        r2 = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
        const i4 = e2 + 7 >> 3, n3 = i4 + 3 & -4;
        if (i4 !== n3) {
          const e3 = new Uint8Array(n3 * t2);
          let a3 = 0;
          for (let r3 = 0, g3 = t2 * i4; r3 < g3; r3 += i4, a3 += n3)
            e3.set(s2.subarray(r3, r3 + i4), a3);
          s2 = e3;
        }
        break;
      }
      case F:
        a2 = 24;
        if (3 & e2) {
          const i4 = 3 * e2, a3 = i4 + 3 & -4, r3 = a3 - i4, n3 = new Uint8Array(a3 * t2);
          let g3 = 0;
          for (let e3 = 0, a4 = t2 * i4; e3 < a4; e3 += i4) {
            const t3 = s2.subarray(e3, e3 + i4);
            for (let e4 = 0; e4 < i4; e4 += 3) {
              n3[g3++] = t3[e4 + 2];
              n3[g3++] = t3[e4 + 1];
              n3[g3++] = t3[e4];
            }
            g3 += r3;
          }
          s2 = n3;
        } else
          for (let e3 = 0, t3 = s2.length; e3 < t3; e3 += 3) {
            const t4 = s2[e3];
            s2[e3] = s2[e3 + 2];
            s2[e3 + 2] = t4;
          }
        break;
      case S:
        a2 = 32;
        g2 = 3;
        n2 = new Uint8Array(68);
        const i3 = new DataView(n2.buffer);
        if (FeatureTest.isLittleEndian) {
          i3.setUint32(0, 255, true);
          i3.setUint32(4, 65280, true);
          i3.setUint32(8, 16711680, true);
          i3.setUint32(12, 4278190080, true);
        } else {
          i3.setUint32(0, 4278190080, true);
          i3.setUint32(4, 16711680, true);
          i3.setUint32(8, 65280, true);
          i3.setUint32(12, 255, true);
        }
        break;
      default:
        throw new Error("invalid format");
    }
    let o2 = 0;
    const c2 = 40 + n2.length, C2 = 14 + c2 + r2.length + s2.length, h2 = new Uint8Array(C2), l2 = new DataView(h2.buffer);
    l2.setUint16(o2, 19778, true);
    o2 += 2;
    l2.setUint32(o2, C2, true);
    o2 += 4;
    l2.setUint32(o2, 0, true);
    o2 += 4;
    l2.setUint32(o2, 14 + c2 + r2.length, true);
    o2 += 4;
    l2.setUint32(o2, c2, true);
    o2 += 4;
    l2.setInt32(o2, e2, true);
    o2 += 4;
    l2.setInt32(o2, -t2, true);
    o2 += 4;
    l2.setUint16(o2, 1, true);
    o2 += 2;
    l2.setUint16(o2, a2, true);
    o2 += 2;
    l2.setUint32(o2, g2, true);
    o2 += 4;
    l2.setUint32(o2, 0, true);
    o2 += 4;
    l2.setInt32(o2, 0, true);
    o2 += 4;
    l2.setInt32(o2, 0, true);
    o2 += 4;
    l2.setUint32(o2, r2.length / 4, true);
    o2 += 4;
    l2.setUint32(o2, 0, true);
    o2 += 4;
    h2.set(n2, o2);
    o2 += n2.length;
    h2.set(r2, o2);
    o2 += r2.length;
    h2.set(s2, o2);
    return h2;
  }
};
ImageResizer._goodSquareLength = 2048;
var bs = 3285377520;
var Fs = 4294901760;
var Ss = 65535;
var MurmurHash3_64 = class {
  constructor(e2) {
    this.h1 = e2 ? 4294967295 & e2 : bs;
    this.h2 = e2 ? 4294967295 & e2 : bs;
  }
  update(e2) {
    let t2, i2;
    if ("string" == typeof e2) {
      t2 = new Uint8Array(2 * e2.length);
      i2 = 0;
      for (let a3 = 0, s3 = e2.length; a3 < s3; a3++) {
        const s4 = e2.charCodeAt(a3);
        if (s4 <= 255)
          t2[i2++] = s4;
        else {
          t2[i2++] = s4 >>> 8;
          t2[i2++] = 255 & s4;
        }
      }
    } else {
      if (!ArrayBuffer.isView(e2))
        throw new Error("Invalid data format, must be a string or TypedArray.");
      t2 = e2.slice();
      i2 = t2.byteLength;
    }
    const a2 = i2 >> 2, s2 = i2 - 4 * a2, r2 = new Uint32Array(t2.buffer, 0, a2);
    let n2 = 0, g2 = 0, o2 = this.h1, c2 = this.h2;
    const C2 = 3432918353, h2 = 461845907, l2 = 11601, Q2 = 13715;
    for (let e3 = 0; e3 < a2; e3++)
      if (1 & e3) {
        n2 = r2[e3];
        n2 = n2 * C2 & Fs | n2 * l2 & Ss;
        n2 = n2 << 15 | n2 >>> 17;
        n2 = n2 * h2 & Fs | n2 * Q2 & Ss;
        o2 ^= n2;
        o2 = o2 << 13 | o2 >>> 19;
        o2 = 5 * o2 + 3864292196;
      } else {
        g2 = r2[e3];
        g2 = g2 * C2 & Fs | g2 * l2 & Ss;
        g2 = g2 << 15 | g2 >>> 17;
        g2 = g2 * h2 & Fs | g2 * Q2 & Ss;
        c2 ^= g2;
        c2 = c2 << 13 | c2 >>> 19;
        c2 = 5 * c2 + 3864292196;
      }
    n2 = 0;
    switch (s2) {
      case 3:
        n2 ^= t2[4 * a2 + 2] << 16;
      case 2:
        n2 ^= t2[4 * a2 + 1] << 8;
      case 1:
        n2 ^= t2[4 * a2];
        n2 = n2 * C2 & Fs | n2 * l2 & Ss;
        n2 = n2 << 15 | n2 >>> 17;
        n2 = n2 * h2 & Fs | n2 * Q2 & Ss;
        1 & a2 ? o2 ^= n2 : c2 ^= n2;
    }
    this.h1 = o2;
    this.h2 = c2;
  }
  hexdigest() {
    let e2 = this.h1, t2 = this.h2;
    e2 ^= t2 >>> 1;
    e2 = 3981806797 * e2 & Fs | 36045 * e2 & Ss;
    t2 = 4283543511 * t2 & Fs | (2950163797 * (t2 << 16 | e2 >>> 16) & Fs) >>> 16;
    e2 ^= t2 >>> 1;
    e2 = 444984403 * e2 & Fs | 60499 * e2 & Ss;
    t2 = 3301882366 * t2 & Fs | (3120437893 * (t2 << 16 | e2 >>> 16) & Fs) >>> 16;
    e2 ^= t2 >>> 1;
    return (e2 >>> 0).toString(16).padStart(8, "0") + (t2 >>> 0).toString(16).padStart(8, "0");
  }
};
function addState(e2, t2, i2, a2, s2) {
  let r2 = e2;
  for (let e3 = 0, i3 = t2.length - 1; e3 < i3; e3++) {
    const i4 = t2[e3];
    r2 = r2[i4] || (r2[i4] = []);
  }
  r2[t2.at(-1)] = { checkFn: i2, iterateFn: a2, processFn: s2 };
}
var ks = [];
addState(ks, [xA, MA, _e, UA], null, function iterateInlineImageGroup(e2, t2) {
  const i2 = e2.fnArray, a2 = (t2 - (e2.iCurr - 3)) % 4;
  switch (a2) {
    case 0:
      return i2[t2] === xA;
    case 1:
      return i2[t2] === MA;
    case 2:
      return i2[t2] === _e;
    case 3:
      return i2[t2] === UA;
  }
  throw new Error(`iterateInlineImageGroup - invalid pos: ${a2}`);
}, function foundInlineImageGroup(e2, t2) {
  const i2 = e2.fnArray, a2 = e2.argsArray, s2 = e2.iCurr, r2 = s2 - 3, n2 = s2 - 2, g2 = s2 - 1, o2 = Math.min(Math.floor((t2 - r2) / 4), 200);
  if (o2 < 10)
    return t2 - (t2 - r2) % 4;
  let c2 = 0;
  const C2 = [];
  let h2 = 0, l2 = 1, Q2 = 1;
  for (let e3 = 0; e3 < o2; e3++) {
    const t3 = a2[n2 + (e3 << 2)], i3 = a2[g2 + (e3 << 2)][0];
    if (l2 + i3.width > 1e3) {
      c2 = Math.max(c2, l2);
      Q2 += h2 + 2;
      l2 = 0;
      h2 = 0;
    }
    C2.push({ transform: t3, x: l2, y: Q2, w: i3.width, h: i3.height });
    l2 += i3.width + 2;
    h2 = Math.max(h2, i3.height);
  }
  const E2 = Math.max(c2, l2) + 1, u2 = Q2 + h2 + 1, d2 = new Uint8Array(E2 * u2 * 4), f2 = E2 << 2;
  for (let e3 = 0; e3 < o2; e3++) {
    const t3 = a2[g2 + (e3 << 2)][0].data, i3 = C2[e3].w << 2;
    let s3 = 0, r3 = C2[e3].x + C2[e3].y * E2 << 2;
    d2.set(t3.subarray(0, i3), r3 - f2);
    for (let a3 = 0, n3 = C2[e3].h; a3 < n3; a3++) {
      d2.set(t3.subarray(s3, s3 + i3), r3);
      s3 += i3;
      r3 += f2;
    }
    d2.set(t3.subarray(s3 - i3, s3), r3);
    for (; r3 >= 0; ) {
      t3[r3 - 4] = t3[r3];
      t3[r3 - 3] = t3[r3 + 1];
      t3[r3 - 2] = t3[r3 + 2];
      t3[r3 - 1] = t3[r3 + 3];
      t3[r3 + i3] = t3[r3 + i3 - 4];
      t3[r3 + i3 + 1] = t3[r3 + i3 - 3];
      t3[r3 + i3 + 2] = t3[r3 + i3 - 2];
      t3[r3 + i3 + 3] = t3[r3 + i3 - 1];
      r3 -= f2;
    }
  }
  const p2 = { width: E2, height: u2 };
  if (e2.isOffscreenCanvasSupported) {
    const e3 = new OffscreenCanvas(E2, u2);
    e3.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(d2.buffer), E2, u2), 0, 0);
    p2.bitmap = e3.transferToImageBitmap();
    p2.data = null;
  } else {
    p2.kind = S;
    p2.data = d2;
  }
  i2.splice(r2, 4 * o2, $e);
  a2.splice(r2, 4 * o2, [p2, C2]);
  return r2 + 1;
});
addState(ks, [xA, MA, Ze, UA], null, function iterateImageMaskGroup(e2, t2) {
  const i2 = e2.fnArray, a2 = (t2 - (e2.iCurr - 3)) % 4;
  switch (a2) {
    case 0:
      return i2[t2] === xA;
    case 1:
      return i2[t2] === MA;
    case 2:
      return i2[t2] === Ze;
    case 3:
      return i2[t2] === UA;
  }
  throw new Error(`iterateImageMaskGroup - invalid pos: ${a2}`);
}, function foundImageMaskGroup(e2, t2) {
  const i2 = e2.fnArray, a2 = e2.argsArray, s2 = e2.iCurr, r2 = s2 - 3, n2 = s2 - 2, g2 = s2 - 1;
  let o2 = Math.floor((t2 - r2) / 4);
  if (o2 < 10)
    return t2 - (t2 - r2) % 4;
  let c2, C2, h2 = false;
  const l2 = a2[g2][0], Q2 = a2[n2][0], E2 = a2[n2][1], u2 = a2[n2][2], d2 = a2[n2][3];
  if (E2 === u2) {
    h2 = true;
    c2 = n2 + 4;
    let e3 = g2 + 4;
    for (let t3 = 1; t3 < o2; t3++, c2 += 4, e3 += 4) {
      C2 = a2[c2];
      if (a2[e3][0] !== l2 || C2[0] !== Q2 || C2[1] !== E2 || C2[2] !== u2 || C2[3] !== d2) {
        t3 < 10 ? h2 = false : o2 = t3;
        break;
      }
    }
  }
  if (h2) {
    o2 = Math.min(o2, 1e3);
    const e3 = new Float32Array(2 * o2);
    c2 = n2;
    for (let t3 = 0; t3 < o2; t3++, c2 += 4) {
      C2 = a2[c2];
      e3[t3 << 1] = C2[4];
      e3[1 + (t3 << 1)] = C2[5];
    }
    i2.splice(r2, 4 * o2, et);
    a2.splice(r2, 4 * o2, [l2, Q2, E2, u2, d2, e3]);
  } else {
    o2 = Math.min(o2, 100);
    const e3 = [];
    for (let t3 = 0; t3 < o2; t3++) {
      C2 = a2[n2 + (t3 << 2)];
      const i3 = a2[g2 + (t3 << 2)][0];
      e3.push({ data: i3.data, width: i3.width, height: i3.height, interpolate: i3.interpolate, count: i3.count, transform: C2 });
    }
    i2.splice(r2, 4 * o2, Ve);
    a2.splice(r2, 4 * o2, [e3]);
  }
  return r2 + 1;
});
addState(ks, [xA, MA, ze, UA], function(e2) {
  const t2 = e2.argsArray, i2 = e2.iCurr - 2;
  return 0 === t2[i2][1] && 0 === t2[i2][2];
}, function iterateImageGroup(e2, t2) {
  const i2 = e2.fnArray, a2 = e2.argsArray, s2 = (t2 - (e2.iCurr - 3)) % 4;
  switch (s2) {
    case 0:
      return i2[t2] === xA;
    case 1:
      if (i2[t2] !== MA)
        return false;
      const s3 = e2.iCurr - 2, r2 = a2[s3][0], n2 = a2[s3][3];
      return a2[t2][0] === r2 && 0 === a2[t2][1] && 0 === a2[t2][2] && a2[t2][3] === n2;
    case 2:
      if (i2[t2] !== ze)
        return false;
      const g2 = a2[e2.iCurr - 1][0];
      return a2[t2][0] === g2;
    case 3:
      return i2[t2] === UA;
  }
  throw new Error(`iterateImageGroup - invalid pos: ${s2}`);
}, function(e2, t2) {
  const i2 = e2.fnArray, a2 = e2.argsArray, s2 = e2.iCurr, r2 = s2 - 3, n2 = s2 - 2, g2 = a2[s2 - 1][0], o2 = a2[n2][0], c2 = a2[n2][3], C2 = Math.min(Math.floor((t2 - r2) / 4), 1e3);
  if (C2 < 3)
    return t2 - (t2 - r2) % 4;
  const h2 = new Float32Array(2 * C2);
  let l2 = n2;
  for (let e3 = 0; e3 < C2; e3++, l2 += 4) {
    const t3 = a2[l2];
    h2[e3 << 1] = t3[4];
    h2[1 + (e3 << 1)] = t3[5];
  }
  const Q2 = [g2, o2, c2, h2];
  i2.splice(r2, 4 * C2, At);
  a2.splice(r2, 4 * C2, Q2);
  return r2 + 1;
});
addState(ks, [Ae, re, ce, he, ee], null, function iterateShowTextGroup(e2, t2) {
  const i2 = e2.fnArray, a2 = e2.argsArray, s2 = (t2 - (e2.iCurr - 4)) % 5;
  switch (s2) {
    case 0:
      return i2[t2] === Ae;
    case 1:
      return i2[t2] === re;
    case 2:
      return i2[t2] === ce;
    case 3:
      if (i2[t2] !== he)
        return false;
      const s3 = e2.iCurr - 3, r2 = a2[s3][0], n2 = a2[s3][1];
      return a2[t2][0] === r2 && a2[t2][1] === n2;
    case 4:
      return i2[t2] === ee;
  }
  throw new Error(`iterateShowTextGroup - invalid pos: ${s2}`);
}, function(e2, t2) {
  const i2 = e2.fnArray, a2 = e2.argsArray, s2 = e2.iCurr, r2 = s2 - 4, n2 = s2 - 3, g2 = s2 - 2, o2 = s2 - 1, c2 = s2, C2 = a2[n2][0], h2 = a2[n2][1];
  let l2 = Math.min(Math.floor((t2 - r2) / 5), 1e3);
  if (l2 < 3)
    return t2 - (t2 - r2) % 5;
  let Q2 = r2;
  if (r2 >= 4 && i2[r2 - 4] === i2[n2] && i2[r2 - 3] === i2[g2] && i2[r2 - 2] === i2[o2] && i2[r2 - 1] === i2[c2] && a2[r2 - 4][0] === C2 && a2[r2 - 4][1] === h2) {
    l2++;
    Q2 -= 5;
  }
  let E2 = Q2 + 4;
  for (let e3 = 1; e3 < l2; e3++) {
    i2.splice(E2, 3);
    a2.splice(E2, 3);
    E2 += 2;
  }
  return E2 + 1;
});
var NullOptimizer = class {
  constructor(e2) {
    this.queue = e2;
  }
  _optimize() {
  }
  push(e2, t2) {
    this.queue.fnArray.push(e2);
    this.queue.argsArray.push(t2);
    this._optimize();
  }
  flush() {
  }
  reset() {
  }
};
var QueueOptimizer = class extends NullOptimizer {
  constructor(e2) {
    super(e2);
    this.state = null;
    this.context = { iCurr: 0, fnArray: e2.fnArray, argsArray: e2.argsArray, isOffscreenCanvasSupported: false };
    this.match = null;
    this.lastProcessed = 0;
  }
  set isOffscreenCanvasSupported(e2) {
    this.context.isOffscreenCanvasSupported = e2;
  }
  _optimize() {
    const e2 = this.queue.fnArray;
    let t2 = this.lastProcessed, i2 = e2.length, a2 = this.state, s2 = this.match;
    if (!a2 && !s2 && t2 + 1 === i2 && !ks[e2[t2]]) {
      this.lastProcessed = i2;
      return;
    }
    const r2 = this.context;
    for (; t2 < i2; ) {
      if (s2) {
        if ((0, s2.iterateFn)(r2, t2)) {
          t2++;
          continue;
        }
        t2 = (0, s2.processFn)(r2, t2 + 1);
        i2 = e2.length;
        s2 = null;
        a2 = null;
        if (t2 >= i2)
          break;
      }
      a2 = (a2 || ks)[e2[t2]];
      if (a2 && !Array.isArray(a2)) {
        r2.iCurr = t2;
        t2++;
        if (!a2.checkFn || (0, a2.checkFn)(r2)) {
          s2 = a2;
          a2 = null;
        } else
          a2 = null;
      } else
        t2++;
    }
    this.state = a2;
    this.match = s2;
    this.lastProcessed = t2;
  }
  flush() {
    for (; this.match; ) {
      const e2 = this.queue.fnArray.length;
      this.lastProcessed = (0, this.match.processFn)(this.context, e2);
      this.match = null;
      this.state = null;
      this._optimize();
    }
  }
  reset() {
    this.state = null;
    this.match = null;
    this.lastProcessed = 0;
  }
};
var _OperatorList = class _OperatorList {
  constructor(e2 = 0, t2) {
    this._streamSink = t2;
    this.fnArray = [];
    this.argsArray = [];
    this.optimizer = !t2 || e2 & E ? new NullOptimizer(this) : new QueueOptimizer(this);
    this.dependencies = /* @__PURE__ */ new Set();
    this._totalLength = 0;
    this.weight = 0;
    this._resolved = t2 ? null : Promise.resolve();
  }
  set isOffscreenCanvasSupported(e2) {
    this.optimizer.isOffscreenCanvasSupported = e2;
  }
  get length() {
    return this.argsArray.length;
  }
  get ready() {
    return this._resolved || this._streamSink.ready;
  }
  get totalLength() {
    return this._totalLength + this.length;
  }
  addOp(e2, t2) {
    this.optimizer.push(e2, t2);
    this.weight++;
    this._streamSink && (this.weight >= _OperatorList.CHUNK_SIZE || this.weight >= _OperatorList.CHUNK_SIZE_ABOUT && (e2 === UA || e2 === ee)) && this.flush();
  }
  addImageOps(e2, t2, i2) {
    void 0 !== i2 && this.addOp(Ye, ["OC", i2]);
    this.addOp(e2, t2);
    void 0 !== i2 && this.addOp(ve, []);
  }
  addDependency(e2) {
    if (!this.dependencies.has(e2)) {
      this.dependencies.add(e2);
      this.addOp(wA, [e2]);
    }
  }
  addDependencies(e2) {
    for (const t2 of e2)
      this.addDependency(t2);
  }
  addOpList(e2) {
    if (e2 instanceof _OperatorList) {
      for (const t2 of e2.dependencies)
        this.dependencies.add(t2);
      for (let t2 = 0, i2 = e2.length; t2 < i2; t2++)
        this.addOp(e2.fnArray[t2], e2.argsArray[t2]);
    } else
      warn('addOpList - ignoring invalid "opList" parameter.');
  }
  getIR() {
    return { fnArray: this.fnArray, argsArray: this.argsArray, length: this.length };
  }
  get _transfers() {
    var _a4;
    const e2 = [], { fnArray: t2, argsArray: i2, length: a2 } = this;
    for (let s2 = 0; s2 < a2; s2++)
      switch (t2[s2]) {
        case _e:
        case $e:
        case Ze:
          const t3 = i2[s2][0];
          !t3.cached && ((_a4 = t3.data) == null ? void 0 : _a4.buffer) instanceof ArrayBuffer && e2.push(t3.data.buffer);
      }
    return e2;
  }
  flush(e2 = false, t2 = null) {
    this.optimizer.flush();
    const i2 = this.length;
    this._totalLength += i2;
    this._streamSink.enqueue({ fnArray: this.fnArray, argsArray: this.argsArray, lastChunk: e2, separateAnnots: t2, length: i2 }, 1, this._transfers);
    this.dependencies.clear();
    this.fnArray.length = 0;
    this.argsArray.length = 0;
    this.weight = 0;
    this.optimizer.reset();
  }
};
__publicField(_OperatorList, "CHUNK_SIZE", 1e3);
__publicField(_OperatorList, "CHUNK_SIZE_ABOUT", _OperatorList.CHUNK_SIZE - 5);
var OperatorList = _OperatorList;
function decodeAndClamp(e2, t2, i2, a2) {
  (e2 = t2 + e2 * i2) < 0 ? e2 = 0 : e2 > a2 && (e2 = a2);
  return e2;
}
function resizeImageMask(e2, t2, i2, a2, s2, r2) {
  const n2 = s2 * r2;
  let g2;
  g2 = t2 <= 8 ? new Uint8Array(n2) : t2 <= 16 ? new Uint16Array(n2) : new Uint32Array(n2);
  const o2 = i2 / s2, c2 = a2 / r2;
  let C2, h2, l2, Q2, E2 = 0;
  const u2 = new Uint16Array(s2), d2 = i2;
  for (C2 = 0; C2 < s2; C2++)
    u2[C2] = Math.floor(C2 * o2);
  for (C2 = 0; C2 < r2; C2++) {
    l2 = Math.floor(C2 * c2) * d2;
    for (h2 = 0; h2 < s2; h2++) {
      Q2 = l2 + u2[h2];
      g2[E2++] = e2[Q2];
    }
  }
  return g2;
}
var PDFImage = class _PDFImage {
  constructor({ xref: e2, res: t2, image: i2, isInline: a2 = false, smask: s2 = null, mask: r2 = null, isMask: n2 = false, pdfFunctionFactory: g2, localColorSpaceCache: o2 }) {
    var _a4, _b2;
    this.image = i2;
    const c2 = i2.dict, C2 = c2.get("F", "Filter");
    let h2;
    if (C2 instanceof Name)
      h2 = C2.name;
    else if (Array.isArray(C2)) {
      const t3 = e2.fetchIfRef(C2[0]);
      t3 instanceof Name && (h2 = t3.name);
    }
    switch (h2) {
      case "JPXDecode":
        ({ width: i2.width, height: i2.height, componentsCount: i2.numComps, bitsPerComponent: i2.bitsPerComponent } = JpxImage.parseImageProperties(i2.stream));
        i2.stream.reset();
        this.jpxDecoderOptions = { numComponents: 0, isIndexedColormap: false, smaskInData: c2.has("SMaskInData") };
        break;
      case "JBIG2Decode":
        i2.bitsPerComponent = 1;
        i2.numComps = 1;
    }
    let l2 = c2.get("W", "Width"), Q2 = c2.get("H", "Height");
    if (Number.isInteger(i2.width) && i2.width > 0 && Number.isInteger(i2.height) && i2.height > 0 && (i2.width !== l2 || i2.height !== Q2)) {
      warn("PDFImage - using the Width/Height of the image data, rather than the image dictionary.");
      l2 = i2.width;
      Q2 = i2.height;
    }
    if (l2 < 1 || Q2 < 1)
      throw new FormatError(`Invalid image width: ${l2} or height: ${Q2}`);
    this.width = l2;
    this.height = Q2;
    this.interpolate = c2.get("I", "Interpolate");
    this.imageMask = c2.get("IM", "ImageMask") || false;
    this.matte = c2.get("Matte") || false;
    let E2 = i2.bitsPerComponent;
    if (!E2) {
      E2 = c2.get("BPC", "BitsPerComponent");
      if (!E2) {
        if (!this.imageMask)
          throw new FormatError(`Bits per component missing in image: ${this.imageMask}`);
        E2 = 1;
      }
    }
    this.bpc = E2;
    if (!this.imageMask) {
      let s3 = c2.getRaw("CS") || c2.getRaw("ColorSpace");
      const r3 = !!s3;
      if (r3)
        ((_a4 = this.jpxDecoderOptions) == null ? void 0 : _a4.smaskInData) && (s3 = Name.get("DeviceRGBA"));
      else if (this.jpxDecoderOptions)
        s3 = Name.get("DeviceRGBA");
      else
        switch (i2.numComps) {
          case 1:
            s3 = Name.get("DeviceGray");
            break;
          case 3:
            s3 = Name.get("DeviceRGB");
            break;
          case 4:
            s3 = Name.get("DeviceCMYK");
            break;
          default:
            throw new Error(`Images with ${i2.numComps} color components not supported.`);
        }
      this.colorSpace = ColorSpace.parse({ cs: s3, xref: e2, resources: a2 ? t2 : null, pdfFunctionFactory: g2, localColorSpaceCache: o2 });
      this.numComps = this.colorSpace.numComps;
      if (this.jpxDecoderOptions) {
        this.jpxDecoderOptions.numComponents = r3 ? this.numComp : 0;
        this.jpxDecoderOptions.isIndexedColormap = "Indexed" === this.colorSpace.name;
      }
    }
    this.decode = c2.getArray("D", "Decode");
    this.needsDecode = false;
    if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, E2) || n2 && !ColorSpace.isDefaultDecode(this.decode, 1))) {
      this.needsDecode = true;
      const e3 = (1 << E2) - 1;
      this.decodeCoefficients = [];
      this.decodeAddends = [];
      const t3 = "Indexed" === ((_b2 = this.colorSpace) == null ? void 0 : _b2.name);
      for (let i3 = 0, a3 = 0; i3 < this.decode.length; i3 += 2, ++a3) {
        const s3 = this.decode[i3], r3 = this.decode[i3 + 1];
        this.decodeCoefficients[a3] = t3 ? (r3 - s3) / e3 : r3 - s3;
        this.decodeAddends[a3] = t3 ? s3 : e3 * s3;
      }
    }
    if (s2)
      this.smask = new _PDFImage({ xref: e2, res: t2, image: s2, isInline: a2, pdfFunctionFactory: g2, localColorSpaceCache: o2 });
    else if (r2)
      if (r2 instanceof BaseStream) {
        r2.dict.get("IM", "ImageMask") ? this.mask = new _PDFImage({ xref: e2, res: t2, image: r2, isInline: a2, isMask: true, pdfFunctionFactory: g2, localColorSpaceCache: o2 }) : warn("Ignoring /Mask in image without /ImageMask.");
      } else
        this.mask = r2;
  }
  static async buildImage({ xref: e2, res: t2, image: i2, isInline: a2 = false, pdfFunctionFactory: s2, localColorSpaceCache: r2 }) {
    const n2 = i2;
    let g2 = null, o2 = null;
    const c2 = i2.dict.get("SMask"), C2 = i2.dict.get("Mask");
    c2 ? c2 instanceof BaseStream ? g2 = c2 : warn("Unsupported /SMask format.") : C2 && (C2 instanceof BaseStream || Array.isArray(C2) ? o2 = C2 : warn("Unsupported /Mask format."));
    return new _PDFImage({ xref: e2, res: t2, image: n2, isInline: a2, smask: g2, mask: o2, pdfFunctionFactory: s2, localColorSpaceCache: r2 });
  }
  static createRawMask({ imgArray: e2, width: t2, height: i2, imageIsFromDecodeStream: a2, inverseDecode: s2, interpolate: r2 }) {
    const n2 = (t2 + 7 >> 3) * i2, g2 = e2.byteLength;
    let o2, c2;
    if (!a2 || s2 && !(n2 === g2))
      if (s2) {
        o2 = new Uint8Array(n2);
        o2.set(e2);
        o2.fill(255, g2);
      } else
        o2 = new Uint8Array(e2);
    else
      o2 = e2;
    if (s2)
      for (c2 = 0; c2 < g2; c2++)
        o2[c2] ^= 255;
    return { data: o2, width: t2, height: i2, interpolate: r2 };
  }
  static async createMask({ imgArray: e2, width: t2, height: i2, imageIsFromDecodeStream: a2, inverseDecode: s2, interpolate: r2, isOffscreenCanvasSupported: n2 = false }) {
    const g2 = 1 === t2 && 1 === i2 && s2 === (0 === e2.length || !!(128 & e2[0]));
    if (g2)
      return { isSingleOpaquePixel: g2 };
    if (n2) {
      if (ImageResizer.needsToBeResized(t2, i2)) {
        const a4 = new Uint8ClampedArray(t2 * i2 * 4);
        convertBlackAndWhiteToRGBA({ src: e2, dest: a4, width: t2, height: i2, nonBlackColor: 0, inverseDecode: s2 });
        return ImageResizer.createImage({ kind: S, data: a4, width: t2, height: i2, interpolate: r2 });
      }
      const a3 = new OffscreenCanvas(t2, i2), n3 = a3.getContext("2d"), g3 = n3.createImageData(t2, i2);
      convertBlackAndWhiteToRGBA({ src: e2, dest: g3.data, width: t2, height: i2, nonBlackColor: 0, inverseDecode: s2 });
      n3.putImageData(g3, 0, 0);
      return { data: null, width: t2, height: i2, interpolate: r2, bitmap: a3.transferToImageBitmap() };
    }
    return this.createRawMask({ imgArray: e2, width: t2, height: i2, inverseDecode: s2, imageIsFromDecodeStream: a2, interpolate: r2 });
  }
  get drawWidth() {
    var _a4, _b2;
    return Math.max(this.width, ((_a4 = this.smask) == null ? void 0 : _a4.width) || 0, ((_b2 = this.mask) == null ? void 0 : _b2.width) || 0);
  }
  get drawHeight() {
    var _a4, _b2;
    return Math.max(this.height, ((_a4 = this.smask) == null ? void 0 : _a4.height) || 0, ((_b2 = this.mask) == null ? void 0 : _b2.height) || 0);
  }
  decodeBuffer(e2) {
    const t2 = this.bpc, i2 = this.numComps, a2 = this.decodeAddends, s2 = this.decodeCoefficients, r2 = (1 << t2) - 1;
    let n2, g2;
    if (1 === t2) {
      for (n2 = 0, g2 = e2.length; n2 < g2; n2++)
        e2[n2] = +!e2[n2];
      return;
    }
    let o2 = 0;
    for (n2 = 0, g2 = this.width * this.height; n2 < g2; n2++)
      for (let t3 = 0; t3 < i2; t3++) {
        e2[o2] = decodeAndClamp(e2[o2], a2[t3], s2[t3], r2);
        o2++;
      }
  }
  getComponents(e2) {
    const t2 = this.bpc;
    if (8 === t2)
      return e2;
    const i2 = this.width, a2 = this.height, s2 = this.numComps, r2 = i2 * a2 * s2;
    let n2, g2 = 0;
    n2 = t2 <= 8 ? new Uint8Array(r2) : t2 <= 16 ? new Uint16Array(r2) : new Uint32Array(r2);
    const o2 = i2 * s2, c2 = (1 << t2) - 1;
    let C2, h2, l2 = 0;
    if (1 === t2) {
      let t3, i3, s3;
      for (let r3 = 0; r3 < a2; r3++) {
        i3 = l2 + (-8 & o2);
        s3 = l2 + o2;
        for (; l2 < i3; ) {
          h2 = e2[g2++];
          n2[l2] = h2 >> 7 & 1;
          n2[l2 + 1] = h2 >> 6 & 1;
          n2[l2 + 2] = h2 >> 5 & 1;
          n2[l2 + 3] = h2 >> 4 & 1;
          n2[l2 + 4] = h2 >> 3 & 1;
          n2[l2 + 5] = h2 >> 2 & 1;
          n2[l2 + 6] = h2 >> 1 & 1;
          n2[l2 + 7] = 1 & h2;
          l2 += 8;
        }
        if (l2 < s3) {
          h2 = e2[g2++];
          t3 = 128;
          for (; l2 < s3; ) {
            n2[l2++] = +!!(h2 & t3);
            t3 >>= 1;
          }
        }
      }
    } else {
      let i3 = 0;
      h2 = 0;
      for (l2 = 0, C2 = r2; l2 < C2; ++l2) {
        if (l2 % o2 == 0) {
          h2 = 0;
          i3 = 0;
        }
        for (; i3 < t2; ) {
          h2 = h2 << 8 | e2[g2++];
          i3 += 8;
        }
        const a3 = i3 - t2;
        let s3 = h2 >> a3;
        s3 < 0 ? s3 = 0 : s3 > c2 && (s3 = c2);
        n2[l2] = s3;
        h2 &= (1 << a3) - 1;
        i3 = a3;
      }
    }
    return n2;
  }
  async fillOpacity(e2, t2, i2, a2, s2) {
    const r2 = this.smask, n2 = this.mask;
    let g2, o2, c2, C2, h2, l2;
    if (r2) {
      o2 = r2.width;
      c2 = r2.height;
      g2 = new Uint8ClampedArray(o2 * c2);
      await r2.fillGrayBuffer(g2);
      o2 === t2 && c2 === i2 || (g2 = resizeImageMask(g2, r2.bpc, o2, c2, t2, i2));
    } else if (n2)
      if (n2 instanceof _PDFImage) {
        o2 = n2.width;
        c2 = n2.height;
        g2 = new Uint8ClampedArray(o2 * c2);
        n2.numComps = 1;
        await n2.fillGrayBuffer(g2);
        for (C2 = 0, h2 = o2 * c2; C2 < h2; ++C2)
          g2[C2] = 255 - g2[C2];
        o2 === t2 && c2 === i2 || (g2 = resizeImageMask(g2, n2.bpc, o2, c2, t2, i2));
      } else {
        if (!Array.isArray(n2))
          throw new FormatError("Unknown mask format.");
        {
          g2 = new Uint8ClampedArray(t2 * i2);
          const e3 = this.numComps;
          for (C2 = 0, h2 = t2 * i2; C2 < h2; ++C2) {
            let t3 = 0;
            const i3 = C2 * e3;
            for (l2 = 0; l2 < e3; ++l2) {
              const e4 = s2[i3 + l2], a3 = 2 * l2;
              if (e4 < n2[a3] || e4 > n2[a3 + 1]) {
                t3 = 255;
                break;
              }
            }
            g2[C2] = t3;
          }
        }
      }
    if (g2)
      for (C2 = 0, l2 = 3, h2 = t2 * a2; C2 < h2; ++C2, l2 += 4)
        e2[l2] = g2[C2];
    else
      for (C2 = 0, l2 = 3, h2 = t2 * a2; C2 < h2; ++C2, l2 += 4)
        e2[l2] = 255;
  }
  undoPreblend(e2, t2, i2) {
    var _a4;
    const a2 = (_a4 = this.smask) == null ? void 0 : _a4.matte;
    if (!a2)
      return;
    const s2 = this.colorSpace.getRgb(a2, 0), r2 = s2[0], n2 = s2[1], g2 = s2[2], o2 = t2 * i2 * 4;
    for (let t3 = 0; t3 < o2; t3 += 4) {
      const i3 = e2[t3 + 3];
      if (0 === i3) {
        e2[t3] = 255;
        e2[t3 + 1] = 255;
        e2[t3 + 2] = 255;
        continue;
      }
      const a3 = 255 / i3;
      e2[t3] = (e2[t3] - r2) * a3 + r2;
      e2[t3 + 1] = (e2[t3 + 1] - n2) * a3 + n2;
      e2[t3 + 2] = (e2[t3 + 2] - g2) * a3 + g2;
    }
  }
  async createImageData(e2 = false, t2 = false) {
    const i2 = this.drawWidth, a2 = this.drawHeight, s2 = { width: i2, height: a2, interpolate: this.interpolate, kind: 0, data: null }, r2 = this.numComps, n2 = this.width, g2 = this.height, o2 = this.bpc, c2 = n2 * r2 * o2 + 7 >> 3, C2 = t2 && ImageResizer.needsToBeResized(i2, a2);
    if ("DeviceRGBA" === this.colorSpace.name) {
      s2.kind = S;
      const e3 = s2.data = await this.getImageBytes(g2 * n2 * 4, {});
      return t2 ? C2 ? ImageResizer.createImage(s2, false) : this.createBitmap(S, i2, a2, e3) : s2;
    }
    if (!e2) {
      let e3;
      "DeviceGray" === this.colorSpace.name && 1 === o2 ? e3 = b : "DeviceRGB" !== this.colorSpace.name || 8 !== o2 || this.needsDecode || (e3 = F);
      if (e3 && !this.smask && !this.mask && i2 === n2 && a2 === g2) {
        const r3 = await this.getImageBytes(g2 * c2, {});
        if (t2)
          return C2 ? ImageResizer.createImage({ data: r3, kind: e3, width: i2, height: a2, interpolate: this.interpolate }, this.needsDecode) : this.createBitmap(e3, n2, g2, r3);
        s2.kind = e3;
        s2.data = r3;
        if (this.needsDecode) {
          assert(e3 === b, "PDFImage.createImageData: The image must be grayscale.");
          const t3 = s2.data;
          for (let e4 = 0, i3 = t3.length; e4 < i3; e4++)
            t3[e4] ^= 255;
        }
        return s2;
      }
      if (this.image instanceof JpegStream && !this.smask && !this.mask && !this.needsDecode) {
        let e4 = g2 * c2;
        if (t2 && !C2) {
          let t3 = false;
          switch (this.colorSpace.name) {
            case "DeviceGray":
              e4 *= 4;
              t3 = true;
              break;
            case "DeviceRGB":
              e4 = e4 / 3 * 4;
              t3 = true;
              break;
            case "DeviceCMYK":
              t3 = true;
          }
          if (t3) {
            const t4 = await this.getImageBytes(e4, { drawWidth: i2, drawHeight: a2, forceRGBA: true });
            return this.createBitmap(S, i2, a2, t4);
          }
        } else
          switch (this.colorSpace.name) {
            case "DeviceGray":
              e4 *= 3;
            case "DeviceRGB":
            case "DeviceCMYK":
              s2.kind = F;
              s2.data = await this.getImageBytes(e4, { drawWidth: i2, drawHeight: a2, forceRGB: true });
              return C2 ? ImageResizer.createImage(s2) : s2;
          }
      }
    }
    const h2 = await this.getImageBytes(g2 * c2, { internal: true }), l2 = 0 | h2.length / c2 * a2 / g2, Q2 = this.getComponents(h2);
    let E2, u2, d2, f2, p2, m2;
    if (t2 && !C2) {
      d2 = new OffscreenCanvas(i2, a2);
      f2 = d2.getContext("2d");
      p2 = f2.createImageData(i2, a2);
      m2 = p2.data;
    }
    s2.kind = S;
    if (e2 || this.smask || this.mask) {
      t2 && !C2 || (m2 = new Uint8ClampedArray(i2 * a2 * 4));
      E2 = 1;
      u2 = true;
      await this.fillOpacity(m2, i2, a2, l2, Q2);
    } else {
      if (!t2 || C2) {
        s2.kind = F;
        m2 = new Uint8ClampedArray(i2 * a2 * 3);
        E2 = 0;
      } else {
        new Uint32Array(m2.buffer).fill(FeatureTest.isLittleEndian ? 4278190080 : 255);
        E2 = 1;
      }
      u2 = false;
    }
    this.needsDecode && this.decodeBuffer(Q2);
    this.colorSpace.fillRgb(m2, n2, g2, i2, a2, l2, o2, Q2, E2);
    u2 && this.undoPreblend(m2, i2, l2);
    if (t2 && !C2) {
      f2.putImageData(p2, 0, 0);
      return { data: null, width: i2, height: a2, bitmap: d2.transferToImageBitmap(), interpolate: this.interpolate };
    }
    s2.data = m2;
    return C2 ? ImageResizer.createImage(s2) : s2;
  }
  async fillGrayBuffer(e2) {
    const t2 = this.numComps;
    if (1 !== t2)
      throw new FormatError(`Reading gray scale from a color image: ${t2}`);
    const i2 = this.width, a2 = this.height, s2 = this.bpc, r2 = i2 * t2 * s2 + 7 >> 3, n2 = await this.getImageBytes(a2 * r2, { internal: true }), g2 = this.getComponents(n2);
    let o2, c2;
    if (1 === s2) {
      c2 = i2 * a2;
      if (this.needsDecode)
        for (o2 = 0; o2 < c2; ++o2)
          e2[o2] = g2[o2] - 1 & 255;
      else
        for (o2 = 0; o2 < c2; ++o2)
          e2[o2] = 255 & -g2[o2];
      return;
    }
    this.needsDecode && this.decodeBuffer(g2);
    c2 = i2 * a2;
    const C2 = 255 / ((1 << s2) - 1);
    for (o2 = 0; o2 < c2; ++o2)
      e2[o2] = C2 * g2[o2];
  }
  createBitmap(e2, t2, i2, a2) {
    const s2 = new OffscreenCanvas(t2, i2), r2 = s2.getContext("2d");
    let n2;
    if (e2 === S)
      n2 = new ImageData(a2, t2, i2);
    else {
      n2 = r2.createImageData(t2, i2);
      convertToRGBA({ kind: e2, src: a2, dest: new Uint32Array(n2.data.buffer), width: t2, height: i2, inverseDecode: this.needsDecode });
    }
    r2.putImageData(n2, 0, 0);
    return { data: null, width: t2, height: i2, bitmap: s2.transferToImageBitmap(), interpolate: this.interpolate };
  }
  async getImageBytes(e2, { drawWidth: t2, drawHeight: i2, forceRGBA: a2 = false, forceRGB: s2 = false, internal: r2 = false }) {
    this.image.reset();
    this.image.drawWidth = t2 || this.width;
    this.image.drawHeight = i2 || this.height;
    this.image.forceRGBA = !!a2;
    this.image.forceRGB = !!s2;
    const n2 = await this.image.getImageData(e2, this.jpxDecoderOptions);
    if (r2 || this.image instanceof DecodeStream)
      return n2;
    assert(n2 instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.');
    return new Uint8Array(n2);
  }
};
var Rs = Object.freeze({ maxImageSize: -1, disableFontFace: false, ignoreErrors: false, isEvalSupported: true, isOffscreenCanvasSupported: false, canvasMaxAreaInBytes: -1, fontExtraProperties: false, useSystemFonts: true, cMapUrl: null, standardFontDataUrl: null });
var Ns = 1;
var Gs = 2;
var xs = Promise.resolve();
function normalizeBlendMode(e2, t2 = false) {
  if (Array.isArray(e2)) {
    for (const t3 of e2) {
      const e3 = normalizeBlendMode(t3, true);
      if (e3)
        return e3;
    }
    warn(`Unsupported blend mode Array: ${e2}`);
    return "source-over";
  }
  if (!(e2 instanceof Name))
    return t2 ? null : "source-over";
  switch (e2.name) {
    case "Normal":
    case "Compatible":
      return "source-over";
    case "Multiply":
      return "multiply";
    case "Screen":
      return "screen";
    case "Overlay":
      return "overlay";
    case "Darken":
      return "darken";
    case "Lighten":
      return "lighten";
    case "ColorDodge":
      return "color-dodge";
    case "ColorBurn":
      return "color-burn";
    case "HardLight":
      return "hard-light";
    case "SoftLight":
      return "soft-light";
    case "Difference":
      return "difference";
    case "Exclusion":
      return "exclusion";
    case "Hue":
      return "hue";
    case "Saturation":
      return "saturation";
    case "Color":
      return "color";
    case "Luminosity":
      return "luminosity";
  }
  if (t2)
    return null;
  warn(`Unsupported blend mode: ${e2.name}`);
  return "source-over";
}
function addLocallyCachedImageOps(e2, t2) {
  var _a4;
  t2.objId && e2.addDependency(t2.objId);
  e2.addImageOps(t2.fn, t2.args, t2.optionalContent);
  t2.fn === Ze && ((_a4 = t2.args[0]) == null ? void 0 : _a4.count) > 0 && t2.args[0].count++;
}
var _TimeSlotManager = class _TimeSlotManager {
  constructor() {
    this.reset();
  }
  check() {
    if (++this.checked < _TimeSlotManager.CHECK_TIME_EVERY)
      return false;
    this.checked = 0;
    return this.endTime <= Date.now();
  }
  reset() {
    this.endTime = Date.now() + _TimeSlotManager.TIME_SLOT_DURATION_MS;
    this.checked = 0;
  }
};
__publicField(_TimeSlotManager, "TIME_SLOT_DURATION_MS", 20);
__publicField(_TimeSlotManager, "CHECK_TIME_EVERY", 100);
var TimeSlotManager = _TimeSlotManager;
var PartialEvaluator = class _PartialEvaluator {
  constructor({ xref: e2, handler: t2, pageIndex: i2, idFactory: a2, fontCache: s2, builtInCMapCache: r2, standardFontDataCache: n2, globalImageCache: g2, systemFontCache: o2, options: c2 = null }) {
    this.xref = e2;
    this.handler = t2;
    this.pageIndex = i2;
    this.idFactory = a2;
    this.fontCache = s2;
    this.builtInCMapCache = r2;
    this.standardFontDataCache = n2;
    this.globalImageCache = g2;
    this.systemFontCache = o2;
    this.options = c2 || Rs;
    this.type3FontRefs = null;
    this._regionalImageCache = new RegionalImageCache();
    this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
    ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
  }
  get _pdfFunctionFactory() {
    return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.options.isEvalSupported }));
  }
  get parsingType3Font() {
    return !!this.type3FontRefs;
  }
  clone(e2 = null) {
    const t2 = Object.create(this);
    t2.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, e2);
    return t2;
  }
  hasBlendModes(e2, t2) {
    if (!(e2 instanceof Dict))
      return false;
    if (e2.objId && t2.has(e2.objId))
      return false;
    const i2 = new RefSet(t2);
    e2.objId && i2.put(e2.objId);
    const a2 = [e2], s2 = this.xref;
    for (; a2.length; ) {
      const e3 = a2.shift(), t3 = e3.get("ExtGState");
      if (t3 instanceof Dict)
        for (let e4 of t3.getRawValues()) {
          if (e4 instanceof Ref) {
            if (i2.has(e4))
              continue;
            try {
              e4 = s2.fetch(e4);
            } catch (t5) {
              i2.put(e4);
              info(`hasBlendModes - ignoring ExtGState: "${t5}".`);
              continue;
            }
          }
          if (!(e4 instanceof Dict))
            continue;
          e4.objId && i2.put(e4.objId);
          const t4 = e4.get("BM");
          if (t4 instanceof Name) {
            if ("Normal" !== t4.name)
              return true;
          } else if (void 0 !== t4 && Array.isArray(t4)) {
            for (const e5 of t4)
              if (e5 instanceof Name && "Normal" !== e5.name)
                return true;
          }
        }
      const r2 = e3.get("XObject");
      if (r2 instanceof Dict)
        for (let e4 of r2.getRawValues()) {
          if (e4 instanceof Ref) {
            if (i2.has(e4))
              continue;
            try {
              e4 = s2.fetch(e4);
            } catch (t5) {
              i2.put(e4);
              info(`hasBlendModes - ignoring XObject: "${t5}".`);
              continue;
            }
          }
          if (!(e4 instanceof BaseStream))
            continue;
          e4.dict.objId && i2.put(e4.dict.objId);
          const t4 = e4.dict.get("Resources");
          if (t4 instanceof Dict && (!t4.objId || !i2.has(t4.objId))) {
            a2.push(t4);
            t4.objId && i2.put(t4.objId);
          }
        }
    }
    for (const e3 of i2)
      t2.put(e3);
    return false;
  }
  async fetchBuiltInCMap(e2) {
    const t2 = this.builtInCMapCache.get(e2);
    if (t2)
      return t2;
    let i2;
    if (null !== this.options.cMapUrl) {
      const t3 = `${this.options.cMapUrl}${e2}.bcmap`, a2 = await fetch(t3);
      if (!a2.ok)
        throw new Error(`fetchBuiltInCMap: failed to fetch file "${t3}" with "${a2.statusText}".`);
      i2 = { cMapData: new Uint8Array(await a2.arrayBuffer()), compressionType: yA.BINARY };
    } else
      i2 = await this.handler.sendWithPromise("FetchBuiltInCMap", { name: e2 });
    i2.compressionType !== yA.NONE && this.builtInCMapCache.set(e2, i2);
    return i2;
  }
  async fetchStandardFontData(e2) {
    const t2 = this.standardFontDataCache.get(e2);
    if (t2)
      return new Stream(t2);
    if (this.options.useSystemFonts && "Symbol" !== e2 && "ZapfDingbats" !== e2)
      return null;
    const i2 = Vi()[e2];
    let a2;
    if (null !== this.options.standardFontDataUrl) {
      const e3 = `${this.options.standardFontDataUrl}${i2}`, t3 = await fetch(e3);
      t3.ok ? a2 = new Uint8Array(await t3.arrayBuffer()) : warn(`fetchStandardFontData: failed to fetch file "${e3}" with "${t3.statusText}".`);
    } else
      try {
        a2 = await this.handler.sendWithPromise("FetchStandardFontData", { filename: i2 });
      } catch (e3) {
        warn(`fetchStandardFontData: failed to fetch file "${i2}" with "${e3}".`);
      }
    if (!a2)
      return null;
    this.standardFontDataCache.set(e2, a2);
    return new Stream(a2);
  }
  async buildFormXObject(e2, t2, i2, a2, s2, r2, n2) {
    const g2 = t2.dict, o2 = lookupMatrix(g2.getArray("Matrix"), null), c2 = lookupNormalRect(g2.getArray("BBox"), null);
    let C2, h2;
    g2.has("OC") && (C2 = await this.parseMarkedContentProps(g2.get("OC"), e2));
    void 0 !== C2 && a2.addOp(Ye, ["OC", C2]);
    const l2 = g2.get("Group");
    if (l2) {
      h2 = { matrix: o2, bbox: c2, smask: i2, isolated: false, knockout: false };
      let t3 = null;
      if (isName(l2.get("S"), "Transparency")) {
        h2.isolated = l2.get("I") || false;
        h2.knockout = l2.get("K") || false;
        if (l2.has("CS")) {
          const i3 = l2.getRaw("CS"), a3 = ColorSpace.getCached(i3, this.xref, n2);
          t3 = a3 || await this.parseColorSpace({ cs: i3, resources: e2, localColorSpaceCache: n2 });
        }
      }
      if (i2 == null ? void 0 : i2.backdrop) {
        t3 || (t3 = ColorSpace.singletons.rgb);
        i2.backdrop = t3.getRgb(i2.backdrop, 0);
      }
      a2.addOp(Pe, [h2]);
    }
    const Q2 = l2 ? [o2, null] : [o2, c2];
    a2.addOp(qe, Q2);
    await this.getOperatorList({ stream: t2, task: s2, resources: g2.get("Resources") || e2, operatorList: a2, initialState: r2 });
    a2.addOp(Oe, []);
    l2 && a2.addOp(We, [h2]);
    void 0 !== C2 && a2.addOp(ve, []);
  }
  _sendImgData(e2, t2, i2 = false) {
    const a2 = t2 ? [t2.bitmap || t2.data.buffer] : null;
    return this.parsingType3Font || i2 ? this.handler.send("commonobj", [e2, "Image", t2], a2) : this.handler.send("obj", [e2, this.pageIndex, "Image", t2], a2);
  }
  async buildPaintImageXObject({ resources: e2, image: t2, isInline: i2 = false, operatorList: a2, cacheKey: s2, localImageCache: r2, localColorSpaceCache: n2 }) {
    const g2 = t2.dict, o2 = g2.objId, c2 = g2.get("W", "Width"), C2 = g2.get("H", "Height");
    if (!c2 || "number" != typeof c2 || !C2 || "number" != typeof C2) {
      warn("Image dimensions are missing, or not numbers.");
      return;
    }
    const h2 = this.options.maxImageSize;
    if (-1 !== h2 && c2 * C2 > h2) {
      const e3 = "Image exceeded maximum allowed size and was removed.";
      if (this.options.ignoreErrors) {
        warn(e3);
        return;
      }
      throw new Error(e3);
    }
    let l2;
    g2.has("OC") && (l2 = await this.parseMarkedContentProps(g2.get("OC"), e2));
    let Q2, E2;
    if (g2.get("IM", "ImageMask") || false) {
      const e3 = g2.get("I", "Interpolate"), i3 = c2 + 7 >> 3, n3 = t2.getBytes(i3 * C2), h3 = g2.getArray("D", "Decode");
      if (this.parsingType3Font) {
        Q2 = PDFImage.createRawMask({ imgArray: n3, width: c2, height: C2, imageIsFromDecodeStream: t2 instanceof DecodeStream, inverseDecode: (h3 == null ? void 0 : h3[0]) > 0, interpolate: e3 });
        Q2.cached = !!s2;
        E2 = [Q2];
        a2.addImageOps(Ze, E2, l2);
        if (s2) {
          const e4 = { fn: Ze, args: E2, optionalContent: l2 };
          r2.set(s2, o2, e4);
          o2 && this._regionalImageCache.set(null, o2, e4);
        }
        return;
      }
      Q2 = await PDFImage.createMask({ imgArray: n3, width: c2, height: C2, imageIsFromDecodeStream: t2 instanceof DecodeStream, inverseDecode: (h3 == null ? void 0 : h3[0]) > 0, interpolate: e3, isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported });
      if (Q2.isSingleOpaquePixel) {
        a2.addImageOps(tt, [], l2);
        if (s2) {
          const e4 = { fn: tt, args: [], optionalContent: l2 };
          r2.set(s2, o2, e4);
          o2 && this._regionalImageCache.set(null, o2, e4);
        }
        return;
      }
      const u3 = `mask_${this.idFactory.createObjId()}`;
      a2.addDependency(u3);
      Q2.dataLen = Q2.bitmap ? Q2.width * Q2.height * 4 : Q2.data.length;
      this._sendImgData(u3, Q2);
      E2 = [{ data: u3, width: Q2.width, height: Q2.height, interpolate: Q2.interpolate, count: 1 }];
      a2.addImageOps(Ze, E2, l2);
      if (s2) {
        const e4 = { objId: u3, fn: Ze, args: E2, optionalContent: l2 };
        r2.set(s2, o2, e4);
        o2 && this._regionalImageCache.set(null, o2, e4);
      }
      return;
    }
    if (i2 && c2 + C2 < 200 && !g2.has("SMask") && !g2.has("Mask")) {
      try {
        const s3 = new PDFImage({ xref: this.xref, res: e2, image: t2, isInline: i2, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: n2 });
        Q2 = await s3.createImageData(true, false);
        a2.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported;
        a2.addImageOps(_e, [Q2], l2);
      } catch (e3) {
        const t3 = `Unable to decode inline image: "${e3}".`;
        if (!this.options.ignoreErrors)
          throw new Error(t3);
        warn(t3);
      }
      return;
    }
    let u2 = `img_${this.idFactory.createObjId()}`, d2 = false;
    if (this.parsingType3Font)
      u2 = `${this.idFactory.getDocId()}_type3_${u2}`;
    else if (s2 && o2) {
      d2 = this.globalImageCache.shouldCache(o2, this.pageIndex);
      if (d2) {
        assert(!i2, "Cannot cache an inline image globally.");
        u2 = `${this.idFactory.getDocId()}_${u2}`;
      }
    }
    a2.addDependency(u2);
    E2 = [u2, c2, C2];
    a2.addImageOps(ze, E2, l2);
    if (d2) {
      if (this.globalImageCache.hasDecodeFailed(o2)) {
        this.globalImageCache.setData(o2, { objId: u2, fn: ze, args: E2, optionalContent: l2, byteSize: 0 });
        this._sendImgData(u2, null, d2);
        return;
      }
      if (c2 * C2 > 25e4 || g2.has("SMask") || g2.has("Mask")) {
        const e3 = await this.handler.sendWithPromise("commonobj", [u2, "CopyLocalImage", { imageRef: o2 }]);
        if (e3) {
          this.globalImageCache.setData(o2, { objId: u2, fn: ze, args: E2, optionalContent: l2, byteSize: 0 });
          this.globalImageCache.addByteSize(o2, e3);
          return;
        }
      }
    }
    PDFImage.buildImage({ xref: this.xref, res: e2, image: t2, isInline: i2, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: n2 }).then(async (e3) => {
      Q2 = await e3.createImageData(false, this.options.isOffscreenCanvasSupported);
      Q2.dataLen = Q2.bitmap ? Q2.width * Q2.height * 4 : Q2.data.length;
      Q2.ref = o2;
      d2 && this.globalImageCache.addByteSize(o2, Q2.dataLen);
      return this._sendImgData(u2, Q2, d2);
    }).catch((e3) => {
      warn(`Unable to decode image "${u2}": "${e3}".`);
      o2 && this.globalImageCache.addDecodeFailed(o2);
      return this._sendImgData(u2, null, d2);
    });
    if (s2) {
      const e3 = { objId: u2, fn: ze, args: E2, optionalContent: l2 };
      r2.set(s2, o2, e3);
      if (o2) {
        this._regionalImageCache.set(null, o2, e3);
        d2 && this.globalImageCache.setData(o2, { objId: u2, fn: ze, args: E2, optionalContent: l2, byteSize: 0 });
      }
    }
  }
  handleSMask(e2, t2, i2, a2, s2, r2) {
    const n2 = e2.get("G"), g2 = { subtype: e2.get("S").name, backdrop: e2.get("BC") }, o2 = e2.get("TR");
    if (isPDFFunction(o2)) {
      const e3 = this._pdfFunctionFactory.create(o2), t3 = new Uint8Array(256), i3 = new Float32Array(1);
      for (let a3 = 0; a3 < 256; a3++) {
        i3[0] = a3 / 255;
        e3(i3, 0, i3, 0);
        t3[a3] = 255 * i3[0] | 0;
      }
      g2.transferMap = t3;
    }
    return this.buildFormXObject(t2, n2, g2, i2, a2, s2.state.clone(), r2);
  }
  handleTransferFunction(e2) {
    let t2;
    if (Array.isArray(e2))
      t2 = e2;
    else {
      if (!isPDFFunction(e2))
        return null;
      t2 = [e2];
    }
    const i2 = [];
    let a2 = 0, s2 = 0;
    for (const e3 of t2) {
      const t3 = this.xref.fetchIfRef(e3);
      a2++;
      if (isName(t3, "Identity")) {
        i2.push(null);
        continue;
      }
      if (!isPDFFunction(t3))
        return null;
      const r2 = this._pdfFunctionFactory.create(t3), n2 = new Uint8Array(256), g2 = new Float32Array(1);
      for (let e4 = 0; e4 < 256; e4++) {
        g2[0] = e4 / 255;
        r2(g2, 0, g2, 0);
        n2[e4] = 255 * g2[0] | 0;
      }
      i2.push(n2);
      s2++;
    }
    return 1 !== a2 && 4 !== a2 || 0 === s2 ? null : i2;
  }
  handleTilingType(e2, t2, i2, a2, s2, r2, n2, g2) {
    const o2 = new OperatorList(), c2 = Dict.merge({ xref: this.xref, dictArray: [s2.get("Resources"), i2] });
    return this.getOperatorList({ stream: a2, task: n2, resources: c2, operatorList: o2 }).then(function() {
      const i3 = o2.getIR(), a3 = getTilingPatternIR(i3, s2, t2);
      r2.addDependencies(o2.dependencies);
      r2.addOp(e2, a3);
      s2.objId && g2.set(null, s2.objId, { operatorListIR: i3, dict: s2 });
    }).catch((e3) => {
      if (!(e3 instanceof AbortException)) {
        if (!this.options.ignoreErrors)
          throw e3;
        warn(`handleTilingType - ignoring pattern: "${e3}".`);
      }
    });
  }
  async handleSetFont(e2, t2, i2, a2, s2, r2, n2 = null, g2 = null) {
    const o2 = (t2 == null ? void 0 : t2[0]) instanceof Name ? t2[0].name : null;
    let c2 = await this.loadFont(o2, i2, e2, n2, g2);
    if (c2.font.isType3Font)
      try {
        await c2.loadType3Data(this, e2, s2);
        a2.addDependencies(c2.type3Dependencies);
      } catch (e3) {
        c2 = new TranslatedFont({ loadedName: "g_font_error", font: new ErrorFont(`Type3 font load error: ${e3}`), dict: c2.font, evaluatorOptions: this.options });
      }
    r2.font = c2.font;
    c2.send(this.handler);
    return c2.loadedName;
  }
  handleText(e2, t2) {
    const i2 = t2.font, a2 = i2.charsToGlyphs(e2);
    if (i2.data) {
      (!!(t2.textRenderingMode & D) || "Pattern" === t2.fillColorSpace.name || i2.disableFontFace || this.options.disableFontFace) && _PartialEvaluator.buildFontPaths(i2, a2, this.handler, this.options);
    }
    return a2;
  }
  ensureStateFont(e2) {
    if (e2.font)
      return;
    const t2 = new FormatError("Missing setFont (Tf) operator before text rendering operator.");
    if (!this.options.ignoreErrors)
      throw t2;
    warn(`ensureStateFont: "${t2}".`);
  }
  async setGState({ resources: e2, gState: t2, operatorList: i2, cacheKey: a2, task: s2, stateManager: r2, localGStateCache: n2, localColorSpaceCache: g2 }) {
    const o2 = t2.objId;
    let c2 = true;
    const C2 = [];
    let h2 = Promise.resolve();
    for (const a3 of t2.getKeys()) {
      const n3 = t2.get(a3);
      switch (a3) {
        case "Type":
          break;
        case "LW":
        case "LC":
        case "LJ":
        case "ML":
        case "D":
        case "RI":
        case "FL":
        case "CA":
        case "ca":
          C2.push([a3, n3]);
          break;
        case "Font":
          c2 = false;
          h2 = h2.then(() => this.handleSetFont(e2, null, n3[0], i2, s2, r2.state).then(function(e3) {
            i2.addDependency(e3);
            C2.push([a3, [e3, n3[1]]]);
          }));
          break;
        case "BM":
          C2.push([a3, normalizeBlendMode(n3)]);
          break;
        case "SMask":
          if (isName(n3, "None")) {
            C2.push([a3, false]);
            break;
          }
          if (n3 instanceof Dict) {
            c2 = false;
            h2 = h2.then(() => this.handleSMask(n3, e2, i2, s2, r2, g2));
            C2.push([a3, true]);
          } else
            warn("Unsupported SMask type");
          break;
        case "TR":
          const t3 = this.handleTransferFunction(n3);
          C2.push([a3, t3]);
          break;
        case "OP":
        case "op":
        case "OPM":
        case "BG":
        case "BG2":
        case "UCR":
        case "UCR2":
        case "TR2":
        case "HT":
        case "SM":
        case "SA":
        case "AIS":
        case "TK":
          info("graphic state operator " + a3);
          break;
        default:
          info("Unknown graphic state operator " + a3);
      }
    }
    await h2;
    C2.length > 0 && i2.addOp(GA, [C2]);
    c2 && n2.set(a2, o2, C2);
  }
  loadFont(e2, t2, i2, a2 = null, s2 = null) {
    var _a4;
    const errorFont = async () => new TranslatedFont({ loadedName: "g_font_error", font: new ErrorFont(`Font "${e2}" is not available.`), dict: t2, evaluatorOptions: this.options });
    let r2;
    if (t2)
      t2 instanceof Ref && (r2 = t2);
    else {
      const t3 = i2.get("Font");
      t3 && (r2 = t3.getRaw(e2));
    }
    if (r2) {
      if ((_a4 = this.type3FontRefs) == null ? void 0 : _a4.has(r2))
        return errorFont();
      if (this.fontCache.has(r2))
        return this.fontCache.get(r2);
      try {
        t2 = this.xref.fetchIfRef(r2);
      } catch (e3) {
        warn(`loadFont - lookup failed: "${e3}".`);
      }
    }
    if (!(t2 instanceof Dict)) {
      if (!this.options.ignoreErrors && !this.parsingType3Font) {
        warn(`Font "${e2}" is not available.`);
        return errorFont();
      }
      warn(`Font "${e2}" is not available -- attempting to fallback to a default font.`);
      t2 = a2 || _PartialEvaluator.fallbackFontDict;
    }
    if (t2.cacheKey && this.fontCache.has(t2.cacheKey))
      return this.fontCache.get(t2.cacheKey);
    const { promise: n2, resolve: g2 } = Promise.withResolvers();
    let o2;
    try {
      o2 = this.preEvaluateFont(t2);
      o2.cssFontInfo = s2;
    } catch (e3) {
      warn(`loadFont - preEvaluateFont failed: "${e3}".`);
      return errorFont();
    }
    const { descriptor: c2, hash: C2 } = o2, h2 = r2 instanceof Ref;
    let l2;
    if (C2 && c2 instanceof Dict) {
      const e3 = c2.fontAliases || (c2.fontAliases = /* @__PURE__ */ Object.create(null));
      if (e3[C2]) {
        const t3 = e3[C2].aliasRef;
        if (h2 && t3 && this.fontCache.has(t3)) {
          this.fontCache.putAlias(r2, t3);
          return this.fontCache.get(r2);
        }
      } else
        e3[C2] = { fontID: this.idFactory.createFontId() };
      h2 && (e3[C2].aliasRef = r2);
      l2 = e3[C2].fontID;
    } else
      l2 = this.idFactory.createFontId();
    assert(l2 == null ? void 0 : l2.startsWith("f"), 'The "fontID" must be (correctly) defined.');
    if (h2)
      this.fontCache.put(r2, n2);
    else {
      t2.cacheKey = `cacheKey_${l2}`;
      this.fontCache.put(t2.cacheKey, n2);
    }
    t2.loadedName = `${this.idFactory.getDocId()}_${l2}`;
    this.translateFont(o2).then((e3) => {
      g2(new TranslatedFont({ loadedName: t2.loadedName, font: e3, dict: t2, evaluatorOptions: this.options }));
    }).catch((e3) => {
      warn(`loadFont - translateFont failed: "${e3}".`);
      g2(new TranslatedFont({ loadedName: t2.loadedName, font: new ErrorFont(e3 instanceof Error ? e3.message : e3), dict: t2, evaluatorOptions: this.options }));
    });
    return n2;
  }
  buildPath(e2, t2, i2, a2 = false) {
    const s2 = e2.length - 1;
    i2 || (i2 = []);
    if (s2 < 0 || e2.fnArray[s2] !== it) {
      if (a2) {
        warn(`Encountered path operator "${t2}" inside of a text object.`);
        e2.addOp(xA, null);
      }
      let s3;
      switch (t2) {
        case TA:
          const e3 = i2[0] + i2[2], t3 = i2[1] + i2[3];
          s3 = [Math.min(i2[0], e3), Math.min(i2[1], t3), Math.max(i2[0], e3), Math.max(i2[1], t3)];
          break;
        case LA:
        case HA:
          s3 = [i2[0], i2[1], i2[0], i2[1]];
          break;
        default:
          s3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      }
      e2.addOp(it, [[t2], i2, s3]);
      a2 && e2.addOp(UA, null);
    } else {
      const a3 = e2.argsArray[s2];
      a3[0].push(t2);
      a3[1].push(...i2);
      const r2 = a3[2];
      switch (t2) {
        case TA:
          const e3 = i2[0] + i2[2], t3 = i2[1] + i2[3];
          r2[0] = Math.min(r2[0], i2[0], e3);
          r2[1] = Math.min(r2[1], i2[1], t3);
          r2[2] = Math.max(r2[2], i2[0], e3);
          r2[3] = Math.max(r2[3], i2[1], t3);
          break;
        case LA:
        case HA:
          r2[0] = Math.min(r2[0], i2[0]);
          r2[1] = Math.min(r2[1], i2[1]);
          r2[2] = Math.max(r2[2], i2[0]);
          r2[3] = Math.max(r2[3], i2[1]);
      }
    }
  }
  parseColorSpace({ cs: e2, resources: t2, localColorSpaceCache: i2 }) {
    return ColorSpace.parseAsync({ cs: e2, xref: this.xref, resources: t2, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: i2 }).catch((e3) => {
      if (e3 instanceof AbortException)
        return null;
      if (this.options.ignoreErrors) {
        warn(`parseColorSpace - ignoring ColorSpace: "${e3}".`);
        return null;
      }
      throw e3;
    });
  }
  parseShading({ shading: e2, resources: t2, localColorSpaceCache: i2, localShadingPatternCache: a2 }) {
    let s2, r2 = a2.get(e2);
    if (r2)
      return r2;
    try {
      s2 = Pattern.parseShading(e2, this.xref, t2, this._pdfFunctionFactory, i2).getIR();
    } catch (t3) {
      if (t3 instanceof AbortException)
        return null;
      if (this.options.ignoreErrors) {
        warn(`parseShading - ignoring shading: "${t3}".`);
        a2.set(e2, null);
        return null;
      }
      throw t3;
    }
    r2 = `pattern_${this.idFactory.createObjId()}`;
    this.parsingType3Font && (r2 = `${this.idFactory.getDocId()}_type3_${r2}`);
    a2.set(e2, r2);
    this.parsingType3Font ? this.handler.send("commonobj", [r2, "Pattern", s2]) : this.handler.send("obj", [r2, this.pageIndex, "Pattern", s2]);
    return r2;
  }
  handleColorN(e2, t2, i2, a2, s2, r2, n2, g2, o2, c2) {
    const C2 = i2.pop();
    if (C2 instanceof Name) {
      const h2 = s2.getRaw(C2.name), l2 = h2 instanceof Ref && o2.getByRef(h2);
      if (l2)
        try {
          const s3 = a2.base ? a2.base.getRgb(i2, 0) : null, r3 = getTilingPatternIR(l2.operatorListIR, l2.dict, s3);
          e2.addOp(t2, r3);
          return;
        } catch {
        }
      const Q2 = this.xref.fetchIfRef(h2);
      if (Q2) {
        const s3 = Q2 instanceof BaseStream ? Q2.dict : Q2, C3 = s3.get("PatternType");
        if (C3 === Ns) {
          const g3 = a2.base ? a2.base.getRgb(i2, 0) : null;
          return this.handleTilingType(t2, g3, r2, Q2, s3, e2, n2, o2);
        }
        if (C3 === Gs) {
          const i3 = s3.get("Shading"), a3 = this.parseShading({ shading: i3, resources: r2, localColorSpaceCache: g2, localShadingPatternCache: c2 });
          if (a3) {
            const i4 = lookupMatrix(s3.getArray("Matrix"), null);
            e2.addOp(t2, ["Shading", a3, i4]);
          }
          return;
        }
        throw new FormatError(`Unknown PatternType: ${C3}`);
      }
    }
    throw new FormatError(`Unknown PatternName: ${C2}`);
  }
  _parseVisibilityExpression(e2, t2, i2) {
    if (++t2 > 10) {
      warn("Visibility expression is too deeply nested");
      return;
    }
    const a2 = e2.length, s2 = this.xref.fetchIfRef(e2[0]);
    if (!(a2 < 2) && s2 instanceof Name) {
      switch (s2.name) {
        case "And":
        case "Or":
        case "Not":
          i2.push(s2.name);
          break;
        default:
          warn(`Invalid operator ${s2.name} in visibility expression`);
          return;
      }
      for (let s3 = 1; s3 < a2; s3++) {
        const a3 = e2[s3], r2 = this.xref.fetchIfRef(a3);
        if (Array.isArray(r2)) {
          const e3 = [];
          i2.push(e3);
          this._parseVisibilityExpression(r2, t2, e3);
        } else
          a3 instanceof Ref && i2.push(a3.toString());
      }
    } else
      warn("Invalid visibility expression");
  }
  async parseMarkedContentProps(e2, t2) {
    var _a4;
    let i2;
    if (e2 instanceof Name) {
      i2 = t2.get("Properties").get(e2.name);
    } else {
      if (!(e2 instanceof Dict))
        throw new FormatError("Optional content properties malformed.");
      i2 = e2;
    }
    const a2 = (_a4 = i2.get("Type")) == null ? void 0 : _a4.name;
    if ("OCG" === a2)
      return { type: a2, id: i2.objId };
    if ("OCMD" === a2) {
      const e3 = i2.get("VE");
      if (Array.isArray(e3)) {
        const t4 = [];
        this._parseVisibilityExpression(e3, 0, t4);
        if (t4.length > 0)
          return { type: "OCMD", expression: t4 };
      }
      const t3 = i2.get("OCGs");
      if (Array.isArray(t3) || t3 instanceof Dict) {
        const e4 = [];
        if (Array.isArray(t3))
          for (const i3 of t3)
            e4.push(i3.toString());
        else
          e4.push(t3.objId);
        return { type: a2, ids: e4, policy: i2.get("P") instanceof Name ? i2.get("P").name : null, expression: null };
      }
      if (t3 instanceof Ref)
        return { type: a2, id: t3.toString() };
    }
    return null;
  }
  getOperatorList({ stream: e2, task: t2, resources: i2, operatorList: a2, initialState: s2 = null, fallbackFontDict: r2 = null }) {
    i2 || (i2 = Dict.empty);
    s2 || (s2 = new EvalState());
    if (!a2)
      throw new Error('getOperatorList: missing "operatorList" parameter');
    const n2 = this, g2 = this.xref;
    let o2 = false;
    const c2 = new LocalImageCache(), C2 = new LocalColorSpaceCache(), h2 = new LocalGStateCache(), l2 = new LocalTilingPatternCache(), Q2 = /* @__PURE__ */ new Map(), E2 = i2.get("XObject") || Dict.empty, u2 = i2.get("Pattern") || Dict.empty, d2 = new StateManager(s2), f2 = new EvaluatorPreprocessor(e2, g2, d2), p2 = new TimeSlotManager();
    function closePendingRestoreOPS(e3) {
      for (let e4 = 0, t3 = f2.savedStatesDepth; e4 < t3; e4++)
        a2.addOp(UA, []);
    }
    return new Promise(function promiseBody(e3, s3) {
      const next = function(t3) {
        Promise.all([t3, a2.ready]).then(function() {
          try {
            promiseBody(e3, s3);
          } catch (e4) {
            s3(e4);
          }
        }, s3);
      };
      t2.ensureNotTerminated();
      p2.reset();
      const m2 = {};
      let y2, w2, D2, b2, F2, S2;
      for (; !(y2 = p2.check()); ) {
        m2.args = null;
        if (!f2.read(m2))
          break;
        let e4 = m2.args, s4 = m2.fn;
        switch (0 | s4) {
          case Me:
            S2 = e4[0] instanceof Name;
            F2 = e4[0].name;
            if (S2) {
              const t3 = c2.getByName(F2);
              if (t3) {
                addLocallyCachedImageOps(a2, t3);
                e4 = null;
                continue;
              }
            }
            next(new Promise(function(e5, s5) {
              if (!S2)
                throw new FormatError("XObject must be referred to by name.");
              let r3 = E2.getRaw(F2);
              if (r3 instanceof Ref) {
                const t3 = c2.getByRef(r3) || n2._regionalImageCache.getByRef(r3);
                if (t3) {
                  addLocallyCachedImageOps(a2, t3);
                  e5();
                  return;
                }
                const i3 = n2.globalImageCache.getData(r3, n2.pageIndex);
                if (i3) {
                  a2.addDependency(i3.objId);
                  a2.addImageOps(i3.fn, i3.args, i3.optionalContent);
                  e5();
                  return;
                }
                r3 = g2.fetch(r3);
              }
              if (!(r3 instanceof BaseStream))
                throw new FormatError("XObject should be a stream");
              const o3 = r3.dict.get("Subtype");
              if (!(o3 instanceof Name))
                throw new FormatError("XObject should have a Name subtype");
              if ("Form" !== o3.name)
                if ("Image" !== o3.name) {
                  if ("PS" !== o3.name)
                    throw new FormatError(`Unhandled XObject subtype ${o3.name}`);
                  info("Ignored XObject subtype PS");
                  e5();
                } else
                  n2.buildPaintImageXObject({ resources: i2, image: r3, operatorList: a2, cacheKey: F2, localImageCache: c2, localColorSpaceCache: C2 }).then(e5, s5);
              else {
                d2.save();
                n2.buildFormXObject(i2, r3, null, a2, t2, d2.state.clone(), C2).then(function() {
                  d2.restore();
                  e5();
                }, s5);
              }
            }).catch(function(e5) {
              if (!(e5 instanceof AbortException)) {
                if (!n2.options.ignoreErrors)
                  throw e5;
                warn(`getOperatorList - ignoring XObject: "${e5}".`);
              }
            }));
            return;
          case re:
            var k2 = e4[1];
            next(n2.handleSetFont(i2, e4, null, a2, t2, d2.state, r2).then(function(e5) {
              a2.addDependency(e5);
              a2.addOp(re, [e5, k2]);
            }));
            return;
          case Ae:
            o2 = true;
            break;
          case ee:
            o2 = false;
            break;
          case Ue:
            var R2 = e4[0].cacheKey;
            if (R2) {
              const t3 = c2.getByName(R2);
              if (t3) {
                addLocallyCachedImageOps(a2, t3);
                e4 = null;
                continue;
              }
            }
            next(n2.buildPaintImageXObject({ resources: i2, image: e4[0], isInline: true, operatorList: a2, cacheKey: R2, localImageCache: c2, localColorSpaceCache: C2 }));
            return;
          case he:
            if (!d2.state.font) {
              n2.ensureStateFont(d2.state);
              continue;
            }
            e4[0] = n2.handleText(e4[0], d2.state);
            break;
          case Be:
            if (!d2.state.font) {
              n2.ensureStateFont(d2.state);
              continue;
            }
            var N2 = [], G2 = d2.state;
            for (const t3 of e4[0])
              "string" == typeof t3 ? N2.push(...n2.handleText(t3, G2)) : "number" == typeof t3 && N2.push(t3);
            e4[0] = N2;
            s4 = he;
            break;
          case le:
            if (!d2.state.font) {
              n2.ensureStateFont(d2.state);
              continue;
            }
            a2.addOp(Ce);
            e4[0] = n2.handleText(e4[0], d2.state);
            s4 = he;
            break;
          case Qe:
            if (!d2.state.font) {
              n2.ensureStateFont(d2.state);
              continue;
            }
            a2.addOp(Ce);
            a2.addOp(ie, [e4.shift()]);
            a2.addOp(te, [e4.shift()]);
            e4[0] = n2.handleText(e4[0], d2.state);
            s4 = he;
            break;
          case ne:
            d2.state.textRenderingMode = e4[0];
            break;
          case fe: {
            const t3 = ColorSpace.getCached(e4[0], g2, C2);
            if (t3) {
              d2.state.fillColorSpace = t3;
              continue;
            }
            next(n2.parseColorSpace({ cs: e4[0], resources: i2, localColorSpaceCache: C2 }).then(function(e5) {
              d2.state.fillColorSpace = e5 || ColorSpace.singletons.gray;
            }));
            return;
          }
          case de: {
            const t3 = ColorSpace.getCached(e4[0], g2, C2);
            if (t3) {
              d2.state.strokeColorSpace = t3;
              continue;
            }
            next(n2.parseColorSpace({ cs: e4[0], resources: i2, localColorSpaceCache: C2 }).then(function(e5) {
              d2.state.strokeColorSpace = e5 || ColorSpace.singletons.gray;
            }));
            return;
          }
          case ye:
            b2 = d2.state.fillColorSpace;
            e4 = b2.getRgb(e4, 0);
            s4 = Se;
            break;
          case pe:
            b2 = d2.state.strokeColorSpace;
            e4 = b2.getRgb(e4, 0);
            s4 = Fe;
            break;
          case be:
            d2.state.fillColorSpace = ColorSpace.singletons.gray;
            e4 = ColorSpace.singletons.gray.getRgb(e4, 0);
            s4 = Se;
            break;
          case De:
            d2.state.strokeColorSpace = ColorSpace.singletons.gray;
            e4 = ColorSpace.singletons.gray.getRgb(e4, 0);
            s4 = Fe;
            break;
          case Re:
            d2.state.fillColorSpace = ColorSpace.singletons.cmyk;
            e4 = ColorSpace.singletons.cmyk.getRgb(e4, 0);
            s4 = Se;
            break;
          case ke:
            d2.state.strokeColorSpace = ColorSpace.singletons.cmyk;
            e4 = ColorSpace.singletons.cmyk.getRgb(e4, 0);
            s4 = Fe;
            break;
          case Se:
            d2.state.fillColorSpace = ColorSpace.singletons.rgb;
            e4 = ColorSpace.singletons.rgb.getRgb(e4, 0);
            break;
          case Fe:
            d2.state.strokeColorSpace = ColorSpace.singletons.rgb;
            e4 = ColorSpace.singletons.rgb.getRgb(e4, 0);
            break;
          case we:
            b2 = d2.state.patternFillColorSpace;
            if (!b2) {
              e4 = [];
              s4 = st;
              break;
            }
            if ("Pattern" === b2.name) {
              next(n2.handleColorN(a2, we, e4, b2, u2, i2, t2, C2, l2, Q2));
              return;
            }
            e4 = b2.getRgb(e4, 0);
            s4 = Se;
            break;
          case me:
            b2 = d2.state.patternStrokeColorSpace;
            if (!b2) {
              e4 = [];
              s4 = at;
              break;
            }
            if ("Pattern" === b2.name) {
              next(n2.handleColorN(a2, me, e4, b2, u2, i2, t2, C2, l2, Q2));
              return;
            }
            e4 = b2.getRgb(e4, 0);
            s4 = Fe;
            break;
          case Ne:
            var x2 = i2.get("Shading");
            if (!x2)
              throw new FormatError("No shading resource found");
            var U2 = x2.get(e4[0].name);
            if (!U2)
              throw new FormatError("No shading object found");
            const f3 = n2.parseShading({ shading: U2, resources: i2, localColorSpaceCache: C2, localShadingPatternCache: Q2 });
            if (!f3)
              continue;
            e4 = [f3];
            s4 = Ne;
            break;
          case GA:
            S2 = e4[0] instanceof Name;
            F2 = e4[0].name;
            if (S2) {
              const t3 = h2.getByName(F2);
              if (t3) {
                t3.length > 0 && a2.addOp(GA, [t3]);
                e4 = null;
                continue;
              }
            }
            next(new Promise(function(e5, s5) {
              if (!S2)
                throw new FormatError("GState must be referred to by name.");
              const r3 = i2.get("ExtGState");
              if (!(r3 instanceof Dict))
                throw new FormatError("ExtGState should be a dictionary.");
              const g3 = r3.get(F2);
              if (!(g3 instanceof Dict))
                throw new FormatError("GState should be a dictionary.");
              n2.setGState({ resources: i2, gState: g3, operatorList: a2, cacheKey: F2, task: t2, stateManager: d2, localGStateCache: h2, localColorSpaceCache: C2 }).then(e5, s5);
            }).catch(function(e5) {
              if (!(e5 instanceof AbortException)) {
                if (!n2.options.ignoreErrors)
                  throw e5;
                warn(`getOperatorList - ignoring ExtGState: "${e5}".`);
              }
            }));
            return;
          case LA:
          case HA:
          case JA:
          case YA:
          case vA:
          case KA:
          case TA:
            n2.buildPath(a2, s4, e4, o2);
            continue;
          case Le:
          case He:
          case Ke:
          case Te:
            continue;
          case Ye:
            if (!(e4[0] instanceof Name)) {
              warn(`Expected name for beginMarkedContentProps arg0=${e4[0]}`);
              a2.addOp(Ye, ["OC", null]);
              continue;
            }
            if ("OC" === e4[0].name) {
              next(n2.parseMarkedContentProps(e4[1], i2).then((e5) => {
                a2.addOp(Ye, ["OC", e5]);
              }).catch((e5) => {
                if (!(e5 instanceof AbortException)) {
                  if (!n2.options.ignoreErrors)
                    throw e5;
                  warn(`getOperatorList - ignoring beginMarkedContentProps: "${e5}".`);
                  a2.addOp(Ye, ["OC", null]);
                }
              }));
              return;
            }
            e4 = [e4[0].name, e4[1] instanceof Dict ? e4[1].get("MCID") : null];
            break;
          default:
            if (null !== e4) {
              for (w2 = 0, D2 = e4.length; w2 < D2 && !(e4[w2] instanceof Dict); w2++)
                ;
              if (w2 < D2) {
                warn("getOperatorList - ignoring operator: " + s4);
                continue;
              }
            }
        }
        a2.addOp(s4, e4);
      }
      if (y2)
        next(xs);
      else {
        closePendingRestoreOPS();
        e3();
      }
    }).catch((e3) => {
      if (!(e3 instanceof AbortException)) {
        if (!this.options.ignoreErrors)
          throw e3;
        warn(`getOperatorList - ignoring errors during "${t2.name}" task: "${e3}".`);
        closePendingRestoreOPS();
      }
    });
  }
  getTextContent({ stream: e2, task: t2, resources: s2, stateManager: r2 = null, includeMarkedContent: n2 = false, sink: g2, seenStyles: o2 = /* @__PURE__ */ new Set(), viewBox: c2, lang: C2 = null, markedContentData: h2 = null, disableNormalization: l2 = false, keepWhiteSpace: Q2 = false }) {
    s2 || (s2 = Dict.empty);
    r2 || (r2 = new StateManager(new TextState()));
    n2 && (h2 || (h2 = { level: 0 }));
    const E2 = { items: [], styles: /* @__PURE__ */ Object.create(null), lang: C2 }, u2 = { initialized: false, str: [], totalWidth: 0, totalHeight: 0, width: 0, height: 0, vertical: false, prevTransform: null, textAdvanceScale: 0, spaceInFlowMin: 0, spaceInFlowMax: 0, trackingSpaceMin: 1 / 0, negativeSpaceMax: -1 / 0, notASpace: -1 / 0, transform: null, fontName: null, hasEOL: false }, d2 = [" ", " "];
    let f2 = 0;
    function saveLastChar(e3) {
      const t3 = (f2 + 1) % 2, i2 = " " !== d2[f2] && " " === d2[t3];
      d2[f2] = e3;
      f2 = t3;
      return !Q2 && i2;
    }
    function shouldAddWhitepsace() {
      return !Q2 && " " !== d2[f2] && " " === d2[(f2 + 1) % 2];
    }
    function resetLastChars() {
      d2[0] = d2[1] = " ";
      f2 = 0;
    }
    const p2 = this, m2 = this.xref, y2 = [];
    let w2 = null;
    const D2 = new LocalImageCache(), b2 = new LocalGStateCache(), F2 = new EvaluatorPreprocessor(e2, m2, r2);
    let S2;
    function pushWhitespace({ width: e3 = 0, height: t3 = 0, transform: i2 = u2.prevTransform, fontName: a2 = u2.fontName }) {
      E2.items.push({ str: " ", dir: "ltr", width: e3, height: t3, transform: i2, fontName: a2, hasEOL: false });
    }
    function getCurrentTextTransform() {
      const e3 = S2.font, t3 = [S2.fontSize * S2.textHScale, 0, 0, S2.fontSize, 0, S2.textRise];
      if (e3.isType3Font && (S2.fontSize <= 1 || e3.isCharBBox) && !isArrayEqual(S2.fontMatrix, a)) {
        const i2 = e3.bbox[3] - e3.bbox[1];
        i2 > 0 && (t3[3] *= i2 * S2.fontMatrix[3]);
      }
      return Util.transform(S2.ctm, Util.transform(S2.textMatrix, t3));
    }
    function ensureTextContentItem() {
      if (u2.initialized)
        return u2;
      const { font: e3, loadedName: t3 } = S2;
      if (!o2.has(t3)) {
        o2.add(t3);
        E2.styles[t3] = { fontFamily: e3.fallbackName, ascent: e3.ascent, descent: e3.descent, vertical: e3.vertical };
        if (p2.options.fontExtraProperties && e3.systemFontInfo) {
          const i3 = E2.styles[t3];
          i3.fontSubstitution = e3.systemFontInfo.css;
          i3.fontSubstitutionLoadedName = e3.systemFontInfo.loadedName;
        }
      }
      u2.fontName = t3;
      const i2 = u2.transform = getCurrentTextTransform();
      if (e3.vertical) {
        u2.width = u2.totalWidth = Math.hypot(i2[0], i2[1]);
        u2.height = u2.totalHeight = 0;
        u2.vertical = true;
      } else {
        u2.width = u2.totalWidth = 0;
        u2.height = u2.totalHeight = Math.hypot(i2[2], i2[3]);
        u2.vertical = false;
      }
      const a2 = Math.hypot(S2.textLineMatrix[0], S2.textLineMatrix[1]), s3 = Math.hypot(S2.ctm[0], S2.ctm[1]);
      u2.textAdvanceScale = s3 * a2;
      const { fontSize: r3 } = S2;
      u2.trackingSpaceMin = 0.102 * r3;
      u2.notASpace = 0.03 * r3;
      u2.negativeSpaceMax = -0.2 * r3;
      u2.spaceInFlowMin = 0.102 * r3;
      u2.spaceInFlowMax = 0.6 * r3;
      u2.hasEOL = false;
      u2.initialized = true;
      return u2;
    }
    function updateAdvanceScale() {
      if (!u2.initialized)
        return;
      const e3 = Math.hypot(S2.textLineMatrix[0], S2.textLineMatrix[1]), t3 = Math.hypot(S2.ctm[0], S2.ctm[1]) * e3;
      if (t3 !== u2.textAdvanceScale) {
        if (u2.vertical) {
          u2.totalHeight += u2.height * u2.textAdvanceScale;
          u2.height = 0;
        } else {
          u2.totalWidth += u2.width * u2.textAdvanceScale;
          u2.width = 0;
        }
        u2.textAdvanceScale = t3;
      }
    }
    function runBidiTransform(e3) {
      let t3 = e3.str.join("");
      l2 || (t3 = function normalizeUnicode(e4) {
        if (!Ct) {
          Ct = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
          ht = /* @__PURE__ */ new Map([["ﬅ", "ſt"]]);
        }
        return e4.replaceAll(Ct, (e5, t4, i3) => t4 ? t4.normalize("NFKC") : ht.get(i3));
      }(t3));
      const i2 = bidi(t3, -1, e3.vertical);
      return { str: i2.str, dir: i2.dir, width: Math.abs(e3.totalWidth), height: Math.abs(e3.totalHeight), transform: e3.transform, fontName: e3.fontName, hasEOL: e3.hasEOL };
    }
    async function handleSetFont(e3, i2) {
      const r3 = await p2.loadFont(e3, i2, s2);
      if (r3.font.isType3Font)
        try {
          await r3.loadType3Data(p2, s2, t2);
        } catch {
        }
      S2.loadedName = r3.loadedName;
      S2.font = r3.font;
      S2.fontMatrix = r3.font.fontMatrix || a;
    }
    function applyInverseRotation(e3, t3, i2) {
      const a2 = Math.hypot(i2[0], i2[1]);
      return [(i2[0] * e3 + i2[1] * t3) / a2, (i2[2] * e3 + i2[3] * t3) / a2];
    }
    function compareWithLastPosition(e3) {
      var _a4;
      const t3 = getCurrentTextTransform();
      let i2 = t3[4], a2 = t3[5];
      if ((_a4 = S2.font) == null ? void 0 : _a4.vertical) {
        if (i2 < c2[0] || i2 > c2[2] || a2 + e3 < c2[1] || a2 > c2[3])
          return false;
      } else if (i2 + e3 < c2[0] || i2 > c2[2] || a2 < c2[1] || a2 > c2[3])
        return false;
      if (!S2.font || !u2.prevTransform)
        return true;
      let s3 = u2.prevTransform[4], r3 = u2.prevTransform[5];
      if (s3 === i2 && r3 === a2)
        return true;
      let n3 = -1;
      t3[0] && 0 === t3[1] && 0 === t3[2] ? n3 = t3[0] > 0 ? 0 : 180 : t3[1] && 0 === t3[0] && 0 === t3[3] && (n3 = t3[1] > 0 ? 90 : 270);
      switch (n3) {
        case 0:
          break;
        case 90:
          [i2, a2] = [a2, i2];
          [s3, r3] = [r3, s3];
          break;
        case 180:
          [i2, a2, s3, r3] = [-i2, -a2, -s3, -r3];
          break;
        case 270:
          [i2, a2] = [-a2, -i2];
          [s3, r3] = [-r3, -s3];
          break;
        default:
          [i2, a2] = applyInverseRotation(i2, a2, t3);
          [s3, r3] = applyInverseRotation(s3, r3, u2.prevTransform);
      }
      if (S2.font.vertical) {
        const e4 = (r3 - a2) / u2.textAdvanceScale, t4 = i2 - s3, n4 = Math.sign(u2.height);
        if (e4 < n4 * u2.negativeSpaceMax) {
          if (Math.abs(t4) > 0.5 * u2.width) {
            appendEOL();
            return true;
          }
          resetLastChars();
          flushTextContentItem();
          return true;
        }
        if (Math.abs(t4) > u2.width) {
          appendEOL();
          return true;
        }
        e4 <= n4 * u2.notASpace && resetLastChars();
        if (e4 <= n4 * u2.trackingSpaceMin)
          if (shouldAddWhitepsace()) {
            resetLastChars();
            flushTextContentItem();
            pushWhitespace({ height: Math.abs(e4) });
          } else
            u2.height += e4;
        else if (!addFakeSpaces(e4, u2.prevTransform, n4))
          if (0 === u2.str.length) {
            resetLastChars();
            pushWhitespace({ height: Math.abs(e4) });
          } else
            u2.height += e4;
        Math.abs(t4) > 0.25 * u2.width && flushTextContentItem();
        return true;
      }
      const g3 = (i2 - s3) / u2.textAdvanceScale, o3 = a2 - r3, C3 = Math.sign(u2.width);
      if (g3 < C3 * u2.negativeSpaceMax) {
        if (Math.abs(o3) > 0.5 * u2.height) {
          appendEOL();
          return true;
        }
        resetLastChars();
        flushTextContentItem();
        return true;
      }
      if (Math.abs(o3) > u2.height) {
        appendEOL();
        return true;
      }
      g3 <= C3 * u2.notASpace && resetLastChars();
      if (g3 <= C3 * u2.trackingSpaceMin)
        if (shouldAddWhitepsace()) {
          resetLastChars();
          flushTextContentItem();
          pushWhitespace({ width: Math.abs(g3) });
        } else
          u2.width += g3;
      else if (!addFakeSpaces(g3, u2.prevTransform, C3))
        if (0 === u2.str.length) {
          resetLastChars();
          pushWhitespace({ width: Math.abs(g3) });
        } else
          u2.width += g3;
      Math.abs(o3) > 0.25 * u2.height && flushTextContentItem();
      return true;
    }
    function buildTextContentItem({ chars: e3, extraSpacing: t3 }) {
      const i2 = S2.font;
      if (!e3) {
        const e4 = S2.charSpacing + t3;
        e4 && (i2.vertical ? S2.translateTextMatrix(0, -e4) : S2.translateTextMatrix(e4 * S2.textHScale, 0));
        Q2 && compareWithLastPosition(0);
        return;
      }
      const a2 = i2.charsToGlyphs(e3), s3 = S2.fontMatrix[0] * S2.fontSize;
      for (let e4 = 0, r3 = a2.length; e4 < r3; e4++) {
        const n3 = a2[e4], { category: g3 } = n3;
        if (g3.isInvisibleFormatMark)
          continue;
        let o3 = S2.charSpacing + (e4 + 1 === r3 ? t3 : 0), c3 = n3.width;
        i2.vertical && (c3 = n3.vmetric ? n3.vmetric[0] : -c3);
        let C3 = c3 * s3;
        if (!Q2 && g3.isWhitespace) {
          if (i2.vertical) {
            o3 += -C3 + S2.wordSpacing;
            S2.translateTextMatrix(0, -o3);
          } else {
            o3 += C3 + S2.wordSpacing;
            S2.translateTextMatrix(o3 * S2.textHScale, 0);
          }
          saveLastChar(" ");
          continue;
        }
        if (!g3.isZeroWidthDiacritic && !compareWithLastPosition(C3)) {
          i2.vertical ? S2.translateTextMatrix(0, C3) : S2.translateTextMatrix(C3 * S2.textHScale, 0);
          continue;
        }
        const h3 = ensureTextContentItem();
        g3.isZeroWidthDiacritic && (C3 = 0);
        if (i2.vertical) {
          S2.translateTextMatrix(0, C3);
          C3 = Math.abs(C3);
          h3.height += C3;
        } else {
          C3 *= S2.textHScale;
          S2.translateTextMatrix(C3, 0);
          h3.width += C3;
        }
        C3 && (h3.prevTransform = getCurrentTextTransform());
        const l3 = n3.unicode;
        saveLastChar(l3) && h3.str.push(" ");
        h3.str.push(l3);
        o3 && (i2.vertical ? S2.translateTextMatrix(0, -o3) : S2.translateTextMatrix(o3 * S2.textHScale, 0));
      }
    }
    function appendEOL() {
      resetLastChars();
      if (u2.initialized) {
        u2.hasEOL = true;
        flushTextContentItem();
      } else
        E2.items.push({ str: "", dir: "ltr", width: 0, height: 0, transform: getCurrentTextTransform(), fontName: S2.loadedName, hasEOL: true });
    }
    function addFakeSpaces(e3, t3, i2) {
      if (i2 * u2.spaceInFlowMin <= e3 && e3 <= i2 * u2.spaceInFlowMax) {
        if (u2.initialized) {
          resetLastChars();
          u2.str.push(" ");
        }
        return false;
      }
      const a2 = u2.fontName;
      let s3 = 0;
      if (u2.vertical) {
        s3 = e3;
        e3 = 0;
      }
      flushTextContentItem();
      resetLastChars();
      pushWhitespace({ width: Math.abs(e3), height: Math.abs(s3), transform: t3 || getCurrentTextTransform(), fontName: a2 });
      return true;
    }
    function flushTextContentItem() {
      if (u2.initialized && u2.str) {
        u2.vertical ? u2.totalHeight += u2.height * u2.textAdvanceScale : u2.totalWidth += u2.width * u2.textAdvanceScale;
        E2.items.push(runBidiTransform(u2));
        u2.initialized = false;
        u2.str.length = 0;
      }
    }
    function enqueueChunk(e3 = false) {
      const t3 = E2.items.length;
      if (0 !== t3 && !(e3 && t3 < 10)) {
        g2.enqueue(E2, t3);
        E2.items = [];
        E2.styles = /* @__PURE__ */ Object.create(null);
      }
    }
    const k2 = new TimeSlotManager();
    return new Promise(function promiseBody(e3, a2) {
      const next = function(t3) {
        enqueueChunk(true);
        Promise.all([t3, g2.ready]).then(function() {
          try {
            promiseBody(e3, a2);
          } catch (e4) {
            a2(e4);
          }
        }, a2);
      };
      t2.ensureNotTerminated();
      k2.reset();
      const u3 = {};
      let d3, f3 = [];
      for (; !(d3 = k2.check()); ) {
        f3.length = 0;
        u3.args = f3;
        if (!F2.read(u3))
          break;
        const e4 = S2;
        S2 = r2.state;
        const a3 = u3.fn;
        f3 = u3.args;
        switch (0 | a3) {
          case re:
            var R2 = f3[0].name, N2 = f3[1];
            if (S2.font && R2 === S2.fontName && N2 === S2.fontSize)
              break;
            flushTextContentItem();
            S2.fontName = R2;
            S2.fontSize = N2;
            next(handleSetFont(R2, null));
            return;
          case ge:
            S2.textRise = f3[0];
            break;
          case ae:
            S2.textHScale = f3[0] / 100;
            break;
          case se:
            S2.leading = f3[0];
            break;
          case oe:
            S2.translateTextLineMatrix(f3[0], f3[1]);
            S2.textMatrix = S2.textLineMatrix.slice();
            break;
          case Ie:
            S2.leading = -f3[1];
            S2.translateTextLineMatrix(f3[0], f3[1]);
            S2.textMatrix = S2.textLineMatrix.slice();
            break;
          case Ce:
            S2.carriageReturn();
            break;
          case ce:
            S2.setTextMatrix(f3[0], f3[1], f3[2], f3[3], f3[4], f3[5]);
            S2.setTextLineMatrix(f3[0], f3[1], f3[2], f3[3], f3[4], f3[5]);
            updateAdvanceScale();
            break;
          case te:
            S2.charSpacing = f3[0];
            break;
          case ie:
            S2.wordSpacing = f3[0];
            break;
          case Ae:
            S2.textMatrix = i.slice();
            S2.textLineMatrix = i.slice();
            break;
          case Be:
            if (!r2.state.font) {
              p2.ensureStateFont(r2.state);
              continue;
            }
            const a4 = (S2.font.vertical ? 1 : -1) * S2.fontSize / 1e3, u4 = f3[0];
            for (let e5 = 0, t3 = u4.length; e5 < t3; e5++) {
              const t4 = u4[e5];
              if ("string" == typeof t4)
                y2.push(t4);
              else if ("number" == typeof t4 && 0 !== t4) {
                const e6 = y2.join("");
                y2.length = 0;
                buildTextContentItem({ chars: e6, extraSpacing: t4 * a4 });
              }
            }
            if (y2.length > 0) {
              const e5 = y2.join("");
              y2.length = 0;
              buildTextContentItem({ chars: e5, extraSpacing: 0 });
            }
            break;
          case he:
            if (!r2.state.font) {
              p2.ensureStateFont(r2.state);
              continue;
            }
            buildTextContentItem({ chars: f3[0], extraSpacing: 0 });
            break;
          case le:
            if (!r2.state.font) {
              p2.ensureStateFont(r2.state);
              continue;
            }
            S2.carriageReturn();
            buildTextContentItem({ chars: f3[0], extraSpacing: 0 });
            break;
          case Qe:
            if (!r2.state.font) {
              p2.ensureStateFont(r2.state);
              continue;
            }
            S2.wordSpacing = f3[0];
            S2.charSpacing = f3[1];
            S2.carriageReturn();
            buildTextContentItem({ chars: f3[2], extraSpacing: 0 });
            break;
          case Me:
            flushTextContentItem();
            w2 || (w2 = s2.get("XObject") || Dict.empty);
            var G2 = f3[0] instanceof Name, x2 = f3[0].name;
            if (G2 && D2.getByName(x2))
              break;
            next(new Promise(function(e5, i2) {
              if (!G2)
                throw new FormatError("XObject must be referred to by name.");
              let a5 = w2.getRaw(x2);
              if (a5 instanceof Ref) {
                if (D2.getByRef(a5)) {
                  e5();
                  return;
                }
                if (p2.globalImageCache.getData(a5, p2.pageIndex)) {
                  e5();
                  return;
                }
                a5 = m2.fetch(a5);
              }
              if (!(a5 instanceof BaseStream))
                throw new FormatError("XObject should be a stream");
              const E3 = a5.dict.get("Subtype");
              if (!(E3 instanceof Name))
                throw new FormatError("XObject should have a Name subtype");
              if ("Form" !== E3.name) {
                D2.set(x2, a5.dict.objId, true);
                e5();
                return;
              }
              const u5 = r2.state.clone(), d4 = new StateManager(u5), f4 = lookupMatrix(a5.dict.getArray("Matrix"), null);
              f4 && d4.transform(f4);
              enqueueChunk();
              const y3 = { enqueueInvoked: false, enqueue(e6, t3) {
                this.enqueueInvoked = true;
                g2.enqueue(e6, t3);
              }, get desiredSize() {
                return g2.desiredSize;
              }, get ready() {
                return g2.ready;
              } };
              p2.getTextContent({ stream: a5, task: t2, resources: a5.dict.get("Resources") || s2, stateManager: d4, includeMarkedContent: n2, sink: y3, seenStyles: o2, viewBox: c2, lang: C2, markedContentData: h2, disableNormalization: l2, keepWhiteSpace: Q2 }).then(function() {
                y3.enqueueInvoked || D2.set(x2, a5.dict.objId, true);
                e5();
              }, i2);
            }).catch(function(e5) {
              if (!(e5 instanceof AbortException)) {
                if (!p2.options.ignoreErrors)
                  throw e5;
                warn(`getTextContent - ignoring XObject: "${e5}".`);
              }
            }));
            return;
          case GA:
            G2 = f3[0] instanceof Name;
            x2 = f3[0].name;
            if (G2 && b2.getByName(x2))
              break;
            next(new Promise(function(e5, t3) {
              if (!G2)
                throw new FormatError("GState must be referred to by name.");
              const i2 = s2.get("ExtGState");
              if (!(i2 instanceof Dict))
                throw new FormatError("ExtGState should be a dictionary.");
              const a5 = i2.get(x2);
              if (!(a5 instanceof Dict))
                throw new FormatError("GState should be a dictionary.");
              const r3 = a5.get("Font");
              if (r3) {
                flushTextContentItem();
                S2.fontName = null;
                S2.fontSize = r3[1];
                handleSetFont(null, r3[0]).then(e5, t3);
              } else {
                b2.set(x2, a5.objId, true);
                e5();
              }
            }).catch(function(e5) {
              if (!(e5 instanceof AbortException)) {
                if (!p2.options.ignoreErrors)
                  throw e5;
                warn(`getTextContent - ignoring ExtGState: "${e5}".`);
              }
            }));
            return;
          case Je:
            flushTextContentItem();
            if (n2) {
              h2.level++;
              E2.items.push({ type: "beginMarkedContent", tag: f3[0] instanceof Name ? f3[0].name : null });
            }
            break;
          case Ye:
            flushTextContentItem();
            if (n2) {
              h2.level++;
              let e5 = null;
              f3[1] instanceof Dict && (e5 = f3[1].get("MCID"));
              E2.items.push({ type: "beginMarkedContentProps", id: Number.isInteger(e5) ? `${p2.idFactory.getPageObjId()}_mc${e5}` : null, tag: f3[0] instanceof Name ? f3[0].name : null });
            }
            break;
          case ve:
            flushTextContentItem();
            if (n2) {
              if (0 === h2.level)
                break;
              h2.level--;
              E2.items.push({ type: "endMarkedContent" });
            }
            break;
          case UA:
            !e4 || e4.font === S2.font && e4.fontSize === S2.fontSize && e4.fontName === S2.fontName || flushTextContentItem();
        }
        if (E2.items.length >= g2.desiredSize) {
          d3 = true;
          break;
        }
      }
      if (d3)
        next(xs);
      else {
        flushTextContentItem();
        enqueueChunk();
        e3();
      }
    }).catch((e3) => {
      if (!(e3 instanceof AbortException)) {
        if (!this.options.ignoreErrors)
          throw e3;
        warn(`getTextContent - ignoring errors during "${t2.name}" task: "${e3}".`);
        flushTextContentItem();
        enqueueChunk();
      }
    });
  }
  async extractDataStructures(e2, t2) {
    const i2 = this.xref;
    let a2;
    const s2 = this.readToUnicode(t2.toUnicode);
    if (t2.composite) {
      const i3 = e2.get("CIDSystemInfo");
      i3 instanceof Dict && (t2.cidSystemInfo = { registry: stringToPDFString(i3.get("Registry")), ordering: stringToPDFString(i3.get("Ordering")), supplement: i3.get("Supplement") });
      try {
        const t3 = e2.get("CIDToGIDMap");
        t3 instanceof BaseStream && (a2 = t3.getBytes());
      } catch (e3) {
        if (!this.options.ignoreErrors)
          throw e3;
        warn(`extractDataStructures - ignoring CIDToGIDMap data: "${e3}".`);
      }
    }
    const r2 = [];
    let n2, g2 = null;
    if (e2.has("Encoding")) {
      n2 = e2.get("Encoding");
      if (n2 instanceof Dict) {
        g2 = n2.get("BaseEncoding");
        g2 = g2 instanceof Name ? g2.name : null;
        if (n2.has("Differences")) {
          const e3 = n2.get("Differences");
          let t3 = 0;
          for (const a3 of e3) {
            const e4 = i2.fetchIfRef(a3);
            if ("number" == typeof e4)
              t3 = e4;
            else {
              if (!(e4 instanceof Name))
                throw new FormatError(`Invalid entry in 'Differences' array: ${e4}`);
              r2[t3++] = e4.name;
            }
          }
        }
      } else if (n2 instanceof Name)
        g2 = n2.name;
      else {
        const e3 = "Encoding is not a Name nor a Dict";
        if (!this.options.ignoreErrors)
          throw new FormatError(e3);
        warn(e3);
      }
      "MacRomanEncoding" !== g2 && "MacExpertEncoding" !== g2 && "WinAnsiEncoding" !== g2 && (g2 = null);
    }
    const o2 = !t2.file || t2.isInternalFont, c2 = $i()[t2.name];
    g2 && o2 && c2 && (g2 = null);
    if (g2)
      t2.defaultEncoding = getEncoding(g2);
    else {
      const e3 = !!(t2.flags & Pi), i3 = !!(t2.flags & Wi);
      n2 = yi;
      "TrueType" !== t2.type || i3 || (n2 = wi);
      if (e3 || c2) {
        n2 = mi;
        o2 && (/Symbol/i.test(t2.name) ? n2 = Di : /Dingbats/i.test(t2.name) ? n2 = bi : /Wingdings/i.test(t2.name) && (n2 = wi));
      }
      t2.defaultEncoding = n2;
    }
    t2.differences = r2;
    t2.baseEncodingName = g2;
    t2.hasEncoding = !!g2 || r2.length > 0;
    t2.dict = e2;
    t2.toUnicode = await s2;
    const C2 = await this.buildToUnicode(t2);
    t2.toUnicode = C2;
    a2 && (t2.cidToGidMap = this.readCidToGidMap(a2, C2));
    return t2;
  }
  _simpleFontToUnicode(e2, t2 = false) {
    assert(!e2.composite, "Must be a simple font.");
    const i2 = [], a2 = e2.defaultEncoding.slice(), s2 = e2.baseEncodingName, r2 = e2.differences;
    for (const e3 in r2) {
      const t3 = r2[e3];
      ".notdef" !== t3 && (a2[e3] = t3);
    }
    const n2 = Mi();
    for (const r3 in a2) {
      let g2 = a2[r3];
      if ("" === g2)
        continue;
      let o2 = n2[g2];
      if (void 0 !== o2) {
        i2[r3] = String.fromCharCode(o2);
        continue;
      }
      let c2 = 0;
      switch (g2[0]) {
        case "G":
          3 === g2.length && (c2 = parseInt(g2.substring(1), 16));
          break;
        case "g":
          5 === g2.length && (c2 = parseInt(g2.substring(1), 16));
          break;
        case "C":
        case "c":
          if (g2.length >= 3 && g2.length <= 4) {
            const i3 = g2.substring(1);
            if (t2) {
              c2 = parseInt(i3, 16);
              break;
            }
            c2 = +i3;
            if (Number.isNaN(c2) && Number.isInteger(parseInt(i3, 16)))
              return this._simpleFontToUnicode(e2, true);
          }
          break;
        case "u":
          o2 = getUnicodeForGlyph(g2, n2);
          -1 !== o2 && (c2 = o2);
          break;
        default:
          switch (g2) {
            case "f_h":
            case "f_t":
            case "T_h":
              i2[r3] = g2.replaceAll("_", "");
              continue;
          }
      }
      if (c2 > 0 && c2 <= 1114111 && Number.isInteger(c2)) {
        if (s2 && c2 === +r3) {
          const e3 = getEncoding(s2);
          if (e3 && (g2 = e3[r3])) {
            i2[r3] = String.fromCharCode(n2[g2]);
            continue;
          }
        }
        i2[r3] = String.fromCodePoint(c2);
      }
    }
    return i2;
  }
  async buildToUnicode(e2) {
    var _a4, _b2;
    e2.hasIncludedToUnicodeMap = ((_a4 = e2.toUnicode) == null ? void 0 : _a4.length) > 0;
    if (e2.hasIncludedToUnicodeMap) {
      !e2.composite && e2.hasEncoding && (e2.fallbackToUnicode = this._simpleFontToUnicode(e2));
      return e2.toUnicode;
    }
    if (!e2.composite)
      return new ToUnicodeMap(this._simpleFontToUnicode(e2));
    if (e2.composite && (e2.cMap.builtInCMap && !(e2.cMap instanceof IdentityCMap) || "Adobe" === ((_b2 = e2.cidSystemInfo) == null ? void 0 : _b2.registry) && ("GB1" === e2.cidSystemInfo.ordering || "CNS1" === e2.cidSystemInfo.ordering || "Japan1" === e2.cidSystemInfo.ordering || "Korea1" === e2.cidSystemInfo.ordering))) {
      const { registry: t2, ordering: i2 } = e2.cidSystemInfo, a2 = Name.get(`${t2}-${i2}-UCS2`), s2 = await CMapFactory.create({ encoding: a2, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }), r2 = [], n2 = [];
      e2.cMap.forEach(function(e3, t3) {
        if (t3 > 65535)
          throw new FormatError("Max size of CID is 65,535");
        const i3 = s2.lookup(t3);
        if (i3) {
          n2.length = 0;
          for (let e4 = 0, t4 = i3.length; e4 < t4; e4 += 2)
            n2.push((i3.charCodeAt(e4) << 8) + i3.charCodeAt(e4 + 1));
          r2[e3] = String.fromCharCode(...n2);
        }
      });
      return new ToUnicodeMap(r2);
    }
    return new IdentityToUnicodeMap(e2.firstChar, e2.lastChar);
  }
  async readToUnicode(e2) {
    if (!e2)
      return null;
    if (e2 instanceof Name) {
      const t2 = await CMapFactory.create({ encoding: e2, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      return t2 instanceof IdentityCMap ? new IdentityToUnicodeMap(0, 65535) : new ToUnicodeMap(t2.getMap());
    }
    if (e2 instanceof BaseStream)
      try {
        const t2 = await CMapFactory.create({ encoding: e2, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
        if (t2 instanceof IdentityCMap)
          return new IdentityToUnicodeMap(0, 65535);
        const i2 = new Array(t2.length);
        t2.forEach(function(e3, t3) {
          if ("number" == typeof t3) {
            i2[e3] = String.fromCodePoint(t3);
            return;
          }
          t3.length % 2 != 0 && (t3 = "\0" + t3);
          const a2 = [];
          for (let e4 = 0; e4 < t3.length; e4 += 2) {
            const i3 = t3.charCodeAt(e4) << 8 | t3.charCodeAt(e4 + 1);
            if (55296 != (63488 & i3)) {
              a2.push(i3);
              continue;
            }
            e4 += 2;
            const s2 = t3.charCodeAt(e4) << 8 | t3.charCodeAt(e4 + 1);
            a2.push(((1023 & i3) << 10) + (1023 & s2) + 65536);
          }
          i2[e3] = String.fromCodePoint(...a2);
        });
        return new ToUnicodeMap(i2);
      } catch (e3) {
        if (e3 instanceof AbortException)
          return null;
        if (this.options.ignoreErrors) {
          warn(`readToUnicode - ignoring ToUnicode data: "${e3}".`);
          return null;
        }
        throw e3;
      }
    return null;
  }
  readCidToGidMap(e2, t2) {
    const i2 = [];
    for (let a2 = 0, s2 = e2.length; a2 < s2; a2++) {
      const s3 = e2[a2++] << 8 | e2[a2], r2 = a2 >> 1;
      (0 !== s3 || t2.has(r2)) && (i2[r2] = s3);
    }
    return i2;
  }
  extractWidths(e2, t2, i2) {
    const a2 = this.xref;
    let s2 = [], r2 = 0;
    const n2 = [];
    let g2;
    if (i2.composite) {
      const t3 = e2.get("DW");
      r2 = "number" == typeof t3 ? Math.ceil(t3) : 1e3;
      const o3 = e2.get("W");
      if (Array.isArray(o3))
        for (let e3 = 0, t4 = o3.length; e3 < t4; e3++) {
          let t5 = a2.fetchIfRef(o3[e3++]);
          if (!Number.isInteger(t5))
            break;
          const i3 = a2.fetchIfRef(o3[e3]);
          if (Array.isArray(i3))
            for (const e4 of i3) {
              const i4 = a2.fetchIfRef(e4);
              "number" == typeof i4 && (s2[t5] = i4);
              t5++;
            }
          else {
            if (!Number.isInteger(i3))
              break;
            {
              const r3 = a2.fetchIfRef(o3[++e3]);
              if ("number" != typeof r3)
                continue;
              for (let e4 = t5; e4 <= i3; e4++)
                s2[e4] = r3;
            }
          }
        }
      if (i2.vertical) {
        const t4 = e2.getArray("DW2");
        let i3 = isNumberArray(t4, 2) ? t4 : [880, -1e3];
        g2 = [i3[1], 0.5 * r2, i3[0]];
        i3 = e2.get("W2");
        if (Array.isArray(i3))
          for (let e3 = 0, t5 = i3.length; e3 < t5; e3++) {
            let t6 = a2.fetchIfRef(i3[e3++]);
            if (!Number.isInteger(t6))
              break;
            const s3 = a2.fetchIfRef(i3[e3]);
            if (Array.isArray(s3))
              for (let e4 = 0, i4 = s3.length; e4 < i4; e4++) {
                const i5 = [a2.fetchIfRef(s3[e4++]), a2.fetchIfRef(s3[e4++]), a2.fetchIfRef(s3[e4])];
                isNumberArray(i5, null) && (n2[t6] = i5);
                t6++;
              }
            else {
              if (!Number.isInteger(s3))
                break;
              {
                const r3 = [a2.fetchIfRef(i3[++e3]), a2.fetchIfRef(i3[++e3]), a2.fetchIfRef(i3[++e3])];
                if (!isNumberArray(r3, null))
                  continue;
                for (let e4 = t6; e4 <= s3; e4++)
                  n2[e4] = r3;
              }
            }
          }
      }
    } else {
      const n3 = e2.get("Widths");
      if (Array.isArray(n3)) {
        let e3 = i2.firstChar;
        for (const t3 of n3) {
          const i3 = a2.fetchIfRef(t3);
          "number" == typeof i3 && (s2[e3] = i3);
          e3++;
        }
        const g3 = t2.get("MissingWidth");
        r2 = "number" == typeof g3 ? g3 : 0;
      } else {
        const t3 = e2.get("BaseFont");
        if (t3 instanceof Name) {
          const e3 = this.getBaseFontMetrics(t3.name);
          s2 = this.buildCharCodeToWidth(e3.widths, i2);
          r2 = e3.defaultWidth;
        }
      }
    }
    let o2 = true, c2 = r2;
    for (const e3 in s2) {
      const t3 = s2[e3];
      if (t3)
        if (c2) {
          if (c2 !== t3) {
            o2 = false;
            break;
          }
        } else
          c2 = t3;
    }
    o2 ? i2.flags |= qi : i2.flags &= ~qi;
    i2.defaultWidth = r2;
    i2.widths = s2;
    i2.defaultVMetrics = g2;
    i2.vmetrics = n2;
  }
  isSerifFont(e2) {
    const t2 = e2.split("-", 1)[0];
    return t2 in _i2() || /serif/gi.test(t2);
  }
  getBaseFontMetrics(e2) {
    let t2 = 0, i2 = /* @__PURE__ */ Object.create(null), a2 = false;
    let s2 = Zi()[e2] || e2;
    const r2 = aa();
    s2 in r2 || (s2 = this.isSerifFont(e2) ? "Times-Roman" : "Helvetica");
    const n2 = r2[s2];
    if ("number" == typeof n2) {
      t2 = n2;
      a2 = true;
    } else
      i2 = n2();
    return { defaultWidth: t2, monospace: a2, widths: i2 };
  }
  buildCharCodeToWidth(e2, t2) {
    const i2 = /* @__PURE__ */ Object.create(null), a2 = t2.differences, s2 = t2.defaultEncoding;
    for (let t3 = 0; t3 < 256; t3++)
      t3 in a2 && e2[a2[t3]] ? i2[t3] = e2[a2[t3]] : t3 in s2 && e2[s2[t3]] && (i2[t3] = e2[s2[t3]]);
    return i2;
  }
  preEvaluateFont(e2) {
    const t2 = e2;
    let i2 = e2.get("Subtype");
    if (!(i2 instanceof Name))
      throw new FormatError("invalid font Subtype");
    let a2, s2 = false;
    if ("Type0" === i2.name) {
      const t3 = e2.get("DescendantFonts");
      if (!t3)
        throw new FormatError("Descendant fonts are not specified");
      if (!((e2 = Array.isArray(t3) ? this.xref.fetchIfRef(t3[0]) : t3) instanceof Dict))
        throw new FormatError("Descendant font is not a dictionary.");
      i2 = e2.get("Subtype");
      if (!(i2 instanceof Name))
        throw new FormatError("invalid font Subtype");
      s2 = true;
    }
    let r2 = e2.get("FirstChar");
    Number.isInteger(r2) || (r2 = 0);
    let n2 = e2.get("LastChar");
    Number.isInteger(n2) || (n2 = s2 ? 65535 : 255);
    const g2 = e2.get("FontDescriptor"), o2 = e2.get("ToUnicode") || t2.get("ToUnicode");
    if (g2) {
      a2 = new MurmurHash3_64();
      const i3 = t2.getRaw("Encoding");
      if (i3 instanceof Name)
        a2.update(i3.name);
      else if (i3 instanceof Ref)
        a2.update(i3.toString());
      else if (i3 instanceof Dict) {
        for (const e3 of i3.getRawValues())
          if (e3 instanceof Name)
            a2.update(e3.name);
          else if (e3 instanceof Ref)
            a2.update(e3.toString());
          else if (Array.isArray(e3)) {
            const t3 = e3.length, i4 = new Array(t3);
            for (let a3 = 0; a3 < t3; a3++) {
              const t4 = e3[a3];
              t4 instanceof Name ? i4[a3] = t4.name : ("number" == typeof t4 || t4 instanceof Ref) && (i4[a3] = t4.toString());
            }
            a2.update(i4.join());
          }
      }
      a2.update(`${r2}-${n2}`);
      if (o2 instanceof BaseStream) {
        const e3 = o2.str || o2, t3 = e3.buffer ? new Uint8Array(e3.buffer.buffer, 0, e3.bufferLength) : new Uint8Array(e3.bytes.buffer, e3.start, e3.end - e3.start);
        a2.update(t3);
      } else
        o2 instanceof Name && a2.update(o2.name);
      const g3 = e2.get("Widths") || t2.get("Widths");
      if (Array.isArray(g3)) {
        const e3 = [];
        for (const t3 of g3)
          ("number" == typeof t3 || t3 instanceof Ref) && e3.push(t3.toString());
        a2.update(e3.join());
      }
      if (s2) {
        a2.update("compositeFont");
        const i4 = e2.get("W") || t2.get("W");
        if (Array.isArray(i4)) {
          const e3 = [];
          for (const t3 of i4)
            if ("number" == typeof t3 || t3 instanceof Ref)
              e3.push(t3.toString());
            else if (Array.isArray(t3)) {
              const i5 = [];
              for (const e4 of t3)
                ("number" == typeof e4 || e4 instanceof Ref) && i5.push(e4.toString());
              e3.push(`[${i5.join()}]`);
            }
          a2.update(e3.join());
        }
        const s3 = e2.getRaw("CIDToGIDMap") || t2.getRaw("CIDToGIDMap");
        s3 instanceof Name ? a2.update(s3.name) : s3 instanceof Ref ? a2.update(s3.toString()) : s3 instanceof BaseStream && a2.update(s3.peekBytes());
      }
    }
    return { descriptor: g2, dict: e2, baseDict: t2, composite: s2, type: i2.name, firstChar: r2, lastChar: n2, toUnicode: o2, hash: a2 ? a2.hexdigest() : "" };
  }
  async translateFont({ descriptor: e2, dict: t2, baseDict: i2, composite: s2, type: r2, firstChar: n2, lastChar: g2, toUnicode: o2, cssFontInfo: c2 }) {
    const C2 = "Type3" === r2;
    if (!e2) {
      if (!C2) {
        let e3 = t2.get("BaseFont");
        if (!(e3 instanceof Name))
          throw new FormatError("Base font is not specified");
        e3 = e3.name.replaceAll(/[,_]/g, "-");
        const a2 = this.getBaseFontMetrics(e3), s3 = e3.split("-", 1)[0], c3 = (this.isSerifFont(s3) ? Oi : 0) | (a2.monospace ? qi : 0) | ($i()[s3] ? Pi : Wi), h3 = { type: r2, name: e3, loadedName: i2.loadedName, systemFontInfo: null, widths: a2.widths, defaultWidth: a2.defaultWidth, isSimulatedFlags: true, flags: c3, firstChar: n2, lastChar: g2, toUnicode: o2, xHeight: 0, capHeight: 0, italicAngle: 0, isType3Font: C2 }, l3 = t2.get("Widths"), Q3 = getStandardFontName(e3);
        let E3 = null;
        if (Q3) {
          E3 = await this.fetchStandardFontData(Q3);
          h3.isInternalFont = !!E3;
        }
        !h3.isInternalFont && this.options.useSystemFonts && (h3.systemFontInfo = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, e3, Q3, r2));
        const u3 = await this.extractDataStructures(t2, h3);
        if (Array.isArray(l3)) {
          const e4 = [];
          let t3 = n2;
          for (const i3 of l3) {
            const a3 = this.xref.fetchIfRef(i3);
            "number" == typeof a3 && (e4[t3] = a3);
            t3++;
          }
          u3.widths = e4;
        } else
          u3.widths = this.buildCharCodeToWidth(a2.widths, u3);
        return new Font(e3, E3, u3);
      }
      {
        const i3 = lookupNormalRect(t2.getArray("FontBBox"), [0, 0, 0, 0]);
        (e2 = new Dict(null)).set("FontName", Name.get(r2));
        e2.set("FontBBox", i3);
      }
    }
    let h2 = e2.get("FontName"), l2 = t2.get("BaseFont");
    "string" == typeof h2 && (h2 = Name.get(h2));
    "string" == typeof l2 && (l2 = Name.get(l2));
    const Q2 = h2 == null ? void 0 : h2.name, E2 = l2 == null ? void 0 : l2.name;
    if (!C2 && Q2 !== E2) {
      info(`The FontDescriptor's FontName is "${Q2}" but should be the same as the Font's BaseFont "${E2}".`);
      Q2 && E2 && (E2.startsWith(Q2) || !isKnownFontName(Q2) && isKnownFontName(E2)) && (h2 = null);
    }
    h2 || (h2 = l2);
    if (!(h2 instanceof Name))
      throw new FormatError("invalid font name");
    let u2, d2, f2, p2, m2;
    try {
      u2 = e2.get("FontFile", "FontFile2", "FontFile3");
    } catch (e3) {
      if (!this.options.ignoreErrors)
        throw e3;
      warn(`translateFont - fetching "${h2.name}" font file: "${e3}".`);
      u2 = new NullStream();
    }
    let y2 = false, w2 = null, D2 = null;
    if (u2) {
      if (u2.dict) {
        const e3 = u2.dict.get("Subtype");
        e3 instanceof Name && (d2 = e3.name);
        f2 = u2.dict.get("Length1");
        p2 = u2.dict.get("Length2");
        m2 = u2.dict.get("Length3");
      }
    } else if (c2) {
      const e3 = getXfaFontName(h2.name);
      if (e3) {
        c2.fontFamily = `${c2.fontFamily}-PdfJS-XFA`;
        c2.metrics = e3.metrics || null;
        w2 = e3.factors || null;
        u2 = await this.fetchStandardFontData(e3.name);
        y2 = !!u2;
        i2 = t2 = getXfaFontDict(h2.name);
        s2 = true;
      }
    } else if (!C2) {
      const e3 = getStandardFontName(h2.name);
      if (e3) {
        u2 = await this.fetchStandardFontData(e3);
        y2 = !!u2;
      }
      !y2 && this.options.useSystemFonts && (D2 = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, h2.name, e3, r2));
    }
    const b2 = lookupMatrix(t2.getArray("FontMatrix"), a), F2 = lookupNormalRect(e2.getArray("FontBBox") || t2.getArray("FontBBox"), void 0);
    let S2 = e2.get("Ascent");
    "number" != typeof S2 && (S2 = void 0);
    let k2 = e2.get("Descent");
    "number" != typeof k2 && (k2 = void 0);
    let R2 = e2.get("XHeight");
    "number" != typeof R2 && (R2 = 0);
    let N2 = e2.get("CapHeight");
    "number" != typeof N2 && (N2 = 0);
    let G2 = e2.get("Flags");
    Number.isInteger(G2) || (G2 = 0);
    let x2 = e2.get("ItalicAngle");
    "number" != typeof x2 && (x2 = 0);
    const U2 = { type: r2, name: h2.name, subtype: d2, file: u2, length1: f2, length2: p2, length3: m2, isInternalFont: y2, loadedName: i2.loadedName, composite: s2, fixedPitch: false, fontMatrix: b2, firstChar: n2, lastChar: g2, toUnicode: o2, bbox: F2, ascent: S2, descent: k2, xHeight: R2, capHeight: N2, flags: G2, italicAngle: x2, isType3Font: C2, cssFontInfo: c2, scaleFactors: w2, systemFontInfo: D2 };
    if (s2) {
      const e3 = i2.get("Encoding");
      e3 instanceof Name && (U2.cidEncoding = e3.name);
      const t3 = await CMapFactory.create({ encoding: e3, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      U2.cMap = t3;
      U2.vertical = U2.cMap.vertical;
    }
    const M2 = await this.extractDataStructures(t2, U2);
    this.extractWidths(t2, e2, M2);
    return new Font(h2.name, u2, M2);
  }
  static buildFontPaths(e2, t2, i2, a2) {
    function buildPath(t3) {
      const s2 = `${e2.loadedName}_path_${t3}`;
      try {
        if (e2.renderer.hasBuiltPath(t3))
          return;
        i2.send("commonobj", [s2, "FontPath", e2.renderer.getPathJs(t3)]);
      } catch (e3) {
        if (a2.ignoreErrors) {
          warn(`buildFontPaths - ignoring ${s2} glyph: "${e3}".`);
          return;
        }
        throw e3;
      }
    }
    for (const e3 of t2) {
      buildPath(e3.fontChar);
      const t3 = e3.accent;
      (t3 == null ? void 0 : t3.fontChar) && buildPath(t3.fontChar);
    }
  }
  static get fallbackFontDict() {
    const e2 = new Dict();
    e2.set("BaseFont", Name.get("Helvetica"));
    e2.set("Type", Name.get("FallbackType"));
    e2.set("Subtype", Name.get("FallbackType"));
    e2.set("Encoding", Name.get("WinAnsiEncoding"));
    return shadow(this, "fallbackFontDict", e2);
  }
};
var TranslatedFont = class {
  constructor({ loadedName: e2, font: t2, dict: i2, evaluatorOptions: a2 }) {
    this.loadedName = e2;
    this.font = t2;
    this.dict = i2;
    this._evaluatorOptions = a2 || Rs;
    this.type3Loaded = null;
    this.type3Dependencies = t2.isType3Font ? /* @__PURE__ */ new Set() : null;
    this.sent = false;
  }
  send(e2) {
    if (!this.sent) {
      this.sent = true;
      e2.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]);
    }
  }
  fallback(e2) {
    if (this.font.data) {
      this.font.disableFontFace = true;
      PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, e2, this._evaluatorOptions);
    }
  }
  loadType3Data(e2, t2, i2) {
    if (this.type3Loaded)
      return this.type3Loaded;
    if (!this.font.isType3Font)
      throw new Error("Must be a Type3 font.");
    const a2 = e2.clone({ ignoreErrors: false }), s2 = new RefSet(e2.type3FontRefs);
    this.dict.objId && !s2.has(this.dict.objId) && s2.put(this.dict.objId);
    a2.type3FontRefs = s2;
    const r2 = this.font, n2 = this.type3Dependencies;
    let g2 = Promise.resolve();
    const o2 = this.dict.get("CharProcs"), c2 = this.dict.get("Resources") || t2, C2 = /* @__PURE__ */ Object.create(null), h2 = Util.normalizeRect(r2.bbox || [0, 0, 0, 0]), l2 = h2[2] - h2[0], Q2 = h2[3] - h2[1], E2 = Math.hypot(l2, Q2);
    for (const e3 of o2.getKeys())
      g2 = g2.then(() => {
        const t3 = o2.get(e3), s3 = new OperatorList();
        return a2.getOperatorList({ stream: t3, task: i2, resources: c2, operatorList: s3 }).then(() => {
          s3.fnArray[0] === ue && this._removeType3ColorOperators(s3, E2);
          C2[e3] = s3.getIR();
          for (const e4 of s3.dependencies)
            n2.add(e4);
        }).catch(function(t4) {
          warn(`Type3 font resource "${e3}" is not available.`);
          const i3 = new OperatorList();
          C2[e3] = i3.getIR();
        });
      });
    this.type3Loaded = g2.then(() => {
      r2.charProcOperatorList = C2;
      if (this._bbox) {
        r2.isCharBBox = true;
        r2.bbox = this._bbox;
      }
    });
    return this.type3Loaded;
  }
  _removeType3ColorOperators(e2, t2 = NaN) {
    const i2 = Util.normalizeRect(e2.argsArray[0].slice(2)), a2 = i2[2] - i2[0], s2 = i2[3] - i2[1], r2 = Math.hypot(a2, s2);
    if (0 === a2 || 0 === s2) {
      e2.fnArray.splice(0, 1);
      e2.argsArray.splice(0, 1);
    } else if (0 === t2 || Math.round(r2 / t2) >= 10) {
      this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]);
      this._bbox[0] = Math.min(this._bbox[0], i2[0]);
      this._bbox[1] = Math.min(this._bbox[1], i2[1]);
      this._bbox[2] = Math.max(this._bbox[2], i2[2]);
      this._bbox[3] = Math.max(this._bbox[3], i2[3]);
    }
    let n2 = 0, g2 = e2.length;
    for (; n2 < g2; ) {
      switch (e2.fnArray[n2]) {
        case ue:
          break;
        case de:
        case fe:
        case pe:
        case me:
        case ye:
        case we:
        case De:
        case be:
        case Fe:
        case Se:
        case ke:
        case Re:
        case Ne:
        case RA:
          e2.fnArray.splice(n2, 1);
          e2.argsArray.splice(n2, 1);
          g2--;
          continue;
        case GA:
          const [t3] = e2.argsArray[n2];
          let i3 = 0, a3 = t3.length;
          for (; i3 < a3; ) {
            const [e3] = t3[i3];
            switch (e3) {
              case "TR":
              case "TR2":
              case "HT":
              case "BG":
              case "BG2":
              case "UCR":
              case "UCR2":
                t3.splice(i3, 1);
                a3--;
                continue;
            }
            i3++;
          }
      }
      n2++;
    }
  }
};
var StateManager = class {
  constructor(e2 = new EvalState()) {
    this.state = e2;
    this.stateStack = [];
  }
  save() {
    const e2 = this.state;
    this.stateStack.push(this.state);
    this.state = e2.clone();
  }
  restore() {
    const e2 = this.stateStack.pop();
    e2 && (this.state = e2);
  }
  transform(e2) {
    this.state.ctm = Util.transform(this.state.ctm, e2);
  }
};
var TextState = class {
  constructor() {
    this.ctm = new Float32Array(i);
    this.fontName = null;
    this.fontSize = 0;
    this.loadedName = null;
    this.font = null;
    this.fontMatrix = a;
    this.textMatrix = i.slice();
    this.textLineMatrix = i.slice();
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.leading = 0;
    this.textHScale = 1;
    this.textRise = 0;
  }
  setTextMatrix(e2, t2, i2, a2, s2, r2) {
    const n2 = this.textMatrix;
    n2[0] = e2;
    n2[1] = t2;
    n2[2] = i2;
    n2[3] = a2;
    n2[4] = s2;
    n2[5] = r2;
  }
  setTextLineMatrix(e2, t2, i2, a2, s2, r2) {
    const n2 = this.textLineMatrix;
    n2[0] = e2;
    n2[1] = t2;
    n2[2] = i2;
    n2[3] = a2;
    n2[4] = s2;
    n2[5] = r2;
  }
  translateTextMatrix(e2, t2) {
    const i2 = this.textMatrix;
    i2[4] = i2[0] * e2 + i2[2] * t2 + i2[4];
    i2[5] = i2[1] * e2 + i2[3] * t2 + i2[5];
  }
  translateTextLineMatrix(e2, t2) {
    const i2 = this.textLineMatrix;
    i2[4] = i2[0] * e2 + i2[2] * t2 + i2[4];
    i2[5] = i2[1] * e2 + i2[3] * t2 + i2[5];
  }
  carriageReturn() {
    this.translateTextLineMatrix(0, -this.leading);
    this.textMatrix = this.textLineMatrix.slice();
  }
  clone() {
    const e2 = Object.create(this);
    e2.textMatrix = this.textMatrix.slice();
    e2.textLineMatrix = this.textLineMatrix.slice();
    e2.fontMatrix = this.fontMatrix.slice();
    return e2;
  }
};
var EvalState = class {
  constructor() {
    this.ctm = new Float32Array(i);
    this.font = null;
    this.textRenderingMode = w;
    this._fillColorSpace = ColorSpace.singletons.gray;
    this._strokeColorSpace = ColorSpace.singletons.gray;
    this.patternFillColorSpace = null;
    this.patternStrokeColorSpace = null;
  }
  get fillColorSpace() {
    return this._fillColorSpace;
  }
  set fillColorSpace(e2) {
    this._fillColorSpace = this.patternFillColorSpace = e2;
  }
  get strokeColorSpace() {
    return this._strokeColorSpace;
  }
  set strokeColorSpace(e2) {
    this._strokeColorSpace = this.patternStrokeColorSpace = e2;
  }
  clone() {
    return Object.create(this);
  }
};
var _EvaluatorPreprocessor = class _EvaluatorPreprocessor {
  static get opMap() {
    return shadow(this, "opMap", Object.assign(/* @__PURE__ */ Object.create(null), { w: { id: DA, numArgs: 1, variableArgs: false }, J: { id: bA, numArgs: 1, variableArgs: false }, j: { id: FA, numArgs: 1, variableArgs: false }, M: { id: SA, numArgs: 1, variableArgs: false }, d: { id: kA, numArgs: 2, variableArgs: false }, ri: { id: RA, numArgs: 1, variableArgs: false }, i: { id: NA, numArgs: 1, variableArgs: false }, gs: { id: GA, numArgs: 1, variableArgs: false }, q: { id: xA, numArgs: 0, variableArgs: false }, Q: { id: UA, numArgs: 0, variableArgs: false }, cm: { id: MA, numArgs: 6, variableArgs: false }, m: { id: LA, numArgs: 2, variableArgs: false }, l: { id: HA, numArgs: 2, variableArgs: false }, c: { id: JA, numArgs: 6, variableArgs: false }, v: { id: YA, numArgs: 4, variableArgs: false }, y: { id: vA, numArgs: 4, variableArgs: false }, h: { id: KA, numArgs: 0, variableArgs: false }, re: { id: TA, numArgs: 4, variableArgs: false }, S: { id: qA, numArgs: 0, variableArgs: false }, s: { id: OA, numArgs: 0, variableArgs: false }, f: { id: PA, numArgs: 0, variableArgs: false }, F: { id: PA, numArgs: 0, variableArgs: false }, "f*": { id: WA, numArgs: 0, variableArgs: false }, B: { id: jA, numArgs: 0, variableArgs: false }, "B*": { id: XA, numArgs: 0, variableArgs: false }, b: { id: ZA, numArgs: 0, variableArgs: false }, "b*": { id: VA, numArgs: 0, variableArgs: false }, n: { id: zA, numArgs: 0, variableArgs: false }, W: { id: _A, numArgs: 0, variableArgs: false }, "W*": { id: $A, numArgs: 0, variableArgs: false }, BT: { id: Ae, numArgs: 0, variableArgs: false }, ET: { id: ee, numArgs: 0, variableArgs: false }, Tc: { id: te, numArgs: 1, variableArgs: false }, Tw: { id: ie, numArgs: 1, variableArgs: false }, Tz: { id: ae, numArgs: 1, variableArgs: false }, TL: { id: se, numArgs: 1, variableArgs: false }, Tf: { id: re, numArgs: 2, variableArgs: false }, Tr: { id: ne, numArgs: 1, variableArgs: false }, Ts: { id: ge, numArgs: 1, variableArgs: false }, Td: { id: oe, numArgs: 2, variableArgs: false }, TD: { id: Ie, numArgs: 2, variableArgs: false }, Tm: { id: ce, numArgs: 6, variableArgs: false }, "T*": { id: Ce, numArgs: 0, variableArgs: false }, Tj: { id: he, numArgs: 1, variableArgs: false }, TJ: { id: Be, numArgs: 1, variableArgs: false }, "'": { id: le, numArgs: 1, variableArgs: false }, '"': { id: Qe, numArgs: 3, variableArgs: false }, d0: { id: Ee, numArgs: 2, variableArgs: false }, d1: { id: ue, numArgs: 6, variableArgs: false }, CS: { id: de, numArgs: 1, variableArgs: false }, cs: { id: fe, numArgs: 1, variableArgs: false }, SC: { id: pe, numArgs: 4, variableArgs: true }, SCN: { id: me, numArgs: 33, variableArgs: true }, sc: { id: ye, numArgs: 4, variableArgs: true }, scn: { id: we, numArgs: 33, variableArgs: true }, G: { id: De, numArgs: 1, variableArgs: false }, g: { id: be, numArgs: 1, variableArgs: false }, RG: { id: Fe, numArgs: 3, variableArgs: false }, rg: { id: Se, numArgs: 3, variableArgs: false }, K: { id: ke, numArgs: 4, variableArgs: false }, k: { id: Re, numArgs: 4, variableArgs: false }, sh: { id: Ne, numArgs: 1, variableArgs: false }, BI: { id: Ge, numArgs: 0, variableArgs: false }, ID: { id: xe, numArgs: 0, variableArgs: false }, EI: { id: Ue, numArgs: 1, variableArgs: false }, Do: { id: Me, numArgs: 1, variableArgs: false }, MP: { id: Le, numArgs: 1, variableArgs: false }, DP: { id: He, numArgs: 2, variableArgs: false }, BMC: { id: Je, numArgs: 1, variableArgs: false }, BDC: { id: Ye, numArgs: 2, variableArgs: false }, EMC: { id: ve, numArgs: 0, variableArgs: false }, BX: { id: Ke, numArgs: 0, variableArgs: false }, EX: { id: Te, numArgs: 0, variableArgs: false }, BM: null, BD: null, true: null, fa: null, fal: null, fals: null, false: null, nu: null, nul: null, null: null }));
  }
  constructor(e2, t2, i2 = new StateManager()) {
    this.parser = new Parser({ lexer: new Lexer(e2, _EvaluatorPreprocessor.opMap), xref: t2 });
    this.stateManager = i2;
    this.nonProcessedArgs = [];
    this._isPathOp = false;
    this._numInvalidPathOPS = 0;
  }
  get savedStatesDepth() {
    return this.stateManager.stateStack.length;
  }
  read(e2) {
    let t2 = e2.args;
    for (; ; ) {
      const i2 = this.parser.getObj();
      if (i2 instanceof Cmd) {
        const a2 = i2.cmd, s2 = _EvaluatorPreprocessor.opMap[a2];
        if (!s2) {
          warn(`Unknown command "${a2}".`);
          continue;
        }
        const r2 = s2.id, n2 = s2.numArgs;
        let g2 = null !== t2 ? t2.length : 0;
        this._isPathOp || (this._numInvalidPathOPS = 0);
        this._isPathOp = r2 >= LA && r2 <= zA;
        if (s2.variableArgs)
          g2 > n2 && info(`Command ${a2}: expected [0, ${n2}] args, but received ${g2} args.`);
        else {
          if (g2 !== n2) {
            const e3 = this.nonProcessedArgs;
            for (; g2 > n2; ) {
              e3.push(t2.shift());
              g2--;
            }
            for (; g2 < n2 && 0 !== e3.length; ) {
              null === t2 && (t2 = []);
              t2.unshift(e3.pop());
              g2++;
            }
          }
          if (g2 < n2) {
            const e3 = `command ${a2}: expected ${n2} args, but received ${g2} args.`;
            if (this._isPathOp && ++this._numInvalidPathOPS > _EvaluatorPreprocessor.MAX_INVALID_PATH_OPS)
              throw new FormatError(`Invalid ${e3}`);
            warn(`Skipping ${e3}`);
            null !== t2 && (t2.length = 0);
            continue;
          }
        }
        this.preprocessCommand(r2, t2);
        e2.fn = r2;
        e2.args = t2;
        return true;
      }
      if (i2 === wt)
        return false;
      if (null !== i2) {
        null === t2 && (t2 = []);
        t2.push(i2);
        if (t2.length > 33)
          throw new FormatError("Too many arguments");
      }
    }
  }
  preprocessCommand(e2, t2) {
    switch (0 | e2) {
      case xA:
        this.stateManager.save();
        break;
      case UA:
        this.stateManager.restore();
        break;
      case MA:
        this.stateManager.transform(t2);
    }
  }
};
__publicField(_EvaluatorPreprocessor, "MAX_INVALID_PATH_OPS", 10);
var EvaluatorPreprocessor = _EvaluatorPreprocessor;
var DefaultAppearanceEvaluator = class extends EvaluatorPreprocessor {
  constructor(e2) {
    super(new StringStream(e2));
  }
  parse() {
    const e2 = { fn: 0, args: [] }, t2 = { fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3) };
    try {
      for (; ; ) {
        e2.args.length = 0;
        if (!this.read(e2))
          break;
        if (0 !== this.savedStatesDepth)
          continue;
        const { fn: i2, args: a2 } = e2;
        switch (0 | i2) {
          case re:
            const [e3, i3] = a2;
            e3 instanceof Name && (t2.fontName = e3.name);
            "number" == typeof i3 && i3 > 0 && (t2.fontSize = i3);
            break;
          case Se:
            ColorSpace.singletons.rgb.getRgbItem(a2, 0, t2.fontColor, 0);
            break;
          case be:
            ColorSpace.singletons.gray.getRgbItem(a2, 0, t2.fontColor, 0);
            break;
          case Re:
            ColorSpace.singletons.cmyk.getRgbItem(a2, 0, t2.fontColor, 0);
        }
      }
    } catch (e3) {
      warn(`parseDefaultAppearance - ignoring errors: "${e3}".`);
    }
    return t2;
  }
};
function parseDefaultAppearance(e2) {
  return new DefaultAppearanceEvaluator(e2).parse();
}
var AppearanceStreamEvaluator = class extends EvaluatorPreprocessor {
  constructor(e2, t2, i2) {
    var _a4;
    super(e2);
    this.stream = e2;
    this.evaluatorOptions = t2;
    this.xref = i2;
    this.resources = (_a4 = e2.dict) == null ? void 0 : _a4.get("Resources");
  }
  parse() {
    const e2 = { fn: 0, args: [] };
    let t2 = { scaleFactor: 1, fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3), fillColorSpace: ColorSpace.singletons.gray }, i2 = false;
    const a2 = [];
    try {
      for (; ; ) {
        e2.args.length = 0;
        if (i2 || !this.read(e2))
          break;
        const { fn: s2, args: r2 } = e2;
        switch (0 | s2) {
          case xA:
            a2.push({ scaleFactor: t2.scaleFactor, fontSize: t2.fontSize, fontName: t2.fontName, fontColor: t2.fontColor.slice(), fillColorSpace: t2.fillColorSpace });
            break;
          case UA:
            t2 = a2.pop() || t2;
            break;
          case ce:
            t2.scaleFactor *= Math.hypot(r2[0], r2[1]);
            break;
          case re:
            const [e3, s3] = r2;
            e3 instanceof Name && (t2.fontName = e3.name);
            "number" == typeof s3 && s3 > 0 && (t2.fontSize = s3 * t2.scaleFactor);
            break;
          case fe:
            t2.fillColorSpace = ColorSpace.parse({ cs: r2[0], xref: this.xref, resources: this.resources, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: this._localColorSpaceCache });
            break;
          case ye:
            t2.fillColorSpace.getRgbItem(r2, 0, t2.fontColor, 0);
            break;
          case Se:
            ColorSpace.singletons.rgb.getRgbItem(r2, 0, t2.fontColor, 0);
            break;
          case be:
            ColorSpace.singletons.gray.getRgbItem(r2, 0, t2.fontColor, 0);
            break;
          case Re:
            ColorSpace.singletons.cmyk.getRgbItem(r2, 0, t2.fontColor, 0);
            break;
          case he:
          case Be:
          case le:
          case Qe:
            i2 = true;
        }
      }
    } catch (e3) {
      warn(`parseAppearanceStream - ignoring errors: "${e3}".`);
    }
    this.stream.reset();
    delete t2.scaleFactor;
    delete t2.fillColorSpace;
    return t2;
  }
  get _localColorSpaceCache() {
    return shadow(this, "_localColorSpaceCache", new LocalColorSpaceCache());
  }
  get _pdfFunctionFactory() {
    return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.evaluatorOptions.isEvalSupported }));
  }
};
function getPdfColor(e2, t2) {
  if (e2[0] === e2[1] && e2[1] === e2[2]) {
    return `${numberToString(e2[0] / 255)} ${t2 ? "g" : "G"}`;
  }
  return Array.from(e2, (e3) => numberToString(e3 / 255)).join(" ") + " " + (t2 ? "rg" : "RG");
}
var FakeUnicodeFont = class _FakeUnicodeFont {
  constructor(e2, t2) {
    this.xref = e2;
    this.widths = null;
    this.firstChar = 1 / 0;
    this.lastChar = -1 / 0;
    this.fontFamily = t2;
    const i2 = new OffscreenCanvas(1, 1);
    this.ctxMeasure = i2.getContext("2d", { willReadFrequently: true });
    _FakeUnicodeFont._fontNameId || (_FakeUnicodeFont._fontNameId = 1);
    this.fontName = Name.get(`InvalidPDFjsFont_${t2}_${_FakeUnicodeFont._fontNameId++}`);
  }
  get fontDescriptorRef() {
    if (!_FakeUnicodeFont._fontDescriptorRef) {
      const e2 = new Dict(this.xref);
      e2.set("Type", Name.get("FontDescriptor"));
      e2.set("FontName", this.fontName);
      e2.set("FontFamily", "MyriadPro Regular");
      e2.set("FontBBox", [0, 0, 0, 0]);
      e2.set("FontStretch", Name.get("Normal"));
      e2.set("FontWeight", 400);
      e2.set("ItalicAngle", 0);
      _FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(e2);
    }
    return _FakeUnicodeFont._fontDescriptorRef;
  }
  get descendantFontRef() {
    const e2 = new Dict(this.xref);
    e2.set("BaseFont", this.fontName);
    e2.set("Type", Name.get("Font"));
    e2.set("Subtype", Name.get("CIDFontType0"));
    e2.set("CIDToGIDMap", Name.get("Identity"));
    e2.set("FirstChar", this.firstChar);
    e2.set("LastChar", this.lastChar);
    e2.set("FontDescriptor", this.fontDescriptorRef);
    e2.set("DW", 1e3);
    const t2 = [], i2 = [...this.widths.entries()].sort();
    let a2 = null, s2 = null;
    for (const [e3, r3] of i2)
      if (a2)
        if (e3 === a2 + s2.length)
          s2.push(r3);
        else {
          t2.push(a2, s2);
          a2 = e3;
          s2 = [r3];
        }
      else {
        a2 = e3;
        s2 = [r3];
      }
    a2 && t2.push(a2, s2);
    e2.set("W", t2);
    const r2 = new Dict(this.xref);
    r2.set("Ordering", "Identity");
    r2.set("Registry", "Adobe");
    r2.set("Supplement", 0);
    e2.set("CIDSystemInfo", r2);
    return this.xref.getNewPersistentRef(e2);
  }
  get baseFontRef() {
    const e2 = new Dict(this.xref);
    e2.set("BaseFont", this.fontName);
    e2.set("Type", Name.get("Font"));
    e2.set("Subtype", Name.get("Type0"));
    e2.set("Encoding", Name.get("Identity-H"));
    e2.set("DescendantFonts", [this.descendantFontRef]);
    e2.set("ToUnicode", Name.get("Identity-H"));
    return this.xref.getNewPersistentRef(e2);
  }
  get resources() {
    const e2 = new Dict(this.xref), t2 = new Dict(this.xref);
    t2.set(this.fontName.name, this.baseFontRef);
    e2.set("Font", t2);
    return e2;
  }
  _createContext() {
    this.widths = /* @__PURE__ */ new Map();
    this.ctxMeasure.font = `1000px ${this.fontFamily}`;
    return this.ctxMeasure;
  }
  createFontResources(e2) {
    const t2 = this._createContext();
    for (const i2 of e2.split(/\r\n?|\n/))
      for (const e3 of i2.split("")) {
        const i3 = e3.charCodeAt(0);
        if (this.widths.has(i3))
          continue;
        const a2 = t2.measureText(e3), s2 = Math.ceil(a2.width);
        this.widths.set(i3, s2);
        this.firstChar = Math.min(i3, this.firstChar);
        this.lastChar = Math.max(i3, this.lastChar);
      }
    return this.resources;
  }
  static getFirstPositionInfo(e2, t2, i2) {
    const [a2, n2, g2, o2] = e2;
    let c2 = g2 - a2, C2 = o2 - n2;
    t2 % 180 != 0 && ([c2, C2] = [C2, c2]);
    const h2 = s * i2;
    return { coords: [0, C2 + r * i2 - h2], bbox: [0, 0, c2, C2], matrix: 0 !== t2 ? getRotationMatrix(t2, C2, h2) : void 0 };
  }
  createAppearance(e2, t2, i2, a2, n2, g2) {
    const o2 = this._createContext(), c2 = [];
    let C2 = -1 / 0;
    for (const t3 of e2.split(/\r\n?|\n/)) {
      c2.push(t3);
      const e3 = o2.measureText(t3).width;
      C2 = Math.max(C2, e3);
      for (const e4 of codePointIter(t3)) {
        const t4 = String.fromCodePoint(e4);
        let i3 = this.widths.get(e4);
        if (void 0 === i3) {
          const a3 = o2.measureText(t4);
          i3 = Math.ceil(a3.width);
          this.widths.set(e4, i3);
          this.firstChar = Math.min(e4, this.firstChar);
          this.lastChar = Math.max(e4, this.lastChar);
        }
      }
    }
    C2 *= a2 / 1e3;
    const [h2, l2, Q2, E2] = t2;
    let u2 = Q2 - h2, d2 = E2 - l2;
    i2 % 180 != 0 && ([u2, d2] = [d2, u2]);
    let f2 = 1;
    C2 > u2 && (f2 = u2 / C2);
    let p2 = 1;
    const m2 = s * a2, y2 = r * a2, w2 = m2 * c2.length;
    w2 > d2 && (p2 = d2 / w2);
    const D2 = a2 * Math.min(f2, p2), b2 = ["q", `0 0 ${numberToString(u2)} ${numberToString(d2)} re W n`, "BT", `1 0 0 1 0 ${numberToString(d2 + y2)} Tm 0 Tc ${getPdfColor(n2, true)}`, `/${this.fontName.name} ${numberToString(D2)} Tf`], { resources: F2 } = this;
    if (1 !== (g2 = "number" == typeof g2 && g2 >= 0 && g2 <= 1 ? g2 : 1)) {
      b2.push("/R0 gs");
      const e3 = new Dict(this.xref), t3 = new Dict(this.xref);
      t3.set("ca", g2);
      t3.set("CA", g2);
      t3.set("Type", Name.get("ExtGState"));
      e3.set("R0", t3);
      F2.set("ExtGState", e3);
    }
    const S2 = numberToString(m2);
    for (const e3 of c2)
      b2.push(`0 -${S2} Td <${stringToUTF16HexString(e3)}> Tj`);
    b2.push("ET", "Q");
    const k2 = b2.join("\n"), R2 = new Dict(this.xref);
    R2.set("Subtype", Name.get("Form"));
    R2.set("Type", Name.get("XObject"));
    R2.set("BBox", [0, 0, u2, d2]);
    R2.set("Length", k2.length);
    R2.set("Resources", F2);
    if (i2) {
      const e3 = getRotationMatrix(i2, u2, d2);
      R2.set("Matrix", e3);
    }
    const N2 = new StringStream(k2);
    N2.dict = R2;
    return N2;
  }
};
var NameOrNumberTree = class _NameOrNumberTree {
  constructor(e2, t2, i2) {
    this.constructor === _NameOrNumberTree && unreachable("Cannot initialize NameOrNumberTree.");
    this.root = e2;
    this.xref = t2;
    this._type = i2;
  }
  getAll() {
    const e2 = /* @__PURE__ */ new Map();
    if (!this.root)
      return e2;
    const t2 = this.xref, i2 = new RefSet();
    i2.put(this.root);
    const a2 = [this.root];
    for (; a2.length > 0; ) {
      const s2 = t2.fetchIfRef(a2.shift());
      if (!(s2 instanceof Dict))
        continue;
      if (s2.has("Kids")) {
        const e3 = s2.get("Kids");
        if (!Array.isArray(e3))
          continue;
        for (const t3 of e3) {
          if (i2.has(t3))
            throw new FormatError(`Duplicate entry in "${this._type}" tree.`);
          a2.push(t3);
          i2.put(t3);
        }
        continue;
      }
      const r2 = s2.get(this._type);
      if (Array.isArray(r2))
        for (let i3 = 0, a3 = r2.length; i3 < a3; i3 += 2)
          e2.set(t2.fetchIfRef(r2[i3]), t2.fetchIfRef(r2[i3 + 1]));
    }
    return e2;
  }
  get(e2) {
    if (!this.root)
      return null;
    const t2 = this.xref;
    let i2 = t2.fetchIfRef(this.root), a2 = 0;
    for (; i2.has("Kids"); ) {
      if (++a2 > 10) {
        warn(`Search depth limit reached for "${this._type}" tree.`);
        return null;
      }
      const s3 = i2.get("Kids");
      if (!Array.isArray(s3))
        return null;
      let r2 = 0, n2 = s3.length - 1;
      for (; r2 <= n2; ) {
        const a3 = r2 + n2 >> 1, g2 = t2.fetchIfRef(s3[a3]), o2 = g2.get("Limits");
        if (e2 < t2.fetchIfRef(o2[0]))
          n2 = a3 - 1;
        else {
          if (!(e2 > t2.fetchIfRef(o2[1]))) {
            i2 = g2;
            break;
          }
          r2 = a3 + 1;
        }
      }
      if (r2 > n2)
        return null;
    }
    const s2 = i2.get(this._type);
    if (Array.isArray(s2)) {
      let i3 = 0, a3 = s2.length - 2;
      for (; i3 <= a3; ) {
        const r2 = i3 + a3 >> 1, n2 = r2 + (1 & r2), g2 = t2.fetchIfRef(s2[n2]);
        if (e2 < g2)
          a3 = n2 - 2;
        else {
          if (!(e2 > g2))
            return t2.fetchIfRef(s2[n2 + 1]);
          i3 = n2 + 2;
        }
      }
    }
    return null;
  }
};
var NameTree = class extends NameOrNumberTree {
  constructor(e2, t2) {
    super(e2, t2, "Names");
  }
};
var NumberTree = class extends NameOrNumberTree {
  constructor(e2, t2) {
    super(e2, t2, "Nums");
  }
};
function clearGlobalCaches() {
  !function clearPatternCaches() {
    Fa = /* @__PURE__ */ Object.create(null);
  }();
  !function clearPrimitiveCaches() {
    Dt = /* @__PURE__ */ Object.create(null);
    bt = /* @__PURE__ */ Object.create(null);
    Ft = /* @__PURE__ */ Object.create(null);
  }();
  !function clearUnicodeCaches() {
    Ki.clear();
  }();
  JpxImage.cleanup();
}
function pickPlatformItem(e2) {
  return e2 instanceof Dict ? e2.has("UF") ? e2.get("UF") : e2.has("F") ? e2.get("F") : e2.has("Unix") ? e2.get("Unix") : e2.has("Mac") ? e2.get("Mac") : e2.has("DOS") ? e2.get("DOS") : null : null;
}
var _S;
var FileSpec = class {
  constructor(e2, t2, i2 = false) {
    __privateAdd(this, _S, false);
    if (e2 instanceof Dict) {
      this.xref = t2;
      this.root = e2;
      e2.has("FS") && (this.fs = e2.get("FS"));
      e2.has("RF") && warn("Related file specifications are not supported");
      i2 || (e2.has("EF") ? __privateSet(this, _S, true) : warn("Non-embedded file specifications are not supported"));
    }
  }
  get filename() {
    let e2 = "";
    const t2 = pickPlatformItem(this.root);
    t2 && "string" == typeof t2 && (e2 = stringToPDFString(t2).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/"));
    return shadow(this, "filename", e2 || "unnamed");
  }
  get content() {
    var _a4;
    if (!__privateGet(this, _S))
      return null;
    this._contentRef || (this._contentRef = pickPlatformItem((_a4 = this.root) == null ? void 0 : _a4.get("EF")));
    let e2 = null;
    if (this._contentRef) {
      const t2 = this.xref.fetchIfRef(this._contentRef);
      t2 instanceof BaseStream ? e2 = t2.getBytes() : warn("Embedded file specification points to non-existing/invalid content");
    } else
      warn("Embedded file specification does not have any content");
    return e2;
  }
  get description() {
    var _a4;
    let e2 = "";
    const t2 = (_a4 = this.root) == null ? void 0 : _a4.get("Desc");
    t2 && "string" == typeof t2 && (e2 = stringToPDFString(t2));
    return shadow(this, "description", e2);
  }
  get serializable() {
    return { rawFilename: this.filename, filename: (e2 = this.filename, e2.substring(e2.lastIndexOf("/") + 1)), content: this.content, description: this.description };
    var e2;
  }
};
_S = new WeakMap();
var Us = 0;
var Ms = -2;
var Ls = -3;
var Hs = -4;
var Js = -5;
var Ys = -6;
var vs = -9;
function isWhitespace(e2, t2) {
  const i2 = e2[t2];
  return " " === i2 || "\n" === i2 || "\r" === i2 || "	" === i2;
}
var XMLParserBase = class {
  _resolveEntities(e2) {
    return e2.replaceAll(/&([^;]+);/g, (e3, t2) => {
      if ("#x" === t2.substring(0, 2))
        return String.fromCodePoint(parseInt(t2.substring(2), 16));
      if ("#" === t2.substring(0, 1))
        return String.fromCodePoint(parseInt(t2.substring(1), 10));
      switch (t2) {
        case "lt":
          return "<";
        case "gt":
          return ">";
        case "amp":
          return "&";
        case "quot":
          return '"';
        case "apos":
          return "'";
      }
      return this.onResolveEntity(t2);
    });
  }
  _parseContent(e2, t2) {
    const i2 = [];
    let a2 = t2;
    function skipWs() {
      for (; a2 < e2.length && isWhitespace(e2, a2); )
        ++a2;
    }
    for (; a2 < e2.length && !isWhitespace(e2, a2) && ">" !== e2[a2] && "/" !== e2[a2]; )
      ++a2;
    const s2 = e2.substring(t2, a2);
    skipWs();
    for (; a2 < e2.length && ">" !== e2[a2] && "/" !== e2[a2] && "?" !== e2[a2]; ) {
      skipWs();
      let t3 = "", s3 = "";
      for (; a2 < e2.length && !isWhitespace(e2, a2) && "=" !== e2[a2]; ) {
        t3 += e2[a2];
        ++a2;
      }
      skipWs();
      if ("=" !== e2[a2])
        return null;
      ++a2;
      skipWs();
      const r2 = e2[a2];
      if ('"' !== r2 && "'" !== r2)
        return null;
      const n2 = e2.indexOf(r2, ++a2);
      if (n2 < 0)
        return null;
      s3 = e2.substring(a2, n2);
      i2.push({ name: t3, value: this._resolveEntities(s3) });
      a2 = n2 + 1;
      skipWs();
    }
    return { name: s2, attributes: i2, parsed: a2 - t2 };
  }
  _parseProcessingInstruction(e2, t2) {
    let i2 = t2;
    for (; i2 < e2.length && !isWhitespace(e2, i2) && ">" !== e2[i2] && "?" !== e2[i2] && "/" !== e2[i2]; )
      ++i2;
    const a2 = e2.substring(t2, i2);
    !function skipWs() {
      for (; i2 < e2.length && isWhitespace(e2, i2); )
        ++i2;
    }();
    const s2 = i2;
    for (; i2 < e2.length && ("?" !== e2[i2] || ">" !== e2[i2 + 1]); )
      ++i2;
    return { name: a2, value: e2.substring(s2, i2), parsed: i2 - t2 };
  }
  parseXml(e2) {
    let t2 = 0;
    for (; t2 < e2.length; ) {
      let i2 = t2;
      if ("<" === e2[t2]) {
        ++i2;
        let t3;
        switch (e2[i2]) {
          case "/":
            ++i2;
            t3 = e2.indexOf(">", i2);
            if (t3 < 0) {
              this.onError(vs);
              return;
            }
            this.onEndElement(e2.substring(i2, t3));
            i2 = t3 + 1;
            break;
          case "?":
            ++i2;
            const a2 = this._parseProcessingInstruction(e2, i2);
            if ("?>" !== e2.substring(i2 + a2.parsed, i2 + a2.parsed + 2)) {
              this.onError(Ls);
              return;
            }
            this.onPi(a2.name, a2.value);
            i2 += a2.parsed + 2;
            break;
          case "!":
            if ("--" === e2.substring(i2 + 1, i2 + 3)) {
              t3 = e2.indexOf("-->", i2 + 3);
              if (t3 < 0) {
                this.onError(Js);
                return;
              }
              this.onComment(e2.substring(i2 + 3, t3));
              i2 = t3 + 3;
            } else if ("[CDATA[" === e2.substring(i2 + 1, i2 + 8)) {
              t3 = e2.indexOf("]]>", i2 + 8);
              if (t3 < 0) {
                this.onError(Ms);
                return;
              }
              this.onCdata(e2.substring(i2 + 8, t3));
              i2 = t3 + 3;
            } else {
              if ("DOCTYPE" !== e2.substring(i2 + 1, i2 + 8)) {
                this.onError(Ys);
                return;
              }
              {
                const a3 = e2.indexOf("[", i2 + 8);
                let s3 = false;
                t3 = e2.indexOf(">", i2 + 8);
                if (t3 < 0) {
                  this.onError(Hs);
                  return;
                }
                if (a3 > 0 && t3 > a3) {
                  t3 = e2.indexOf("]>", i2 + 8);
                  if (t3 < 0) {
                    this.onError(Hs);
                    return;
                  }
                  s3 = true;
                }
                const r3 = e2.substring(i2 + 8, t3 + (s3 ? 1 : 0));
                this.onDoctype(r3);
                i2 = t3 + (s3 ? 2 : 1);
              }
            }
            break;
          default:
            const s2 = this._parseContent(e2, i2);
            if (null === s2) {
              this.onError(Ys);
              return;
            }
            let r2 = false;
            if ("/>" === e2.substring(i2 + s2.parsed, i2 + s2.parsed + 2))
              r2 = true;
            else if (">" !== e2.substring(i2 + s2.parsed, i2 + s2.parsed + 1)) {
              this.onError(vs);
              return;
            }
            this.onBeginElement(s2.name, s2.attributes, r2);
            i2 += s2.parsed + (r2 ? 2 : 1);
        }
      } else {
        for (; i2 < e2.length && "<" !== e2[i2]; )
          i2++;
        const a2 = e2.substring(t2, i2);
        this.onText(this._resolveEntities(a2));
      }
      t2 = i2;
    }
  }
  onResolveEntity(e2) {
    return `&${e2};`;
  }
  onPi(e2, t2) {
  }
  onComment(e2) {
  }
  onCdata(e2) {
  }
  onDoctype(e2) {
  }
  onText(e2) {
  }
  onBeginElement(e2, t2, i2) {
  }
  onEndElement(e2) {
  }
  onError(e2) {
  }
};
var SimpleDOMNode = class {
  constructor(e2, t2) {
    this.nodeName = e2;
    this.nodeValue = t2;
    Object.defineProperty(this, "parentNode", { value: null, writable: true });
  }
  get firstChild() {
    var _a4;
    return (_a4 = this.childNodes) == null ? void 0 : _a4[0];
  }
  get nextSibling() {
    const e2 = this.parentNode.childNodes;
    if (!e2)
      return;
    const t2 = e2.indexOf(this);
    return -1 !== t2 ? e2[t2 + 1] : void 0;
  }
  get textContent() {
    return this.childNodes ? this.childNodes.map(function(e2) {
      return e2.textContent;
    }).join("") : this.nodeValue || "";
  }
  get children() {
    return this.childNodes || [];
  }
  hasChildNodes() {
    var _a4;
    return ((_a4 = this.childNodes) == null ? void 0 : _a4.length) > 0;
  }
  searchNode(e2, t2) {
    var _a4;
    if (t2 >= e2.length)
      return this;
    const i2 = e2[t2];
    if (i2.name.startsWith("#") && t2 < e2.length - 1)
      return this.searchNode(e2, t2 + 1);
    const a2 = [];
    let s2 = this;
    for (; ; ) {
      if (i2.name === s2.nodeName) {
        if (0 !== i2.pos) {
          if (0 === a2.length)
            return null;
          {
            const [r2] = a2.pop();
            let n2 = 0;
            for (const a3 of r2.childNodes)
              if (i2.name === a3.nodeName) {
                if (n2 === i2.pos)
                  return a3.searchNode(e2, t2 + 1);
                n2++;
              }
            return s2.searchNode(e2, t2 + 1);
          }
        }
        {
          const i3 = s2.searchNode(e2, t2 + 1);
          if (null !== i3)
            return i3;
        }
      }
      if (((_a4 = s2.childNodes) == null ? void 0 : _a4.length) > 0) {
        a2.push([s2, 0]);
        s2 = s2.childNodes[0];
      } else {
        if (0 === a2.length)
          return null;
        for (; 0 !== a2.length; ) {
          const [e3, t3] = a2.pop(), i3 = t3 + 1;
          if (i3 < e3.childNodes.length) {
            a2.push([e3, i3]);
            s2 = e3.childNodes[i3];
            break;
          }
        }
        if (0 === a2.length)
          return null;
      }
    }
  }
  dump(e2) {
    if ("#text" !== this.nodeName) {
      e2.push(`<${this.nodeName}`);
      if (this.attributes)
        for (const t2 of this.attributes)
          e2.push(` ${t2.name}="${encodeToXmlString(t2.value)}"`);
      if (this.hasChildNodes()) {
        e2.push(">");
        for (const t2 of this.childNodes)
          t2.dump(e2);
        e2.push(`</${this.nodeName}>`);
      } else
        this.nodeValue ? e2.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`) : e2.push("/>");
    } else
      e2.push(encodeToXmlString(this.nodeValue));
  }
};
var SimpleXMLParser = class extends XMLParserBase {
  constructor({ hasAttributes: e2 = false, lowerCaseName: t2 = false }) {
    super();
    this._currentFragment = null;
    this._stack = null;
    this._errorCode = Us;
    this._hasAttributes = e2;
    this._lowerCaseName = t2;
  }
  parseFromString(e2) {
    this._currentFragment = [];
    this._stack = [];
    this._errorCode = Us;
    this.parseXml(e2);
    if (this._errorCode !== Us)
      return;
    const [t2] = this._currentFragment;
    return t2 ? { documentElement: t2 } : void 0;
  }
  onText(e2) {
    if (function isWhitespaceString(e3) {
      for (let t3 = 0, i2 = e3.length; t3 < i2; t3++)
        if (!isWhitespace(e3, t3))
          return false;
      return true;
    }(e2))
      return;
    const t2 = new SimpleDOMNode("#text", e2);
    this._currentFragment.push(t2);
  }
  onCdata(e2) {
    const t2 = new SimpleDOMNode("#text", e2);
    this._currentFragment.push(t2);
  }
  onBeginElement(e2, t2, i2) {
    this._lowerCaseName && (e2 = e2.toLowerCase());
    const a2 = new SimpleDOMNode(e2);
    a2.childNodes = [];
    this._hasAttributes && (a2.attributes = t2);
    this._currentFragment.push(a2);
    if (!i2) {
      this._stack.push(this._currentFragment);
      this._currentFragment = a2.childNodes;
    }
  }
  onEndElement(e2) {
    this._currentFragment = this._stack.pop() || [];
    const t2 = this._currentFragment.at(-1);
    if (!t2)
      return null;
    for (const e3 of t2.childNodes)
      e3.parentNode = t2;
    return t2;
  }
  onError(e2) {
    this._errorCode = e2;
  }
};
var MetadataParser = class {
  constructor(e2) {
    e2 = this._repair(e2);
    const t2 = new SimpleXMLParser({ lowerCaseName: true }).parseFromString(e2);
    this._metadataMap = /* @__PURE__ */ new Map();
    this._data = e2;
    t2 && this._parse(t2);
  }
  _repair(e2) {
    return e2.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(e3, t2) {
      const i2 = t2.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(e4, t3, i3, a3) {
        return String.fromCharCode(64 * t3 + 8 * i3 + 1 * a3);
      }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(e4, t3) {
        switch (t3) {
          case "amp":
            return "&";
          case "apos":
            return "'";
          case "gt":
            return ">";
          case "lt":
            return "<";
          case "quot":
            return '"';
        }
        throw new Error(`_repair: ${t3} isn't defined.`);
      }), a2 = [">"];
      for (let e4 = 0, t3 = i2.length; e4 < t3; e4 += 2) {
        const t4 = 256 * i2.charCodeAt(e4) + i2.charCodeAt(e4 + 1);
        t4 >= 32 && t4 < 127 && 60 !== t4 && 62 !== t4 && 38 !== t4 ? a2.push(String.fromCharCode(t4)) : a2.push("&#x" + (65536 + t4).toString(16).substring(1) + ";");
      }
      return a2.join("");
    });
  }
  _getSequence(e2) {
    const t2 = e2.nodeName;
    return "rdf:bag" !== t2 && "rdf:seq" !== t2 && "rdf:alt" !== t2 ? null : e2.childNodes.filter((e3) => "rdf:li" === e3.nodeName);
  }
  _parseArray(e2) {
    if (!e2.hasChildNodes())
      return;
    const [t2] = e2.childNodes, i2 = this._getSequence(t2) || [];
    this._metadataMap.set(e2.nodeName, i2.map((e3) => e3.textContent.trim()));
  }
  _parse(e2) {
    let t2 = e2.documentElement;
    if ("rdf:rdf" !== t2.nodeName) {
      t2 = t2.firstChild;
      for (; t2 && "rdf:rdf" !== t2.nodeName; )
        t2 = t2.nextSibling;
    }
    if (t2 && "rdf:rdf" === t2.nodeName && t2.hasChildNodes()) {
      for (const e3 of t2.childNodes)
        if ("rdf:description" === e3.nodeName)
          for (const t3 of e3.childNodes) {
            const e4 = t3.nodeName;
            switch (e4) {
              case "#text":
                continue;
              case "dc:creator":
              case "dc:subject":
                this._parseArray(t3);
                continue;
            }
            this._metadataMap.set(e4, t3.textContent.trim());
          }
    }
  }
  get serializable() {
    return { parsedData: this._metadataMap, rawData: this._data };
  }
};
var DecryptStream = class extends DecodeStream {
  constructor(e2, t2, i2) {
    super(t2);
    this.str = e2;
    this.dict = e2.dict;
    this.decrypt = i2;
    this.nextChunk = null;
    this.initialized = false;
  }
  readBlock() {
    var _a4;
    let e2;
    if (this.initialized)
      e2 = this.nextChunk;
    else {
      e2 = this.str.getBytes(512);
      this.initialized = true;
    }
    if (!e2 || 0 === e2.length) {
      this.eof = true;
      return;
    }
    this.nextChunk = this.str.getBytes(512);
    const t2 = ((_a4 = this.nextChunk) == null ? void 0 : _a4.length) > 0;
    e2 = (0, this.decrypt)(e2, !t2);
    const i2 = this.bufferLength, a2 = i2 + e2.length;
    this.ensureBuffer(a2).set(e2, i2);
    this.bufferLength = a2;
  }
};
var ARCFourCipher = class {
  constructor(e2) {
    this.a = 0;
    this.b = 0;
    const t2 = new Uint8Array(256), i2 = e2.length;
    for (let e3 = 0; e3 < 256; ++e3)
      t2[e3] = e3;
    for (let a2 = 0, s2 = 0; a2 < 256; ++a2) {
      const r2 = t2[a2];
      s2 = s2 + r2 + e2[a2 % i2] & 255;
      t2[a2] = t2[s2];
      t2[s2] = r2;
    }
    this.s = t2;
  }
  encryptBlock(e2) {
    let t2 = this.a, i2 = this.b;
    const a2 = this.s, s2 = e2.length, r2 = new Uint8Array(s2);
    for (let n2 = 0; n2 < s2; ++n2) {
      t2 = t2 + 1 & 255;
      const s3 = a2[t2];
      i2 = i2 + s3 & 255;
      const g2 = a2[i2];
      a2[t2] = g2;
      a2[i2] = s3;
      r2[n2] = e2[n2] ^ a2[s3 + g2 & 255];
    }
    this.a = t2;
    this.b = i2;
    return r2;
  }
  decryptBlock(e2) {
    return this.encryptBlock(e2);
  }
  encrypt(e2) {
    return this.encryptBlock(e2);
  }
};
var Ks = function calculateMD5Closure() {
  const e2 = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]), t2 = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
  return function hash(i2, a2, s2) {
    let r2 = 1732584193, n2 = -271733879, g2 = -1732584194, o2 = 271733878;
    const c2 = s2 + 72 & -64, C2 = new Uint8Array(c2);
    let h2, l2;
    for (h2 = 0; h2 < s2; ++h2)
      C2[h2] = i2[a2++];
    C2[h2++] = 128;
    const Q2 = c2 - 8;
    for (; h2 < Q2; )
      C2[h2++] = 0;
    C2[h2++] = s2 << 3 & 255;
    C2[h2++] = s2 >> 5 & 255;
    C2[h2++] = s2 >> 13 & 255;
    C2[h2++] = s2 >> 21 & 255;
    C2[h2++] = s2 >>> 29 & 255;
    C2[h2++] = 0;
    C2[h2++] = 0;
    C2[h2++] = 0;
    const E2 = new Int32Array(16);
    for (h2 = 0; h2 < c2; ) {
      for (l2 = 0; l2 < 16; ++l2, h2 += 4)
        E2[l2] = C2[h2] | C2[h2 + 1] << 8 | C2[h2 + 2] << 16 | C2[h2 + 3] << 24;
      let i3, a3, s3 = r2, c3 = n2, Q3 = g2, u2 = o2;
      for (l2 = 0; l2 < 64; ++l2) {
        if (l2 < 16) {
          i3 = c3 & Q3 | ~c3 & u2;
          a3 = l2;
        } else if (l2 < 32) {
          i3 = u2 & c3 | ~u2 & Q3;
          a3 = 5 * l2 + 1 & 15;
        } else if (l2 < 48) {
          i3 = c3 ^ Q3 ^ u2;
          a3 = 3 * l2 + 5 & 15;
        } else {
          i3 = Q3 ^ (c3 | ~u2);
          a3 = 7 * l2 & 15;
        }
        const r3 = u2, n3 = s3 + i3 + t2[l2] + E2[a3] | 0, g3 = e2[l2];
        u2 = Q3;
        Q3 = c3;
        c3 = c3 + (n3 << g3 | n3 >>> 32 - g3) | 0;
        s3 = r3;
      }
      r2 = r2 + s3 | 0;
      n2 = n2 + c3 | 0;
      g2 = g2 + Q3 | 0;
      o2 = o2 + u2 | 0;
    }
    return new Uint8Array([255 & r2, r2 >> 8 & 255, r2 >> 16 & 255, r2 >>> 24 & 255, 255 & n2, n2 >> 8 & 255, n2 >> 16 & 255, n2 >>> 24 & 255, 255 & g2, g2 >> 8 & 255, g2 >> 16 & 255, g2 >>> 24 & 255, 255 & o2, o2 >> 8 & 255, o2 >> 16 & 255, o2 >>> 24 & 255]);
  };
}();
var Word64 = class {
  constructor(e2, t2) {
    this.high = 0 | e2;
    this.low = 0 | t2;
  }
  and(e2) {
    this.high &= e2.high;
    this.low &= e2.low;
  }
  xor(e2) {
    this.high ^= e2.high;
    this.low ^= e2.low;
  }
  or(e2) {
    this.high |= e2.high;
    this.low |= e2.low;
  }
  shiftRight(e2) {
    if (e2 >= 32) {
      this.low = this.high >>> e2 - 32 | 0;
      this.high = 0;
    } else {
      this.low = this.low >>> e2 | this.high << 32 - e2;
      this.high = this.high >>> e2 | 0;
    }
  }
  shiftLeft(e2) {
    if (e2 >= 32) {
      this.high = this.low << e2 - 32;
      this.low = 0;
    } else {
      this.high = this.high << e2 | this.low >>> 32 - e2;
      this.low <<= e2;
    }
  }
  rotateRight(e2) {
    let t2, i2;
    if (32 & e2) {
      i2 = this.low;
      t2 = this.high;
    } else {
      t2 = this.low;
      i2 = this.high;
    }
    e2 &= 31;
    this.low = t2 >>> e2 | i2 << 32 - e2;
    this.high = i2 >>> e2 | t2 << 32 - e2;
  }
  not() {
    this.high = ~this.high;
    this.low = ~this.low;
  }
  add(e2) {
    const t2 = (this.low >>> 0) + (e2.low >>> 0);
    let i2 = (this.high >>> 0) + (e2.high >>> 0);
    t2 > 4294967295 && (i2 += 1);
    this.low = 0 | t2;
    this.high = 0 | i2;
  }
  copyTo(e2, t2) {
    e2[t2] = this.high >>> 24 & 255;
    e2[t2 + 1] = this.high >> 16 & 255;
    e2[t2 + 2] = this.high >> 8 & 255;
    e2[t2 + 3] = 255 & this.high;
    e2[t2 + 4] = this.low >>> 24 & 255;
    e2[t2 + 5] = this.low >> 16 & 255;
    e2[t2 + 6] = this.low >> 8 & 255;
    e2[t2 + 7] = 255 & this.low;
  }
  assign(e2) {
    this.high = e2.high;
    this.low = e2.low;
  }
};
var Ts = /* @__PURE__ */ function calculateSHA256Closure() {
  function rotr(e3, t2) {
    return e3 >>> t2 | e3 << 32 - t2;
  }
  function ch(e3, t2, i2) {
    return e3 & t2 ^ ~e3 & i2;
  }
  function maj(e3, t2, i2) {
    return e3 & t2 ^ e3 & i2 ^ t2 & i2;
  }
  function sigma(e3) {
    return rotr(e3, 2) ^ rotr(e3, 13) ^ rotr(e3, 22);
  }
  function sigmaPrime(e3) {
    return rotr(e3, 6) ^ rotr(e3, 11) ^ rotr(e3, 25);
  }
  function littleSigma(e3) {
    return rotr(e3, 7) ^ rotr(e3, 18) ^ e3 >>> 3;
  }
  const e2 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  return function hash(t2, i2, a2) {
    let s2 = 1779033703, r2 = 3144134277, n2 = 1013904242, g2 = 2773480762, o2 = 1359893119, c2 = 2600822924, C2 = 528734635, h2 = 1541459225;
    const l2 = 64 * Math.ceil((a2 + 9) / 64), Q2 = new Uint8Array(l2);
    let E2, u2;
    for (E2 = 0; E2 < a2; ++E2)
      Q2[E2] = t2[i2++];
    Q2[E2++] = 128;
    const d2 = l2 - 8;
    for (; E2 < d2; )
      Q2[E2++] = 0;
    Q2[E2++] = 0;
    Q2[E2++] = 0;
    Q2[E2++] = 0;
    Q2[E2++] = a2 >>> 29 & 255;
    Q2[E2++] = a2 >> 21 & 255;
    Q2[E2++] = a2 >> 13 & 255;
    Q2[E2++] = a2 >> 5 & 255;
    Q2[E2++] = a2 << 3 & 255;
    const f2 = new Uint32Array(64);
    for (E2 = 0; E2 < l2; ) {
      for (u2 = 0; u2 < 16; ++u2) {
        f2[u2] = Q2[E2] << 24 | Q2[E2 + 1] << 16 | Q2[E2 + 2] << 8 | Q2[E2 + 3];
        E2 += 4;
      }
      for (u2 = 16; u2 < 64; ++u2)
        f2[u2] = (rotr(p2 = f2[u2 - 2], 17) ^ rotr(p2, 19) ^ p2 >>> 10) + f2[u2 - 7] + littleSigma(f2[u2 - 15]) + f2[u2 - 16] | 0;
      let t3, i3, a3 = s2, l3 = r2, d3 = n2, m2 = g2, y2 = o2, w2 = c2, D2 = C2, b2 = h2;
      for (u2 = 0; u2 < 64; ++u2) {
        t3 = b2 + sigmaPrime(y2) + ch(y2, w2, D2) + e2[u2] + f2[u2];
        i3 = sigma(a3) + maj(a3, l3, d3);
        b2 = D2;
        D2 = w2;
        w2 = y2;
        y2 = m2 + t3 | 0;
        m2 = d3;
        d3 = l3;
        l3 = a3;
        a3 = t3 + i3 | 0;
      }
      s2 = s2 + a3 | 0;
      r2 = r2 + l3 | 0;
      n2 = n2 + d3 | 0;
      g2 = g2 + m2 | 0;
      o2 = o2 + y2 | 0;
      c2 = c2 + w2 | 0;
      C2 = C2 + D2 | 0;
      h2 = h2 + b2 | 0;
    }
    var p2;
    return new Uint8Array([s2 >> 24 & 255, s2 >> 16 & 255, s2 >> 8 & 255, 255 & s2, r2 >> 24 & 255, r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2, n2 >> 24 & 255, n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2, g2 >> 24 & 255, g2 >> 16 & 255, g2 >> 8 & 255, 255 & g2, o2 >> 24 & 255, o2 >> 16 & 255, o2 >> 8 & 255, 255 & o2, c2 >> 24 & 255, c2 >> 16 & 255, c2 >> 8 & 255, 255 & c2, C2 >> 24 & 255, C2 >> 16 & 255, C2 >> 8 & 255, 255 & C2, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, 255 & h2]);
  };
}();
var qs = function calculateSHA512Closure() {
  function ch(e3, t2, i2, a2, s2) {
    e3.assign(t2);
    e3.and(i2);
    s2.assign(t2);
    s2.not();
    s2.and(a2);
    e3.xor(s2);
  }
  function maj(e3, t2, i2, a2, s2) {
    e3.assign(t2);
    e3.and(i2);
    s2.assign(t2);
    s2.and(a2);
    e3.xor(s2);
    s2.assign(i2);
    s2.and(a2);
    e3.xor(s2);
  }
  function sigma(e3, t2, i2) {
    e3.assign(t2);
    e3.rotateRight(28);
    i2.assign(t2);
    i2.rotateRight(34);
    e3.xor(i2);
    i2.assign(t2);
    i2.rotateRight(39);
    e3.xor(i2);
  }
  function sigmaPrime(e3, t2, i2) {
    e3.assign(t2);
    e3.rotateRight(14);
    i2.assign(t2);
    i2.rotateRight(18);
    e3.xor(i2);
    i2.assign(t2);
    i2.rotateRight(41);
    e3.xor(i2);
  }
  function littleSigma(e3, t2, i2) {
    e3.assign(t2);
    e3.rotateRight(1);
    i2.assign(t2);
    i2.rotateRight(8);
    e3.xor(i2);
    i2.assign(t2);
    i2.shiftRight(7);
    e3.xor(i2);
  }
  function littleSigmaPrime(e3, t2, i2) {
    e3.assign(t2);
    e3.rotateRight(19);
    i2.assign(t2);
    i2.rotateRight(61);
    e3.xor(i2);
    i2.assign(t2);
    i2.shiftRight(6);
    e3.xor(i2);
  }
  const e2 = [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)];
  return function hash(t2, i2, a2, s2 = false) {
    let r2, n2, g2, o2, c2, C2, h2, l2;
    if (s2) {
      r2 = new Word64(3418070365, 3238371032);
      n2 = new Word64(1654270250, 914150663);
      g2 = new Word64(2438529370, 812702999);
      o2 = new Word64(355462360, 4144912697);
      c2 = new Word64(1731405415, 4290775857);
      C2 = new Word64(2394180231, 1750603025);
      h2 = new Word64(3675008525, 1694076839);
      l2 = new Word64(1203062813, 3204075428);
    } else {
      r2 = new Word64(1779033703, 4089235720);
      n2 = new Word64(3144134277, 2227873595);
      g2 = new Word64(1013904242, 4271175723);
      o2 = new Word64(2773480762, 1595750129);
      c2 = new Word64(1359893119, 2917565137);
      C2 = new Word64(2600822924, 725511199);
      h2 = new Word64(528734635, 4215389547);
      l2 = new Word64(1541459225, 327033209);
    }
    const Q2 = 128 * Math.ceil((a2 + 17) / 128), E2 = new Uint8Array(Q2);
    let u2, d2;
    for (u2 = 0; u2 < a2; ++u2)
      E2[u2] = t2[i2++];
    E2[u2++] = 128;
    const f2 = Q2 - 16;
    for (; u2 < f2; )
      E2[u2++] = 0;
    E2[u2++] = 0;
    E2[u2++] = 0;
    E2[u2++] = 0;
    E2[u2++] = 0;
    E2[u2++] = 0;
    E2[u2++] = 0;
    E2[u2++] = 0;
    E2[u2++] = 0;
    E2[u2++] = 0;
    E2[u2++] = 0;
    E2[u2++] = 0;
    E2[u2++] = a2 >>> 29 & 255;
    E2[u2++] = a2 >> 21 & 255;
    E2[u2++] = a2 >> 13 & 255;
    E2[u2++] = a2 >> 5 & 255;
    E2[u2++] = a2 << 3 & 255;
    const p2 = new Array(80);
    for (u2 = 0; u2 < 80; u2++)
      p2[u2] = new Word64(0, 0);
    let m2 = new Word64(0, 0), y2 = new Word64(0, 0), w2 = new Word64(0, 0), D2 = new Word64(0, 0), b2 = new Word64(0, 0), F2 = new Word64(0, 0), S2 = new Word64(0, 0), k2 = new Word64(0, 0);
    const R2 = new Word64(0, 0), N2 = new Word64(0, 0), G2 = new Word64(0, 0), x2 = new Word64(0, 0);
    let U2, M2;
    for (u2 = 0; u2 < Q2; ) {
      for (d2 = 0; d2 < 16; ++d2) {
        p2[d2].high = E2[u2] << 24 | E2[u2 + 1] << 16 | E2[u2 + 2] << 8 | E2[u2 + 3];
        p2[d2].low = E2[u2 + 4] << 24 | E2[u2 + 5] << 16 | E2[u2 + 6] << 8 | E2[u2 + 7];
        u2 += 8;
      }
      for (d2 = 16; d2 < 80; ++d2) {
        U2 = p2[d2];
        littleSigmaPrime(U2, p2[d2 - 2], x2);
        U2.add(p2[d2 - 7]);
        littleSigma(G2, p2[d2 - 15], x2);
        U2.add(G2);
        U2.add(p2[d2 - 16]);
      }
      m2.assign(r2);
      y2.assign(n2);
      w2.assign(g2);
      D2.assign(o2);
      b2.assign(c2);
      F2.assign(C2);
      S2.assign(h2);
      k2.assign(l2);
      for (d2 = 0; d2 < 80; ++d2) {
        R2.assign(k2);
        sigmaPrime(G2, b2, x2);
        R2.add(G2);
        ch(G2, b2, F2, S2, x2);
        R2.add(G2);
        R2.add(e2[d2]);
        R2.add(p2[d2]);
        sigma(N2, m2, x2);
        maj(G2, m2, y2, w2, x2);
        N2.add(G2);
        U2 = k2;
        k2 = S2;
        S2 = F2;
        F2 = b2;
        D2.add(R2);
        b2 = D2;
        D2 = w2;
        w2 = y2;
        y2 = m2;
        U2.assign(R2);
        U2.add(N2);
        m2 = U2;
      }
      r2.add(m2);
      n2.add(y2);
      g2.add(w2);
      o2.add(D2);
      c2.add(b2);
      C2.add(F2);
      h2.add(S2);
      l2.add(k2);
    }
    if (s2) {
      M2 = new Uint8Array(48);
      r2.copyTo(M2, 0);
      n2.copyTo(M2, 8);
      g2.copyTo(M2, 16);
      o2.copyTo(M2, 24);
      c2.copyTo(M2, 32);
      C2.copyTo(M2, 40);
    } else {
      M2 = new Uint8Array(64);
      r2.copyTo(M2, 0);
      n2.copyTo(M2, 8);
      g2.copyTo(M2, 16);
      o2.copyTo(M2, 24);
      c2.copyTo(M2, 32);
      C2.copyTo(M2, 40);
      h2.copyTo(M2, 48);
      l2.copyTo(M2, 56);
    }
    return M2;
  };
}();
var NullCipher = class {
  decryptBlock(e2) {
    return e2;
  }
  encrypt(e2) {
    return e2;
  }
};
var AESBaseCipher = class _AESBaseCipher {
  constructor() {
    this.constructor === _AESBaseCipher && unreachable("Cannot initialize AESBaseCipher.");
    this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
    this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
    this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
    this._mixCol = new Uint8Array(256);
    for (let e2 = 0; e2 < 256; e2++)
      this._mixCol[e2] = e2 < 128 ? e2 << 1 : e2 << 1 ^ 27;
    this.buffer = new Uint8Array(16);
    this.bufferPosition = 0;
  }
  _expandKey(e2) {
    unreachable("Cannot call `_expandKey` on the base class");
  }
  _decrypt(e2, t2) {
    let i2, a2, s2;
    const r2 = new Uint8Array(16);
    r2.set(e2);
    for (let e3 = 0, i3 = this._keySize; e3 < 16; ++e3, ++i3)
      r2[e3] ^= t2[i3];
    for (let e3 = this._cyclesOfRepetition - 1; e3 >= 1; --e3) {
      i2 = r2[13];
      r2[13] = r2[9];
      r2[9] = r2[5];
      r2[5] = r2[1];
      r2[1] = i2;
      i2 = r2[14];
      a2 = r2[10];
      r2[14] = r2[6];
      r2[10] = r2[2];
      r2[6] = i2;
      r2[2] = a2;
      i2 = r2[15];
      a2 = r2[11];
      s2 = r2[7];
      r2[15] = r2[3];
      r2[11] = i2;
      r2[7] = a2;
      r2[3] = s2;
      for (let e4 = 0; e4 < 16; ++e4)
        r2[e4] = this._inv_s[r2[e4]];
      for (let i3 = 0, a3 = 16 * e3; i3 < 16; ++i3, ++a3)
        r2[i3] ^= t2[a3];
      for (let e4 = 0; e4 < 16; e4 += 4) {
        const t3 = this._mix[r2[e4]], a3 = this._mix[r2[e4 + 1]], s3 = this._mix[r2[e4 + 2]], n2 = this._mix[r2[e4 + 3]];
        i2 = t3 ^ a3 >>> 8 ^ a3 << 24 ^ s3 >>> 16 ^ s3 << 16 ^ n2 >>> 24 ^ n2 << 8;
        r2[e4] = i2 >>> 24 & 255;
        r2[e4 + 1] = i2 >> 16 & 255;
        r2[e4 + 2] = i2 >> 8 & 255;
        r2[e4 + 3] = 255 & i2;
      }
    }
    i2 = r2[13];
    r2[13] = r2[9];
    r2[9] = r2[5];
    r2[5] = r2[1];
    r2[1] = i2;
    i2 = r2[14];
    a2 = r2[10];
    r2[14] = r2[6];
    r2[10] = r2[2];
    r2[6] = i2;
    r2[2] = a2;
    i2 = r2[15];
    a2 = r2[11];
    s2 = r2[7];
    r2[15] = r2[3];
    r2[11] = i2;
    r2[7] = a2;
    r2[3] = s2;
    for (let e3 = 0; e3 < 16; ++e3) {
      r2[e3] = this._inv_s[r2[e3]];
      r2[e3] ^= t2[e3];
    }
    return r2;
  }
  _encrypt(e2, t2) {
    const i2 = this._s;
    let a2, s2, r2;
    const n2 = new Uint8Array(16);
    n2.set(e2);
    for (let e3 = 0; e3 < 16; ++e3)
      n2[e3] ^= t2[e3];
    for (let e3 = 1; e3 < this._cyclesOfRepetition; e3++) {
      for (let e4 = 0; e4 < 16; ++e4)
        n2[e4] = i2[n2[e4]];
      r2 = n2[1];
      n2[1] = n2[5];
      n2[5] = n2[9];
      n2[9] = n2[13];
      n2[13] = r2;
      r2 = n2[2];
      s2 = n2[6];
      n2[2] = n2[10];
      n2[6] = n2[14];
      n2[10] = r2;
      n2[14] = s2;
      r2 = n2[3];
      s2 = n2[7];
      a2 = n2[11];
      n2[3] = n2[15];
      n2[7] = r2;
      n2[11] = s2;
      n2[15] = a2;
      for (let e4 = 0; e4 < 16; e4 += 4) {
        const t3 = n2[e4 + 0], i3 = n2[e4 + 1], s3 = n2[e4 + 2], r3 = n2[e4 + 3];
        a2 = t3 ^ i3 ^ s3 ^ r3;
        n2[e4 + 0] ^= a2 ^ this._mixCol[t3 ^ i3];
        n2[e4 + 1] ^= a2 ^ this._mixCol[i3 ^ s3];
        n2[e4 + 2] ^= a2 ^ this._mixCol[s3 ^ r3];
        n2[e4 + 3] ^= a2 ^ this._mixCol[r3 ^ t3];
      }
      for (let i3 = 0, a3 = 16 * e3; i3 < 16; ++i3, ++a3)
        n2[i3] ^= t2[a3];
    }
    for (let e3 = 0; e3 < 16; ++e3)
      n2[e3] = i2[n2[e3]];
    r2 = n2[1];
    n2[1] = n2[5];
    n2[5] = n2[9];
    n2[9] = n2[13];
    n2[13] = r2;
    r2 = n2[2];
    s2 = n2[6];
    n2[2] = n2[10];
    n2[6] = n2[14];
    n2[10] = r2;
    n2[14] = s2;
    r2 = n2[3];
    s2 = n2[7];
    a2 = n2[11];
    n2[3] = n2[15];
    n2[7] = r2;
    n2[11] = s2;
    n2[15] = a2;
    for (let e3 = 0, i3 = this._keySize; e3 < 16; ++e3, ++i3)
      n2[e3] ^= t2[i3];
    return n2;
  }
  _decryptBlock2(e2, t2) {
    const i2 = e2.length;
    let a2 = this.buffer, s2 = this.bufferPosition;
    const r2 = [];
    let n2 = this.iv;
    for (let t3 = 0; t3 < i2; ++t3) {
      a2[s2] = e2[t3];
      ++s2;
      if (s2 < 16)
        continue;
      const i3 = this._decrypt(a2, this._key);
      for (let e3 = 0; e3 < 16; ++e3)
        i3[e3] ^= n2[e3];
      n2 = a2;
      r2.push(i3);
      a2 = new Uint8Array(16);
      s2 = 0;
    }
    this.buffer = a2;
    this.bufferLength = s2;
    this.iv = n2;
    if (0 === r2.length)
      return new Uint8Array(0);
    let g2 = 16 * r2.length;
    if (t2) {
      const e3 = r2.at(-1);
      let t3 = e3[15];
      if (t3 <= 16) {
        for (let i3 = 15, a3 = 16 - t3; i3 >= a3; --i3)
          if (e3[i3] !== t3) {
            t3 = 0;
            break;
          }
        g2 -= t3;
        r2[r2.length - 1] = e3.subarray(0, 16 - t3);
      }
    }
    const o2 = new Uint8Array(g2);
    for (let e3 = 0, t3 = 0, i3 = r2.length; e3 < i3; ++e3, t3 += 16)
      o2.set(r2[e3], t3);
    return o2;
  }
  decryptBlock(e2, t2, i2 = null) {
    const a2 = e2.length, s2 = this.buffer;
    let r2 = this.bufferPosition;
    if (i2)
      this.iv = i2;
    else {
      for (let t3 = 0; r2 < 16 && t3 < a2; ++t3, ++r2)
        s2[r2] = e2[t3];
      if (r2 < 16) {
        this.bufferLength = r2;
        return new Uint8Array(0);
      }
      this.iv = s2;
      e2 = e2.subarray(16);
    }
    this.buffer = new Uint8Array(16);
    this.bufferLength = 0;
    this.decryptBlock = this._decryptBlock2;
    return this.decryptBlock(e2, t2);
  }
  encrypt(e2, t2) {
    const i2 = e2.length;
    let a2 = this.buffer, s2 = this.bufferPosition;
    const r2 = [];
    t2 || (t2 = new Uint8Array(16));
    for (let n3 = 0; n3 < i2; ++n3) {
      a2[s2] = e2[n3];
      ++s2;
      if (s2 < 16)
        continue;
      for (let e3 = 0; e3 < 16; ++e3)
        a2[e3] ^= t2[e3];
      const i3 = this._encrypt(a2, this._key);
      t2 = i3;
      r2.push(i3);
      a2 = new Uint8Array(16);
      s2 = 0;
    }
    this.buffer = a2;
    this.bufferLength = s2;
    this.iv = t2;
    if (0 === r2.length)
      return new Uint8Array(0);
    const n2 = 16 * r2.length, g2 = new Uint8Array(n2);
    for (let e3 = 0, t3 = 0, i3 = r2.length; e3 < i3; ++e3, t3 += 16)
      g2.set(r2[e3], t3);
    return g2;
  }
};
var AES128Cipher = class extends AESBaseCipher {
  constructor(e2) {
    super();
    this._cyclesOfRepetition = 10;
    this._keySize = 160;
    this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
    this._key = this._expandKey(e2);
  }
  _expandKey(e2) {
    const t2 = this._s, i2 = this._rcon, a2 = new Uint8Array(176);
    a2.set(e2);
    for (let e3 = 16, s2 = 1; e3 < 176; ++s2) {
      let r2 = a2[e3 - 3], n2 = a2[e3 - 2], g2 = a2[e3 - 1], o2 = a2[e3 - 4];
      r2 = t2[r2];
      n2 = t2[n2];
      g2 = t2[g2];
      o2 = t2[o2];
      r2 ^= i2[s2];
      for (let t3 = 0; t3 < 4; ++t3) {
        a2[e3] = r2 ^= a2[e3 - 16];
        e3++;
        a2[e3] = n2 ^= a2[e3 - 16];
        e3++;
        a2[e3] = g2 ^= a2[e3 - 16];
        e3++;
        a2[e3] = o2 ^= a2[e3 - 16];
        e3++;
      }
    }
    return a2;
  }
};
var AES256Cipher = class extends AESBaseCipher {
  constructor(e2) {
    super();
    this._cyclesOfRepetition = 14;
    this._keySize = 224;
    this._key = this._expandKey(e2);
  }
  _expandKey(e2) {
    const t2 = this._s, i2 = new Uint8Array(240);
    i2.set(e2);
    let a2, s2, r2, n2, g2 = 1;
    for (let e3 = 32, o2 = 1; e3 < 240; ++o2) {
      if (e3 % 32 == 16) {
        a2 = t2[a2];
        s2 = t2[s2];
        r2 = t2[r2];
        n2 = t2[n2];
      } else if (e3 % 32 == 0) {
        a2 = i2[e3 - 3];
        s2 = i2[e3 - 2];
        r2 = i2[e3 - 1];
        n2 = i2[e3 - 4];
        a2 = t2[a2];
        s2 = t2[s2];
        r2 = t2[r2];
        n2 = t2[n2];
        a2 ^= g2;
        (g2 <<= 1) >= 256 && (g2 = 255 & (27 ^ g2));
      }
      for (let t3 = 0; t3 < 4; ++t3) {
        i2[e3] = a2 ^= i2[e3 - 32];
        e3++;
        i2[e3] = s2 ^= i2[e3 - 32];
        e3++;
        i2[e3] = r2 ^= i2[e3 - 32];
        e3++;
        i2[e3] = n2 ^= i2[e3 - 32];
        e3++;
      }
    }
    return i2;
  }
};
var PDF17 = class {
  checkOwnerPassword(e2, t2, i2, a2) {
    const s2 = new Uint8Array(e2.length + 56);
    s2.set(e2, 0);
    s2.set(t2, e2.length);
    s2.set(i2, e2.length + t2.length);
    return isArrayEqual(Ts(s2, 0, s2.length), a2);
  }
  checkUserPassword(e2, t2, i2) {
    const a2 = new Uint8Array(e2.length + 8);
    a2.set(e2, 0);
    a2.set(t2, e2.length);
    return isArrayEqual(Ts(a2, 0, a2.length), i2);
  }
  getOwnerKey(e2, t2, i2, a2) {
    const s2 = new Uint8Array(e2.length + 56);
    s2.set(e2, 0);
    s2.set(t2, e2.length);
    s2.set(i2, e2.length + t2.length);
    const r2 = Ts(s2, 0, s2.length);
    return new AES256Cipher(r2).decryptBlock(a2, false, new Uint8Array(16));
  }
  getUserKey(e2, t2, i2) {
    const a2 = new Uint8Array(e2.length + 8);
    a2.set(e2, 0);
    a2.set(t2, e2.length);
    const s2 = Ts(a2, 0, a2.length);
    return new AES256Cipher(s2).decryptBlock(i2, false, new Uint8Array(16));
  }
};
var PDF20 = class {
  _hash(e2, t2, i2) {
    let a2 = Ts(t2, 0, t2.length).subarray(0, 32), s2 = [0], r2 = 0;
    for (; r2 < 64 || s2.at(-1) > r2 - 32; ) {
      const t3 = e2.length + a2.length + i2.length, c2 = new Uint8Array(t3);
      let C2 = 0;
      c2.set(e2, C2);
      C2 += e2.length;
      c2.set(a2, C2);
      C2 += a2.length;
      c2.set(i2, C2);
      const h2 = new Uint8Array(64 * t3);
      for (let e3 = 0, i3 = 0; e3 < 64; e3++, i3 += t3)
        h2.set(c2, i3);
      s2 = new AES128Cipher(a2.subarray(0, 16)).encrypt(h2, a2.subarray(16, 32));
      const l2 = s2.slice(0, 16).reduce((e3, t4) => e3 + t4, 0) % 3;
      0 === l2 ? a2 = Ts(s2, 0, s2.length) : 1 === l2 ? a2 = (n2 = s2, g2 = 0, o2 = s2.length, qs(n2, g2, o2, true)) : 2 === l2 && (a2 = qs(s2, 0, s2.length));
      r2++;
    }
    var n2, g2, o2;
    return a2.subarray(0, 32);
  }
  checkOwnerPassword(e2, t2, i2, a2) {
    const s2 = new Uint8Array(e2.length + 56);
    s2.set(e2, 0);
    s2.set(t2, e2.length);
    s2.set(i2, e2.length + t2.length);
    return isArrayEqual(this._hash(e2, s2, i2), a2);
  }
  checkUserPassword(e2, t2, i2) {
    const a2 = new Uint8Array(e2.length + 8);
    a2.set(e2, 0);
    a2.set(t2, e2.length);
    return isArrayEqual(this._hash(e2, a2, []), i2);
  }
  getOwnerKey(e2, t2, i2, a2) {
    const s2 = new Uint8Array(e2.length + 56);
    s2.set(e2, 0);
    s2.set(t2, e2.length);
    s2.set(i2, e2.length + t2.length);
    const r2 = this._hash(e2, s2, i2);
    return new AES256Cipher(r2).decryptBlock(a2, false, new Uint8Array(16));
  }
  getUserKey(e2, t2, i2) {
    const a2 = new Uint8Array(e2.length + 8);
    a2.set(e2, 0);
    a2.set(t2, e2.length);
    const s2 = this._hash(e2, a2, []);
    return new AES256Cipher(s2).decryptBlock(i2, false, new Uint8Array(16));
  }
};
var CipherTransform = class {
  constructor(e2, t2) {
    this.StringCipherConstructor = e2;
    this.StreamCipherConstructor = t2;
  }
  createStream(e2, t2) {
    const i2 = new this.StreamCipherConstructor();
    return new DecryptStream(e2, t2, function cipherTransformDecryptStream(e3, t3) {
      return i2.decryptBlock(e3, t3);
    });
  }
  decryptString(e2) {
    const t2 = new this.StringCipherConstructor();
    let i2 = stringToBytes(e2);
    i2 = t2.decryptBlock(i2, true);
    return bytesToString(i2);
  }
  encryptString(e2) {
    const t2 = new this.StringCipherConstructor();
    if (t2 instanceof AESBaseCipher) {
      const i3 = 16 - e2.length % 16;
      e2 += String.fromCharCode(i3).repeat(i3);
      const a2 = new Uint8Array(16);
      if ("undefined" != typeof crypto)
        crypto.getRandomValues(a2);
      else
        for (let e3 = 0; e3 < 16; e3++)
          a2[e3] = Math.floor(256 * Math.random());
      let s2 = stringToBytes(e2);
      s2 = t2.encrypt(s2, a2);
      const r2 = new Uint8Array(16 + s2.length);
      r2.set(a2);
      r2.set(s2, 16);
      return bytesToString(r2);
    }
    let i2 = stringToBytes(e2);
    i2 = t2.encrypt(i2);
    return bytesToString(i2);
  }
};
var _k, _R, R_fn, _N, N_fn, _G, G_fn, _x, x_fn, _U, U_fn;
var _CipherTransformFactory = class _CipherTransformFactory {
  constructor(e2, t2, i2) {
    __privateAdd(this, _R);
    __privateAdd(this, _N);
    __privateAdd(this, _G);
    __privateAdd(this, _x);
    __privateAdd(this, _U);
    const a2 = e2.get("Filter");
    if (!isName(a2, "Standard"))
      throw new FormatError("unknown encryption method");
    this.filterName = a2.name;
    this.dict = e2;
    const s2 = e2.get("V");
    if (!Number.isInteger(s2) || 1 !== s2 && 2 !== s2 && 4 !== s2 && 5 !== s2)
      throw new FormatError("unsupported encryption algorithm");
    this.algorithm = s2;
    let r2 = e2.get("Length");
    if (!r2)
      if (s2 <= 3)
        r2 = 40;
      else {
        const t3 = e2.get("CF"), i3 = e2.get("StmF");
        if (t3 instanceof Dict && i3 instanceof Name) {
          t3.suppressEncryption = true;
          const e3 = t3.get(i3.name);
          r2 = (e3 == null ? void 0 : e3.get("Length")) || 128;
          r2 < 40 && (r2 <<= 3);
        }
      }
    if (!Number.isInteger(r2) || r2 < 40 || r2 % 8 != 0)
      throw new FormatError("invalid key length");
    const n2 = stringToBytes(e2.get("O")), g2 = stringToBytes(e2.get("U")), o2 = n2.subarray(0, 32), c2 = g2.subarray(0, 32), C2 = e2.get("P"), h2 = e2.get("R"), l2 = (4 === s2 || 5 === s2) && false !== e2.get("EncryptMetadata");
    this.encryptMetadata = l2;
    const Q2 = stringToBytes(t2);
    let E2, u2;
    if (i2) {
      if (6 === h2)
        try {
          i2 = utf8StringToString(i2);
        } catch {
          warn("CipherTransformFactory: Unable to convert UTF8 encoded password.");
        }
      E2 = stringToBytes(i2);
    }
    if (5 !== s2)
      u2 = __privateMethod(this, _N, N_fn).call(this, Q2, E2, o2, c2, C2, h2, r2, l2);
    else {
      const t3 = n2.subarray(32, 40), i3 = n2.subarray(40, 48), a3 = g2.subarray(0, 48), s3 = g2.subarray(32, 40), r3 = g2.subarray(40, 48), C3 = stringToBytes(e2.get("OE")), l3 = stringToBytes(e2.get("UE")), Q3 = stringToBytes(e2.get("Perms"));
      u2 = __privateMethod(this, _R, R_fn).call(this, h2, E2, o2, t3, i3, a3, c2, s3, r3, C3, l3, Q3);
    }
    if (!u2 && !i2)
      throw new PasswordException("No password given", rt);
    if (!u2 && i2) {
      const e3 = __privateMethod(this, _G, G_fn).call(this, E2, o2, h2, r2);
      u2 = __privateMethod(this, _N, N_fn).call(this, Q2, e3, o2, c2, C2, h2, r2, l2);
    }
    if (!u2)
      throw new PasswordException("Incorrect Password", nt);
    this.encryptionKey = u2;
    if (s2 >= 4) {
      const t3 = e2.get("CF");
      t3 instanceof Dict && (t3.suppressEncryption = true);
      this.cf = t3;
      this.stmf = e2.get("StmF") || Name.get("Identity");
      this.strf = e2.get("StrF") || Name.get("Identity");
      this.eff = e2.get("EFF") || this.stmf;
    }
  }
  createCipherTransform(e2, t2) {
    if (4 === this.algorithm || 5 === this.algorithm)
      return new CipherTransform(__privateMethod(this, _U, U_fn).call(this, this.cf, this.strf, e2, t2, this.encryptionKey), __privateMethod(this, _U, U_fn).call(this, this.cf, this.stmf, e2, t2, this.encryptionKey));
    const i2 = __privateMethod(this, _x, x_fn).call(this, e2, t2, this.encryptionKey, false), cipherConstructor = function() {
      return new ARCFourCipher(i2);
    };
    return new CipherTransform(cipherConstructor, cipherConstructor);
  }
};
_k = new WeakMap();
_R = new WeakSet();
R_fn = function(e2, t2, i2, a2, s2, r2, n2, g2, o2, c2, C2, h2) {
  if (t2) {
    const e3 = Math.min(127, t2.length);
    t2 = t2.subarray(0, e3);
  } else
    t2 = [];
  const l2 = 6 === e2 ? new PDF20() : new PDF17();
  return l2.checkUserPassword(t2, g2, n2) ? l2.getUserKey(t2, o2, C2) : t2.length && l2.checkOwnerPassword(t2, a2, r2, i2) ? l2.getOwnerKey(t2, s2, r2, c2) : null;
};
_N = new WeakSet();
N_fn = function(e2, t2, i2, a2, s2, r2, n2, g2) {
  const o2 = 40 + i2.length + e2.length, c2 = new Uint8Array(o2);
  let C2, h2, l2 = 0;
  if (t2) {
    h2 = Math.min(32, t2.length);
    for (; l2 < h2; ++l2)
      c2[l2] = t2[l2];
  }
  C2 = 0;
  for (; l2 < 32; )
    c2[l2++] = __privateGet(_CipherTransformFactory, _k)[C2++];
  for (C2 = 0, h2 = i2.length; C2 < h2; ++C2)
    c2[l2++] = i2[C2];
  c2[l2++] = 255 & s2;
  c2[l2++] = s2 >> 8 & 255;
  c2[l2++] = s2 >> 16 & 255;
  c2[l2++] = s2 >>> 24 & 255;
  for (C2 = 0, h2 = e2.length; C2 < h2; ++C2)
    c2[l2++] = e2[C2];
  if (r2 >= 4 && !g2) {
    c2[l2++] = 255;
    c2[l2++] = 255;
    c2[l2++] = 255;
    c2[l2++] = 255;
  }
  let Q2 = Ks(c2, 0, l2);
  const E2 = n2 >> 3;
  if (r2 >= 3)
    for (C2 = 0; C2 < 50; ++C2)
      Q2 = Ks(Q2, 0, E2);
  const u2 = Q2.subarray(0, E2);
  let d2, f2;
  if (r2 >= 3) {
    for (l2 = 0; l2 < 32; ++l2)
      c2[l2] = __privateGet(_CipherTransformFactory, _k)[l2];
    for (C2 = 0, h2 = e2.length; C2 < h2; ++C2)
      c2[l2++] = e2[C2];
    d2 = new ARCFourCipher(u2);
    f2 = d2.encryptBlock(Ks(c2, 0, l2));
    h2 = u2.length;
    const t3 = new Uint8Array(h2);
    for (C2 = 1; C2 <= 19; ++C2) {
      for (let e3 = 0; e3 < h2; ++e3)
        t3[e3] = u2[e3] ^ C2;
      d2 = new ARCFourCipher(t3);
      f2 = d2.encryptBlock(f2);
    }
    for (C2 = 0, h2 = f2.length; C2 < h2; ++C2)
      if (a2[C2] !== f2[C2])
        return null;
  } else {
    d2 = new ARCFourCipher(u2);
    f2 = d2.encryptBlock(__privateGet(_CipherTransformFactory, _k));
    for (C2 = 0, h2 = f2.length; C2 < h2; ++C2)
      if (a2[C2] !== f2[C2])
        return null;
  }
  return u2;
};
_G = new WeakSet();
G_fn = function(e2, t2, i2, a2) {
  const s2 = new Uint8Array(32);
  let r2 = 0;
  const n2 = Math.min(32, e2.length);
  for (; r2 < n2; ++r2)
    s2[r2] = e2[r2];
  let g2 = 0;
  for (; r2 < 32; )
    s2[r2++] = __privateGet(_CipherTransformFactory, _k)[g2++];
  let o2 = Ks(s2, 0, r2);
  const c2 = a2 >> 3;
  if (i2 >= 3)
    for (g2 = 0; g2 < 50; ++g2)
      o2 = Ks(o2, 0, o2.length);
  let C2, h2;
  if (i2 >= 3) {
    h2 = t2;
    const e3 = new Uint8Array(c2);
    for (g2 = 19; g2 >= 0; g2--) {
      for (let t3 = 0; t3 < c2; ++t3)
        e3[t3] = o2[t3] ^ g2;
      C2 = new ARCFourCipher(e3);
      h2 = C2.encryptBlock(h2);
    }
  } else {
    C2 = new ARCFourCipher(o2.subarray(0, c2));
    h2 = C2.encryptBlock(t2);
  }
  return h2;
};
_x = new WeakSet();
x_fn = function(e2, t2, i2, a2 = false) {
  const s2 = new Uint8Array(i2.length + 9), r2 = i2.length;
  let n2;
  for (n2 = 0; n2 < r2; ++n2)
    s2[n2] = i2[n2];
  s2[n2++] = 255 & e2;
  s2[n2++] = e2 >> 8 & 255;
  s2[n2++] = e2 >> 16 & 255;
  s2[n2++] = 255 & t2;
  s2[n2++] = t2 >> 8 & 255;
  if (a2) {
    s2[n2++] = 115;
    s2[n2++] = 65;
    s2[n2++] = 108;
    s2[n2++] = 84;
  }
  return Ks(s2, 0, n2).subarray(0, Math.min(i2.length + 5, 16));
};
_U = new WeakSet();
U_fn = function(e2, t2, i2, a2, s2) {
  if (!(t2 instanceof Name))
    throw new FormatError("Invalid crypt filter name.");
  const r2 = this, n2 = e2.get(t2.name), g2 = n2 == null ? void 0 : n2.get("CFM");
  if (!g2 || "None" === g2.name)
    return function() {
      return new NullCipher();
    };
  if ("V2" === g2.name)
    return function() {
      var _a4;
      return new ARCFourCipher(__privateMethod(_a4 = r2, _x, x_fn).call(_a4, i2, a2, s2, false));
    };
  if ("AESV2" === g2.name)
    return function() {
      var _a4;
      return new AES128Cipher(__privateMethod(_a4 = r2, _x, x_fn).call(_a4, i2, a2, s2, true));
    };
  if ("AESV3" === g2.name)
    return function() {
      return new AES256Cipher(s2);
    };
  throw new FormatError("Unknown crypto method");
};
__privateAdd(_CipherTransformFactory, _k, new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]));
var CipherTransformFactory = _CipherTransformFactory;
async function writeObject(e2, t2, i2, { encrypt: a2 = null }) {
  const s2 = a2 == null ? void 0 : a2.createCipherTransform(e2.num, e2.gen);
  i2.push(`${e2.num} ${e2.gen} obj
`);
  t2 instanceof Dict ? await writeDict(t2, i2, s2) : t2 instanceof BaseStream ? await writeStream(t2, i2, s2) : (Array.isArray(t2) || ArrayBuffer.isView(t2)) && await writeArray(t2, i2, s2);
  i2.push("\nendobj\n");
}
async function writeDict(e2, t2, i2) {
  t2.push("<<");
  for (const a2 of e2.getKeys()) {
    t2.push(` /${escapePDFName(a2)} `);
    await writeValue(e2.getRaw(a2), t2, i2);
  }
  t2.push(">>");
}
async function writeStream(e2, t2, i2) {
  let a2 = e2.getBytes();
  const { dict: s2 } = e2, [r2, n2] = await Promise.all([s2.getAsync("Filter"), s2.getAsync("DecodeParms")]), g2 = isName(Array.isArray(r2) ? await s2.xref.fetchIfRefAsync(r2[0]) : r2, "FlateDecode");
  if (a2.length >= 256 || g2)
    try {
      const e3 = new CompressionStream("deflate"), t3 = e3.writable.getWriter();
      t3.write(a2);
      t3.close();
      const i3 = await new Response(e3.readable).arrayBuffer();
      a2 = new Uint8Array(i3);
      let o3, c2;
      if (r2) {
        if (!g2) {
          o3 = Array.isArray(r2) ? [Name.get("FlateDecode"), ...r2] : [Name.get("FlateDecode"), r2];
          n2 && (c2 = Array.isArray(n2) ? [null, ...n2] : [null, n2]);
        }
      } else
        o3 = Name.get("FlateDecode");
      o3 && s2.set("Filter", o3);
      c2 && s2.set("DecodeParms", c2);
    } catch (e3) {
      info(`writeStream - cannot compress data: "${e3}".`);
    }
  let o2 = bytesToString(a2);
  i2 && (o2 = i2.encryptString(o2));
  s2.set("Length", o2.length);
  await writeDict(s2, t2, i2);
  t2.push(" stream\n", o2, "\nendstream");
}
async function writeArray(e2, t2, i2) {
  t2.push("[");
  let a2 = true;
  for (const s2 of e2) {
    a2 ? a2 = false : t2.push(" ");
    await writeValue(s2, t2, i2);
  }
  t2.push("]");
}
async function writeValue(e2, t2, i2) {
  if (e2 instanceof Name)
    t2.push(`/${escapePDFName(e2.name)}`);
  else if (e2 instanceof Ref)
    t2.push(`${e2.num} ${e2.gen} R`);
  else if (Array.isArray(e2) || ArrayBuffer.isView(e2))
    await writeArray(e2, t2, i2);
  else if ("string" == typeof e2) {
    i2 && (e2 = i2.encryptString(e2));
    t2.push(`(${escapeString(e2)})`);
  } else
    "number" == typeof e2 ? t2.push(numberToString(e2)) : "boolean" == typeof e2 ? t2.push(e2.toString()) : e2 instanceof Dict ? await writeDict(e2, t2, i2) : e2 instanceof BaseStream ? await writeStream(e2, t2, i2) : null === e2 ? t2.push("null") : warn(`Unhandled value in writer: ${typeof e2}, please file a bug.`);
}
function writeInt(e2, t2, i2, a2) {
  for (let s2 = t2 + i2 - 1; s2 > i2 - 1; s2--) {
    a2[s2] = 255 & e2;
    e2 >>= 8;
  }
  return i2 + t2;
}
function writeString(e2, t2, i2) {
  for (let a2 = 0, s2 = e2.length; a2 < s2; a2++)
    i2[t2 + a2] = 255 & e2.charCodeAt(a2);
}
function updateXFA({ xfaData: e2, xfaDatasetsRef: t2, newRefs: i2, xref: a2 }) {
  if (null === e2) {
    e2 = function writeXFADataForAcroform(e3, t3) {
      const i3 = new SimpleXMLParser({ hasAttributes: true }).parseFromString(e3);
      for (const { xfa: e4 } of t3) {
        if (!e4)
          continue;
        const { path: t4, value: a4 } = e4;
        if (!t4)
          continue;
        const s3 = parseXFAPath(t4);
        let r3 = i3.documentElement.searchNode(s3, 0);
        !r3 && s3.length > 1 && (r3 = i3.documentElement.searchNode([s3.at(-1)], 0));
        r3 ? r3.childNodes = Array.isArray(a4) ? a4.map((e5) => new SimpleDOMNode("value", e5)) : [new SimpleDOMNode("#text", a4)] : warn(`Node not found for path: ${t4}`);
      }
      const a3 = [];
      i3.documentElement.dump(a3);
      return a3.join("");
    }(a2.fetchIfRef(t2).getString(), i2);
  }
  const s2 = a2.encrypt;
  if (s2) {
    e2 = s2.createCipherTransform(t2.num, t2.gen).encryptString(e2);
  }
  const r2 = `${t2.num} ${t2.gen} obj
<< /Type /EmbeddedFile /Length ${e2.length}>>
stream
` + e2 + "\nendstream\nendobj\n";
  i2.push({ ref: t2, data: r2 });
}
function getIndexes(e2) {
  const t2 = [];
  for (const { ref: i2 } of e2)
    i2.num === t2.at(-2) + t2.at(-1) ? t2[t2.length - 1] += 1 : t2.push(i2.num, 1);
  return t2;
}
function computeIDs(e2, t2, i2) {
  if (Array.isArray(t2.fileIds) && t2.fileIds.length > 0) {
    const a2 = function computeMD5(e3, t3) {
      const i3 = Math.floor(Date.now() / 1e3), a3 = t3.filename || "", s2 = [i3.toString(), a3, e3.toString()];
      let r2 = s2.reduce((e4, t4) => e4 + t4.length, 0);
      for (const e4 of Object.values(t3.info)) {
        s2.push(e4);
        r2 += e4.length;
      }
      const n2 = new Uint8Array(r2);
      let g2 = 0;
      for (const e4 of s2) {
        writeString(e4, g2, n2);
        g2 += e4.length;
      }
      return bytesToString(Ks(n2));
    }(e2, t2);
    i2.set("ID", [t2.fileIds[0], a2]);
  }
}
async function incrementalUpdate({ originalData: e2, xrefInfo: t2, newRefs: i2, xref: a2 = null, hasXfa: s2 = false, xfaDatasetsRef: r2 = null, hasXfaDatasetsEntry: n2 = false, needAppearances: g2, acroFormRef: o2 = null, acroForm: c2 = null, xfaData: C2 = null, useXrefStream: h2 = false }) {
  await async function updateAcroform({ xref: e3, acroForm: t3, acroFormRef: i3, hasXfa: a3, hasXfaDatasetsEntry: s3, xfaDatasetsRef: r3, needAppearances: n3, newRefs: g3 }) {
    !a3 || s3 || r3 || warn("XFA - Cannot save it");
    if (!n3 && (!a3 || !r3 || s3))
      return;
    const o3 = t3.clone();
    if (a3 && !s3) {
      const e4 = t3.get("XFA").slice();
      e4.splice(2, 0, "datasets");
      e4.splice(3, 0, r3);
      o3.set("XFA", e4);
    }
    n3 && o3.set("NeedAppearances", true);
    const c3 = [];
    await writeObject(i3, o3, c3, e3);
    g3.push({ ref: i3, data: c3.join("") });
  }({ xref: a2, acroForm: c2, acroFormRef: o2, hasXfa: s2, hasXfaDatasetsEntry: n2, xfaDatasetsRef: r2, needAppearances: g2, newRefs: i2 });
  s2 && updateXFA({ xfaData: C2, xfaDatasetsRef: r2, newRefs: i2, xref: a2 });
  const l2 = [];
  let Q2 = e2.length;
  const E2 = e2.at(-1);
  if (10 !== E2 && 13 !== E2) {
    l2.push("\n");
    Q2 += 1;
  }
  const u2 = function getTrailerDict(e3, t3, i3) {
    const a3 = new Dict(null);
    a3.set("Prev", e3.startXRef);
    const s3 = e3.newRef;
    if (i3) {
      t3.push({ ref: s3, data: "" });
      a3.set("Size", s3.num + 1);
      a3.set("Type", Name.get("XRef"));
    } else
      a3.set("Size", s3.num);
    null !== e3.rootRef && a3.set("Root", e3.rootRef);
    null !== e3.infoRef && a3.set("Info", e3.infoRef);
    null !== e3.encryptRef && a3.set("Encrypt", e3.encryptRef);
    return a3;
  }(t2, i2, h2);
  i2 = i2.sort((e3, t3) => e3.ref.num - t3.ref.num);
  for (const { data: e3 } of i2)
    null !== e3 && l2.push(e3);
  await (h2 ? async function getXRefStreamTable(e3, t3, i3, a3, s3) {
    const r3 = [];
    let n3 = 0, g3 = 0;
    for (const { ref: e4, data: a4 } of i3) {
      let i4;
      n3 = Math.max(n3, t3);
      if (null !== a4) {
        i4 = Math.min(e4.gen, 65535);
        r3.push([1, t3, i4]);
        t3 += a4.length;
      } else {
        i4 = Math.min(e4.gen + 1, 65535);
        r3.push([0, 0, i4]);
      }
      g3 = Math.max(g3, i4);
    }
    a3.set("Index", getIndexes(i3));
    const o3 = [1, getSizeInBytes(n3), getSizeInBytes(g3)];
    a3.set("W", o3);
    computeIDs(t3, e3, a3);
    const c3 = o3.reduce((e4, t4) => e4 + t4, 0), C3 = new Uint8Array(c3 * r3.length), h3 = new Stream(C3);
    h3.dict = a3;
    let l3 = 0;
    for (const [e4, t4, i4] of r3) {
      l3 = writeInt(e4, o3[0], l3, C3);
      l3 = writeInt(t4, o3[1], l3, C3);
      l3 = writeInt(i4, o3[2], l3, C3);
    }
    await writeObject(e3.newRef, h3, s3, {});
    s3.push("startxref\n", t3.toString(), "\n%%EOF\n");
  }(t2, Q2, i2, u2, l2) : async function getXRefTable(e3, t3, i3, a3, s3) {
    s3.push("xref\n");
    const r3 = getIndexes(i3);
    let n3 = 0;
    for (const { ref: e4, data: a4 } of i3) {
      if (e4.num === r3[n3]) {
        s3.push(`${r3[n3]} ${r3[n3 + 1]}
`);
        n3 += 2;
      }
      if (null !== a4) {
        s3.push(`${t3.toString().padStart(10, "0")} ${Math.min(e4.gen, 65535).toString().padStart(5, "0")} n\r
`);
        t3 += a4.length;
      } else
        s3.push(`0000000000 ${Math.min(e4.gen + 1, 65535).toString().padStart(5, "0")} f\r
`);
    }
    computeIDs(t3, e3, a3);
    s3.push("trailer\n");
    await writeDict(a3, s3);
    s3.push("\nstartxref\n", t3.toString(), "\n%%EOF\n");
  }(t2, Q2, i2, u2, l2));
  const d2 = l2.reduce((e3, t3) => e3 + t3.length, e2.length), f2 = new Uint8Array(d2);
  f2.set(e2);
  let p2 = e2.length;
  for (const e3 of l2) {
    writeString(e3, p2, f2);
    p2 += e3.length;
  }
  return f2;
}
var Os = 1;
var Ws = 2;
var js = 3;
var Xs = 4;
var Zs = 5;
var _M, M_fn, _L, L_fn, _H, H_fn, _J, J_fn;
var _StructTreeRoot = class _StructTreeRoot {
  constructor(e2, t2) {
    __privateAdd(this, _M);
    this.dict = e2;
    this.ref = t2 instanceof Ref ? t2 : null;
    this.roleMap = /* @__PURE__ */ new Map();
    this.structParentIds = null;
  }
  init() {
    this.readRoleMap();
  }
  addAnnotationIdToPage(e2, t2) {
    __privateMethod(this, _M, M_fn).call(this, e2, t2, Xs);
  }
  readRoleMap() {
    const e2 = this.dict.get("RoleMap");
    e2 instanceof Dict && e2.forEach((e3, t2) => {
      t2 instanceof Name && this.roleMap.set(e3, t2.name);
    });
  }
  static async canCreateStructureTree({ catalogRef: e2, pdfManager: t2, newAnnotationsByPage: i2 }) {
    var _a4;
    if (!(e2 instanceof Ref)) {
      warn("Cannot save the struct tree: no catalog reference.");
      return false;
    }
    let a2 = 0, s2 = true;
    for (const [e3, r2] of i2) {
      const { ref: i3 } = await t2.getPage(e3);
      if (!(i3 instanceof Ref)) {
        warn(`Cannot save the struct tree: page ${e3} has no ref.`);
        s2 = true;
        break;
      }
      for (const e4 of r2)
        if ((_a4 = e4.accessibilityData) == null ? void 0 : _a4.type) {
          e4.parentTreeId = a2++;
          s2 = false;
        }
    }
    if (s2) {
      for (const e3 of i2.values())
        for (const t3 of e3)
          delete t3.parentTreeId;
      return false;
    }
    return true;
  }
  static async createStructureTree({ newAnnotationsByPage: e2, xref: t2, catalogRef: i2, pdfManager: a2, newRefs: s2 }) {
    const r2 = a2.catalog.cloneDict(), n2 = new RefSetCache();
    n2.put(i2, r2);
    const g2 = t2.getNewTemporaryRef();
    r2.set("StructTreeRoot", g2);
    const o2 = new Dict(t2);
    o2.set("Type", Name.get("StructTreeRoot"));
    const c2 = t2.getNewTemporaryRef();
    o2.set("ParentTree", c2);
    const C2 = [];
    o2.set("K", C2);
    n2.put(g2, o2);
    const h2 = new Dict(t2), l2 = [];
    h2.set("Nums", l2);
    const Q2 = await __privateMethod(this, _L, L_fn).call(this, { newAnnotationsByPage: e2, structTreeRootRef: g2, kids: C2, nums: l2, xref: t2, pdfManager: a2, cache: n2 });
    o2.set("ParentTreeNextKey", Q2);
    n2.put(c2, h2);
    const E2 = [];
    for (const [e3, i3] of n2.items()) {
      E2.length = 0;
      await writeObject(e3, i3, E2, t2);
      s2.push({ ref: e3, data: E2.join("") });
    }
  }
  async canUpdateStructTree({ pdfManager: e2, xref: t2, newAnnotationsByPage: i2 }) {
    var _a4, _b2;
    if (!this.ref) {
      warn("Cannot update the struct tree: no root reference.");
      return false;
    }
    let a2 = this.dict.get("ParentTreeNextKey");
    if (!Number.isInteger(a2) || a2 < 0) {
      warn("Cannot update the struct tree: invalid next key.");
      return false;
    }
    const s2 = this.dict.get("ParentTree");
    if (!(s2 instanceof Dict)) {
      warn("Cannot update the struct tree: ParentTree isn't a dict.");
      return false;
    }
    const r2 = s2.get("Nums");
    if (!Array.isArray(r2)) {
      warn("Cannot update the struct tree: nums isn't an array.");
      return false;
    }
    const n2 = new NumberTree(s2, t2);
    for (const t3 of i2.keys()) {
      const { pageDict: i3 } = await e2.getPage(t3);
      if (!i3.has("StructParents"))
        continue;
      const a3 = i3.get("StructParents");
      if (!Number.isInteger(a3) || !Array.isArray(n2.get(a3))) {
        warn(`Cannot save the struct tree: page ${t3} has a wrong id.`);
        return false;
      }
    }
    let g2 = true;
    for (const [t3, s3] of i2) {
      const { pageDict: i3 } = await e2.getPage(t3);
      __privateMethod(_a4 = _StructTreeRoot, _H, H_fn).call(_a4, { elements: s3, xref: this.dict.xref, pageDict: i3, numberTree: n2 });
      for (const e3 of s3)
        if ((_b2 = e3.accessibilityData) == null ? void 0 : _b2.type) {
          e3.parentTreeId = a2++;
          g2 = false;
        }
    }
    if (g2) {
      for (const e3 of i2.values())
        for (const t3 of e3) {
          delete t3.parentTreeId;
          delete t3.structTreeParent;
        }
      return false;
    }
    return true;
  }
  async updateStructureTree({ newAnnotationsByPage: e2, pdfManager: t2, newRefs: i2 }) {
    var _a4;
    const a2 = this.dict.xref, s2 = this.dict.clone(), r2 = this.ref, n2 = new RefSetCache();
    n2.put(r2, s2);
    let g2, o2 = s2.getRaw("ParentTree");
    if (o2 instanceof Ref)
      g2 = a2.fetch(o2);
    else {
      g2 = o2;
      o2 = a2.getNewTemporaryRef();
      s2.set("ParentTree", o2);
    }
    g2 = g2.clone();
    n2.put(o2, g2);
    let c2 = g2.getRaw("Nums"), C2 = null;
    if (c2 instanceof Ref) {
      C2 = c2;
      c2 = a2.fetch(C2);
    }
    c2 = c2.slice();
    C2 || g2.set("Nums", c2);
    const h2 = await __privateMethod(_a4 = _StructTreeRoot, _L, L_fn).call(_a4, { newAnnotationsByPage: e2, structTreeRootRef: r2, kids: null, nums: c2, xref: a2, pdfManager: t2, cache: n2 });
    s2.set("ParentTreeNextKey", h2);
    C2 && n2.put(C2, c2);
    const l2 = [];
    for (const [e3, t3] of n2.items()) {
      l2.length = 0;
      await writeObject(e3, t3, l2, a2);
      i2.push({ ref: e3, data: l2.join("") });
    }
  }
};
_M = new WeakSet();
M_fn = function(e2, t2, i2) {
  if (!(e2 instanceof Ref) || t2 < 0)
    return;
  this.structParentIds || (this.structParentIds = new RefSetCache());
  let a2 = this.structParentIds.get(e2);
  if (!a2) {
    a2 = [];
    this.structParentIds.put(e2, a2);
  }
  a2.push([t2, i2]);
};
_L = new WeakSet();
L_fn = async function({ newAnnotationsByPage: e2, structTreeRootRef: t2, kids: i2, nums: a2, xref: s2, pdfManager: r2, cache: n2 }) {
  const g2 = Name.get("OBJR");
  let o2 = -1 / 0;
  for (const [c2, C2] of e2) {
    const { ref: e3 } = await r2.getPage(c2), h2 = e3 instanceof Ref;
    for (const { accessibilityData: r3, ref: c3, parentTreeId: l2, structTreeParent: Q2 } of C2) {
      if (!(r3 == null ? void 0 : r3.type))
        continue;
      const { type: C3, title: E2, lang: u2, alt: d2, expanded: f2, actualText: p2 } = r3;
      o2 = Math.max(o2, l2);
      const m2 = s2.getNewTemporaryRef(), y2 = new Dict(s2);
      y2.set("S", Name.get(C3));
      E2 && y2.set("T", stringToAsciiOrUTF16BE(E2));
      u2 && y2.set("Lang", u2);
      d2 && y2.set("Alt", stringToAsciiOrUTF16BE(d2));
      f2 && y2.set("E", stringToAsciiOrUTF16BE(f2));
      p2 && y2.set("ActualText", stringToAsciiOrUTF16BE(p2));
      await __privateMethod(this, _J, J_fn).call(this, { structTreeParent: Q2, tagDict: y2, newTagRef: m2, structTreeRootRef: t2, fallbackKids: i2, xref: s2, cache: n2 });
      const w2 = new Dict(s2);
      y2.set("K", w2);
      w2.set("Type", g2);
      h2 && w2.set("Pg", e3);
      w2.set("Obj", c3);
      n2.put(m2, y2);
      a2.push(l2, m2);
    }
  }
  return o2 + 1;
};
_H = new WeakSet();
H_fn = function({ elements: e2, xref: t2, pageDict: i2, numberTree: a2 }) {
  const s2 = /* @__PURE__ */ new Map();
  for (const t3 of e2)
    if (t3.structTreeParentId) {
      const e3 = parseInt(t3.structTreeParentId.split("_mc")[1], 10);
      let i3 = s2.get(e3);
      if (!i3) {
        i3 = [];
        s2.set(e3, i3);
      }
      i3.push(t3);
    }
  const r2 = i2.get("StructParents");
  if (!Number.isInteger(r2))
    return;
  const n2 = a2.get(r2), updateElement = (e3, i3, a3) => {
    const r3 = s2.get(e3);
    if (r3) {
      const e4 = i3.getRaw("P"), s3 = t2.fetchIfRef(e4);
      if (e4 instanceof Ref && s3 instanceof Dict) {
        const e5 = { ref: a3, dict: i3 };
        for (const t3 of r3)
          t3.structTreeParent = e5;
      }
      return true;
    }
    return false;
  };
  for (const e3 of n2) {
    if (!(e3 instanceof Ref))
      continue;
    const i3 = t2.fetch(e3), a3 = i3.get("K");
    if (Number.isInteger(a3))
      updateElement(a3, i3, e3);
    else if (Array.isArray(a3))
      for (let s3 of a3) {
        s3 = t2.fetchIfRef(s3);
        if (Number.isInteger(s3) && updateElement(s3, i3, e3))
          break;
        if (!(s3 instanceof Dict))
          continue;
        if (!isName(s3.get("Type"), "MCR"))
          break;
        const a4 = s3.get("MCID");
        if (Number.isInteger(a4) && updateElement(a4, i3, e3))
          break;
      }
  }
};
_J = new WeakSet();
J_fn = async function({ structTreeParent: e2, tagDict: t2, newTagRef: i2, structTreeRootRef: a2, fallbackKids: s2, xref: r2, cache: n2 }) {
  let g2, o2 = null;
  if (e2) {
    ({ ref: o2 } = e2);
    g2 = e2.dict.getRaw("P") || a2;
  } else
    g2 = a2;
  t2.set("P", g2);
  const c2 = r2.fetchIfRef(g2);
  if (!c2) {
    s2.push(i2);
    return;
  }
  let C2 = n2.get(g2);
  if (!C2) {
    C2 = c2.clone();
    n2.put(g2, C2);
  }
  const h2 = C2.getRaw("K");
  let l2 = h2 instanceof Ref ? n2.get(h2) : null;
  if (!l2) {
    l2 = r2.fetchIfRef(h2);
    l2 = Array.isArray(l2) ? l2.slice() : [h2];
    const e3 = r2.getNewTemporaryRef();
    C2.set("K", e3);
    n2.put(e3, l2);
  }
  const Q2 = l2.indexOf(o2);
  l2.splice(Q2 >= 0 ? Q2 + 1 : l2.length, 0, i2);
};
__privateAdd(_StructTreeRoot, _L);
__privateAdd(_StructTreeRoot, _H);
__privateAdd(_StructTreeRoot, _J);
var StructTreeRoot = _StructTreeRoot;
var StructElementNode = class {
  constructor(e2, t2) {
    this.tree = e2;
    this.dict = t2;
    this.kids = [];
    this.parseKids();
  }
  get role() {
    const e2 = this.dict.get("S"), t2 = e2 instanceof Name ? e2.name : "", { root: i2 } = this.tree;
    return i2.roleMap.has(t2) ? i2.roleMap.get(t2) : t2;
  }
  parseKids() {
    let e2 = null;
    const t2 = this.dict.getRaw("Pg");
    t2 instanceof Ref && (e2 = t2.toString());
    const i2 = this.dict.get("K");
    if (Array.isArray(i2))
      for (const t3 of i2) {
        const i3 = this.parseKid(e2, t3);
        i3 && this.kids.push(i3);
      }
    else {
      const t3 = this.parseKid(e2, i2);
      t3 && this.kids.push(t3);
    }
  }
  parseKid(e2, t2) {
    if (Number.isInteger(t2))
      return this.tree.pageDict.objId !== e2 ? null : new StructElement({ type: Os, mcid: t2, pageObjId: e2 });
    let i2 = null;
    t2 instanceof Ref ? i2 = this.dict.xref.fetch(t2) : t2 instanceof Dict && (i2 = t2);
    if (!i2)
      return null;
    const a2 = i2.getRaw("Pg");
    a2 instanceof Ref && (e2 = a2.toString());
    const s2 = i2.get("Type") instanceof Name ? i2.get("Type").name : null;
    if ("MCR" === s2) {
      if (this.tree.pageDict.objId !== e2)
        return null;
      const t3 = i2.getRaw("Stm");
      return new StructElement({ type: Ws, refObjId: t3 instanceof Ref ? t3.toString() : null, pageObjId: e2, mcid: i2.get("MCID") });
    }
    if ("OBJR" === s2) {
      if (this.tree.pageDict.objId !== e2)
        return null;
      const t3 = i2.getRaw("Obj");
      return new StructElement({ type: js, refObjId: t3 instanceof Ref ? t3.toString() : null, pageObjId: e2 });
    }
    return new StructElement({ type: Zs, dict: i2 });
  }
};
var StructElement = class {
  constructor({ type: e2, dict: t2 = null, mcid: i2 = null, pageObjId: a2 = null, refObjId: s2 = null }) {
    this.type = e2;
    this.dict = t2;
    this.mcid = i2;
    this.pageObjId = a2;
    this.refObjId = s2;
    this.parentNode = null;
  }
};
var StructTreePage = class {
  constructor(e2, t2) {
    this.root = e2;
    this.rootDict = e2 ? e2.dict : null;
    this.pageDict = t2;
    this.nodes = [];
  }
  parse(e2) {
    var _a4, _b2;
    if (!this.root || !this.rootDict)
      return;
    const t2 = this.rootDict.get("ParentTree");
    if (!t2)
      return;
    const i2 = this.pageDict.get("StructParents"), a2 = e2 instanceof Ref && ((_a4 = this.root.structParentIds) == null ? void 0 : _a4.get(e2));
    if (!Number.isInteger(i2) && !a2)
      return;
    const s2 = /* @__PURE__ */ new Map(), r2 = new NumberTree(t2, this.rootDict.xref);
    if (Number.isInteger(i2)) {
      const e3 = r2.get(i2);
      if (Array.isArray(e3))
        for (const t3 of e3)
          t3 instanceof Ref && this.addNode(this.rootDict.xref.fetch(t3), s2);
    }
    if (a2)
      for (const [e3, t3] of a2) {
        const i3 = r2.get(e3);
        if (i3) {
          const e4 = this.addNode(this.rootDict.xref.fetchIfRef(i3), s2);
          1 === ((_b2 = e4 == null ? void 0 : e4.kids) == null ? void 0 : _b2.length) && e4.kids[0].type === js && (e4.kids[0].type = t3);
        }
      }
  }
  addNode(e2, t2, i2 = 0) {
    if (i2 > 40) {
      warn("StructTree MAX_DEPTH reached.");
      return null;
    }
    if (t2.has(e2))
      return t2.get(e2);
    const a2 = new StructElementNode(this, e2);
    t2.set(e2, a2);
    const s2 = e2.get("P");
    if (!s2 || isName(s2.get("Type"), "StructTreeRoot")) {
      this.addTopLevelNode(e2, a2) || t2.delete(e2);
      return a2;
    }
    const r2 = this.addNode(s2, t2, i2 + 1);
    if (!r2)
      return a2;
    let n2 = false;
    for (const t3 of r2.kids)
      if (t3.type === Zs && t3.dict === e2) {
        t3.parentNode = a2;
        n2 = true;
      }
    n2 || t2.delete(e2);
    return a2;
  }
  addTopLevelNode(e2, t2) {
    const i2 = this.rootDict.get("K");
    if (!i2)
      return false;
    if (i2 instanceof Dict) {
      if (i2.objId !== e2.objId)
        return false;
      this.nodes[0] = t2;
      return true;
    }
    if (!Array.isArray(i2))
      return true;
    let a2 = false;
    for (let s2 = 0; s2 < i2.length; s2++) {
      const r2 = i2[s2];
      if ((r2 == null ? void 0 : r2.toString()) === e2.objId) {
        this.nodes[s2] = t2;
        a2 = true;
      }
    }
    return a2;
  }
  get serializable() {
    function nodeToSerializable(e3, t2, i2 = 0) {
      if (i2 > 40) {
        warn("StructTree too deep to be fully serialized.");
        return;
      }
      const a2 = /* @__PURE__ */ Object.create(null);
      a2.role = e3.role;
      a2.children = [];
      t2.children.push(a2);
      const s2 = e3.dict.get("Alt");
      "string" == typeof s2 && (a2.alt = stringToPDFString(s2));
      const r2 = e3.dict.get("Lang");
      "string" == typeof r2 && (a2.lang = stringToPDFString(r2));
      for (const t3 of e3.kids) {
        const e4 = t3.type === Zs ? t3.parentNode : null;
        e4 ? nodeToSerializable(e4, a2, i2 + 1) : t3.type === Os || t3.type === Ws ? a2.children.push({ type: "content", id: `p${t3.pageObjId}_mc${t3.mcid}` }) : t3.type === js ? a2.children.push({ type: "object", id: t3.refObjId }) : t3.type === Xs && a2.children.push({ type: "annotation", id: `pdfjs_internal_id_${t3.refObjId}` });
      }
    }
    const e2 = /* @__PURE__ */ Object.create(null);
    e2.children = [];
    e2.role = "Root";
    for (const t2 of this.nodes)
      t2 && nodeToSerializable(t2, e2);
    return e2;
  }
};
function isValidExplicitDest(e2) {
  if (!Array.isArray(e2) || e2.length < 2)
    return false;
  const [t2, i2, ...a2] = e2;
  if (!(t2 instanceof Ref || Number.isInteger(t2)))
    return false;
  if (!(i2 instanceof Name))
    return false;
  const s2 = a2.length;
  let r2 = true;
  switch (i2.name) {
    case "XYZ":
      if (s2 < 2 || s2 > 3)
        return false;
      break;
    case "Fit":
    case "FitB":
      return 0 === s2;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (s2 > 1)
        return false;
      break;
    case "FitR":
      if (4 !== s2)
        return false;
      r2 = false;
      break;
    default:
      return false;
  }
  for (const e3 of a2)
    if (!("number" == typeof e3 || r2 && null === e3))
      return false;
  return true;
}
function fetchDest(e2) {
  e2 instanceof Dict && (e2 = e2.get("D"));
  return isValidExplicitDest(e2) ? e2 : null;
}
function fetchRemoteDest(e2) {
  let t2 = e2.get("D");
  if (t2) {
    t2 instanceof Name && (t2 = t2.name);
    if ("string" == typeof t2)
      return stringToPDFString(t2);
    if (isValidExplicitDest(t2))
      return JSON.stringify(t2);
  }
  return null;
}
var _Y, Y_fn, _v, v_fn;
var _Catalog = class _Catalog {
  constructor(e2, t2) {
    __privateAdd(this, _Y);
    __privateAdd(this, _v);
    this.pdfManager = e2;
    this.xref = t2;
    this._catDict = t2.getCatalogObj();
    if (!(this._catDict instanceof Dict))
      throw new FormatError("Catalog object is not a dictionary.");
    this.toplevelPagesDict;
    this._actualNumPages = null;
    this.fontCache = new RefSetCache();
    this.builtInCMapCache = /* @__PURE__ */ new Map();
    this.standardFontDataCache = /* @__PURE__ */ new Map();
    this.globalImageCache = new GlobalImageCache();
    this.pageKidsCountCache = new RefSetCache();
    this.pageIndexCache = new RefSetCache();
    this.nonBlendModesSet = new RefSet();
    this.systemFontCache = /* @__PURE__ */ new Map();
  }
  cloneDict() {
    return this._catDict.clone();
  }
  get version() {
    const e2 = this._catDict.get("Version");
    if (e2 instanceof Name) {
      if (kt.test(e2.name))
        return shadow(this, "version", e2.name);
      warn(`Invalid PDF catalog version: ${e2.name}`);
    }
    return shadow(this, "version", null);
  }
  get lang() {
    const e2 = this._catDict.get("Lang");
    return shadow(this, "lang", e2 && "string" == typeof e2 ? stringToPDFString(e2) : null);
  }
  get needsRendering() {
    const e2 = this._catDict.get("NeedsRendering");
    return shadow(this, "needsRendering", "boolean" == typeof e2 && e2);
  }
  get collection() {
    let e2 = null;
    try {
      const t2 = this._catDict.get("Collection");
      t2 instanceof Dict && t2.size > 0 && (e2 = t2);
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      info("Cannot fetch Collection entry; assuming no collection is present.");
    }
    return shadow(this, "collection", e2);
  }
  get acroForm() {
    let e2 = null;
    try {
      const t2 = this._catDict.get("AcroForm");
      t2 instanceof Dict && t2.size > 0 && (e2 = t2);
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      info("Cannot fetch AcroForm entry; assuming no forms are present.");
    }
    return shadow(this, "acroForm", e2);
  }
  get acroFormRef() {
    const e2 = this._catDict.getRaw("AcroForm");
    return shadow(this, "acroFormRef", e2 instanceof Ref ? e2 : null);
  }
  get metadata() {
    var _a4;
    const e2 = this._catDict.getRaw("Metadata");
    if (!(e2 instanceof Ref))
      return shadow(this, "metadata", null);
    let t2 = null;
    try {
      const i2 = this.xref.fetch(e2, !((_a4 = this.xref.encrypt) == null ? void 0 : _a4.encryptMetadata));
      if (i2 instanceof BaseStream && i2.dict instanceof Dict) {
        const e3 = i2.dict.get("Type"), a2 = i2.dict.get("Subtype");
        if (isName(e3, "Metadata") && isName(a2, "XML")) {
          const e4 = stringToUTF8String(i2.getString());
          e4 && (t2 = new MetadataParser(e4).serializable);
        }
      }
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      info(`Skipping invalid Metadata: "${e3}".`);
    }
    return shadow(this, "metadata", t2);
  }
  get markInfo() {
    let e2 = null;
    try {
      e2 = this._readMarkInfo();
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      warn("Unable to read mark info.");
    }
    return shadow(this, "markInfo", e2);
  }
  _readMarkInfo() {
    const e2 = this._catDict.get("MarkInfo");
    if (!(e2 instanceof Dict))
      return null;
    const t2 = { Marked: false, UserProperties: false, Suspects: false };
    for (const i2 in t2) {
      const a2 = e2.get(i2);
      "boolean" == typeof a2 && (t2[i2] = a2);
    }
    return t2;
  }
  get structTreeRoot() {
    let e2 = null;
    try {
      e2 = this._readStructTreeRoot();
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      warn("Unable read to structTreeRoot info.");
    }
    return shadow(this, "structTreeRoot", e2);
  }
  _readStructTreeRoot() {
    const e2 = this._catDict.getRaw("StructTreeRoot"), t2 = this.xref.fetchIfRef(e2);
    if (!(t2 instanceof Dict))
      return null;
    const i2 = new StructTreeRoot(t2, e2);
    i2.init();
    return i2;
  }
  get toplevelPagesDict() {
    const e2 = this._catDict.get("Pages");
    if (!(e2 instanceof Dict))
      throw new FormatError("Invalid top-level pages dictionary.");
    return shadow(this, "toplevelPagesDict", e2);
  }
  get documentOutline() {
    let e2 = null;
    try {
      e2 = this._readDocumentOutline();
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      warn("Unable to read document outline.");
    }
    return shadow(this, "documentOutline", e2);
  }
  _readDocumentOutline() {
    let e2 = this._catDict.get("Outlines");
    if (!(e2 instanceof Dict))
      return null;
    e2 = e2.getRaw("First");
    if (!(e2 instanceof Ref))
      return null;
    const t2 = { items: [] }, i2 = [{ obj: e2, parent: t2 }], a2 = new RefSet();
    a2.put(e2);
    const s2 = this.xref, r2 = new Uint8ClampedArray(3);
    for (; i2.length > 0; ) {
      const t3 = i2.shift(), n2 = s2.fetchIfRef(t3.obj);
      if (null === n2)
        continue;
      n2.has("Title") || warn("Invalid outline item encountered.");
      const g2 = { url: null, dest: null, action: null };
      _Catalog.parseDestDictionary({ destDict: n2, resultObj: g2, docBaseUrl: this.baseUrl, docAttachments: this.attachments });
      const o2 = n2.get("Title"), c2 = n2.get("F") || 0, C2 = n2.getArray("C"), h2 = n2.get("Count");
      let l2 = r2;
      !isNumberArray(C2, 3) || 0 === C2[0] && 0 === C2[1] && 0 === C2[2] || (l2 = ColorSpace.singletons.rgb.getRgb(C2, 0));
      const Q2 = { action: g2.action, attachment: g2.attachment, dest: g2.dest, url: g2.url, unsafeUrl: g2.unsafeUrl, newWindow: g2.newWindow, setOCGState: g2.setOCGState, title: "string" == typeof o2 ? stringToPDFString(o2) : "", color: l2, count: Number.isInteger(h2) ? h2 : void 0, bold: !!(2 & c2), italic: !!(1 & c2), items: [] };
      t3.parent.items.push(Q2);
      e2 = n2.getRaw("First");
      if (e2 instanceof Ref && !a2.has(e2)) {
        i2.push({ obj: e2, parent: Q2 });
        a2.put(e2);
      }
      e2 = n2.getRaw("Next");
      if (e2 instanceof Ref && !a2.has(e2)) {
        i2.push({ obj: e2, parent: t3.parent });
        a2.put(e2);
      }
    }
    return t2.items.length > 0 ? t2.items : null;
  }
  get permissions() {
    let e2 = null;
    try {
      e2 = this._readPermissions();
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      warn("Unable to read permissions.");
    }
    return shadow(this, "permissions", e2);
  }
  _readPermissions() {
    const e2 = this.xref.trailer.get("Encrypt");
    if (!(e2 instanceof Dict))
      return null;
    let t2 = e2.get("P");
    if ("number" != typeof t2)
      return null;
    t2 += 2 ** 32;
    const i2 = [];
    for (const e3 in y) {
      const a2 = y[e3];
      t2 & a2 && i2.push(a2);
    }
    return i2;
  }
  get optionalContentConfig() {
    let e2 = null;
    try {
      const t2 = this._catDict.get("OCProperties");
      if (!t2)
        return shadow(this, "optionalContentConfig", null);
      const i2 = t2.get("D");
      if (!i2)
        return shadow(this, "optionalContentConfig", null);
      const a2 = t2.get("OCGs");
      if (!Array.isArray(a2))
        return shadow(this, "optionalContentConfig", null);
      const s2 = [], r2 = new RefSet();
      for (const e3 of a2)
        if (e3 instanceof Ref && !r2.has(e3)) {
          r2.put(e3);
          s2.push(__privateMethod(this, _Y, Y_fn).call(this, e3));
        }
      e2 = __privateMethod(this, _v, v_fn).call(this, i2, r2);
      e2.groups = s2;
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      warn(`Unable to read optional content config: ${e3}`);
    }
    return shadow(this, "optionalContentConfig", e2);
  }
  setActualNumPages(e2 = null) {
    this._actualNumPages = e2;
  }
  get hasActualNumPages() {
    return null !== this._actualNumPages;
  }
  get _pagesCount() {
    const e2 = this.toplevelPagesDict.get("Count");
    if (!Number.isInteger(e2))
      throw new FormatError("Page count in top-level pages dictionary is not an integer.");
    return shadow(this, "_pagesCount", e2);
  }
  get numPages() {
    return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
  }
  get destinations() {
    const e2 = this._readDests(), t2 = /* @__PURE__ */ Object.create(null);
    if (e2 instanceof NameTree)
      for (const [i2, a2] of e2.getAll()) {
        const e3 = fetchDest(a2);
        e3 && (t2[stringToPDFString(i2)] = e3);
      }
    else
      e2 instanceof Dict && e2.forEach(function(e3, i2) {
        const a2 = fetchDest(i2);
        a2 && (t2[e3] = a2);
      });
    return shadow(this, "destinations", t2);
  }
  getDestination(e2) {
    const t2 = this._readDests();
    if (t2 instanceof NameTree) {
      const i2 = fetchDest(t2.get(e2));
      if (i2)
        return i2;
      const a2 = this.destinations[e2];
      if (a2) {
        warn(`Found "${e2}" at an incorrect position in the NameTree.`);
        return a2;
      }
    } else if (t2 instanceof Dict) {
      const i2 = fetchDest(t2.get(e2));
      if (i2)
        return i2;
    }
    return null;
  }
  _readDests() {
    const e2 = this._catDict.get("Names");
    return (e2 == null ? void 0 : e2.has("Dests")) ? new NameTree(e2.getRaw("Dests"), this.xref) : this._catDict.has("Dests") ? this._catDict.get("Dests") : void 0;
  }
  get pageLabels() {
    let e2 = null;
    try {
      e2 = this._readPageLabels();
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      warn("Unable to read page labels.");
    }
    return shadow(this, "pageLabels", e2);
  }
  _readPageLabels() {
    const e2 = this._catDict.getRaw("PageLabels");
    if (!e2)
      return null;
    const t2 = new Array(this.numPages);
    let i2 = null, a2 = "";
    const s2 = new NumberTree(e2, this.xref).getAll();
    let r2 = "", n2 = 1;
    for (let e3 = 0, g2 = this.numPages; e3 < g2; e3++) {
      const g3 = s2.get(e3);
      if (void 0 !== g3) {
        if (!(g3 instanceof Dict))
          throw new FormatError("PageLabel is not a dictionary.");
        if (g3.has("Type") && !isName(g3.get("Type"), "PageLabel"))
          throw new FormatError("Invalid type in PageLabel dictionary.");
        if (g3.has("S")) {
          const e4 = g3.get("S");
          if (!(e4 instanceof Name))
            throw new FormatError("Invalid style in PageLabel dictionary.");
          i2 = e4.name;
        } else
          i2 = null;
        if (g3.has("P")) {
          const e4 = g3.get("P");
          if ("string" != typeof e4)
            throw new FormatError("Invalid prefix in PageLabel dictionary.");
          a2 = stringToPDFString(e4);
        } else
          a2 = "";
        if (g3.has("St")) {
          const e4 = g3.get("St");
          if (!(Number.isInteger(e4) && e4 >= 1))
            throw new FormatError("Invalid start in PageLabel dictionary.");
          n2 = e4;
        } else
          n2 = 1;
      }
      switch (i2) {
        case "D":
          r2 = n2;
          break;
        case "R":
        case "r":
          r2 = toRomanNumerals(n2, "r" === i2);
          break;
        case "A":
        case "a":
          const e4 = 26, t3 = "a" === i2 ? 97 : 65, a3 = n2 - 1;
          r2 = String.fromCharCode(t3 + a3 % e4).repeat(Math.floor(a3 / e4) + 1);
          break;
        default:
          if (i2)
            throw new FormatError(`Invalid style "${i2}" in PageLabel dictionary.`);
          r2 = "";
      }
      t2[e3] = a2 + r2;
      n2++;
    }
    return t2;
  }
  get pageLayout() {
    const e2 = this._catDict.get("PageLayout");
    let t2 = "";
    if (e2 instanceof Name)
      switch (e2.name) {
        case "SinglePage":
        case "OneColumn":
        case "TwoColumnLeft":
        case "TwoColumnRight":
        case "TwoPageLeft":
        case "TwoPageRight":
          t2 = e2.name;
      }
    return shadow(this, "pageLayout", t2);
  }
  get pageMode() {
    const e2 = this._catDict.get("PageMode");
    let t2 = "UseNone";
    if (e2 instanceof Name)
      switch (e2.name) {
        case "UseNone":
        case "UseOutlines":
        case "UseThumbs":
        case "FullScreen":
        case "UseOC":
        case "UseAttachments":
          t2 = e2.name;
      }
    return shadow(this, "pageMode", t2);
  }
  get viewerPreferences() {
    const e2 = this._catDict.get("ViewerPreferences");
    if (!(e2 instanceof Dict))
      return shadow(this, "viewerPreferences", null);
    let t2 = null;
    for (const i2 of e2.getKeys()) {
      const a2 = e2.get(i2);
      let s2;
      switch (i2) {
        case "HideToolbar":
        case "HideMenubar":
        case "HideWindowUI":
        case "FitWindow":
        case "CenterWindow":
        case "DisplayDocTitle":
        case "PickTrayByPDFSize":
          "boolean" == typeof a2 && (s2 = a2);
          break;
        case "NonFullScreenPageMode":
          if (a2 instanceof Name)
            switch (a2.name) {
              case "UseNone":
              case "UseOutlines":
              case "UseThumbs":
              case "UseOC":
                s2 = a2.name;
                break;
              default:
                s2 = "UseNone";
            }
          break;
        case "Direction":
          if (a2 instanceof Name)
            switch (a2.name) {
              case "L2R":
              case "R2L":
                s2 = a2.name;
                break;
              default:
                s2 = "L2R";
            }
          break;
        case "ViewArea":
        case "ViewClip":
        case "PrintArea":
        case "PrintClip":
          if (a2 instanceof Name)
            switch (a2.name) {
              case "MediaBox":
              case "CropBox":
              case "BleedBox":
              case "TrimBox":
              case "ArtBox":
                s2 = a2.name;
                break;
              default:
                s2 = "CropBox";
            }
          break;
        case "PrintScaling":
          if (a2 instanceof Name)
            switch (a2.name) {
              case "None":
              case "AppDefault":
                s2 = a2.name;
                break;
              default:
                s2 = "AppDefault";
            }
          break;
        case "Duplex":
          if (a2 instanceof Name)
            switch (a2.name) {
              case "Simplex":
              case "DuplexFlipShortEdge":
              case "DuplexFlipLongEdge":
                s2 = a2.name;
                break;
              default:
                s2 = "None";
            }
          break;
        case "PrintPageRange":
          if (Array.isArray(a2) && a2.length % 2 == 0) {
            a2.every((e3, t3, i3) => Number.isInteger(e3) && e3 > 0 && (0 === t3 || e3 >= i3[t3 - 1]) && e3 <= this.numPages) && (s2 = a2);
          }
          break;
        case "NumCopies":
          Number.isInteger(a2) && a2 > 0 && (s2 = a2);
          break;
        default:
          warn(`Ignoring non-standard key in ViewerPreferences: ${i2}.`);
          continue;
      }
      if (void 0 !== s2) {
        t2 || (t2 = /* @__PURE__ */ Object.create(null));
        t2[i2] = s2;
      } else
        warn(`Bad value, for key "${i2}", in ViewerPreferences: ${a2}.`);
    }
    return shadow(this, "viewerPreferences", t2);
  }
  get openAction() {
    const e2 = this._catDict.get("OpenAction"), t2 = /* @__PURE__ */ Object.create(null);
    if (e2 instanceof Dict) {
      const i2 = new Dict(this.xref);
      i2.set("A", e2);
      const a2 = { url: null, dest: null, action: null };
      _Catalog.parseDestDictionary({ destDict: i2, resultObj: a2 });
      Array.isArray(a2.dest) ? t2.dest = a2.dest : a2.action && (t2.action = a2.action);
    } else
      Array.isArray(e2) && (t2.dest = e2);
    return shadow(this, "openAction", objectSize(t2) > 0 ? t2 : null);
  }
  get attachments() {
    const e2 = this._catDict.get("Names");
    let t2 = null;
    if (e2 instanceof Dict && e2.has("EmbeddedFiles")) {
      const i2 = new NameTree(e2.getRaw("EmbeddedFiles"), this.xref);
      for (const [e3, a2] of i2.getAll()) {
        const i3 = new FileSpec(a2, this.xref);
        t2 || (t2 = /* @__PURE__ */ Object.create(null));
        t2[stringToPDFString(e3)] = i3.serializable;
      }
    }
    return shadow(this, "attachments", t2);
  }
  get xfaImages() {
    const e2 = this._catDict.get("Names");
    let t2 = null;
    if (e2 instanceof Dict && e2.has("XFAImages")) {
      const i2 = new NameTree(e2.getRaw("XFAImages"), this.xref);
      for (const [e3, a2] of i2.getAll()) {
        t2 || (t2 = new Dict(this.xref));
        t2.set(stringToPDFString(e3), a2);
      }
    }
    return shadow(this, "xfaImages", t2);
  }
  _collectJavaScript() {
    const e2 = this._catDict.get("Names");
    let t2 = null;
    function appendIfJavaScriptDict(e3, i3) {
      if (!(i3 instanceof Dict))
        return;
      if (!isName(i3.get("S"), "JavaScript"))
        return;
      let a2 = i3.get("JS");
      if (a2 instanceof BaseStream)
        a2 = a2.getString();
      else if ("string" != typeof a2)
        return;
      a2 = stringToPDFString(a2).replaceAll("\0", "");
      a2 && (t2 || (t2 = /* @__PURE__ */ new Map())).set(e3, a2);
    }
    if (e2 instanceof Dict && e2.has("JavaScript")) {
      const t3 = new NameTree(e2.getRaw("JavaScript"), this.xref);
      for (const [e3, i3] of t3.getAll())
        appendIfJavaScriptDict(stringToPDFString(e3), i3);
    }
    const i2 = this._catDict.get("OpenAction");
    i2 && appendIfJavaScriptDict("OpenAction", i2);
    return t2;
  }
  get jsActions() {
    const e2 = this._collectJavaScript();
    let t2 = collectActions(this.xref, this._catDict, fA);
    if (e2) {
      t2 || (t2 = /* @__PURE__ */ Object.create(null));
      for (const [i2, a2] of e2)
        i2 in t2 ? t2[i2].push(a2) : t2[i2] = [a2];
    }
    return shadow(this, "jsActions", t2);
  }
  async fontFallback(e2, t2) {
    const i2 = await Promise.all(this.fontCache);
    for (const a2 of i2)
      if (a2.loadedName === e2) {
        a2.fallback(t2);
        return;
      }
  }
  async cleanup(e2 = false) {
    clearGlobalCaches();
    this.globalImageCache.clear(e2);
    this.pageKidsCountCache.clear();
    this.pageIndexCache.clear();
    this.nonBlendModesSet.clear();
    const t2 = await Promise.all(this.fontCache);
    for (const { dict: e3 } of t2)
      delete e3.cacheKey;
    this.fontCache.clear();
    this.builtInCMapCache.clear();
    this.standardFontDataCache.clear();
    this.systemFontCache.clear();
  }
  async getPageDict(e2) {
    const t2 = [this.toplevelPagesDict], i2 = new RefSet(), a2 = this._catDict.getRaw("Pages");
    a2 instanceof Ref && i2.put(a2);
    const s2 = this.xref, r2 = this.pageKidsCountCache, n2 = this.pageIndexCache;
    let g2 = 0;
    for (; t2.length; ) {
      const a3 = t2.pop();
      if (a3 instanceof Ref) {
        const o3 = r2.get(a3);
        if (o3 >= 0 && g2 + o3 <= e2) {
          g2 += o3;
          continue;
        }
        if (i2.has(a3))
          throw new FormatError("Pages tree contains circular reference.");
        i2.put(a3);
        const c3 = await s2.fetchAsync(a3);
        if (c3 instanceof Dict) {
          let t3 = c3.getRaw("Type");
          t3 instanceof Ref && (t3 = await s2.fetchAsync(t3));
          if (isName(t3, "Page") || !c3.has("Kids")) {
            r2.has(a3) || r2.put(a3, 1);
            n2.has(a3) || n2.put(a3, g2);
            if (g2 === e2)
              return [c3, a3];
            g2++;
            continue;
          }
        }
        t2.push(c3);
        continue;
      }
      if (!(a3 instanceof Dict))
        throw new FormatError("Page dictionary kid reference points to wrong type of object.");
      const { objId: o2 } = a3;
      let c2 = a3.getRaw("Count");
      c2 instanceof Ref && (c2 = await s2.fetchAsync(c2));
      if (Number.isInteger(c2) && c2 >= 0) {
        o2 && !r2.has(o2) && r2.put(o2, c2);
        if (g2 + c2 <= e2) {
          g2 += c2;
          continue;
        }
      }
      let C2 = a3.getRaw("Kids");
      C2 instanceof Ref && (C2 = await s2.fetchAsync(C2));
      if (!Array.isArray(C2)) {
        let t3 = a3.getRaw("Type");
        t3 instanceof Ref && (t3 = await s2.fetchAsync(t3));
        if (isName(t3, "Page") || !a3.has("Kids")) {
          if (g2 === e2)
            return [a3, null];
          g2++;
          continue;
        }
        throw new FormatError("Page dictionary kids object is not an array.");
      }
      for (let e3 = C2.length - 1; e3 >= 0; e3--)
        t2.push(C2[e3]);
    }
    throw new Error(`Page index ${e2} not found.`);
  }
  async getAllPageDicts(e2 = false) {
    const { ignoreErrors: t2 } = this.pdfManager.evaluatorOptions, i2 = [{ currentNode: this.toplevelPagesDict, posInKids: 0 }], a2 = new RefSet(), s2 = this._catDict.getRaw("Pages");
    s2 instanceof Ref && a2.put(s2);
    const r2 = /* @__PURE__ */ new Map(), n2 = this.xref, g2 = this.pageIndexCache;
    let o2 = 0;
    function addPageDict(e3, t3) {
      t3 && !g2.has(t3) && g2.put(t3, o2);
      r2.set(o2++, [e3, t3]);
    }
    function addPageError(i3) {
      if (i3 instanceof XRefEntryException && !e2)
        throw i3;
      if (e2 && t2 && 0 === o2) {
        warn(`getAllPageDicts - Skipping invalid first page: "${i3}".`);
        i3 = Dict.empty;
      }
      r2.set(o2++, [i3, null]);
    }
    for (; i2.length > 0; ) {
      const e3 = i2.at(-1), { currentNode: t3, posInKids: s3 } = e3;
      let r3 = t3.getRaw("Kids");
      if (r3 instanceof Ref)
        try {
          r3 = await n2.fetchAsync(r3);
        } catch (e4) {
          addPageError(e4);
          break;
        }
      if (!Array.isArray(r3)) {
        addPageError(new FormatError("Page dictionary kids object is not an array."));
        break;
      }
      if (s3 >= r3.length) {
        i2.pop();
        continue;
      }
      const g3 = r3[s3];
      let o3;
      if (g3 instanceof Ref) {
        if (a2.has(g3)) {
          addPageError(new FormatError("Pages tree contains circular reference."));
          break;
        }
        a2.put(g3);
        try {
          o3 = await n2.fetchAsync(g3);
        } catch (e4) {
          addPageError(e4);
          break;
        }
      } else
        o3 = g3;
      if (!(o3 instanceof Dict)) {
        addPageError(new FormatError("Page dictionary kid reference points to wrong type of object."));
        break;
      }
      let c2 = o3.getRaw("Type");
      if (c2 instanceof Ref)
        try {
          c2 = await n2.fetchAsync(c2);
        } catch (e4) {
          addPageError(e4);
          break;
        }
      isName(c2, "Page") || !o3.has("Kids") ? addPageDict(o3, g3 instanceof Ref ? g3 : null) : i2.push({ currentNode: o3, posInKids: 0 });
      e3.posInKids++;
    }
    return r2;
  }
  getPageIndex(e2) {
    const t2 = this.pageIndexCache.get(e2);
    if (void 0 !== t2)
      return Promise.resolve(t2);
    const i2 = this.xref;
    let a2 = 0;
    const next = (t3) => function pagesBeforeRef(t4) {
      let a3, s2 = 0;
      return i2.fetchAsync(t4).then(function(i3) {
        if (isRefsEqual(t4, e2) && !isDict(i3, "Page") && !(i3 instanceof Dict && !i3.has("Type") && i3.has("Contents")))
          throw new FormatError("The reference does not point to a /Page dictionary.");
        if (!i3)
          return null;
        if (!(i3 instanceof Dict))
          throw new FormatError("Node must be a dictionary.");
        a3 = i3.getRaw("Parent");
        return i3.getAsync("Parent");
      }).then(function(e3) {
        if (!e3)
          return null;
        if (!(e3 instanceof Dict))
          throw new FormatError("Parent must be a dictionary.");
        return e3.getAsync("Kids");
      }).then(function(e3) {
        if (!e3)
          return null;
        const r2 = [];
        let n2 = false;
        for (const a4 of e3) {
          if (!(a4 instanceof Ref))
            throw new FormatError("Kid must be a reference.");
          if (isRefsEqual(a4, t4)) {
            n2 = true;
            break;
          }
          r2.push(i2.fetchAsync(a4).then(function(e4) {
            if (!(e4 instanceof Dict))
              throw new FormatError("Kid node must be a dictionary.");
            e4.has("Count") ? s2 += e4.get("Count") : s2++;
          }));
        }
        if (!n2)
          throw new FormatError("Kid reference not found in parent's kids.");
        return Promise.all(r2).then(function() {
          return [s2, a3];
        });
      });
    }(t3).then((t4) => {
      if (!t4) {
        this.pageIndexCache.put(e2, a2);
        return a2;
      }
      const [i3, s2] = t4;
      a2 += i3;
      return next(s2);
    });
    return next(e2);
  }
  get baseUrl() {
    const e2 = this._catDict.get("URI");
    if (e2 instanceof Dict) {
      const t2 = e2.get("Base");
      if ("string" == typeof t2) {
        const e3 = createValidAbsoluteUrl(t2, null, { tryConvertEncoding: true });
        if (e3)
          return shadow(this, "baseUrl", e3.href);
      }
    }
    return shadow(this, "baseUrl", this.pdfManager.docBaseUrl);
  }
  static parseDestDictionary({ destDict: e2, resultObj: t2, docBaseUrl: i2 = null, docAttachments: a2 = null }) {
    if (!(e2 instanceof Dict)) {
      warn("parseDestDictionary: `destDict` must be a dictionary.");
      return;
    }
    let s2, r2, n2 = e2.get("A");
    if (!(n2 instanceof Dict))
      if (e2.has("Dest"))
        n2 = e2.get("Dest");
      else {
        n2 = e2.get("AA");
        n2 instanceof Dict && (n2.has("D") ? n2 = n2.get("D") : n2.has("U") && (n2 = n2.get("U")));
      }
    if (n2 instanceof Dict) {
      const e3 = n2.get("S");
      if (!(e3 instanceof Name)) {
        warn("parseDestDictionary: Invalid type in Action dictionary.");
        return;
      }
      const i3 = e3.name;
      switch (i3) {
        case "ResetForm":
          const e4 = n2.get("Flags"), g2 = 0 == (1 & ("number" == typeof e4 ? e4 : 0)), o2 = [], c2 = [];
          for (const e5 of n2.get("Fields") || [])
            e5 instanceof Ref ? c2.push(e5.toString()) : "string" == typeof e5 && o2.push(stringToPDFString(e5));
          t2.resetForm = { fields: o2, refs: c2, include: g2 };
          break;
        case "URI":
          s2 = n2.get("URI");
          s2 instanceof Name && (s2 = "/" + s2.name);
          break;
        case "GoTo":
          r2 = n2.get("D");
          break;
        case "Launch":
        case "GoToR":
          const C2 = n2.get("F");
          if (C2 instanceof Dict) {
            const e5 = new FileSpec(C2, null, true), { rawFilename: t3 } = e5.serializable;
            s2 = t3;
          } else
            "string" == typeof C2 && (s2 = C2);
          const h2 = fetchRemoteDest(n2);
          h2 && "string" == typeof s2 && (s2 = s2.split("#", 1)[0] + "#" + h2);
          const l2 = n2.get("NewWindow");
          "boolean" == typeof l2 && (t2.newWindow = l2);
          break;
        case "GoToE":
          const Q2 = n2.get("T");
          let E2;
          if (a2 && Q2 instanceof Dict) {
            const e5 = Q2.get("R"), t3 = Q2.get("N");
            isName(e5, "C") && "string" == typeof t3 && (E2 = a2[stringToPDFString(t3)]);
          }
          if (E2) {
            t2.attachment = E2;
            const e5 = fetchRemoteDest(n2);
            e5 && (t2.attachmentDest = e5);
          } else
            warn('parseDestDictionary - unimplemented "GoToE" action.');
          break;
        case "Named":
          const u2 = n2.get("N");
          u2 instanceof Name && (t2.action = u2.name);
          break;
        case "SetOCGState":
          const d2 = n2.get("State"), f2 = n2.get("PreserveRB");
          if (!Array.isArray(d2) || 0 === d2.length)
            break;
          const p2 = [];
          for (const e5 of d2)
            if (e5 instanceof Name)
              switch (e5.name) {
                case "ON":
                case "OFF":
                case "Toggle":
                  p2.push(e5.name);
              }
            else
              e5 instanceof Ref && p2.push(e5.toString());
          if (p2.length !== d2.length)
            break;
          t2.setOCGState = { state: p2, preserveRB: "boolean" != typeof f2 || f2 };
          break;
        case "JavaScript":
          const m2 = n2.get("JS");
          let y2;
          m2 instanceof BaseStream ? y2 = m2.getString() : "string" == typeof m2 && (y2 = m2);
          const w2 = y2 && recoverJsURL(stringToPDFString(y2));
          if (w2) {
            s2 = w2.url;
            t2.newWindow = w2.newWindow;
            break;
          }
        default:
          if ("JavaScript" === i3 || "SubmitForm" === i3)
            break;
          warn(`parseDestDictionary - unsupported action: "${i3}".`);
      }
    } else
      e2.has("Dest") && (r2 = e2.get("Dest"));
    if ("string" == typeof s2) {
      const e3 = createValidAbsoluteUrl(s2, i2, { addDefaultProtocol: true, tryConvertEncoding: true });
      e3 && (t2.url = e3.href);
      t2.unsafeUrl = s2;
    }
    if (r2) {
      r2 instanceof Name && (r2 = r2.name);
      "string" == typeof r2 ? t2.dest = stringToPDFString(r2) : isValidExplicitDest(r2) && (t2.dest = r2);
    }
  }
};
_Y = new WeakSet();
Y_fn = function(e2) {
  const t2 = this.xref.fetch(e2), i2 = { id: e2.toString(), name: null, intent: null, usage: { print: null, view: null } }, a2 = t2.get("Name");
  "string" == typeof a2 && (i2.name = stringToPDFString(a2));
  let s2 = t2.getArray("Intent");
  Array.isArray(s2) || (s2 = [s2]);
  s2.every((e3) => e3 instanceof Name) && (i2.intent = s2.map((e3) => e3.name));
  const r2 = t2.get("Usage");
  if (!(r2 instanceof Dict))
    return i2;
  const n2 = i2.usage, g2 = r2.get("Print");
  if (g2 instanceof Dict) {
    const e3 = g2.get("PrintState");
    if (e3 instanceof Name)
      switch (e3.name) {
        case "ON":
        case "OFF":
          n2.print = { printState: e3.name };
      }
  }
  const o2 = r2.get("View");
  if (o2 instanceof Dict) {
    const e3 = o2.get("ViewState");
    if (e3 instanceof Name)
      switch (e3.name) {
        case "ON":
        case "OFF":
          n2.view = { viewState: e3.name };
      }
  }
  return i2;
};
_v = new WeakSet();
v_fn = function(e2, t2) {
  function parseOnOff(e3) {
    const i3 = [];
    if (Array.isArray(e3))
      for (const a3 of e3)
        a3 instanceof Ref && t2.has(a3) && i3.push(a3.toString());
    return i3;
  }
  function parseOrder(e3, i3 = 0) {
    if (!Array.isArray(e3))
      return null;
    const s3 = [];
    for (const r3 of e3) {
      if (r3 instanceof Ref && t2.has(r3)) {
        a2.put(r3);
        s3.push(r3.toString());
        continue;
      }
      const e4 = parseNestedOrder(r3, i3);
      e4 && s3.push(e4);
    }
    if (i3 > 0)
      return s3;
    const r2 = [];
    for (const e4 of t2)
      a2.has(e4) || r2.push(e4.toString());
    r2.length && s3.push({ name: null, order: r2 });
    return s3;
  }
  function parseNestedOrder(e3, t3) {
    if (++t3 > s2) {
      warn("parseNestedOrder - reached MAX_NESTED_LEVELS.");
      return null;
    }
    const a3 = i2.fetchIfRef(e3);
    if (!Array.isArray(a3))
      return null;
    const r2 = i2.fetchIfRef(a3[0]);
    if ("string" != typeof r2)
      return null;
    const n2 = parseOrder(a3.slice(1), t3);
    return n2 && n2.length ? { name: stringToPDFString(r2), order: n2 } : null;
  }
  const i2 = this.xref, a2 = new RefSet(), s2 = 10;
  return { name: "string" == typeof e2.get("Name") ? stringToPDFString(e2.get("Name")) : null, creator: "string" == typeof e2.get("Creator") ? stringToPDFString(e2.get("Creator")) : null, baseState: e2.get("BaseState") instanceof Name ? e2.get("BaseState").name : null, on: parseOnOff(e2.get("ON")), off: parseOnOff(e2.get("OFF")), order: parseOrder(e2.get("Order")), groups: null };
};
var Catalog = _Catalog;
function addChildren(e2, t2) {
  if (e2 instanceof Dict)
    e2 = e2.getRawValues();
  else if (e2 instanceof BaseStream)
    e2 = e2.dict.getRawValues();
  else if (!Array.isArray(e2))
    return;
  for (const a2 of e2)
    ((i2 = a2) instanceof Ref || i2 instanceof Dict || i2 instanceof BaseStream || Array.isArray(i2)) && t2.push(a2);
  var i2;
}
var ObjectLoader = class {
  constructor(e2, t2, i2) {
    this.dict = e2;
    this.keys = t2;
    this.xref = i2;
    this.refSet = null;
  }
  async load() {
    if (this.xref.stream.isDataLoaded)
      return;
    const { keys: e2, dict: t2 } = this;
    this.refSet = new RefSet();
    const i2 = [];
    for (const a2 of e2) {
      const e3 = t2.getRaw(a2);
      void 0 !== e3 && i2.push(e3);
    }
    return this._walk(i2);
  }
  async _walk(e2) {
    const t2 = [], i2 = [];
    for (; e2.length; ) {
      let a2 = e2.pop();
      if (a2 instanceof Ref) {
        if (this.refSet.has(a2))
          continue;
        try {
          this.refSet.put(a2);
          a2 = this.xref.fetch(a2);
        } catch (e3) {
          if (!(e3 instanceof MissingDataException)) {
            warn(`ObjectLoader._walk - requesting all data: "${e3}".`);
            this.refSet = null;
            const { manager: t3 } = this.xref.stream;
            return t3.requestAllChunks();
          }
          t2.push(a2);
          i2.push({ begin: e3.begin, end: e3.end });
        }
      }
      if (a2 instanceof BaseStream) {
        const e3 = a2.getBaseStreams();
        if (e3) {
          let s2 = false;
          for (const t3 of e3)
            if (!t3.isDataLoaded) {
              s2 = true;
              i2.push({ begin: t3.start, end: t3.end });
            }
          s2 && t2.push(a2);
        }
      }
      addChildren(a2, e2);
    }
    if (i2.length) {
      await this.xref.stream.manager.requestRanges(i2);
      for (const e3 of t2)
        e3 instanceof Ref && this.refSet.remove(e3);
      return this._walk(t2);
    }
    this.refSet = null;
  }
};
var Vs = Symbol();
var zs = Symbol();
var _s2 = Symbol();
var $s = Symbol();
var Ar = Symbol();
var er = Symbol();
var tr = Symbol();
var ir = Symbol();
var ar = Symbol();
var sr = Symbol("content");
var rr = Symbol("data");
var nr = Symbol();
var gr = Symbol("extra");
var or = Symbol();
var Ir = Symbol();
var cr = Symbol();
var Cr = Symbol();
var hr = Symbol();
var lr = Symbol();
var Qr = Symbol();
var Er = Symbol();
var ur = Symbol();
var dr = Symbol();
var fr = Symbol();
var pr = Symbol();
var mr = Symbol();
var yr = Symbol();
var wr = Symbol();
var Dr = Symbol();
var br = Symbol();
var Fr = Symbol();
var Sr = Symbol();
var kr = Symbol();
var Rr = Symbol();
var Nr = Symbol();
var Gr = Symbol();
var xr = Symbol();
var Ur = Symbol();
var Mr = Symbol();
var Lr = Symbol();
var Hr = Symbol();
var Jr = Symbol();
var Yr = Symbol();
var vr = Symbol();
var Kr = Symbol();
var Tr = Symbol("namespaceId");
var qr = Symbol("nodeName");
var Or = Symbol();
var Pr = Symbol();
var Wr = Symbol();
var jr = Symbol();
var Xr = Symbol();
var Zr = Symbol();
var Vr = Symbol();
var zr = Symbol();
var _r2 = Symbol("root");
var $r = Symbol();
var An = Symbol();
var en = Symbol();
var tn = Symbol();
var an = Symbol();
var sn = Symbol();
var rn = Symbol();
var nn = Symbol();
var gn = Symbol();
var on = Symbol();
var In = Symbol();
var cn = Symbol("uid");
var Cn = Symbol();
var hn = { config: { id: 0, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xci/") }, connectionSet: { id: 1, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-connection-set/") }, datasets: { id: 2, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-data/") }, form: { id: 3, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-form/") }, localeSet: { id: 4, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-locale-set/") }, pdf: { id: 5, check: (e2) => "http://ns.adobe.com/xdp/pdf/" === e2 }, signature: { id: 6, check: (e2) => "http://www.w3.org/2000/09/xmldsig#" === e2 }, sourceSet: { id: 7, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-source-set/") }, stylesheet: { id: 8, check: (e2) => "http://www.w3.org/1999/XSL/Transform" === e2 }, template: { id: 9, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-template/") }, xdc: { id: 10, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xdc/") }, xdp: { id: 11, check: (e2) => "http://ns.adobe.com/xdp/" === e2 }, xfdf: { id: 12, check: (e2) => "http://ns.adobe.com/xfdf/" === e2 }, xhtml: { id: 13, check: (e2) => "http://www.w3.org/1999/xhtml" === e2 }, xmpmeta: { id: 14, check: (e2) => "http://ns.adobe.com/xmpmeta/" === e2 } };
var Bn = { pt: (e2) => e2, cm: (e2) => e2 / 2.54 * 72, mm: (e2) => e2 / 25.4 * 72, in: (e2) => 72 * e2, px: (e2) => e2 };
var ln = /([+-]?\d+\.?\d*)(.*)/;
function stripQuotes(e2) {
  return e2.startsWith("'") || e2.startsWith('"') ? e2.slice(1, -1) : e2;
}
function getInteger({ data: e2, defaultValue: t2, validate: i2 }) {
  if (!e2)
    return t2;
  e2 = e2.trim();
  const a2 = parseInt(e2, 10);
  return !isNaN(a2) && i2(a2) ? a2 : t2;
}
function getFloat({ data: e2, defaultValue: t2, validate: i2 }) {
  if (!e2)
    return t2;
  e2 = e2.trim();
  const a2 = parseFloat(e2);
  return !isNaN(a2) && i2(a2) ? a2 : t2;
}
function getKeyword({ data: e2, defaultValue: t2, validate: i2 }) {
  return e2 && i2(e2 = e2.trim()) ? e2 : t2;
}
function getStringOption(e2, t2) {
  return getKeyword({ data: e2, defaultValue: t2[0], validate: (e3) => t2.includes(e3) });
}
function getMeasurement(e2, t2 = "0") {
  t2 || (t2 = "0");
  if (!e2)
    return getMeasurement(t2);
  const i2 = e2.trim().match(ln);
  if (!i2)
    return getMeasurement(t2);
  const [, a2, s2] = i2, r2 = parseFloat(a2);
  if (isNaN(r2))
    return getMeasurement(t2);
  if (0 === r2)
    return 0;
  const n2 = Bn[s2];
  return n2 ? n2(r2) : r2;
}
function getRatio(e2) {
  if (!e2)
    return { num: 1, den: 1 };
  const t2 = e2.trim().split(/\s*:\s*/).map((e3) => parseFloat(e3)).filter((e3) => !isNaN(e3));
  1 === t2.length && t2.push(1);
  if (0 === t2.length)
    return { num: 1, den: 1 };
  const [i2, a2] = t2;
  return { num: i2, den: a2 };
}
function getRelevant(e2) {
  return e2 ? e2.trim().split(/\s+/).map((e3) => ({ excluded: "-" === e3[0], viewname: e3.substring(1) })) : [];
}
var HTMLResult = class _HTMLResult {
  static get FAILURE() {
    return shadow(this, "FAILURE", new _HTMLResult(false, null, null, null));
  }
  static get EMPTY() {
    return shadow(this, "EMPTY", new _HTMLResult(true, null, null, null));
  }
  constructor(e2, t2, i2, a2) {
    this.success = e2;
    this.html = t2;
    this.bbox = i2;
    this.breakNode = a2;
  }
  isBreak() {
    return !!this.breakNode;
  }
  static breakNode(e2) {
    return new _HTMLResult(false, null, null, e2);
  }
  static success(e2, t2 = null) {
    return new _HTMLResult(true, e2, t2, null);
  }
};
var FontFinder = class {
  constructor(e2) {
    this.fonts = /* @__PURE__ */ new Map();
    this.cache = /* @__PURE__ */ new Map();
    this.warned = /* @__PURE__ */ new Set();
    this.defaultFont = null;
    this.add(e2);
  }
  add(e2, t2 = null) {
    for (const t3 of e2)
      this.addPdfFont(t3);
    for (const e3 of this.fonts.values())
      e3.regular || (e3.regular = e3.italic || e3.bold || e3.bolditalic);
    if (!t2 || 0 === t2.size)
      return;
    const i2 = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
    for (const e3 of t2)
      this.fonts.set(e3, i2);
  }
  addPdfFont(e2) {
    var _a4, _b2, _c2;
    const t2 = e2.cssFontInfo, i2 = t2.fontFamily;
    let a2 = this.fonts.get(i2);
    if (!a2) {
      a2 = /* @__PURE__ */ Object.create(null);
      this.fonts.set(i2, a2);
      this.defaultFont || (this.defaultFont = a2);
    }
    let s2 = "";
    const r2 = parseFloat(t2.fontWeight);
    0 !== parseFloat(t2.italicAngle) ? s2 = r2 >= 700 ? "bolditalic" : "italic" : r2 >= 700 && (s2 = "bold");
    if (!s2) {
      (e2.name.includes("Bold") || ((_a4 = e2.psName) == null ? void 0 : _a4.includes("Bold"))) && (s2 = "bold");
      (e2.name.includes("Italic") || e2.name.endsWith("It") || ((_b2 = e2.psName) == null ? void 0 : _b2.includes("Italic")) || ((_c2 = e2.psName) == null ? void 0 : _c2.endsWith("It"))) && (s2 += "italic");
    }
    s2 || (s2 = "regular");
    a2[s2] = e2;
  }
  getDefault() {
    return this.defaultFont;
  }
  find(e2, t2 = true) {
    var _a4, _b2;
    let i2 = this.fonts.get(e2) || this.cache.get(e2);
    if (i2)
      return i2;
    const a2 = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
    let s2 = e2.replaceAll(a2, "");
    i2 = this.fonts.get(s2);
    if (i2) {
      this.cache.set(e2, i2);
      return i2;
    }
    s2 = s2.toLowerCase();
    const r2 = [];
    for (const [e3, t3] of this.fonts.entries())
      e3.replaceAll(a2, "").toLowerCase().startsWith(s2) && r2.push(t3);
    if (0 === r2.length)
      for (const [, e3] of this.fonts.entries())
        ((_a4 = e3.regular.name) == null ? void 0 : _a4.replaceAll(a2, "").toLowerCase().startsWith(s2)) && r2.push(e3);
    if (0 === r2.length) {
      s2 = s2.replaceAll(/psmt|mt/gi, "");
      for (const [e3, t3] of this.fonts.entries())
        e3.replaceAll(a2, "").toLowerCase().startsWith(s2) && r2.push(t3);
    }
    if (0 === r2.length)
      for (const e3 of this.fonts.values())
        ((_b2 = e3.regular.name) == null ? void 0 : _b2.replaceAll(a2, "").toLowerCase().startsWith(s2)) && r2.push(e3);
    if (r2.length >= 1) {
      1 !== r2.length && t2 && warn(`XFA - Too many choices to guess the correct font: ${e2}`);
      this.cache.set(e2, r2[0]);
      return r2[0];
    }
    if (t2 && !this.warned.has(e2)) {
      this.warned.add(e2);
      warn(`XFA - Cannot find the font: ${e2}`);
    }
    return null;
  }
};
function selectFont(e2, t2) {
  return "italic" === e2.posture ? "bold" === e2.weight ? t2.bolditalic : t2.italic : "bold" === e2.weight ? t2.bold : t2.regular;
}
var FontInfo = class {
  constructor(e2, t2, i2, a2) {
    this.lineHeight = i2;
    this.paraMargin = t2 || { top: 0, bottom: 0, left: 0, right: 0 };
    if (!e2) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(a2);
      return;
    }
    this.xfaFont = { typeface: e2.typeface, posture: e2.posture, weight: e2.weight, size: e2.size, letterSpacing: e2.letterSpacing };
    const s2 = a2.find(e2.typeface);
    if (s2) {
      this.pdfFont = selectFont(e2, s2);
      this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(a2));
    } else
      [this.pdfFont, this.xfaFont] = this.defaultFont(a2);
  }
  defaultFont(e2) {
    const t2 = e2.find("Helvetica", false) || e2.find("Myriad Pro", false) || e2.find("Arial", false) || e2.getDefault();
    if (t2 == null ? void 0 : t2.regular) {
      const e3 = t2.regular;
      return [e3, { typeface: e3.cssFontInfo.fontFamily, posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
    }
    return [null, { typeface: "Courier", posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
  }
};
var FontSelector = class {
  constructor(e2, t2, i2, a2) {
    this.fontFinder = a2;
    this.stack = [new FontInfo(e2, t2, i2, a2)];
  }
  pushData(e2, t2, i2) {
    const a2 = this.stack.at(-1);
    for (const t3 of ["typeface", "posture", "weight", "size", "letterSpacing"])
      e2[t3] || (e2[t3] = a2.xfaFont[t3]);
    for (const e3 of ["top", "bottom", "left", "right"])
      isNaN(t2[e3]) && (t2[e3] = a2.paraMargin[e3]);
    const s2 = new FontInfo(e2, t2, i2 || a2.lineHeight, this.fontFinder);
    s2.pdfFont || (s2.pdfFont = a2.pdfFont);
    this.stack.push(s2);
  }
  popFont() {
    this.stack.pop();
  }
  topFont() {
    return this.stack.at(-1);
  }
};
var TextMeasure = class {
  constructor(e2, t2, i2, a2) {
    this.glyphs = [];
    this.fontSelector = new FontSelector(e2, t2, i2, a2);
    this.extraHeight = 0;
  }
  pushData(e2, t2, i2) {
    this.fontSelector.pushData(e2, t2, i2);
  }
  popFont(e2) {
    return this.fontSelector.popFont();
  }
  addPara() {
    const e2 = this.fontSelector.topFont();
    this.extraHeight += e2.paraMargin.top + e2.paraMargin.bottom;
  }
  addString(e2) {
    if (!e2)
      return;
    const t2 = this.fontSelector.topFont(), i2 = t2.xfaFont.size;
    if (t2.pdfFont) {
      const a2 = t2.xfaFont.letterSpacing, s2 = t2.pdfFont, r2 = s2.lineHeight || 1.2, n2 = t2.lineHeight || Math.max(1.2, r2) * i2, g2 = r2 - (void 0 === s2.lineGap ? 0.2 : s2.lineGap), o2 = Math.max(1, g2) * i2, c2 = i2 / 1e3, C2 = s2.defaultWidth || s2.charsToGlyphs(" ")[0].width;
      for (const t3 of e2.split(/[\u2029\n]/)) {
        const e3 = s2.encodeString(t3).join(""), i3 = s2.charsToGlyphs(e3);
        for (const e4 of i3) {
          const t4 = e4.width || C2;
          this.glyphs.push([t4 * c2 + a2, n2, o2, e4.unicode, false]);
        }
        this.glyphs.push([0, 0, 0, "\n", true]);
      }
      this.glyphs.pop();
    } else {
      for (const t3 of e2.split(/[\u2029\n]/)) {
        for (const e3 of t3.split(""))
          this.glyphs.push([i2, 1.2 * i2, i2, e3, false]);
        this.glyphs.push([0, 0, 0, "\n", true]);
      }
      this.glyphs.pop();
    }
  }
  compute(e2) {
    let t2 = -1, i2 = 0, a2 = 0, s2 = 0, r2 = 0, n2 = 0, g2 = false, o2 = true;
    for (let c2 = 0, C2 = this.glyphs.length; c2 < C2; c2++) {
      const [C3, h2, l2, Q2, E2] = this.glyphs[c2], u2 = " " === Q2, d2 = o2 ? l2 : h2;
      if (E2) {
        a2 = Math.max(a2, r2);
        r2 = 0;
        s2 += n2;
        n2 = d2;
        t2 = -1;
        i2 = 0;
        o2 = false;
      } else if (u2)
        if (r2 + C3 > e2) {
          a2 = Math.max(a2, r2);
          r2 = 0;
          s2 += n2;
          n2 = d2;
          t2 = -1;
          i2 = 0;
          g2 = true;
          o2 = false;
        } else {
          n2 = Math.max(d2, n2);
          i2 = r2;
          r2 += C3;
          t2 = c2;
        }
      else if (r2 + C3 > e2) {
        s2 += n2;
        n2 = d2;
        if (-1 !== t2) {
          c2 = t2;
          a2 = Math.max(a2, i2);
          r2 = 0;
          t2 = -1;
          i2 = 0;
        } else {
          a2 = Math.max(a2, r2);
          r2 = C3;
        }
        g2 = true;
        o2 = false;
      } else {
        r2 += C3;
        n2 = Math.max(d2, n2);
      }
    }
    a2 = Math.max(a2, r2);
    s2 += n2 + this.extraHeight;
    return { width: 1.02 * a2, height: s2, isBroken: g2 };
  }
};
var Qn = /^[^.[]+/;
var En = /^[^\]]+/;
var un = { dot: 0, dotDot: 1, dotHash: 2, dotBracket: 3, dotParen: 4 };
var dn = /* @__PURE__ */ new Map([["$data", (e2, t2) => e2.datasets ? e2.datasets.data : e2], ["$record", (e2, t2) => (e2.datasets ? e2.datasets.data : e2)[pr]()[0]], ["$template", (e2, t2) => e2.template], ["$connectionSet", (e2, t2) => e2.connectionSet], ["$form", (e2, t2) => e2.form], ["$layout", (e2, t2) => e2.layout], ["$host", (e2, t2) => e2.host], ["$dataWindow", (e2, t2) => e2.dataWindow], ["$event", (e2, t2) => e2.event], ["!", (e2, t2) => e2.datasets], ["$xfa", (e2, t2) => e2], ["xfa", (e2, t2) => e2], ["$", (e2, t2) => t2]]);
var fn = /* @__PURE__ */ new WeakMap();
function parseExpression(e2, t2, i2 = true) {
  let a2 = e2.match(Qn);
  if (!a2)
    return null;
  let [s2] = a2;
  const r2 = [{ name: s2, cacheName: "." + s2, index: 0, js: null, formCalc: null, operator: un.dot }];
  let n2 = s2.length;
  for (; n2 < e2.length; ) {
    const o2 = n2;
    if ("[" === e2.charAt(n2++)) {
      a2 = e2.slice(n2).match(En);
      if (!a2) {
        warn("XFA - Invalid index in SOM expression");
        return null;
      }
      r2.at(-1).index = "*" === (g2 = (g2 = a2[0]).trim()) ? 1 / 0 : parseInt(g2, 10) || 0;
      n2 += a2[0].length + 1;
      continue;
    }
    let c2;
    switch (e2.charAt(n2)) {
      case ".":
        if (!t2)
          return null;
        n2++;
        c2 = un.dotDot;
        break;
      case "#":
        n2++;
        c2 = un.dotHash;
        break;
      case "[":
        if (i2) {
          warn("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");
          return null;
        }
        c2 = un.dotBracket;
        break;
      case "(":
        if (i2) {
          warn("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");
          return null;
        }
        c2 = un.dotParen;
        break;
      default:
        c2 = un.dot;
    }
    a2 = e2.slice(n2).match(Qn);
    if (!a2)
      break;
    [s2] = a2;
    n2 += s2.length;
    r2.push({ name: s2, cacheName: e2.slice(o2, n2), operator: c2, index: 0, js: null, formCalc: null });
  }
  var g2;
  return r2;
}
function searchNode(e2, t2, i2, a2 = true, s2 = true) {
  const r2 = parseExpression(i2, a2);
  if (!r2)
    return null;
  const n2 = dn.get(r2[0].name);
  let g2, o2 = 0;
  if (n2) {
    g2 = true;
    e2 = [n2(e2, t2)];
    o2 = 1;
  } else {
    g2 = null === t2;
    e2 = [t2 || e2];
  }
  for (let i3 = r2.length; o2 < i3; o2++) {
    const { name: i4, cacheName: a3, operator: n3, index: c2 } = r2[o2], C2 = [];
    for (const t3 of e2) {
      if (!t3.isXFAObject)
        continue;
      let e3, r3;
      if (s2) {
        r3 = fn.get(t3);
        if (!r3) {
          r3 = /* @__PURE__ */ new Map();
          fn.set(t3, r3);
        }
        e3 = r3.get(a3);
      }
      if (!e3) {
        switch (n3) {
          case un.dot:
            e3 = t3[Qr](i4, false);
            break;
          case un.dotDot:
            e3 = t3[Qr](i4, true);
            break;
          case un.dotHash:
            e3 = t3[lr](i4);
            e3 = e3.isXFAObjectArray ? e3.children : [e3];
        }
        s2 && r3.set(a3, e3);
      }
      e3.length > 0 && C2.push(e3);
    }
    if (0 !== C2.length || g2 || 0 !== o2)
      e2 = isFinite(c2) ? C2.filter((e3) => c2 < e3.length).map((e3) => e3[c2]) : C2.flat();
    else {
      const i5 = t2[Dr]();
      if (!(t2 = i5))
        return null;
      o2 = -1;
      e2 = [t2];
    }
  }
  return 0 === e2.length ? null : e2;
}
function createDataNode(e2, t2, i2) {
  const a2 = parseExpression(i2);
  if (!a2)
    return null;
  if (a2.some((e3) => e3.operator === un.dotDot))
    return null;
  const s2 = dn.get(a2[0].name);
  let r2 = 0;
  if (s2) {
    e2 = s2(e2, t2);
    r2 = 1;
  } else
    e2 = t2 || e2;
  for (let t3 = a2.length; r2 < t3; r2++) {
    const { name: t4, operator: i3, index: s3 } = a2[r2];
    if (!isFinite(s3)) {
      a2[r2].index = 0;
      return e2.createNodes(a2.slice(r2));
    }
    let n2;
    switch (i3) {
      case un.dot:
        n2 = e2[Qr](t4, false);
        break;
      case un.dotDot:
        n2 = e2[Qr](t4, true);
        break;
      case un.dotHash:
        n2 = e2[lr](t4);
        n2 = n2.isXFAObjectArray ? n2.children : [n2];
    }
    if (0 === n2.length)
      return e2.createNodes(a2.slice(r2));
    if (!(s3 < n2.length)) {
      a2[r2].index = s3 - n2.length;
      return e2.createNodes(a2.slice(r2));
    }
    {
      const t5 = n2[s3];
      if (!t5.isXFAObject) {
        warn("XFA - Cannot create a node.");
        return null;
      }
      e2 = t5;
    }
  }
  return null;
}
var pn = Symbol();
var mn = Symbol();
var yn = Symbol();
var wn = Symbol("_children");
var Dn = Symbol();
var bn = Symbol();
var Fn = Symbol();
var Sn = Symbol();
var kn = Symbol();
var Rn = Symbol();
var Nn = Symbol();
var Gn = Symbol();
var xn = Symbol();
var Un = Symbol("parent");
var Mn = Symbol();
var Ln = Symbol();
var Hn = Symbol();
var Jn = 0;
var Yn = hn.datasets.id;
var XFAObject = class _XFAObject {
  constructor(e2, t2, i2 = false) {
    this[Tr] = e2;
    this[qr] = t2;
    this[Nn] = i2;
    this[Un] = null;
    this[wn] = [];
    this[cn] = `${t2}${Jn++}`;
    this[Fr] = null;
  }
  get isXFAObject() {
    return true;
  }
  get isXFAObjectArray() {
    return false;
  }
  createNodes(e2) {
    let t2 = this, i2 = null;
    for (const { name: a2, index: s2 } of e2) {
      for (let e3 = 0, r2 = isFinite(s2) ? s2 : 0; e3 <= r2; e3++) {
        const e4 = t2[Tr] === Yn ? -1 : t2[Tr];
        i2 = new XmlObject(e4, a2);
        t2[_s2](i2);
      }
      t2 = i2;
    }
    return i2;
  }
  [Pr](e2) {
    if (!this[Nn] || !this[Wr](e2))
      return false;
    const t2 = e2[qr], i2 = this[t2];
    if (!(i2 instanceof XFAObjectArray)) {
      null !== i2 && this[zr](i2);
      this[t2] = e2;
      this[_s2](e2);
      return true;
    }
    if (i2.push(e2)) {
      this[_s2](e2);
      return true;
    }
    let a2 = "";
    this.id ? a2 = ` (id: ${this.id})` : this.name && (a2 = ` (name: ${this.name} ${this.h.value})`);
    warn(`XFA - node "${this[qr]}"${a2} has already enough "${t2}"!`);
    return false;
  }
  [Wr](e2) {
    return this.hasOwnProperty(e2[qr]) && e2[Tr] === this[Tr];
  }
  [Lr]() {
    return false;
  }
  [Vs]() {
    return false;
  }
  [Gr]() {
    return false;
  }
  [xr]() {
    return false;
  }
  [Zr]() {
    this.para && this[br]()[gr].paraStack.pop();
  }
  [Vr]() {
    this[br]()[gr].paraStack.push(this.para);
  }
  [en](e2) {
    this.id && this[Tr] === hn.template.id && e2.set(this.id, this);
  }
  [br]() {
    return this[Fr].template;
  }
  [Hr]() {
    return false;
  }
  [Jr]() {
    return false;
  }
  [_s2](e2) {
    e2[Un] = this;
    this[wn].push(e2);
    !e2[Fr] && this[Fr] && (e2[Fr] = this[Fr]);
  }
  [zr](e2) {
    const t2 = this[wn].indexOf(e2);
    this[wn].splice(t2, 1);
  }
  [Sr]() {
    return this.hasOwnProperty("value");
  }
  [an](e2) {
  }
  [jr](e2) {
  }
  [or]() {
  }
  [Ar](e2) {
    delete this[Nn];
    if (this[tr]) {
      e2.clean(this[tr]);
      delete this[tr];
    }
  }
  [Rr](e2) {
    return this[wn].indexOf(e2);
  }
  [Nr](e2, t2) {
    t2[Un] = this;
    this[wn].splice(e2, 0, t2);
    !t2[Fr] && this[Fr] && (t2[Fr] = this[Fr]);
  }
  [Yr]() {
    return !this.name;
  }
  [Kr]() {
    return "";
  }
  [rn]() {
    return 0 === this[wn].length ? this[sr] : this[wn].map((e2) => e2[rn]()).join("");
  }
  get [yn]() {
    const e2 = Object.getPrototypeOf(this);
    if (!e2._attributes) {
      const t2 = e2._attributes = /* @__PURE__ */ new Set();
      for (const e3 of Object.getOwnPropertyNames(this)) {
        if (null === this[e3] || this[e3] instanceof _XFAObject || this[e3] instanceof XFAObjectArray)
          break;
        t2.add(e3);
      }
    }
    return shadow(this, yn, e2._attributes);
  }
  [Mr](e2) {
    let t2 = this;
    for (; t2; ) {
      if (t2 === e2)
        return true;
      t2 = t2[Dr]();
    }
    return false;
  }
  [Dr]() {
    return this[Un];
  }
  [wr]() {
    return this[Dr]();
  }
  [pr](e2 = null) {
    return e2 ? this[e2] : this[wn];
  }
  [nr]() {
    const e2 = /* @__PURE__ */ Object.create(null);
    this[sr] && (e2.$content = this[sr]);
    for (const t2 of Object.getOwnPropertyNames(this)) {
      const i2 = this[t2];
      null !== i2 && (i2 instanceof _XFAObject ? e2[t2] = i2[nr]() : i2 instanceof XFAObjectArray ? i2.isEmpty() || (e2[t2] = i2.dump()) : e2[t2] = i2);
    }
    return e2;
  }
  [In]() {
    return null;
  }
  [gn]() {
    return HTMLResult.EMPTY;
  }
  *[mr]() {
    for (const e2 of this[pr]())
      yield e2;
  }
  *[Sn](e2, t2) {
    for (const i2 of this[mr]())
      if (!e2 || t2 === e2.has(i2[qr])) {
        const e3 = this[hr](), t3 = i2[gn](e3);
        t3.success || (this[gr].failingNode = i2);
        yield t3;
      }
  }
  [Ir]() {
    return null;
  }
  [zs](e2, t2) {
    this[gr].children.push(e2);
  }
  [hr]() {
  }
  [$s]({ filter: e2 = null, include: t2 = true }) {
    if (this[gr].generator) {
      const e3 = this[hr](), t3 = this[gr].failingNode[gn](e3);
      if (!t3.success)
        return t3;
      t3.html && this[zs](t3.html, t3.bbox);
      delete this[gr].failingNode;
    } else
      this[gr].generator = this[Sn](e2, t2);
    for (; ; ) {
      const e3 = this[gr].generator.next();
      if (e3.done)
        break;
      const t3 = e3.value;
      if (!t3.success)
        return t3;
      t3.html && this[zs](t3.html, t3.bbox);
    }
    this[gr].generator = null;
    return HTMLResult.EMPTY;
  }
  [tn](e2) {
    this[Ln] = new Set(Object.keys(e2));
  }
  [Rn](e2) {
    const t2 = this[yn], i2 = this[Ln];
    return [...e2].filter((e3) => t2.has(e3) && !i2.has(e3));
  }
  [$r](e2, t2 = /* @__PURE__ */ new Set()) {
    for (const i2 of this[wn])
      i2[Mn](e2, t2);
  }
  [Mn](e2, t2) {
    const i2 = this[kn](e2, t2);
    i2 ? this[pn](i2, e2, t2) : this[$r](e2, t2);
  }
  [kn](e2, t2) {
    const { use: i2, usehref: a2 } = this;
    if (!i2 && !a2)
      return null;
    let s2 = null, r2 = null, n2 = null, g2 = i2;
    if (a2) {
      g2 = a2;
      a2.startsWith("#som(") && a2.endsWith(")") ? r2 = a2.slice(5, -1) : a2.startsWith(".#som(") && a2.endsWith(")") ? r2 = a2.slice(6, -1) : a2.startsWith("#") ? n2 = a2.slice(1) : a2.startsWith(".#") && (n2 = a2.slice(2));
    } else
      i2.startsWith("#") ? n2 = i2.slice(1) : r2 = i2;
    this.use = this.usehref = "";
    if (n2)
      s2 = e2.get(n2);
    else {
      s2 = searchNode(e2.get(_r2), this, r2, true, false);
      s2 && (s2 = s2[0]);
    }
    if (!s2) {
      warn(`XFA - Invalid prototype reference: ${g2}.`);
      return null;
    }
    if (s2[qr] !== this[qr]) {
      warn(`XFA - Incompatible prototype: ${s2[qr]} !== ${this[qr]}.`);
      return null;
    }
    if (t2.has(s2)) {
      warn("XFA - Cycle detected in prototypes use.");
      return null;
    }
    t2.add(s2);
    const o2 = s2[kn](e2, t2);
    o2 && s2[pn](o2, e2, t2);
    s2[$r](e2, t2);
    t2.delete(s2);
    return s2;
  }
  [pn](e2, t2, i2) {
    if (i2.has(e2)) {
      warn("XFA - Cycle detected in prototypes use.");
      return;
    }
    !this[sr] && e2[sr] && (this[sr] = e2[sr]);
    new Set(i2).add(e2);
    for (const t3 of this[Rn](e2[Ln])) {
      this[t3] = e2[t3];
      this[Ln] && this[Ln].add(t3);
    }
    for (const a2 of Object.getOwnPropertyNames(this)) {
      if (this[yn].has(a2))
        continue;
      const s2 = this[a2], r2 = e2[a2];
      if (s2 instanceof XFAObjectArray) {
        for (const e3 of s2[wn])
          e3[Mn](t2, i2);
        for (let a3 = s2[wn].length, n2 = r2[wn].length; a3 < n2; a3++) {
          const r3 = e2[wn][a3][ir]();
          if (!s2.push(r3))
            break;
          r3[Un] = this;
          this[wn].push(r3);
          r3[Mn](t2, i2);
        }
      } else if (null === s2) {
        if (null !== r2) {
          const e3 = r2[ir]();
          e3[Un] = this;
          this[a2] = e3;
          this[wn].push(e3);
          e3[Mn](t2, i2);
        }
      } else {
        s2[$r](t2, i2);
        r2 && s2[pn](r2, t2, i2);
      }
    }
  }
  static [Dn](e2) {
    return Array.isArray(e2) ? e2.map((e3) => _XFAObject[Dn](e3)) : "object" == typeof e2 && null !== e2 ? Object.assign({}, e2) : e2;
  }
  [ir]() {
    const e2 = Object.create(Object.getPrototypeOf(this));
    for (const t2 of Object.getOwnPropertySymbols(this))
      try {
        e2[t2] = this[t2];
      } catch {
        shadow(e2, t2, this[t2]);
      }
    e2[cn] = `${e2[qr]}${Jn++}`;
    e2[wn] = [];
    for (const t2 of Object.getOwnPropertyNames(this)) {
      if (this[yn].has(t2)) {
        e2[t2] = _XFAObject[Dn](this[t2]);
        continue;
      }
      const i2 = this[t2];
      e2[t2] = i2 instanceof XFAObjectArray ? new XFAObjectArray(i2[Gn]) : null;
    }
    for (const t2 of this[wn]) {
      const i2 = t2[qr], a2 = t2[ir]();
      e2[wn].push(a2);
      a2[Un] = e2;
      null === e2[i2] ? e2[i2] = a2 : e2[i2][wn].push(a2);
    }
    return e2;
  }
  [pr](e2 = null) {
    return e2 ? this[wn].filter((t2) => t2[qr] === e2) : this[wn];
  }
  [lr](e2) {
    return this[e2];
  }
  [Qr](e2, t2, i2 = true) {
    return Array.from(this[Er](e2, t2, i2));
  }
  *[Er](e2, t2, i2 = true) {
    if ("parent" !== e2) {
      for (const i3 of this[wn]) {
        i3[qr] === e2 && (yield i3);
        i3.name === e2 && (yield i3);
        (t2 || i3[Yr]()) && (yield* i3[Er](e2, t2, false));
      }
      i2 && this[yn].has(e2) && (yield new XFAAttribute(this, e2, this[e2]));
    } else
      yield this[Un];
  }
};
var XFAObjectArray = class _XFAObjectArray {
  constructor(e2 = 1 / 0) {
    this[Gn] = e2;
    this[wn] = [];
  }
  get isXFAObject() {
    return false;
  }
  get isXFAObjectArray() {
    return true;
  }
  push(e2) {
    if (this[wn].length <= this[Gn]) {
      this[wn].push(e2);
      return true;
    }
    warn(`XFA - node "${e2[qr]}" accepts no more than ${this[Gn]} children`);
    return false;
  }
  isEmpty() {
    return 0 === this[wn].length;
  }
  dump() {
    return 1 === this[wn].length ? this[wn][0][nr]() : this[wn].map((e2) => e2[nr]());
  }
  [ir]() {
    const e2 = new _XFAObjectArray(this[Gn]);
    e2[wn] = this[wn].map((e3) => e3[ir]());
    return e2;
  }
  get children() {
    return this[wn];
  }
  clear() {
    this[wn].length = 0;
  }
};
var XFAAttribute = class {
  constructor(e2, t2, i2) {
    this[Un] = e2;
    this[qr] = t2;
    this[sr] = i2;
    this[ar] = false;
    this[cn] = "attribute" + Jn++;
  }
  [Dr]() {
    return this[Un];
  }
  [Ur]() {
    return true;
  }
  [ur]() {
    return this[sr].trim();
  }
  [an](e2) {
    e2 = e2.value || "";
    this[sr] = e2.toString();
  }
  [rn]() {
    return this[sr];
  }
  [Mr](e2) {
    return this[Un] === e2 || this[Un][Mr](e2);
  }
};
var XmlObject = class _XmlObject extends XFAObject {
  constructor(e2, t2, i2 = {}) {
    super(e2, t2);
    this[sr] = "";
    this[bn] = null;
    if ("#text" !== t2) {
      const e3 = /* @__PURE__ */ new Map();
      this[mn] = e3;
      for (const [t3, a2] of Object.entries(i2))
        e3.set(t3, new XFAAttribute(this, t3, a2));
      if (i2.hasOwnProperty(Or)) {
        const e4 = i2[Or].xfa.dataNode;
        void 0 !== e4 && ("dataGroup" === e4 ? this[bn] = false : "dataValue" === e4 && (this[bn] = true));
      }
    }
    this[ar] = false;
  }
  [on](e2) {
    const t2 = this[qr];
    if ("#text" === t2) {
      e2.push(encodeToXmlString(this[sr]));
      return;
    }
    const i2 = utf8StringToString(t2), a2 = this[Tr] === Yn ? "xfa:" : "";
    e2.push(`<${a2}${i2}`);
    for (const [t3, i3] of this[mn].entries()) {
      const a3 = utf8StringToString(t3);
      e2.push(` ${a3}="${encodeToXmlString(i3[sr])}"`);
    }
    null !== this[bn] && (this[bn] ? e2.push(' xfa:dataNode="dataValue"') : e2.push(' xfa:dataNode="dataGroup"'));
    if (this[sr] || 0 !== this[wn].length) {
      e2.push(">");
      if (this[sr])
        "string" == typeof this[sr] ? e2.push(encodeToXmlString(this[sr])) : this[sr][on](e2);
      else
        for (const t3 of this[wn])
          t3[on](e2);
      e2.push(`</${a2}${i2}>`);
    } else
      e2.push("/>");
  }
  [Pr](e2) {
    if (this[sr]) {
      const e3 = new _XmlObject(this[Tr], "#text");
      this[_s2](e3);
      e3[sr] = this[sr];
      this[sr] = "";
    }
    this[_s2](e2);
    return true;
  }
  [jr](e2) {
    this[sr] += e2;
  }
  [or]() {
    if (this[sr] && this[wn].length > 0) {
      const e2 = new _XmlObject(this[Tr], "#text");
      this[_s2](e2);
      e2[sr] = this[sr];
      delete this[sr];
    }
  }
  [gn]() {
    return "#text" === this[qr] ? HTMLResult.success({ name: "#text", value: this[sr] }) : HTMLResult.EMPTY;
  }
  [pr](e2 = null) {
    return e2 ? this[wn].filter((t2) => t2[qr] === e2) : this[wn];
  }
  [Cr]() {
    return this[mn];
  }
  [lr](e2) {
    const t2 = this[mn].get(e2);
    return void 0 !== t2 ? t2 : this[pr](e2);
  }
  *[Er](e2, t2) {
    const i2 = this[mn].get(e2);
    i2 && (yield i2);
    for (const i3 of this[wn]) {
      i3[qr] === e2 && (yield i3);
      t2 && (yield* i3[Er](e2, t2));
    }
  }
  *[cr](e2, t2) {
    const i2 = this[mn].get(e2);
    !i2 || t2 && i2[ar] || (yield i2);
    for (const i3 of this[wn])
      yield* i3[cr](e2, t2);
  }
  *[fr](e2, t2, i2) {
    for (const a2 of this[wn]) {
      a2[qr] !== e2 || i2 && a2[ar] || (yield a2);
      t2 && (yield* a2[fr](e2, t2, i2));
    }
  }
  [Ur]() {
    return null === this[bn] ? 0 === this[wn].length || this[wn][0][Tr] === hn.xhtml.id : this[bn];
  }
  [ur]() {
    return null === this[bn] ? 0 === this[wn].length ? this[sr].trim() : this[wn][0][Tr] === hn.xhtml.id ? this[wn][0][rn]().trim() : null : this[sr].trim();
  }
  [an](e2) {
    e2 = e2.value || "";
    this[sr] = e2.toString();
  }
  [nr](e2 = false) {
    const t2 = /* @__PURE__ */ Object.create(null);
    e2 && (t2.$ns = this[Tr]);
    this[sr] && (t2.$content = this[sr]);
    t2.$name = this[qr];
    t2.children = [];
    for (const i2 of this[wn])
      t2.children.push(i2[nr](e2));
    t2.attributes = /* @__PURE__ */ Object.create(null);
    for (const [e3, i2] of this[mn])
      t2.attributes[e3] = i2[sr];
    return t2;
  }
};
var ContentObject = class extends XFAObject {
  constructor(e2, t2) {
    super(e2, t2);
    this[sr] = "";
  }
  [jr](e2) {
    this[sr] += e2;
  }
  [or]() {
  }
};
var OptionObject = class extends ContentObject {
  constructor(e2, t2, i2) {
    super(e2, t2);
    this[xn] = i2;
  }
  [or]() {
    this[sr] = getKeyword({ data: this[sr], defaultValue: this[xn][0], validate: (e2) => this[xn].includes(e2) });
  }
  [Ar](e2) {
    super[Ar](e2);
    delete this[xn];
  }
};
var StringObject = class extends ContentObject {
  [or]() {
    this[sr] = this[sr].trim();
  }
};
var IntegerObject = class extends ContentObject {
  constructor(e2, t2, i2, a2) {
    super(e2, t2);
    this[Fn] = i2;
    this[Hn] = a2;
  }
  [or]() {
    this[sr] = getInteger({ data: this[sr], defaultValue: this[Fn], validate: this[Hn] });
  }
  [Ar](e2) {
    super[Ar](e2);
    delete this[Fn];
    delete this[Hn];
  }
};
var Option01 = class extends IntegerObject {
  constructor(e2, t2) {
    super(e2, t2, 0, (e3) => 1 === e3);
  }
};
var Option10 = class extends IntegerObject {
  constructor(e2, t2) {
    super(e2, t2, 1, (e3) => 0 === e3);
  }
};
function measureToString(e2) {
  return "string" == typeof e2 ? "0px" : Number.isInteger(e2) ? `${e2}px` : `${e2.toFixed(2)}px`;
}
var vn = { anchorType(e2, t2) {
  const i2 = e2[wr]();
  if (i2 && (!i2.layout || "position" === i2.layout)) {
    "transform" in t2 || (t2.transform = "");
    switch (e2.anchorType) {
      case "bottomCenter":
        t2.transform += "translate(-50%, -100%)";
        break;
      case "bottomLeft":
        t2.transform += "translate(0,-100%)";
        break;
      case "bottomRight":
        t2.transform += "translate(-100%,-100%)";
        break;
      case "middleCenter":
        t2.transform += "translate(-50%,-50%)";
        break;
      case "middleLeft":
        t2.transform += "translate(0,-50%)";
        break;
      case "middleRight":
        t2.transform += "translate(-100%,-50%)";
        break;
      case "topCenter":
        t2.transform += "translate(-50%,0)";
        break;
      case "topRight":
        t2.transform += "translate(-100%,0)";
    }
  }
}, dimensions(e2, t2) {
  var _a4;
  const i2 = e2[wr]();
  let a2 = e2.w;
  const s2 = e2.h;
  if ((_a4 = i2.layout) == null ? void 0 : _a4.includes("row")) {
    const t3 = i2[gr], s3 = e2.colSpan;
    let r2;
    if (-1 === s3) {
      r2 = t3.columnWidths.slice(t3.currentColumn).reduce((e3, t4) => e3 + t4, 0);
      t3.currentColumn = 0;
    } else {
      r2 = t3.columnWidths.slice(t3.currentColumn, t3.currentColumn + s3).reduce((e3, t4) => e3 + t4, 0);
      t3.currentColumn = (t3.currentColumn + e2.colSpan) % t3.columnWidths.length;
    }
    isNaN(r2) || (a2 = e2.w = r2);
  }
  t2.width = "" !== a2 ? measureToString(a2) : "auto";
  t2.height = "" !== s2 ? measureToString(s2) : "auto";
}, position(e2, t2) {
  const i2 = e2[wr]();
  if (!(i2 == null ? void 0 : i2.layout) || "position" === i2.layout) {
    t2.position = "absolute";
    t2.left = measureToString(e2.x);
    t2.top = measureToString(e2.y);
  }
}, rotate(e2, t2) {
  if (e2.rotate) {
    "transform" in t2 || (t2.transform = "");
    t2.transform += `rotate(-${e2.rotate}deg)`;
    t2.transformOrigin = "top left";
  }
}, presence(e2, t2) {
  switch (e2.presence) {
    case "invisible":
      t2.visibility = "hidden";
      break;
    case "hidden":
    case "inactive":
      t2.display = "none";
  }
}, hAlign(e2, t2) {
  if ("para" === e2[qr])
    switch (e2.hAlign) {
      case "justifyAll":
        t2.textAlign = "justify-all";
        break;
      case "radix":
        t2.textAlign = "left";
        break;
      default:
        t2.textAlign = e2.hAlign;
    }
  else
    switch (e2.hAlign) {
      case "left":
        t2.alignSelf = "start";
        break;
      case "center":
        t2.alignSelf = "center";
        break;
      case "right":
        t2.alignSelf = "end";
    }
}, margin(e2, t2) {
  e2.margin && (t2.margin = e2.margin[In]().margin);
} };
function setMinMaxDimensions(e2, t2) {
  if ("position" === e2[wr]().layout) {
    e2.minW > 0 && (t2.minWidth = measureToString(e2.minW));
    e2.maxW > 0 && (t2.maxWidth = measureToString(e2.maxW));
    e2.minH > 0 && (t2.minHeight = measureToString(e2.minH));
    e2.maxH > 0 && (t2.maxHeight = measureToString(e2.maxH));
  }
}
function layoutText(e2, t2, i2, a2, s2, r2) {
  const n2 = new TextMeasure(t2, i2, a2, s2);
  "string" == typeof e2 ? n2.addString(e2) : e2[Xr](n2);
  return n2.compute(r2);
}
function layoutNode(e2, t2) {
  let i2 = null, a2 = null, s2 = false;
  if ((!e2.w || !e2.h) && e2.value) {
    let r2 = 0, n2 = 0;
    if (e2.margin) {
      r2 = e2.margin.leftInset + e2.margin.rightInset;
      n2 = e2.margin.topInset + e2.margin.bottomInset;
    }
    let g2 = null, o2 = null;
    if (e2.para) {
      o2 = /* @__PURE__ */ Object.create(null);
      g2 = "" === e2.para.lineHeight ? null : e2.para.lineHeight;
      o2.top = "" === e2.para.spaceAbove ? 0 : e2.para.spaceAbove;
      o2.bottom = "" === e2.para.spaceBelow ? 0 : e2.para.spaceBelow;
      o2.left = "" === e2.para.marginLeft ? 0 : e2.para.marginLeft;
      o2.right = "" === e2.para.marginRight ? 0 : e2.para.marginRight;
    }
    let c2 = e2.font;
    if (!c2) {
      const t3 = e2[br]();
      let i3 = e2[Dr]();
      for (; i3 && i3 !== t3; ) {
        if (i3.font) {
          c2 = i3.font;
          break;
        }
        i3 = i3[Dr]();
      }
    }
    const C2 = (e2.w || t2.width) - r2, h2 = e2[Fr].fontFinder;
    if (e2.value.exData && e2.value.exData[sr] && "text/html" === e2.value.exData.contentType) {
      const t3 = layoutText(e2.value.exData[sr], c2, o2, g2, h2, C2);
      a2 = t3.width;
      i2 = t3.height;
      s2 = t3.isBroken;
    } else {
      const t3 = e2.value[rn]();
      if (t3) {
        const e3 = layoutText(t3, c2, o2, g2, h2, C2);
        a2 = e3.width;
        i2 = e3.height;
        s2 = e3.isBroken;
      }
    }
    null === a2 || e2.w || (a2 += r2);
    null === i2 || e2.h || (i2 += n2);
  }
  return { w: a2, h: i2, isBroken: s2 };
}
function computeBbox(e2, t2, i2) {
  let a2;
  if ("" !== e2.w && "" !== e2.h)
    a2 = [e2.x, e2.y, e2.w, e2.h];
  else {
    if (!i2)
      return null;
    let s2 = e2.w;
    if ("" === s2) {
      if (0 === e2.maxW) {
        const t3 = e2[wr]();
        s2 = "position" === t3.layout && "" !== t3.w ? 0 : e2.minW;
      } else
        s2 = Math.min(e2.maxW, i2.width);
      t2.attributes.style.width = measureToString(s2);
    }
    let r2 = e2.h;
    if ("" === r2) {
      if (0 === e2.maxH) {
        const t3 = e2[wr]();
        r2 = "position" === t3.layout && "" !== t3.h ? 0 : e2.minH;
      } else
        r2 = Math.min(e2.maxH, i2.height);
      t2.attributes.style.height = measureToString(r2);
    }
    a2 = [e2.x, e2.y, s2, r2];
  }
  return a2;
}
function fixDimensions(e2) {
  var _a4;
  const t2 = e2[wr]();
  if ((_a4 = t2.layout) == null ? void 0 : _a4.includes("row")) {
    const i2 = t2[gr], a2 = e2.colSpan;
    let s2;
    s2 = -1 === a2 ? i2.columnWidths.slice(i2.currentColumn).reduce((e3, t3) => e3 + t3, 0) : i2.columnWidths.slice(i2.currentColumn, i2.currentColumn + a2).reduce((e3, t3) => e3 + t3, 0);
    isNaN(s2) || (e2.w = s2);
  }
  t2.layout && "position" !== t2.layout && (e2.x = e2.y = 0);
  "table" === e2.layout && "" === e2.w && Array.isArray(e2.columnWidths) && (e2.w = e2.columnWidths.reduce((e3, t3) => e3 + t3, 0));
}
function layoutClass(e2) {
  switch (e2.layout) {
    case "position":
    default:
      return "xfaPosition";
    case "lr-tb":
      return "xfaLrTb";
    case "rl-row":
      return "xfaRlRow";
    case "rl-tb":
      return "xfaRlTb";
    case "row":
      return "xfaRow";
    case "table":
      return "xfaTable";
    case "tb":
      return "xfaTb";
  }
}
function toStyle(e2, ...t2) {
  const i2 = /* @__PURE__ */ Object.create(null);
  for (const a2 of t2) {
    const t3 = e2[a2];
    if (null !== t3) {
      if (vn.hasOwnProperty(a2))
        vn[a2](e2, i2);
      else if (t3 instanceof XFAObject) {
        const e3 = t3[In]();
        e3 ? Object.assign(i2, e3) : warn(`(DEBUG) - XFA - style for ${a2} not implemented yet`);
      }
    }
  }
  return i2;
}
function createWrapper(e2, t2) {
  const { attributes: i2 } = t2, { style: a2 } = i2, s2 = { name: "div", attributes: { class: ["xfaWrapper"], style: /* @__PURE__ */ Object.create(null) }, children: [] };
  i2.class.push("xfaWrapped");
  if (e2.border) {
    const { widths: i3, insets: r2 } = e2.border[gr];
    let n2, g2, o2 = r2[0], c2 = r2[3];
    const C2 = r2[0] + r2[2], h2 = r2[1] + r2[3];
    switch (e2.border.hand) {
      case "even":
        o2 -= i3[0] / 2;
        c2 -= i3[3] / 2;
        n2 = `calc(100% + ${(i3[1] + i3[3]) / 2 - h2}px)`;
        g2 = `calc(100% + ${(i3[0] + i3[2]) / 2 - C2}px)`;
        break;
      case "left":
        o2 -= i3[0];
        c2 -= i3[3];
        n2 = `calc(100% + ${i3[1] + i3[3] - h2}px)`;
        g2 = `calc(100% + ${i3[0] + i3[2] - C2}px)`;
        break;
      case "right":
        n2 = h2 ? `calc(100% - ${h2}px)` : "100%";
        g2 = C2 ? `calc(100% - ${C2}px)` : "100%";
    }
    const l2 = ["xfaBorder"];
    isPrintOnly(e2.border) && l2.push("xfaPrintOnly");
    const Q2 = { name: "div", attributes: { class: l2, style: { top: `${o2}px`, left: `${c2}px`, width: n2, height: g2 } }, children: [] };
    for (const e3 of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"])
      if (void 0 !== a2[e3]) {
        Q2.attributes.style[e3] = a2[e3];
        delete a2[e3];
      }
    s2.children.push(Q2, t2);
  } else
    s2.children.push(t2);
  for (const e3 of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"])
    if (void 0 !== a2[e3]) {
      s2.attributes.style[e3] = a2[e3];
      delete a2[e3];
    }
  s2.attributes.style.position = "absolute" === a2.position ? "absolute" : "relative";
  delete a2.position;
  if (a2.alignSelf) {
    s2.attributes.style.alignSelf = a2.alignSelf;
    delete a2.alignSelf;
  }
  return s2;
}
function fixTextIndent(e2) {
  const t2 = getMeasurement(e2.textIndent, "0px");
  if (t2 >= 0)
    return;
  const i2 = "padding" + ("left" === ("right" === e2.textAlign ? "right" : "left") ? "Left" : "Right"), a2 = getMeasurement(e2[i2], "0px");
  e2[i2] = a2 - t2 + "px";
}
function setAccess(e2, t2) {
  switch (e2.access) {
    case "nonInteractive":
      t2.push("xfaNonInteractive");
      break;
    case "readOnly":
      t2.push("xfaReadOnly");
      break;
    case "protected":
      t2.push("xfaDisabled");
  }
}
function isPrintOnly(e2) {
  return e2.relevant.length > 0 && !e2.relevant[0].excluded && "print" === e2.relevant[0].viewname;
}
function getCurrentPara(e2) {
  const t2 = e2[br]()[gr].paraStack;
  return t2.length ? t2.at(-1) : null;
}
function setPara(e2, t2, i2) {
  var _a4;
  if ((_a4 = i2.attributes.class) == null ? void 0 : _a4.includes("xfaRich")) {
    if (t2) {
      "" === e2.h && (t2.height = "auto");
      "" === e2.w && (t2.width = "auto");
    }
    const a2 = getCurrentPara(e2);
    if (a2) {
      const e3 = i2.attributes.style;
      e3.display = "flex";
      e3.flexDirection = "column";
      switch (a2.vAlign) {
        case "top":
          e3.justifyContent = "start";
          break;
        case "bottom":
          e3.justifyContent = "end";
          break;
        case "middle":
          e3.justifyContent = "center";
      }
      const t3 = a2[In]();
      for (const [i3, a3] of Object.entries(t3))
        i3 in e3 || (e3[i3] = a3);
    }
  }
}
function setFontFamily(e2, t2, i2, a2) {
  if (!i2) {
    delete a2.fontFamily;
    return;
  }
  const s2 = stripQuotes(e2.typeface);
  a2.fontFamily = `"${s2}"`;
  const r2 = i2.find(s2);
  if (r2) {
    const { fontFamily: i3 } = r2.regular.cssFontInfo;
    i3 !== s2 && (a2.fontFamily = `"${i3}"`);
    const n2 = getCurrentPara(t2);
    if (n2 && "" !== n2.lineHeight)
      return;
    if (a2.lineHeight)
      return;
    const g2 = selectFont(e2, r2);
    g2 && (a2.lineHeight = Math.max(1.2, g2.lineHeight));
  }
}
function fixURL(e2) {
  const t2 = createValidAbsoluteUrl(e2, null, { addDefaultProtocol: true, tryConvertEncoding: true });
  return t2 ? t2.href : null;
}
function createLine(e2, t2) {
  return { name: "div", attributes: { class: ["lr-tb" === e2.layout ? "xfaLr" : "xfaRl"] }, children: t2 };
}
function flushHTML(e2) {
  if (!e2[gr])
    return null;
  const t2 = { name: "div", attributes: e2[gr].attributes, children: e2[gr].children };
  if (e2[gr].failingNode) {
    const i2 = e2[gr].failingNode[Ir]();
    i2 && (e2.layout.endsWith("-tb") ? t2.children.push(createLine(e2, [i2])) : t2.children.push(i2));
  }
  return 0 === t2.children.length ? null : t2;
}
function addHTML(e2, t2, i2) {
  const a2 = e2[gr], s2 = a2.availableSpace, [r2, n2, g2, o2] = i2;
  switch (e2.layout) {
    case "position":
      a2.width = Math.max(a2.width, r2 + g2);
      a2.height = Math.max(a2.height, n2 + o2);
      a2.children.push(t2);
      break;
    case "lr-tb":
    case "rl-tb":
      if (!a2.line || 1 === a2.attempt) {
        a2.line = createLine(e2, []);
        a2.children.push(a2.line);
        a2.numberInLine = 0;
      }
      a2.numberInLine += 1;
      a2.line.children.push(t2);
      if (0 === a2.attempt) {
        a2.currentWidth += g2;
        a2.height = Math.max(a2.height, a2.prevHeight + o2);
      } else {
        a2.currentWidth = g2;
        a2.prevHeight = a2.height;
        a2.height += o2;
        a2.attempt = 0;
      }
      a2.width = Math.max(a2.width, a2.currentWidth);
      break;
    case "rl-row":
    case "row": {
      a2.children.push(t2);
      a2.width += g2;
      a2.height = Math.max(a2.height, o2);
      const e3 = measureToString(a2.height);
      for (const t3 of a2.children)
        t3.attributes.style.height = e3;
      break;
    }
    case "table":
    case "tb":
      a2.width = Math.min(s2.width, Math.max(a2.width, g2));
      a2.height += o2;
      a2.children.push(t2);
  }
}
function getAvailableSpace(e2) {
  const t2 = e2[gr].availableSpace, i2 = e2.margin ? e2.margin.topInset + e2.margin.bottomInset : 0, a2 = e2.margin ? e2.margin.leftInset + e2.margin.rightInset : 0;
  switch (e2.layout) {
    case "lr-tb":
    case "rl-tb":
      return 0 === e2[gr].attempt ? { width: t2.width - a2 - e2[gr].currentWidth, height: t2.height - i2 - e2[gr].prevHeight } : { width: t2.width - a2, height: t2.height - i2 - e2[gr].height };
    case "rl-row":
    case "row":
      return { width: e2[gr].columnWidths.slice(e2[gr].currentColumn).reduce((e3, t3) => e3 + t3), height: t2.height - a2 };
    case "table":
    case "tb":
      return { width: t2.width - a2, height: t2.height - i2 - e2[gr].height };
    default:
      return t2;
  }
}
function checkDimensions(e2, t2) {
  var _a4;
  if (null === e2[br]()[gr].firstUnsplittable)
    return true;
  if (0 === e2.w || 0 === e2.h)
    return true;
  const i2 = e2[wr](), a2 = ((_a4 = i2[gr]) == null ? void 0 : _a4.attempt) || 0, [, s2, r2, n2] = function getTransformedBBox(e3) {
    let t3, i3, a3 = "" === e3.w ? NaN : e3.w, s3 = "" === e3.h ? NaN : e3.h, [r3, n3] = [0, 0];
    switch (e3.anchorType || "") {
      case "bottomCenter":
        [r3, n3] = [a3 / 2, s3];
        break;
      case "bottomLeft":
        [r3, n3] = [0, s3];
        break;
      case "bottomRight":
        [r3, n3] = [a3, s3];
        break;
      case "middleCenter":
        [r3, n3] = [a3 / 2, s3 / 2];
        break;
      case "middleLeft":
        [r3, n3] = [0, s3 / 2];
        break;
      case "middleRight":
        [r3, n3] = [a3, s3 / 2];
        break;
      case "topCenter":
        [r3, n3] = [a3 / 2, 0];
        break;
      case "topRight":
        [r3, n3] = [a3, 0];
    }
    switch (e3.rotate || 0) {
      case 0:
        [t3, i3] = [-r3, -n3];
        break;
      case 90:
        [t3, i3] = [-n3, r3];
        [a3, s3] = [s3, -a3];
        break;
      case 180:
        [t3, i3] = [r3, n3];
        [a3, s3] = [-a3, -s3];
        break;
      case 270:
        [t3, i3] = [n3, -r3];
        [a3, s3] = [-s3, a3];
    }
    return [e3.x + t3 + Math.min(0, a3), e3.y + i3 + Math.min(0, s3), Math.abs(a3), Math.abs(s3)];
  }(e2);
  switch (i2.layout) {
    case "lr-tb":
    case "rl-tb":
      return 0 === a2 ? e2[br]()[gr].noLayoutFailure ? "" !== e2.w ? Math.round(r2 - t2.width) <= 2 : t2.width > 2 : !("" !== e2.h && Math.round(n2 - t2.height) > 2) && ("" !== e2.w ? Math.round(r2 - t2.width) <= 2 || 0 === i2[gr].numberInLine && t2.height > 2 : t2.width > 2) : !!e2[br]()[gr].noLayoutFailure || !("" !== e2.h && Math.round(n2 - t2.height) > 2) && (("" === e2.w || Math.round(r2 - t2.width) <= 2 || !i2[Jr]()) && t2.height > 2);
    case "table":
    case "tb":
      return !!e2[br]()[gr].noLayoutFailure || ("" === e2.h || e2[Hr]() ? ("" === e2.w || Math.round(r2 - t2.width) <= 2 || !i2[Jr]()) && t2.height > 2 : Math.round(n2 - t2.height) <= 2);
    case "position":
      if (e2[br]()[gr].noLayoutFailure)
        return true;
      if ("" === e2.h || Math.round(n2 + s2 - t2.height) <= 2)
        return true;
      return n2 + s2 > e2[br]()[gr].currentContentArea.h;
    case "rl-row":
    case "row":
      return !!e2[br]()[gr].noLayoutFailure || ("" === e2.h || Math.round(n2 - t2.height) <= 2);
    default:
      return true;
  }
}
var Kn = hn.template.id;
var Tn = "http://www.w3.org/2000/svg";
var qn = /^H(\d+)$/;
var On = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]);
var Pn = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
function getBorderDims(e2) {
  if (!e2 || !e2.border)
    return { w: 0, h: 0 };
  const t2 = e2.border[dr]();
  return t2 ? { w: t2.widths[0] + t2.widths[2] + t2.insets[0] + t2.insets[2], h: t2.widths[1] + t2.widths[3] + t2.insets[1] + t2.insets[3] } : { w: 0, h: 0 };
}
function hasMargin(e2) {
  return e2.margin && (e2.margin.topInset || e2.margin.rightInset || e2.margin.bottomInset || e2.margin.leftInset);
}
function _setValue(e2, t2) {
  if (!e2.value) {
    const t3 = new Value({});
    e2[_s2](t3);
    e2.value = t3;
  }
  e2.value[an](t2);
}
function* getContainedChildren(e2) {
  for (const t2 of e2[pr]())
    t2 instanceof SubformSet ? yield* t2[mr]() : yield t2;
}
function isRequired(e2) {
  var _a4;
  return "error" === ((_a4 = e2.validate) == null ? void 0 : _a4.nullTest);
}
function setTabIndex(e2) {
  for (; e2; ) {
    if (!e2.traversal) {
      e2[sn] = e2[Dr]()[sn];
      return;
    }
    if (e2[sn])
      return;
    let t2 = null;
    for (const i3 of e2.traversal[pr]())
      if ("next" === i3.operation) {
        t2 = i3;
        break;
      }
    if (!t2 || !t2.ref) {
      e2[sn] = e2[Dr]()[sn];
      return;
    }
    const i2 = e2[br]();
    e2[sn] = ++i2[sn];
    const a2 = i2[An](t2.ref, e2);
    if (!a2)
      return;
    e2 = a2[0];
  }
}
function applyAssist(e2, t2) {
  var _a4;
  const i2 = e2.assist;
  if (i2) {
    const e3 = i2[gn]();
    e3 && (t2.title = e3);
    const a2 = i2.role.match(qn);
    if (a2) {
      const e4 = "heading", i3 = a2[1];
      t2.role = e4;
      t2["aria-level"] = i3;
    }
  }
  if ("table" === e2.layout)
    t2.role = "table";
  else if ("row" === e2.layout)
    t2.role = "row";
  else {
    const i3 = e2[Dr]();
    "row" === i3.layout && (t2.role = "TH" === ((_a4 = i3.assist) == null ? void 0 : _a4.role) ? "columnheader" : "cell");
  }
}
function ariaLabel(e2) {
  if (!e2.assist)
    return null;
  const t2 = e2.assist;
  return t2.speak && "" !== t2.speak[sr] ? t2.speak[sr] : t2.toolTip ? t2.toolTip[sr] : null;
}
function valueToHtml(e2) {
  return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: /* @__PURE__ */ Object.create(null) }, children: [{ name: "span", attributes: { style: /* @__PURE__ */ Object.create(null) }, value: e2 }] });
}
function setFirstUnsplittable(e2) {
  const t2 = e2[br]();
  if (null === t2[gr].firstUnsplittable) {
    t2[gr].firstUnsplittable = e2;
    t2[gr].noLayoutFailure = true;
  }
}
function unsetFirstUnsplittable(e2) {
  const t2 = e2[br]();
  t2[gr].firstUnsplittable === e2 && (t2[gr].noLayoutFailure = false);
}
function handleBreak(e2) {
  if (e2[gr])
    return false;
  e2[gr] = /* @__PURE__ */ Object.create(null);
  if ("auto" === e2.targetType)
    return false;
  const t2 = e2[br]();
  let i2 = null;
  if (e2.target) {
    i2 = t2[An](e2.target, e2[Dr]());
    if (!i2)
      return false;
    i2 = i2[0];
  }
  const { currentPageArea: a2, currentContentArea: s2 } = t2[gr];
  if ("pageArea" === e2.targetType) {
    i2 instanceof PageArea || (i2 = null);
    if (e2.startNew) {
      e2[gr].target = i2 || a2;
      return true;
    }
    if (i2 && i2 !== a2) {
      e2[gr].target = i2;
      return true;
    }
    return false;
  }
  i2 instanceof ContentArea || (i2 = null);
  const r2 = i2 && i2[Dr]();
  let n2, g2 = r2;
  if (e2.startNew)
    if (i2) {
      const e3 = r2.contentArea.children, t3 = e3.indexOf(s2), a3 = e3.indexOf(i2);
      -1 !== t3 && t3 < a3 && (g2 = null);
      n2 = a3 - 1;
    } else
      n2 = a2.contentArea.children.indexOf(s2);
  else {
    if (!i2 || i2 === s2)
      return false;
    n2 = r2.contentArea.children.indexOf(i2) - 1;
    g2 = r2 === a2 ? null : r2;
  }
  e2[gr].target = g2;
  e2[gr].index = n2;
  return true;
}
function handleOverflow(e2, t2, i2) {
  const a2 = e2[br](), s2 = a2[gr].noLayoutFailure, r2 = t2[wr];
  t2[wr] = () => e2;
  a2[gr].noLayoutFailure = true;
  const n2 = t2[gn](i2);
  e2[zs](n2.html, n2.bbox);
  a2[gr].noLayoutFailure = s2;
  t2[wr] = r2;
}
var AppearanceFilter = class extends StringObject {
  constructor(e2) {
    super(Kn, "appearanceFilter");
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Arc = class extends XFAObject {
  constructor(e2) {
    super(Kn, "arc", true);
    this.circular = getInteger({ data: e2.circular, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.hand = getStringOption(e2.hand, ["even", "left", "right"]);
    this.id = e2.id || "";
    this.startAngle = getFloat({ data: e2.startAngle, defaultValue: 0, validate: (e3) => true });
    this.sweepAngle = getFloat({ data: e2.sweepAngle, defaultValue: 360, validate: (e3) => true });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.edge = null;
    this.fill = null;
  }
  [gn]() {
    var _a4;
    const e2 = this.edge || new Edge({}), t2 = e2[In](), i2 = /* @__PURE__ */ Object.create(null);
    "visible" === ((_a4 = this.fill) == null ? void 0 : _a4.presence) ? Object.assign(i2, this.fill[In]()) : i2.fill = "transparent";
    i2.strokeWidth = measureToString("visible" === e2.presence ? e2.thickness : 0);
    i2.stroke = t2.color;
    let a2;
    const s2 = { xmlns: Tn, style: { width: "100%", height: "100%", overflow: "visible" } };
    if (360 === this.sweepAngle)
      a2 = { name: "ellipse", attributes: { xmlns: Tn, cx: "50%", cy: "50%", rx: "50%", ry: "50%", style: i2 } };
    else {
      const e3 = this.startAngle * Math.PI / 180, t3 = this.sweepAngle * Math.PI / 180, r3 = this.sweepAngle > 180 ? 1 : 0, [n2, g2, o2, c2] = [50 * (1 + Math.cos(e3)), 50 * (1 - Math.sin(e3)), 50 * (1 + Math.cos(e3 + t3)), 50 * (1 - Math.sin(e3 + t3))];
      a2 = { name: "path", attributes: { xmlns: Tn, d: `M ${n2} ${g2} A 50 50 0 ${r3} 0 ${o2} ${c2}`, vectorEffect: "non-scaling-stroke", style: i2 } };
      Object.assign(s2, { viewBox: "0 0 100 100", preserveAspectRatio: "none" });
    }
    const r2 = { name: "svg", children: [a2], attributes: s2 };
    if (hasMargin(this[Dr]()[Dr]()))
      return HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [r2] });
    r2.attributes.style.position = "absolute";
    return HTMLResult.success(r2);
  }
};
var Area = class extends XFAObject {
  constructor(e2) {
    super(Kn, "area", true);
    this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 });
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.x = getMeasurement(e2.x, "0pt");
    this.y = getMeasurement(e2.y, "0pt");
    this.desc = null;
    this.extras = null;
    this.area = new XFAObjectArray();
    this.draw = new XFAObjectArray();
    this.exObject = new XFAObjectArray();
    this.exclGroup = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.subform = new XFAObjectArray();
    this.subformSet = new XFAObjectArray();
  }
  *[mr]() {
    yield* getContainedChildren(this);
  }
  [Yr]() {
    return true;
  }
  [xr]() {
    return true;
  }
  [zs](e2, t2) {
    const [i2, a2, s2, r2] = t2;
    this[gr].width = Math.max(this[gr].width, i2 + s2);
    this[gr].height = Math.max(this[gr].height, a2 + r2);
    this[gr].children.push(e2);
  }
  [hr]() {
    return this[gr].availableSpace;
  }
  [gn](e2) {
    const t2 = toStyle(this, "position"), i2 = { style: t2, id: this[cn], class: ["xfaArea"] };
    isPrintOnly(this) && i2.class.push("xfaPrintOnly");
    this.name && (i2.xfaName = this.name);
    const a2 = [];
    this[gr] = { children: a2, width: 0, height: 0, availableSpace: e2 };
    const s2 = this[$s]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]), include: true });
    if (!s2.success) {
      if (s2.isBreak())
        return s2;
      delete this[gr];
      return HTMLResult.FAILURE;
    }
    t2.width = measureToString(this[gr].width);
    t2.height = measureToString(this[gr].height);
    const r2 = { name: "div", attributes: i2, children: a2 }, n2 = [this.x, this.y, this[gr].width, this[gr].height];
    delete this[gr];
    return HTMLResult.success(r2, n2);
  }
};
var Assist = class extends XFAObject {
  constructor(e2) {
    super(Kn, "assist", true);
    this.id = e2.id || "";
    this.role = e2.role || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.speak = null;
    this.toolTip = null;
  }
  [gn]() {
    var _a4;
    return ((_a4 = this.toolTip) == null ? void 0 : _a4[sr]) || null;
  }
};
var Barcode = class extends XFAObject {
  constructor(e2) {
    super(Kn, "barcode", true);
    this.charEncoding = getKeyword({ data: e2.charEncoding ? e2.charEncoding.toLowerCase() : "", defaultValue: "", validate: (e3) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e3) || e3.match(/iso-8859-\d{2}/) });
    this.checksum = getStringOption(e2.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]);
    this.dataColumnCount = getInteger({ data: e2.dataColumnCount, defaultValue: -1, validate: (e3) => e3 >= 0 });
    this.dataLength = getInteger({ data: e2.dataLength, defaultValue: -1, validate: (e3) => e3 >= 0 });
    this.dataPrep = getStringOption(e2.dataPrep, ["none", "flateCompress"]);
    this.dataRowCount = getInteger({ data: e2.dataRowCount, defaultValue: -1, validate: (e3) => e3 >= 0 });
    this.endChar = e2.endChar || "";
    this.errorCorrectionLevel = getInteger({ data: e2.errorCorrectionLevel, defaultValue: -1, validate: (e3) => e3 >= 0 && e3 <= 8 });
    this.id = e2.id || "";
    this.moduleHeight = getMeasurement(e2.moduleHeight, "5mm");
    this.moduleWidth = getMeasurement(e2.moduleWidth, "0.25mm");
    this.printCheckDigit = getInteger({ data: e2.printCheckDigit, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.rowColumnRatio = getRatio(e2.rowColumnRatio);
    this.startChar = e2.startChar || "";
    this.textLocation = getStringOption(e2.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]);
    this.truncate = getInteger({ data: e2.truncate, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.type = getStringOption(e2.type ? e2.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]);
    this.upsMode = getStringOption(e2.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.wideNarrowRatio = getRatio(e2.wideNarrowRatio);
    this.encrypt = null;
    this.extras = null;
  }
};
var Bind = class extends XFAObject {
  constructor(e2) {
    super(Kn, "bind", true);
    this.match = getStringOption(e2.match, ["once", "dataRef", "global", "none"]);
    this.ref = e2.ref || "";
    this.picture = null;
  }
};
var BindItems = class extends XFAObject {
  constructor(e2) {
    super(Kn, "bindItems");
    this.connection = e2.connection || "";
    this.labelRef = e2.labelRef || "";
    this.ref = e2.ref || "";
    this.valueRef = e2.valueRef || "";
  }
};
var Bookend = class extends XFAObject {
  constructor(e2) {
    super(Kn, "bookend");
    this.id = e2.id || "";
    this.leader = e2.leader || "";
    this.trailer = e2.trailer || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var BooleanElement = class extends Option01 {
  constructor(e2) {
    super(Kn, "boolean");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [gn](e2) {
    return valueToHtml(1 === this[sr] ? "1" : "0");
  }
};
var Border = class extends XFAObject {
  constructor(e2) {
    super(Kn, "border", true);
    this.break = getStringOption(e2.break, ["close", "open"]);
    this.hand = getStringOption(e2.hand, ["even", "left", "right"]);
    this.id = e2.id || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.corner = new XFAObjectArray(4);
    this.edge = new XFAObjectArray(4);
    this.extras = null;
    this.fill = null;
    this.margin = null;
  }
  [dr]() {
    if (!this[gr]) {
      const e2 = this.edge.children.slice();
      if (e2.length < 4) {
        const t3 = e2.at(-1) || new Edge({});
        for (let i3 = e2.length; i3 < 4; i3++)
          e2.push(t3);
      }
      const t2 = e2.map((e3) => e3.thickness), i2 = [0, 0, 0, 0];
      if (this.margin) {
        i2[0] = this.margin.topInset;
        i2[1] = this.margin.rightInset;
        i2[2] = this.margin.bottomInset;
        i2[3] = this.margin.leftInset;
      }
      this[gr] = { widths: t2, insets: i2, edges: e2 };
    }
    return this[gr];
  }
  [In]() {
    var _a4;
    const { edges: e2 } = this[dr](), t2 = e2.map((e3) => {
      const t3 = e3[In]();
      t3.color || (t3.color = "#000000");
      return t3;
    }), i2 = /* @__PURE__ */ Object.create(null);
    this.margin && Object.assign(i2, this.margin[In]());
    "visible" === ((_a4 = this.fill) == null ? void 0 : _a4.presence) && Object.assign(i2, this.fill[In]());
    if (this.corner.children.some((e3) => 0 !== e3.radius)) {
      const e3 = this.corner.children.map((e4) => e4[In]());
      if (2 === e3.length || 3 === e3.length) {
        const t3 = e3.at(-1);
        for (let i3 = e3.length; i3 < 4; i3++)
          e3.push(t3);
      }
      i2.borderRadius = e3.map((e4) => e4.radius).join(" ");
    }
    switch (this.presence) {
      case "invisible":
      case "hidden":
        i2.borderStyle = "";
        break;
      case "inactive":
        i2.borderStyle = "none";
        break;
      default:
        i2.borderStyle = t2.map((e3) => e3.style).join(" ");
    }
    i2.borderWidth = t2.map((e3) => e3.width).join(" ");
    i2.borderColor = t2.map((e3) => e3.color).join(" ");
    return i2;
  }
};
var Break = class extends XFAObject {
  constructor(e2) {
    super(Kn, "break", true);
    this.after = getStringOption(e2.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.afterTarget = e2.afterTarget || "";
    this.before = getStringOption(e2.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.beforeTarget = e2.beforeTarget || "";
    this.bookendLeader = e2.bookendLeader || "";
    this.bookendTrailer = e2.bookendTrailer || "";
    this.id = e2.id || "";
    this.overflowLeader = e2.overflowLeader || "";
    this.overflowTarget = e2.overflowTarget || "";
    this.overflowTrailer = e2.overflowTrailer || "";
    this.startNew = getInteger({ data: e2.startNew, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
};
var BreakAfter = class extends XFAObject {
  constructor(e2) {
    super(Kn, "breakAfter", true);
    this.id = e2.id || "";
    this.leader = e2.leader || "";
    this.startNew = getInteger({ data: e2.startNew, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.target = e2.target || "";
    this.targetType = getStringOption(e2.targetType, ["auto", "contentArea", "pageArea"]);
    this.trailer = e2.trailer || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.script = null;
  }
};
var BreakBefore = class extends XFAObject {
  constructor(e2) {
    super(Kn, "breakBefore", true);
    this.id = e2.id || "";
    this.leader = e2.leader || "";
    this.startNew = getInteger({ data: e2.startNew, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.target = e2.target || "";
    this.targetType = getStringOption(e2.targetType, ["auto", "contentArea", "pageArea"]);
    this.trailer = e2.trailer || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.script = null;
  }
  [gn](e2) {
    this[gr] = {};
    return HTMLResult.FAILURE;
  }
};
var Button = class extends XFAObject {
  constructor(e2) {
    super(Kn, "button", true);
    this.highlight = getStringOption(e2.highlight, ["inverted", "none", "outline", "push"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
  [gn](e2) {
    const t2 = this[Dr]()[Dr](), i2 = { name: "button", attributes: { id: this[cn], class: ["xfaButton"], style: {} }, children: [] };
    for (const e3 of t2.event.children) {
      if ("click" !== e3.activity || !e3.script)
        continue;
      const t3 = recoverJsURL(e3.script[sr]);
      if (!t3)
        continue;
      const a2 = fixURL(t3.url);
      a2 && i2.children.push({ name: "a", attributes: { id: "link" + this[cn], href: a2, newWindow: t3.newWindow, class: ["xfaLink"], style: {} }, children: [] });
    }
    return HTMLResult.success(i2);
  }
};
var Calculate = class extends XFAObject {
  constructor(e2) {
    super(Kn, "calculate", true);
    this.id = e2.id || "";
    this.override = getStringOption(e2.override, ["disabled", "error", "ignore", "warning"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.message = null;
    this.script = null;
  }
};
var Caption = class extends XFAObject {
  constructor(e2) {
    super(Kn, "caption", true);
    this.id = e2.id || "";
    this.placement = getStringOption(e2.placement, ["left", "bottom", "inline", "right", "top"]);
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.reserve = Math.ceil(getMeasurement(e2.reserve));
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.font = null;
    this.margin = null;
    this.para = null;
    this.value = null;
  }
  [an](e2) {
    _setValue(this, e2);
  }
  [dr](e2) {
    if (!this[gr]) {
      let { width: t2, height: i2 } = e2;
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          t2 = this.reserve <= 0 ? t2 : this.reserve;
          break;
        case "top":
        case "bottom":
          i2 = this.reserve <= 0 ? i2 : this.reserve;
      }
      this[gr] = layoutNode(this, { width: t2, height: i2 });
    }
    return this[gr];
  }
  [gn](e2) {
    if (!this.value)
      return HTMLResult.EMPTY;
    this[Vr]();
    const t2 = this.value[gn](e2).html;
    if (!t2) {
      this[Zr]();
      return HTMLResult.EMPTY;
    }
    const i2 = this.reserve;
    if (this.reserve <= 0) {
      const { w: t3, h: i3 } = this[dr](e2);
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          this.reserve = t3;
          break;
        case "top":
        case "bottom":
          this.reserve = i3;
      }
    }
    const a2 = [];
    "string" == typeof t2 ? a2.push({ name: "#text", value: t2 }) : a2.push(t2);
    const s2 = toStyle(this, "font", "margin", "visibility");
    switch (this.placement) {
      case "left":
      case "right":
        this.reserve > 0 && (s2.width = measureToString(this.reserve));
        break;
      case "top":
      case "bottom":
        this.reserve > 0 && (s2.height = measureToString(this.reserve));
    }
    setPara(this, null, t2);
    this[Zr]();
    this.reserve = i2;
    return HTMLResult.success({ name: "div", attributes: { style: s2, class: ["xfaCaption"] }, children: a2 });
  }
};
var Certificate = class extends StringObject {
  constructor(e2) {
    super(Kn, "certificate");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Certificates = class extends XFAObject {
  constructor(e2) {
    super(Kn, "certificates", true);
    this.credentialServerPolicy = getStringOption(e2.credentialServerPolicy, ["optional", "required"]);
    this.id = e2.id || "";
    this.url = e2.url || "";
    this.urlPolicy = e2.urlPolicy || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.encryption = null;
    this.issuers = null;
    this.keyUsage = null;
    this.oids = null;
    this.signing = null;
    this.subjectDNs = null;
  }
};
var CheckButton = class extends XFAObject {
  constructor(e2) {
    super(Kn, "checkButton", true);
    this.id = e2.id || "";
    this.mark = getStringOption(e2.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]);
    this.shape = getStringOption(e2.shape, ["square", "round"]);
    this.size = getMeasurement(e2.size, "10pt");
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [gn](e2) {
    var _a4, _b2, _c2;
    const t2 = toStyle("margin"), i2 = measureToString(this.size);
    t2.width = t2.height = i2;
    let a2, s2, r2;
    const n2 = this[Dr]()[Dr](), g2 = n2.items.children.length && n2.items.children[0][gn]().html || [], o2 = { on: (void 0 !== g2[0] ? g2[0] : "on").toString(), off: (void 0 !== g2[1] ? g2[1] : "off").toString() }, c2 = (((_a4 = n2.value) == null ? void 0 : _a4[rn]()) || "off") === o2.on || void 0, C2 = n2[wr](), h2 = n2[cn];
    let l2;
    if (C2 instanceof ExclGroup) {
      r2 = C2[cn];
      a2 = "radio";
      s2 = "xfaRadio";
      l2 = ((_b2 = C2[rr]) == null ? void 0 : _b2[cn]) || C2[cn];
    } else {
      a2 = "checkbox";
      s2 = "xfaCheckbox";
      l2 = ((_c2 = n2[rr]) == null ? void 0 : _c2[cn]) || n2[cn];
    }
    const Q2 = { name: "input", attributes: { class: [s2], style: t2, fieldId: h2, dataId: l2, type: a2, checked: c2, xfaOn: o2.on, xfaOff: o2.off, "aria-label": ariaLabel(n2), "aria-required": false } };
    r2 && (Q2.attributes.name = r2);
    if (isRequired(n2)) {
      Q2.attributes["aria-required"] = true;
      Q2.attributes.required = true;
    }
    return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [Q2] });
  }
};
var ChoiceList = class extends XFAObject {
  constructor(e2) {
    super(Kn, "choiceList", true);
    this.commitOn = getStringOption(e2.commitOn, ["select", "exit"]);
    this.id = e2.id || "";
    this.open = getStringOption(e2.open, ["userControl", "always", "multiSelect", "onEntry"]);
    this.textEntry = getInteger({ data: e2.textEntry, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [gn](e2) {
    var _a4, _b2, _c2;
    const t2 = toStyle(this, "border", "margin"), i2 = this[Dr]()[Dr](), a2 = { fontSize: `calc(${((_a4 = i2.font) == null ? void 0 : _a4.size) || 10}px * var(--scale-factor))` }, s2 = [];
    if (i2.items.children.length > 0) {
      const e3 = i2.items;
      let t3 = 0, r3 = 0;
      if (2 === e3.children.length) {
        t3 = e3.children[0].save;
        r3 = 1 - t3;
      }
      const n2 = e3.children[t3][gn]().html, g2 = e3.children[r3][gn]().html;
      let o2 = false;
      const c2 = ((_b2 = i2.value) == null ? void 0 : _b2[rn]()) || "";
      for (let e4 = 0, t4 = n2.length; e4 < t4; e4++) {
        const t5 = { name: "option", attributes: { value: g2[e4] || n2[e4], style: a2 }, value: n2[e4] };
        g2[e4] === c2 && (t5.attributes.selected = o2 = true);
        s2.push(t5);
      }
      o2 || s2.splice(0, 0, { name: "option", attributes: { hidden: true, selected: true }, value: " " });
    }
    const r2 = { class: ["xfaSelect"], fieldId: i2[cn], dataId: ((_c2 = i2[rr]) == null ? void 0 : _c2[cn]) || i2[cn], style: t2, "aria-label": ariaLabel(i2), "aria-required": false };
    if (isRequired(i2)) {
      r2["aria-required"] = true;
      r2.required = true;
    }
    "multiSelect" === this.open && (r2.multiple = true);
    return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [{ name: "select", children: s2, attributes: r2 }] });
  }
};
var Color = class extends XFAObject {
  constructor(e2) {
    super(Kn, "color", true);
    this.cSpace = getStringOption(e2.cSpace, ["SRGB"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.value = e2.value ? function getColor(e3, t2 = [0, 0, 0]) {
      let [i2, a2, s2] = t2;
      if (!e3)
        return { r: i2, g: a2, b: s2 };
      const r2 = e3.trim().split(/\s*,\s*/).map((e4) => Math.min(Math.max(0, parseInt(e4.trim(), 10)), 255)).map((e4) => isNaN(e4) ? 0 : e4);
      if (r2.length < 3)
        return { r: i2, g: a2, b: s2 };
      [i2, a2, s2] = r2;
      return { r: i2, g: a2, b: s2 };
    }(e2.value) : "";
    this.extras = null;
  }
  [Sr]() {
    return false;
  }
  [In]() {
    return this.value ? Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
  }
};
var Comb = class extends XFAObject {
  constructor(e2) {
    super(Kn, "comb");
    this.id = e2.id || "";
    this.numberOfCells = getInteger({ data: e2.numberOfCells, defaultValue: 0, validate: (e3) => e3 >= 0 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Connect = class extends XFAObject {
  constructor(e2) {
    super(Kn, "connect", true);
    this.connection = e2.connection || "";
    this.id = e2.id || "";
    this.ref = e2.ref || "";
    this.usage = getStringOption(e2.usage, ["exportAndImport", "exportOnly", "importOnly"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.picture = null;
  }
};
var ContentArea = class extends XFAObject {
  constructor(e2) {
    super(Kn, "contentArea", true);
    this.h = getMeasurement(e2.h);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.w = getMeasurement(e2.w);
    this.x = getMeasurement(e2.x, "0pt");
    this.y = getMeasurement(e2.y, "0pt");
    this.desc = null;
    this.extras = null;
  }
  [gn](e2) {
    const t2 = { left: measureToString(this.x), top: measureToString(this.y), width: measureToString(this.w), height: measureToString(this.h) }, i2 = ["xfaContentarea"];
    isPrintOnly(this) && i2.push("xfaPrintOnly");
    return HTMLResult.success({ name: "div", children: [], attributes: { style: t2, class: i2, id: this[cn] } });
  }
};
var Corner = class extends XFAObject {
  constructor(e2) {
    super(Kn, "corner", true);
    this.id = e2.id || "";
    this.inverted = getInteger({ data: e2.inverted, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.join = getStringOption(e2.join, ["square", "round"]);
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.radius = getMeasurement(e2.radius);
    this.stroke = getStringOption(e2.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
    this.thickness = getMeasurement(e2.thickness, "0.5pt");
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [In]() {
    const e2 = toStyle(this, "visibility");
    e2.radius = measureToString("square" === this.join ? 0 : this.radius);
    return e2;
  }
};
var DateElement = class extends ContentObject {
  constructor(e2) {
    super(Kn, "date");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [or]() {
    const e2 = this[sr].trim();
    this[sr] = e2 ? new Date(e2) : null;
  }
  [gn](e2) {
    return valueToHtml(this[sr] ? this[sr].toString() : "");
  }
};
var DateTime = class extends ContentObject {
  constructor(e2) {
    super(Kn, "dateTime");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [or]() {
    const e2 = this[sr].trim();
    this[sr] = e2 ? new Date(e2) : null;
  }
  [gn](e2) {
    return valueToHtml(this[sr] ? this[sr].toString() : "");
  }
};
var DateTimeEdit = class extends XFAObject {
  constructor(e2) {
    super(Kn, "dateTimeEdit", true);
    this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]);
    this.id = e2.id || "";
    this.picker = getStringOption(e2.picker, ["host", "none"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [gn](e2) {
    var _a4;
    const t2 = toStyle(this, "border", "font", "margin"), i2 = this[Dr]()[Dr](), a2 = { name: "input", attributes: { type: "text", fieldId: i2[cn], dataId: ((_a4 = i2[rr]) == null ? void 0 : _a4[cn]) || i2[cn], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(i2), "aria-required": false } };
    if (isRequired(i2)) {
      a2.attributes["aria-required"] = true;
      a2.attributes.required = true;
    }
    return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [a2] });
  }
};
var Decimal = class extends ContentObject {
  constructor(e2) {
    super(Kn, "decimal");
    this.fracDigits = getInteger({ data: e2.fracDigits, defaultValue: 2, validate: (e3) => true });
    this.id = e2.id || "";
    this.leadDigits = getInteger({ data: e2.leadDigits, defaultValue: -1, validate: (e3) => true });
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [or]() {
    const e2 = parseFloat(this[sr].trim());
    this[sr] = isNaN(e2) ? null : e2;
  }
  [gn](e2) {
    return valueToHtml(null !== this[sr] ? this[sr].toString() : "");
  }
};
var DefaultUi = class extends XFAObject {
  constructor(e2) {
    super(Kn, "defaultUi", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
};
var Desc = class extends XFAObject {
  constructor(e2) {
    super(Kn, "desc", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
};
var DigestMethod = class extends OptionObject {
  constructor(e2) {
    super(Kn, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var DigestMethods = class extends XFAObject {
  constructor(e2) {
    super(Kn, "digestMethods", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.digestMethod = new XFAObjectArray();
  }
};
var Draw = class extends XFAObject {
  constructor(e2) {
    super(Kn, "draw", true);
    this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 });
    this.h = e2.h ? getMeasurement(e2.h) : "";
    this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = e2.id || "";
    this.locale = e2.locale || "";
    this.maxH = getMeasurement(e2.maxH, "0pt");
    this.maxW = getMeasurement(e2.maxW, "0pt");
    this.minH = getMeasurement(e2.minH, "0pt");
    this.minW = getMeasurement(e2.minW, "0pt");
    this.name = e2.name || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(e2.relevant);
    this.rotate = getInteger({ data: e2.rotate, defaultValue: 0, validate: (e3) => e3 % 90 == 0 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.w = e2.w ? getMeasurement(e2.w) : "";
    this.x = getMeasurement(e2.x, "0pt");
    this.y = getMeasurement(e2.y, "0pt");
    this.assist = null;
    this.border = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.font = null;
    this.keep = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.ui = null;
    this.value = null;
    this.setProperty = new XFAObjectArray();
  }
  [an](e2) {
    _setValue(this, e2);
  }
  [gn](e2) {
    setTabIndex(this);
    if ("hidden" === this.presence || "inactive" === this.presence)
      return HTMLResult.EMPTY;
    fixDimensions(this);
    this[Vr]();
    const t2 = this.w, i2 = this.h, { w: a2, h: s2, isBroken: r2 } = layoutNode(this, e2);
    if (a2 && "" === this.w) {
      if (r2 && this[wr]()[Jr]()) {
        this[Zr]();
        return HTMLResult.FAILURE;
      }
      this.w = a2;
    }
    s2 && "" === this.h && (this.h = s2);
    setFirstUnsplittable(this);
    if (!checkDimensions(this, e2)) {
      this.w = t2;
      this.h = i2;
      this[Zr]();
      return HTMLResult.FAILURE;
    }
    unsetFirstUnsplittable(this);
    const n2 = toStyle(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
    setMinMaxDimensions(this, n2);
    if (n2.margin) {
      n2.padding = n2.margin;
      delete n2.margin;
    }
    const g2 = ["xfaDraw"];
    this.font && g2.push("xfaFont");
    isPrintOnly(this) && g2.push("xfaPrintOnly");
    const o2 = { style: n2, id: this[cn], class: g2 };
    this.name && (o2.xfaName = this.name);
    const c2 = { name: "div", attributes: o2, children: [] };
    applyAssist(this, o2);
    const C2 = computeBbox(this, c2, e2), h2 = this.value ? this.value[gn](e2).html : null;
    if (null === h2) {
      this.w = t2;
      this.h = i2;
      this[Zr]();
      return HTMLResult.success(createWrapper(this, c2), C2);
    }
    c2.children.push(h2);
    setPara(this, n2, h2);
    this.w = t2;
    this.h = i2;
    this[Zr]();
    return HTMLResult.success(createWrapper(this, c2), C2);
  }
};
var Edge = class extends XFAObject {
  constructor(e2) {
    super(Kn, "edge", true);
    this.cap = getStringOption(e2.cap, ["square", "butt", "round"]);
    this.id = e2.id || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.stroke = getStringOption(e2.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
    this.thickness = getMeasurement(e2.thickness, "0.5pt");
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [In]() {
    const e2 = toStyle(this, "visibility");
    Object.assign(e2, { linecap: this.cap, width: measureToString(this.thickness), color: this.color ? this.color[In]() : "#000000", style: "" });
    if ("visible" !== this.presence)
      e2.style = "none";
    else
      switch (this.stroke) {
        case "solid":
          e2.style = "solid";
          break;
        case "dashDot":
        case "dashDotDot":
        case "dashed":
          e2.style = "dashed";
          break;
        case "dotted":
          e2.style = "dotted";
          break;
        case "embossed":
          e2.style = "ridge";
          break;
        case "etched":
          e2.style = "groove";
          break;
        case "lowered":
          e2.style = "inset";
          break;
        case "raised":
          e2.style = "outset";
      }
    return e2;
  }
};
var Encoding = class extends OptionObject {
  constructor(e2) {
    super(Kn, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Encodings = class extends XFAObject {
  constructor(e2) {
    super(Kn, "encodings", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.encoding = new XFAObjectArray();
  }
};
var Encrypt = class extends XFAObject {
  constructor(e2) {
    super(Kn, "encrypt", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.certificate = null;
  }
};
var EncryptData = class extends XFAObject {
  constructor(e2) {
    super(Kn, "encryptData", true);
    this.id = e2.id || "";
    this.operation = getStringOption(e2.operation, ["encrypt", "decrypt"]);
    this.target = e2.target || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.filter = null;
    this.manifest = null;
  }
};
var Encryption = class extends XFAObject {
  constructor(e2) {
    super(Kn, "encryption", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.certificate = new XFAObjectArray();
  }
};
var EncryptionMethod = class extends OptionObject {
  constructor(e2) {
    super(Kn, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var EncryptionMethods = class extends XFAObject {
  constructor(e2) {
    super(Kn, "encryptionMethods", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.encryptionMethod = new XFAObjectArray();
  }
};
var Event = class extends XFAObject {
  constructor(e2) {
    super(Kn, "event", true);
    this.activity = getStringOption(e2.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]);
    this.id = e2.id || "";
    this.listen = getStringOption(e2.listen, ["refOnly", "refAndDescendents"]);
    this.name = e2.name || "";
    this.ref = e2.ref || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.encryptData = null;
    this.execute = null;
    this.script = null;
    this.signData = null;
    this.submit = null;
  }
};
var ExData = class extends ContentObject {
  constructor(e2) {
    super(Kn, "exData");
    this.contentType = e2.contentType || "";
    this.href = e2.href || "";
    this.id = e2.id || "";
    this.maxLength = getInteger({ data: e2.maxLength, defaultValue: -1, validate: (e3) => e3 >= -1 });
    this.name = e2.name || "";
    this.rid = e2.rid || "";
    this.transferEncoding = getStringOption(e2.transferEncoding, ["none", "base64", "package"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [Gr]() {
    return "text/html" === this.contentType;
  }
  [Pr](e2) {
    if ("text/html" === this.contentType && e2[Tr] === hn.xhtml.id) {
      this[sr] = e2;
      return true;
    }
    if ("text/xml" === this.contentType) {
      this[sr] = e2;
      return true;
    }
    return false;
  }
  [gn](e2) {
    return "text/html" === this.contentType && this[sr] ? this[sr][gn](e2) : HTMLResult.EMPTY;
  }
};
var ExObject = class extends XFAObject {
  constructor(e2) {
    super(Kn, "exObject", true);
    this.archive = e2.archive || "";
    this.classId = e2.classId || "";
    this.codeBase = e2.codeBase || "";
    this.codeType = e2.codeType || "";
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.exObject = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
};
var ExclGroup = class extends XFAObject {
  constructor(e2) {
    super(Kn, "exclGroup", true);
    this.access = getStringOption(e2.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.accessKey = e2.accessKey || "";
    this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 });
    this.h = e2.h ? getMeasurement(e2.h) : "";
    this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = e2.id || "";
    this.layout = getStringOption(e2.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
    this.maxH = getMeasurement(e2.maxH, "0pt");
    this.maxW = getMeasurement(e2.maxW, "0pt");
    this.minH = getMeasurement(e2.minH, "0pt");
    this.minW = getMeasurement(e2.minW, "0pt");
    this.name = e2.name || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.w = e2.w ? getMeasurement(e2.w) : "";
    this.x = getMeasurement(e2.x, "0pt");
    this.y = getMeasurement(e2.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.border = null;
    this.calculate = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.validate = null;
    this.connect = new XFAObjectArray();
    this.event = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.setProperty = new XFAObjectArray();
  }
  [xr]() {
    return true;
  }
  [Sr]() {
    return true;
  }
  [an](e2) {
    for (const t2 of this.field.children) {
      if (!t2.value) {
        const e3 = new Value({});
        t2[_s2](e3);
        t2.value = e3;
      }
      t2.value[an](e2);
    }
  }
  [Jr]() {
    return this.layout.endsWith("-tb") && 0 === this[gr].attempt && this[gr].numberInLine > 0 || this[Dr]()[Jr]();
  }
  [Hr]() {
    var _a4;
    const e2 = this[wr]();
    if (!e2[Hr]())
      return false;
    if (void 0 !== this[gr]._isSplittable)
      return this[gr]._isSplittable;
    if ("position" === this.layout || this.layout.includes("row")) {
      this[gr]._isSplittable = false;
      return false;
    }
    if (((_a4 = e2.layout) == null ? void 0 : _a4.endsWith("-tb")) && 0 !== e2[gr].numberInLine)
      return false;
    this[gr]._isSplittable = true;
    return true;
  }
  [Ir]() {
    return flushHTML(this);
  }
  [zs](e2, t2) {
    addHTML(this, e2, t2);
  }
  [hr]() {
    return getAvailableSpace(this);
  }
  [gn](e2) {
    setTabIndex(this);
    if ("hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w)
      return HTMLResult.EMPTY;
    fixDimensions(this);
    const t2 = [], i2 = { id: this[cn], class: [] };
    setAccess(this, i2.class);
    this[gr] || (this[gr] = /* @__PURE__ */ Object.create(null));
    Object.assign(this[gr], { children: t2, attributes: i2, attempt: 0, line: null, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e2.width), height: Math.min(this.h || 1 / 0, e2.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
    const a2 = this[Hr]();
    a2 || setFirstUnsplittable(this);
    if (!checkDimensions(this, e2))
      return HTMLResult.FAILURE;
    const s2 = /* @__PURE__ */ new Set(["field"]);
    if (this.layout.includes("row")) {
      const e3 = this[wr]().columnWidths;
      if (Array.isArray(e3) && e3.length > 0) {
        this[gr].columnWidths = e3;
        this[gr].currentColumn = 0;
      }
    }
    const r2 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), n2 = ["xfaExclgroup"], g2 = layoutClass(this);
    g2 && n2.push(g2);
    isPrintOnly(this) && n2.push("xfaPrintOnly");
    i2.style = r2;
    i2.class = n2;
    this.name && (i2.xfaName = this.name);
    this[Vr]();
    const o2 = "lr-tb" === this.layout || "rl-tb" === this.layout, c2 = o2 ? 2 : 1;
    for (; this[gr].attempt < c2; this[gr].attempt++) {
      o2 && 1 === this[gr].attempt && (this[gr].numberInLine = 0);
      const e3 = this[$s]({ filter: s2, include: true });
      if (e3.success)
        break;
      if (e3.isBreak()) {
        this[Zr]();
        return e3;
      }
      if (o2 && 0 === this[gr].attempt && 0 === this[gr].numberInLine && !this[br]()[gr].noLayoutFailure) {
        this[gr].attempt = c2;
        break;
      }
    }
    this[Zr]();
    a2 || unsetFirstUnsplittable(this);
    if (this[gr].attempt === c2) {
      a2 || delete this[gr];
      return HTMLResult.FAILURE;
    }
    let C2 = 0, h2 = 0;
    if (this.margin) {
      C2 = this.margin.leftInset + this.margin.rightInset;
      h2 = this.margin.topInset + this.margin.bottomInset;
    }
    const l2 = Math.max(this[gr].width + C2, this.w || 0), Q2 = Math.max(this[gr].height + h2, this.h || 0), E2 = [this.x, this.y, l2, Q2];
    "" === this.w && (r2.width = measureToString(l2));
    "" === this.h && (r2.height = measureToString(Q2));
    const u2 = { name: "div", attributes: i2, children: t2 };
    applyAssist(this, i2);
    delete this[gr];
    return HTMLResult.success(createWrapper(this, u2), E2);
  }
};
var Execute = class extends XFAObject {
  constructor(e2) {
    super(Kn, "execute");
    this.connection = e2.connection || "";
    this.executeType = getStringOption(e2.executeType, ["import", "remerge"]);
    this.id = e2.id || "";
    this.runAt = getStringOption(e2.runAt, ["client", "both", "server"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Extras = class extends XFAObject {
  constructor(e2) {
    super(Kn, "extras", true);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.extras = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
};
var Field = class extends XFAObject {
  constructor(e2) {
    super(Kn, "field", true);
    this.access = getStringOption(e2.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.accessKey = e2.accessKey || "";
    this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 });
    this.h = e2.h ? getMeasurement(e2.h) : "";
    this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = e2.id || "";
    this.locale = e2.locale || "";
    this.maxH = getMeasurement(e2.maxH, "0pt");
    this.maxW = getMeasurement(e2.maxW, "0pt");
    this.minH = getMeasurement(e2.minH, "0pt");
    this.minW = getMeasurement(e2.minW, "0pt");
    this.name = e2.name || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(e2.relevant);
    this.rotate = getInteger({ data: e2.rotate, defaultValue: 0, validate: (e3) => e3 % 90 == 0 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.w = e2.w ? getMeasurement(e2.w) : "";
    this.x = getMeasurement(e2.x, "0pt");
    this.y = getMeasurement(e2.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.border = null;
    this.calculate = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.font = null;
    this.format = null;
    this.items = new XFAObjectArray(2);
    this.keep = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.ui = null;
    this.validate = null;
    this.value = null;
    this.bindItems = new XFAObjectArray();
    this.connect = new XFAObjectArray();
    this.event = new XFAObjectArray();
    this.setProperty = new XFAObjectArray();
  }
  [xr]() {
    return true;
  }
  [an](e2) {
    _setValue(this, e2);
  }
  [gn](e2) {
    var _a4, _b2, _c2;
    setTabIndex(this);
    if (!this.ui) {
      this.ui = new Ui({});
      this.ui[Fr] = this[Fr];
      this[_s2](this.ui);
      let e3;
      switch (this.items.children.length) {
        case 0:
          e3 = new TextEdit({});
          this.ui.textEdit = e3;
          break;
        case 1:
          e3 = new CheckButton({});
          this.ui.checkButton = e3;
          break;
        case 2:
          e3 = new ChoiceList({});
          this.ui.choiceList = e3;
      }
      this.ui[_s2](e3);
    }
    if (!this.ui || "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w)
      return HTMLResult.EMPTY;
    this.caption && delete this.caption[gr];
    this[Vr]();
    const t2 = this.caption ? this.caption[gn](e2).html : null, i2 = this.w, a2 = this.h;
    let s2 = 0, r2 = 0;
    if (this.margin) {
      s2 = this.margin.leftInset + this.margin.rightInset;
      r2 = this.margin.topInset + this.margin.bottomInset;
    }
    let n2 = null;
    if ("" === this.w || "" === this.h) {
      let t3 = null, i3 = null, a3 = 0, g3 = 0;
      if (this.ui.checkButton)
        a3 = g3 = this.ui.checkButton.size;
      else {
        const { w: t4, h: i4 } = layoutNode(this, e2);
        if (null !== t4) {
          a3 = t4;
          g3 = i4;
        } else
          g3 = function fonts_getMetrics(e3, t5 = false) {
            let i5 = null;
            if (e3) {
              const t6 = stripQuotes(e3.typeface), a5 = e3[Fr].fontFinder.find(t6);
              i5 = selectFont(e3, a5);
            }
            if (!i5)
              return { lineHeight: 12, lineGap: 2, lineNoGap: 10 };
            const a4 = e3.size || 10, s3 = i5.lineHeight ? Math.max(t5 ? 0 : 1.2, i5.lineHeight) : 1.2, r3 = void 0 === i5.lineGap ? 0.2 : i5.lineGap;
            return { lineHeight: s3 * a4, lineGap: r3 * a4, lineNoGap: Math.max(1, s3 - r3) * a4 };
          }(this.font, true).lineNoGap;
      }
      n2 = getBorderDims(this.ui[dr]());
      a3 += n2.w;
      g3 += n2.h;
      if (this.caption) {
        const { w: s3, h: r3, isBroken: n3 } = this.caption[dr](e2);
        if (n3 && this[wr]()[Jr]()) {
          this[Zr]();
          return HTMLResult.FAILURE;
        }
        t3 = s3;
        i3 = r3;
        switch (this.caption.placement) {
          case "left":
          case "right":
          case "inline":
            t3 += a3;
            break;
          case "top":
          case "bottom":
            i3 += g3;
        }
      } else {
        t3 = a3;
        i3 = g3;
      }
      if (t3 && "" === this.w) {
        t3 += s2;
        this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < t3 ? t3 : this.minW);
      }
      if (i3 && "" === this.h) {
        i3 += r2;
        this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < i3 ? i3 : this.minH);
      }
    }
    this[Zr]();
    fixDimensions(this);
    setFirstUnsplittable(this);
    if (!checkDimensions(this, e2)) {
      this.w = i2;
      this.h = a2;
      this[Zr]();
      return HTMLResult.FAILURE;
    }
    unsetFirstUnsplittable(this);
    const g2 = toStyle(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
    setMinMaxDimensions(this, g2);
    const o2 = ["xfaField"];
    this.font && o2.push("xfaFont");
    isPrintOnly(this) && o2.push("xfaPrintOnly");
    const c2 = { style: g2, id: this[cn], class: o2 };
    if (g2.margin) {
      g2.padding = g2.margin;
      delete g2.margin;
    }
    setAccess(this, o2);
    this.name && (c2.xfaName = this.name);
    const C2 = [], h2 = { name: "div", attributes: c2, children: C2 };
    applyAssist(this, c2);
    const l2 = this.border ? this.border[In]() : null, Q2 = computeBbox(this, h2, e2), E2 = this.ui[gn]().html;
    if (!E2) {
      Object.assign(g2, l2);
      return HTMLResult.success(createWrapper(this, h2), Q2);
    }
    this[sn] && (((_a4 = E2.children) == null ? void 0 : _a4[0]) ? E2.children[0].attributes.tabindex = this[sn] : E2.attributes.tabindex = this[sn]);
    E2.attributes.style || (E2.attributes.style = /* @__PURE__ */ Object.create(null));
    let u2 = null;
    if (this.ui.button) {
      1 === E2.children.length && ([u2] = E2.children.splice(0, 1));
      Object.assign(E2.attributes.style, l2);
    } else
      Object.assign(g2, l2);
    C2.push(E2);
    if (this.value) {
      if (this.ui.imageEdit)
        E2.children.push(this.value[gn]().html);
      else if (!this.ui.button) {
        let e3 = "";
        if (this.value.exData)
          e3 = this.value.exData[rn]();
        else if (this.value.text)
          e3 = this.value.text[dr]();
        else {
          const t3 = this.value[gn]().html;
          null !== t3 && (e3 = t3.children[0].value);
        }
        this.ui.textEdit && ((_b2 = this.value.text) == null ? void 0 : _b2.maxChars) && (E2.children[0].attributes.maxLength = this.value.text.maxChars);
        if (e3) {
          if (this.ui.numericEdit) {
            e3 = parseFloat(e3);
            e3 = isNaN(e3) ? "" : e3.toString();
          }
          "textarea" === E2.children[0].name ? E2.children[0].attributes.textContent = e3 : E2.children[0].attributes.value = e3;
        }
      }
    }
    if (!this.ui.imageEdit && ((_c2 = E2.children) == null ? void 0 : _c2[0]) && this.h) {
      n2 = n2 || getBorderDims(this.ui[dr]());
      let t3 = 0;
      if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
        t3 = this.caption.reserve;
        t3 <= 0 && (t3 = this.caption[dr](e2).h);
        const i3 = this.h - t3 - r2 - n2.h;
        E2.children[0].attributes.style.height = measureToString(i3);
      } else
        E2.children[0].attributes.style.height = "100%";
    }
    u2 && E2.children.push(u2);
    if (!t2) {
      E2.attributes.class && E2.attributes.class.push("xfaLeft");
      this.w = i2;
      this.h = a2;
      return HTMLResult.success(createWrapper(this, h2), Q2);
    }
    if (this.ui.button) {
      g2.padding && delete g2.padding;
      "div" === t2.name && (t2.name = "span");
      E2.children.push(t2);
      return HTMLResult.success(h2, Q2);
    }
    this.ui.checkButton && (t2.attributes.class[0] = "xfaCaptionForCheckButton");
    E2.attributes.class || (E2.attributes.class = []);
    E2.children.splice(0, 0, t2);
    switch (this.caption.placement) {
      case "left":
      case "inline":
        E2.attributes.class.push("xfaLeft");
        break;
      case "right":
        E2.attributes.class.push("xfaRight");
        break;
      case "top":
        E2.attributes.class.push("xfaTop");
        break;
      case "bottom":
        E2.attributes.class.push("xfaBottom");
    }
    this.w = i2;
    this.h = a2;
    return HTMLResult.success(createWrapper(this, h2), Q2);
  }
};
var Fill = class extends XFAObject {
  constructor(e2) {
    super(Kn, "fill", true);
    this.id = e2.id || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
    this.linear = null;
    this.pattern = null;
    this.radial = null;
    this.solid = null;
    this.stipple = null;
  }
  [In]() {
    var _a4;
    const e2 = this[Dr](), t2 = e2[Dr]()[Dr](), i2 = /* @__PURE__ */ Object.create(null);
    let a2 = "color", s2 = a2;
    if (e2 instanceof Border) {
      a2 = "background-color";
      s2 = "background";
      t2 instanceof Ui && (i2.backgroundColor = "white");
    }
    if (e2 instanceof Rectangle || e2 instanceof Arc) {
      a2 = s2 = "fill";
      i2.fill = "white";
    }
    for (const e3 of Object.getOwnPropertyNames(this)) {
      if ("extras" === e3 || "color" === e3)
        continue;
      const t3 = this[e3];
      if (!(t3 instanceof XFAObject))
        continue;
      const r2 = t3[In](this.color);
      r2 && (i2[r2.startsWith("#") ? a2 : s2] = r2);
      return i2;
    }
    if ((_a4 = this.color) == null ? void 0 : _a4.value) {
      const e3 = this.color[In]();
      i2[e3.startsWith("#") ? a2 : s2] = e3;
    }
    return i2;
  }
};
var Filter = class extends XFAObject {
  constructor(e2) {
    super(Kn, "filter", true);
    this.addRevocationInfo = getStringOption(e2.addRevocationInfo, ["", "required", "optional", "none"]);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.version = getInteger({ data: this.version, defaultValue: 5, validate: (e3) => e3 >= 1 && e3 <= 5 });
    this.appearanceFilter = null;
    this.certificates = null;
    this.digestMethods = null;
    this.encodings = null;
    this.encryptionMethods = null;
    this.handler = null;
    this.lockDocument = null;
    this.mdp = null;
    this.reasons = null;
    this.timeStamp = null;
  }
};
var Float = class extends ContentObject {
  constructor(e2) {
    super(Kn, "float");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [or]() {
    const e2 = parseFloat(this[sr].trim());
    this[sr] = isNaN(e2) ? null : e2;
  }
  [gn](e2) {
    return valueToHtml(null !== this[sr] ? this[sr].toString() : "");
  }
};
var template_Font = class extends XFAObject {
  constructor(e2) {
    super(Kn, "font", true);
    this.baselineShift = getMeasurement(e2.baselineShift);
    this.fontHorizontalScale = getFloat({ data: e2.fontHorizontalScale, defaultValue: 100, validate: (e3) => e3 >= 0 });
    this.fontVerticalScale = getFloat({ data: e2.fontVerticalScale, defaultValue: 100, validate: (e3) => e3 >= 0 });
    this.id = e2.id || "";
    this.kerningMode = getStringOption(e2.kerningMode, ["none", "pair"]);
    this.letterSpacing = getMeasurement(e2.letterSpacing, "0");
    this.lineThrough = getInteger({ data: e2.lineThrough, defaultValue: 0, validate: (e3) => 1 === e3 || 2 === e3 });
    this.lineThroughPeriod = getStringOption(e2.lineThroughPeriod, ["all", "word"]);
    this.overline = getInteger({ data: e2.overline, defaultValue: 0, validate: (e3) => 1 === e3 || 2 === e3 });
    this.overlinePeriod = getStringOption(e2.overlinePeriod, ["all", "word"]);
    this.posture = getStringOption(e2.posture, ["normal", "italic"]);
    this.size = getMeasurement(e2.size, "10pt");
    this.typeface = e2.typeface || "Courier";
    this.underline = getInteger({ data: e2.underline, defaultValue: 0, validate: (e3) => 1 === e3 || 2 === e3 });
    this.underlinePeriod = getStringOption(e2.underlinePeriod, ["all", "word"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.weight = getStringOption(e2.weight, ["normal", "bold"]);
    this.extras = null;
    this.fill = null;
  }
  [Ar](e2) {
    super[Ar](e2);
    this[Fr].usedTypefaces.add(this.typeface);
  }
  [In]() {
    const e2 = toStyle(this, "fill"), t2 = e2.color;
    if (t2) {
      if ("#000000" === t2)
        delete e2.color;
      else if (!t2.startsWith("#")) {
        e2.background = t2;
        e2.backgroundClip = "text";
        e2.color = "transparent";
      }
    }
    this.baselineShift && (e2.verticalAlign = measureToString(this.baselineShift));
    e2.fontKerning = "none" === this.kerningMode ? "none" : "normal";
    e2.letterSpacing = measureToString(this.letterSpacing);
    if (0 !== this.lineThrough) {
      e2.textDecoration = "line-through";
      2 === this.lineThrough && (e2.textDecorationStyle = "double");
    }
    if (0 !== this.overline) {
      e2.textDecoration = "overline";
      2 === this.overline && (e2.textDecorationStyle = "double");
    }
    e2.fontStyle = this.posture;
    e2.fontSize = measureToString(0.99 * this.size);
    setFontFamily(this, this, this[Fr].fontFinder, e2);
    if (0 !== this.underline) {
      e2.textDecoration = "underline";
      2 === this.underline && (e2.textDecorationStyle = "double");
    }
    e2.fontWeight = this.weight;
    return e2;
  }
};
var Format = class extends XFAObject {
  constructor(e2) {
    super(Kn, "format", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.picture = null;
  }
};
var Handler = class extends StringObject {
  constructor(e2) {
    super(Kn, "handler");
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Hyphenation = class extends XFAObject {
  constructor(e2) {
    super(Kn, "hyphenation");
    this.excludeAllCaps = getInteger({ data: e2.excludeAllCaps, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.excludeInitialCap = getInteger({ data: e2.excludeInitialCap, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.hyphenate = getInteger({ data: e2.hyphenate, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.id = e2.id || "";
    this.pushCharacterCount = getInteger({ data: e2.pushCharacterCount, defaultValue: 3, validate: (e3) => e3 >= 0 });
    this.remainCharacterCount = getInteger({ data: e2.remainCharacterCount, defaultValue: 3, validate: (e3) => e3 >= 0 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.wordCharacterCount = getInteger({ data: e2.wordCharacterCount, defaultValue: 7, validate: (e3) => e3 >= 0 });
  }
};
var Image = class extends StringObject {
  constructor(e2) {
    super(Kn, "image");
    this.aspect = getStringOption(e2.aspect, ["fit", "actual", "height", "none", "width"]);
    this.contentType = e2.contentType || "";
    this.href = e2.href || "";
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.transferEncoding = getStringOption(e2.transferEncoding, ["base64", "none", "package"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [gn]() {
    if (this.contentType && !On.has(this.contentType.toLowerCase()))
      return HTMLResult.EMPTY;
    let e2 = this[Fr].images && this[Fr].images.get(this.href);
    if (!e2 && (this.href || !this[sr]))
      return HTMLResult.EMPTY;
    e2 || "base64" !== this.transferEncoding || (e2 = stringToBytes(atob(this[sr])));
    if (!e2)
      return HTMLResult.EMPTY;
    if (!this.contentType) {
      for (const [t3, i3] of Pn)
        if (e2.length > t3.length && t3.every((t4, i4) => t4 === e2[i4])) {
          this.contentType = i3;
          break;
        }
      if (!this.contentType)
        return HTMLResult.EMPTY;
    }
    const t2 = new Blob([e2], { type: this.contentType });
    let i2;
    switch (this.aspect) {
      case "fit":
      case "actual":
        break;
      case "height":
        i2 = { height: "100%", objectFit: "fill" };
        break;
      case "none":
        i2 = { width: "100%", height: "100%", objectFit: "fill" };
        break;
      case "width":
        i2 = { width: "100%", objectFit: "fill" };
    }
    const a2 = this[Dr]();
    return HTMLResult.success({ name: "img", attributes: { class: ["xfaImage"], style: i2, src: URL.createObjectURL(t2), alt: a2 ? ariaLabel(a2[Dr]()) : null } });
  }
};
var ImageEdit = class extends XFAObject {
  constructor(e2) {
    super(Kn, "imageEdit", true);
    this.data = getStringOption(e2.data, ["link", "embed"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [gn](e2) {
    return "embed" === this.data ? HTMLResult.success({ name: "div", children: [], attributes: {} }) : HTMLResult.EMPTY;
  }
};
var Integer = class extends ContentObject {
  constructor(e2) {
    super(Kn, "integer");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [or]() {
    const e2 = parseInt(this[sr].trim(), 10);
    this[sr] = isNaN(e2) ? null : e2;
  }
  [gn](e2) {
    return valueToHtml(null !== this[sr] ? this[sr].toString() : "");
  }
};
var Issuers = class extends XFAObject {
  constructor(e2) {
    super(Kn, "issuers", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.certificate = new XFAObjectArray();
  }
};
var Items = class extends XFAObject {
  constructor(e2) {
    super(Kn, "items", true);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.ref = e2.ref || "";
    this.save = getInteger({ data: e2.save, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
  [gn]() {
    const e2 = [];
    for (const t2 of this[pr]())
      e2.push(t2[rn]());
    return HTMLResult.success(e2);
  }
};
var Keep = class extends XFAObject {
  constructor(e2) {
    super(Kn, "keep", true);
    this.id = e2.id || "";
    const t2 = ["none", "contentArea", "pageArea"];
    this.intact = getStringOption(e2.intact, t2);
    this.next = getStringOption(e2.next, t2);
    this.previous = getStringOption(e2.previous, t2);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
};
var KeyUsage = class extends XFAObject {
  constructor(e2) {
    super(Kn, "keyUsage");
    const t2 = ["", "yes", "no"];
    this.crlSign = getStringOption(e2.crlSign, t2);
    this.dataEncipherment = getStringOption(e2.dataEncipherment, t2);
    this.decipherOnly = getStringOption(e2.decipherOnly, t2);
    this.digitalSignature = getStringOption(e2.digitalSignature, t2);
    this.encipherOnly = getStringOption(e2.encipherOnly, t2);
    this.id = e2.id || "";
    this.keyAgreement = getStringOption(e2.keyAgreement, t2);
    this.keyCertSign = getStringOption(e2.keyCertSign, t2);
    this.keyEncipherment = getStringOption(e2.keyEncipherment, t2);
    this.nonRepudiation = getStringOption(e2.nonRepudiation, t2);
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Line = class extends XFAObject {
  constructor(e2) {
    super(Kn, "line", true);
    this.hand = getStringOption(e2.hand, ["even", "left", "right"]);
    this.id = e2.id || "";
    this.slope = getStringOption(e2.slope, ["\\", "/"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.edge = null;
  }
  [gn]() {
    const e2 = this[Dr]()[Dr](), t2 = this.edge || new Edge({}), i2 = t2[In](), a2 = /* @__PURE__ */ Object.create(null), s2 = "visible" === t2.presence ? t2.thickness : 0;
    a2.strokeWidth = measureToString(s2);
    a2.stroke = i2.color;
    let r2, n2, g2, o2, c2 = "100%", C2 = "100%";
    if (e2.w <= s2) {
      [r2, n2, g2, o2] = ["50%", 0, "50%", "100%"];
      c2 = a2.strokeWidth;
    } else if (e2.h <= s2) {
      [r2, n2, g2, o2] = [0, "50%", "100%", "50%"];
      C2 = a2.strokeWidth;
    } else
      "\\" === this.slope ? [r2, n2, g2, o2] = [0, 0, "100%", "100%"] : [r2, n2, g2, o2] = [0, "100%", "100%", 0];
    const h2 = { name: "svg", children: [{ name: "line", attributes: { xmlns: Tn, x1: r2, y1: n2, x2: g2, y2: o2, style: a2 } }], attributes: { xmlns: Tn, width: c2, height: C2, style: { overflow: "visible" } } };
    if (hasMargin(e2))
      return HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [h2] });
    h2.attributes.style.position = "absolute";
    return HTMLResult.success(h2);
  }
};
var Linear = class extends XFAObject {
  constructor(e2) {
    super(Kn, "linear", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["toRight", "toBottom", "toLeft", "toTop"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [In](e2) {
    e2 = e2 ? e2[In]() : "#FFFFFF";
    return `linear-gradient(${this.type.replace(/([RBLT])/, " $1").toLowerCase()}, ${e2}, ${this.color ? this.color[In]() : "#000000"})`;
  }
};
var LockDocument = class extends ContentObject {
  constructor(e2) {
    super(Kn, "lockDocument");
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [or]() {
    this[sr] = getStringOption(this[sr], ["auto", "0", "1"]);
  }
};
var Manifest = class extends XFAObject {
  constructor(e2) {
    super(Kn, "manifest", true);
    this.action = getStringOption(e2.action, ["include", "all", "exclude"]);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.ref = new XFAObjectArray();
  }
};
var Margin = class extends XFAObject {
  constructor(e2) {
    super(Kn, "margin", true);
    this.bottomInset = getMeasurement(e2.bottomInset, "0");
    this.id = e2.id || "";
    this.leftInset = getMeasurement(e2.leftInset, "0");
    this.rightInset = getMeasurement(e2.rightInset, "0");
    this.topInset = getMeasurement(e2.topInset, "0");
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
  [In]() {
    return { margin: measureToString(this.topInset) + " " + measureToString(this.rightInset) + " " + measureToString(this.bottomInset) + " " + measureToString(this.leftInset) };
  }
};
var Mdp = class extends XFAObject {
  constructor(e2) {
    super(Kn, "mdp");
    this.id = e2.id || "";
    this.permissions = getInteger({ data: e2.permissions, defaultValue: 2, validate: (e3) => 1 === e3 || 3 === e3 });
    this.signatureType = getStringOption(e2.signatureType, ["filler", "author"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Medium = class extends XFAObject {
  constructor(e2) {
    super(Kn, "medium");
    this.id = e2.id || "";
    this.imagingBBox = function getBBox(e3) {
      const t2 = -1;
      if (!e3)
        return { x: t2, y: t2, width: t2, height: t2 };
      const i2 = e3.trim().split(/\s*,\s*/).map((e4) => getMeasurement(e4, "-1"));
      if (i2.length < 4 || i2[2] < 0 || i2[3] < 0)
        return { x: t2, y: t2, width: t2, height: t2 };
      const [a2, s2, r2, n2] = i2;
      return { x: a2, y: s2, width: r2, height: n2 };
    }(e2.imagingBBox);
    this.long = getMeasurement(e2.long);
    this.orientation = getStringOption(e2.orientation, ["portrait", "landscape"]);
    this.short = getMeasurement(e2.short);
    this.stock = e2.stock || "";
    this.trayIn = getStringOption(e2.trayIn, ["auto", "delegate", "pageFront"]);
    this.trayOut = getStringOption(e2.trayOut, ["auto", "delegate"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Message = class extends XFAObject {
  constructor(e2) {
    super(Kn, "message", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.text = new XFAObjectArray();
  }
};
var NumericEdit = class extends XFAObject {
  constructor(e2) {
    super(Kn, "numericEdit", true);
    this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [gn](e2) {
    var _a4;
    const t2 = toStyle(this, "border", "font", "margin"), i2 = this[Dr]()[Dr](), a2 = { name: "input", attributes: { type: "text", fieldId: i2[cn], dataId: ((_a4 = i2[rr]) == null ? void 0 : _a4[cn]) || i2[cn], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(i2), "aria-required": false } };
    if (isRequired(i2)) {
      a2.attributes["aria-required"] = true;
      a2.attributes.required = true;
    }
    return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [a2] });
  }
};
var Occur = class extends XFAObject {
  constructor(e2) {
    super(Kn, "occur", true);
    this.id = e2.id || "";
    this.initial = "" !== e2.initial ? getInteger({ data: e2.initial, defaultValue: "", validate: (e3) => true }) : "";
    this.max = "" !== e2.max ? getInteger({ data: e2.max, defaultValue: 1, validate: (e3) => true }) : "";
    this.min = "" !== e2.min ? getInteger({ data: e2.min, defaultValue: 1, validate: (e3) => true }) : "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
  [Ar]() {
    const e2 = this[Dr](), t2 = this.min;
    "" === this.min && (this.min = e2 instanceof PageArea || e2 instanceof PageSet ? 0 : 1);
    "" === this.max && (this.max = "" === t2 ? e2 instanceof PageArea || e2 instanceof PageSet ? -1 : 1 : this.min);
    -1 !== this.max && this.max < this.min && (this.max = this.min);
    "" === this.initial && (this.initial = e2 instanceof Template ? 1 : this.min);
  }
};
var Oid = class extends StringObject {
  constructor(e2) {
    super(Kn, "oid");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Oids = class extends XFAObject {
  constructor(e2) {
    super(Kn, "oids", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.oid = new XFAObjectArray();
  }
};
var Overflow = class extends XFAObject {
  constructor(e2) {
    super(Kn, "overflow");
    this.id = e2.id || "";
    this.leader = e2.leader || "";
    this.target = e2.target || "";
    this.trailer = e2.trailer || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [dr]() {
    if (!this[gr]) {
      const e2 = this[Dr](), t2 = this[br](), i2 = t2[An](this.target, e2), a2 = t2[An](this.leader, e2), s2 = t2[An](this.trailer, e2);
      this[gr] = { target: (i2 == null ? void 0 : i2[0]) || null, leader: (a2 == null ? void 0 : a2[0]) || null, trailer: (s2 == null ? void 0 : s2[0]) || null, addLeader: false, addTrailer: false };
    }
    return this[gr];
  }
};
var PageArea = class extends XFAObject {
  constructor(e2) {
    super(Kn, "pageArea", true);
    this.blankOrNotBlank = getStringOption(e2.blankOrNotBlank, ["any", "blank", "notBlank"]);
    this.id = e2.id || "";
    this.initialNumber = getInteger({ data: e2.initialNumber, defaultValue: 1, validate: (e3) => true });
    this.name = e2.name || "";
    this.numbered = getInteger({ data: e2.numbered, defaultValue: 1, validate: (e3) => true });
    this.oddOrEven = getStringOption(e2.oddOrEven, ["any", "even", "odd"]);
    this.pagePosition = getStringOption(e2.pagePosition, ["any", "first", "last", "only", "rest"]);
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.desc = null;
    this.extras = null;
    this.medium = null;
    this.occur = null;
    this.area = new XFAObjectArray();
    this.contentArea = new XFAObjectArray();
    this.draw = new XFAObjectArray();
    this.exclGroup = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.subform = new XFAObjectArray();
  }
  [vr]() {
    if (!this[gr]) {
      this[gr] = { numberOfUse: 0 };
      return true;
    }
    return !this.occur || -1 === this.occur.max || this[gr].numberOfUse < this.occur.max;
  }
  [er]() {
    delete this[gr];
  }
  [yr]() {
    this[gr] || (this[gr] = { numberOfUse: 0 });
    const e2 = this[Dr]();
    if ("orderedOccurrence" === e2.relation && this[vr]()) {
      this[gr].numberOfUse += 1;
      return this;
    }
    return e2[yr]();
  }
  [hr]() {
    return this[gr].space || { width: 0, height: 0 };
  }
  [gn]() {
    this[gr] || (this[gr] = { numberOfUse: 1 });
    const e2 = [];
    this[gr].children = e2;
    const t2 = /* @__PURE__ */ Object.create(null);
    if (this.medium && this.medium.short && this.medium.long) {
      t2.width = measureToString(this.medium.short);
      t2.height = measureToString(this.medium.long);
      this[gr].space = { width: this.medium.short, height: this.medium.long };
      if ("landscape" === this.medium.orientation) {
        const e3 = t2.width;
        t2.width = t2.height;
        t2.height = e3;
        this[gr].space = { width: this.medium.long, height: this.medium.short };
      }
    } else
      warn("XFA - No medium specified in pageArea: please file a bug.");
    this[$s]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]), include: true });
    this[$s]({ filter: /* @__PURE__ */ new Set(["contentArea"]), include: true });
    return HTMLResult.success({ name: "div", children: e2, attributes: { class: ["xfaPage"], id: this[cn], style: t2, xfaName: this.name } });
  }
};
var PageSet = class _PageSet extends XFAObject {
  constructor(e2) {
    super(Kn, "pageSet", true);
    this.duplexImposition = getStringOption(e2.duplexImposition, ["longEdge", "shortEdge"]);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.relation = getStringOption(e2.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]);
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.occur = null;
    this.pageArea = new XFAObjectArray();
    this.pageSet = new XFAObjectArray();
  }
  [er]() {
    for (const e2 of this.pageArea.children)
      e2[er]();
    for (const e2 of this.pageSet.children)
      e2[er]();
  }
  [vr]() {
    return !this.occur || -1 === this.occur.max || this[gr].numberOfUse < this.occur.max;
  }
  [yr]() {
    this[gr] || (this[gr] = { numberOfUse: 1, pageIndex: -1, pageSetIndex: -1 });
    if ("orderedOccurrence" === this.relation) {
      if (this[gr].pageIndex + 1 < this.pageArea.children.length) {
        this[gr].pageIndex += 1;
        return this.pageArea.children[this[gr].pageIndex][yr]();
      }
      if (this[gr].pageSetIndex + 1 < this.pageSet.children.length) {
        this[gr].pageSetIndex += 1;
        return this.pageSet.children[this[gr].pageSetIndex][yr]();
      }
      if (this[vr]()) {
        this[gr].numberOfUse += 1;
        this[gr].pageIndex = -1;
        this[gr].pageSetIndex = -1;
        return this[yr]();
      }
      const e3 = this[Dr]();
      if (e3 instanceof _PageSet)
        return e3[yr]();
      this[er]();
      return this[yr]();
    }
    const e2 = this[br]()[gr].pageNumber, t2 = e2 % 2 == 0 ? "even" : "odd", i2 = 0 === e2 ? "first" : "rest";
    let a2 = this.pageArea.children.find((e3) => e3.oddOrEven === t2 && e3.pagePosition === i2);
    if (a2)
      return a2;
    a2 = this.pageArea.children.find((e3) => "any" === e3.oddOrEven && e3.pagePosition === i2);
    if (a2)
      return a2;
    a2 = this.pageArea.children.find((e3) => "any" === e3.oddOrEven && "any" === e3.pagePosition);
    return a2 || this.pageArea.children[0];
  }
};
var Para = class extends XFAObject {
  constructor(e2) {
    super(Kn, "para", true);
    this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = e2.id || "";
    this.lineHeight = e2.lineHeight ? getMeasurement(e2.lineHeight, "0pt") : "";
    this.marginLeft = e2.marginLeft ? getMeasurement(e2.marginLeft, "0pt") : "";
    this.marginRight = e2.marginRight ? getMeasurement(e2.marginRight, "0pt") : "";
    this.orphans = getInteger({ data: e2.orphans, defaultValue: 0, validate: (e3) => e3 >= 0 });
    this.preserve = e2.preserve || "";
    this.radixOffset = e2.radixOffset ? getMeasurement(e2.radixOffset, "0pt") : "";
    this.spaceAbove = e2.spaceAbove ? getMeasurement(e2.spaceAbove, "0pt") : "";
    this.spaceBelow = e2.spaceBelow ? getMeasurement(e2.spaceBelow, "0pt") : "";
    this.tabDefault = e2.tabDefault ? getMeasurement(this.tabDefault) : "";
    this.tabStops = (e2.tabStops || "").trim().split(/\s+/).map((e3, t2) => t2 % 2 == 1 ? getMeasurement(e3) : e3);
    this.textIndent = e2.textIndent ? getMeasurement(e2.textIndent, "0pt") : "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.vAlign = getStringOption(e2.vAlign, ["top", "bottom", "middle"]);
    this.widows = getInteger({ data: e2.widows, defaultValue: 0, validate: (e3) => e3 >= 0 });
    this.hyphenation = null;
  }
  [In]() {
    const e2 = toStyle(this, "hAlign");
    "" !== this.marginLeft && (e2.paddingLeft = measureToString(this.marginLeft));
    "" !== this.marginRight && (e2.paddingight = measureToString(this.marginRight));
    "" !== this.spaceAbove && (e2.paddingTop = measureToString(this.spaceAbove));
    "" !== this.spaceBelow && (e2.paddingBottom = measureToString(this.spaceBelow));
    if ("" !== this.textIndent) {
      e2.textIndent = measureToString(this.textIndent);
      fixTextIndent(e2);
    }
    this.lineHeight > 0 && (e2.lineHeight = measureToString(this.lineHeight));
    "" !== this.tabDefault && (e2.tabSize = measureToString(this.tabDefault));
    this.tabStops.length;
    this.hyphenatation && Object.assign(e2, this.hyphenatation[In]());
    return e2;
  }
};
var PasswordEdit = class extends XFAObject {
  constructor(e2) {
    super(Kn, "passwordEdit", true);
    this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]);
    this.id = e2.id || "";
    this.passwordChar = e2.passwordChar || "*";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
};
var template_Pattern = class extends XFAObject {
  constructor(e2) {
    super(Kn, "pattern", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [In](e2) {
    e2 = e2 ? e2[In]() : "#FFFFFF";
    const t2 = this.color ? this.color[In]() : "#000000", i2 = "repeating-linear-gradient", a2 = `${e2},${e2} 5px,${t2} 5px,${t2} 10px`;
    switch (this.type) {
      case "crossHatch":
        return `${i2}(to top,${a2}) ${i2}(to right,${a2})`;
      case "crossDiagonal":
        return `${i2}(45deg,${a2}) ${i2}(-45deg,${a2})`;
      case "diagonalLeft":
        return `${i2}(45deg,${a2})`;
      case "diagonalRight":
        return `${i2}(-45deg,${a2})`;
      case "horizontal":
        return `${i2}(to top,${a2})`;
      case "vertical":
        return `${i2}(to right,${a2})`;
    }
    return "";
  }
};
var Picture = class extends StringObject {
  constructor(e2) {
    super(Kn, "picture");
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Proto = class extends XFAObject {
  constructor(e2) {
    super(Kn, "proto", true);
    this.appearanceFilter = new XFAObjectArray();
    this.arc = new XFAObjectArray();
    this.area = new XFAObjectArray();
    this.assist = new XFAObjectArray();
    this.barcode = new XFAObjectArray();
    this.bindItems = new XFAObjectArray();
    this.bookend = new XFAObjectArray();
    this.boolean = new XFAObjectArray();
    this.border = new XFAObjectArray();
    this.break = new XFAObjectArray();
    this.breakAfter = new XFAObjectArray();
    this.breakBefore = new XFAObjectArray();
    this.button = new XFAObjectArray();
    this.calculate = new XFAObjectArray();
    this.caption = new XFAObjectArray();
    this.certificate = new XFAObjectArray();
    this.certificates = new XFAObjectArray();
    this.checkButton = new XFAObjectArray();
    this.choiceList = new XFAObjectArray();
    this.color = new XFAObjectArray();
    this.comb = new XFAObjectArray();
    this.connect = new XFAObjectArray();
    this.contentArea = new XFAObjectArray();
    this.corner = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.dateTimeEdit = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.defaultUi = new XFAObjectArray();
    this.desc = new XFAObjectArray();
    this.digestMethod = new XFAObjectArray();
    this.digestMethods = new XFAObjectArray();
    this.draw = new XFAObjectArray();
    this.edge = new XFAObjectArray();
    this.encoding = new XFAObjectArray();
    this.encodings = new XFAObjectArray();
    this.encrypt = new XFAObjectArray();
    this.encryptData = new XFAObjectArray();
    this.encryption = new XFAObjectArray();
    this.encryptionMethod = new XFAObjectArray();
    this.encryptionMethods = new XFAObjectArray();
    this.event = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.exObject = new XFAObjectArray();
    this.exclGroup = new XFAObjectArray();
    this.execute = new XFAObjectArray();
    this.extras = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.fill = new XFAObjectArray();
    this.filter = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.font = new XFAObjectArray();
    this.format = new XFAObjectArray();
    this.handler = new XFAObjectArray();
    this.hyphenation = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.imageEdit = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.issuers = new XFAObjectArray();
    this.items = new XFAObjectArray();
    this.keep = new XFAObjectArray();
    this.keyUsage = new XFAObjectArray();
    this.line = new XFAObjectArray();
    this.linear = new XFAObjectArray();
    this.lockDocument = new XFAObjectArray();
    this.manifest = new XFAObjectArray();
    this.margin = new XFAObjectArray();
    this.mdp = new XFAObjectArray();
    this.medium = new XFAObjectArray();
    this.message = new XFAObjectArray();
    this.numericEdit = new XFAObjectArray();
    this.occur = new XFAObjectArray();
    this.oid = new XFAObjectArray();
    this.oids = new XFAObjectArray();
    this.overflow = new XFAObjectArray();
    this.pageArea = new XFAObjectArray();
    this.pageSet = new XFAObjectArray();
    this.para = new XFAObjectArray();
    this.passwordEdit = new XFAObjectArray();
    this.pattern = new XFAObjectArray();
    this.picture = new XFAObjectArray();
    this.radial = new XFAObjectArray();
    this.reason = new XFAObjectArray();
    this.reasons = new XFAObjectArray();
    this.rectangle = new XFAObjectArray();
    this.ref = new XFAObjectArray();
    this.script = new XFAObjectArray();
    this.setProperty = new XFAObjectArray();
    this.signData = new XFAObjectArray();
    this.signature = new XFAObjectArray();
    this.signing = new XFAObjectArray();
    this.solid = new XFAObjectArray();
    this.speak = new XFAObjectArray();
    this.stipple = new XFAObjectArray();
    this.subform = new XFAObjectArray();
    this.subformSet = new XFAObjectArray();
    this.subjectDN = new XFAObjectArray();
    this.subjectDNs = new XFAObjectArray();
    this.submit = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.textEdit = new XFAObjectArray();
    this.time = new XFAObjectArray();
    this.timeStamp = new XFAObjectArray();
    this.toolTip = new XFAObjectArray();
    this.traversal = new XFAObjectArray();
    this.traverse = new XFAObjectArray();
    this.ui = new XFAObjectArray();
    this.validate = new XFAObjectArray();
    this.value = new XFAObjectArray();
    this.variables = new XFAObjectArray();
  }
};
var Radial = class extends XFAObject {
  constructor(e2) {
    super(Kn, "radial", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["toEdge", "toCenter"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [In](e2) {
    e2 = e2 ? e2[In]() : "#FFFFFF";
    const t2 = this.color ? this.color[In]() : "#000000";
    return `radial-gradient(circle at center, ${"toEdge" === this.type ? `${e2},${t2}` : `${t2},${e2}`})`;
  }
};
var Reason = class extends StringObject {
  constructor(e2) {
    super(Kn, "reason");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Reasons = class extends XFAObject {
  constructor(e2) {
    super(Kn, "reasons", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.reason = new XFAObjectArray();
  }
};
var Rectangle = class extends XFAObject {
  constructor(e2) {
    super(Kn, "rectangle", true);
    this.hand = getStringOption(e2.hand, ["even", "left", "right"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.corner = new XFAObjectArray(4);
    this.edge = new XFAObjectArray(4);
    this.fill = null;
  }
  [gn]() {
    var _a4;
    const e2 = this.edge.children.length ? this.edge.children[0] : new Edge({}), t2 = e2[In](), i2 = /* @__PURE__ */ Object.create(null);
    "visible" === ((_a4 = this.fill) == null ? void 0 : _a4.presence) ? Object.assign(i2, this.fill[In]()) : i2.fill = "transparent";
    i2.strokeWidth = measureToString("visible" === e2.presence ? e2.thickness : 0);
    i2.stroke = t2.color;
    const a2 = (this.corner.children.length ? this.corner.children[0] : new Corner({}))[In](), s2 = { name: "svg", children: [{ name: "rect", attributes: { xmlns: Tn, width: "100%", height: "100%", x: 0, y: 0, rx: a2.radius, ry: a2.radius, style: i2 } }], attributes: { xmlns: Tn, style: { overflow: "visible" }, width: "100%", height: "100%" } };
    if (hasMargin(this[Dr]()[Dr]()))
      return HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [s2] });
    s2.attributes.style.position = "absolute";
    return HTMLResult.success(s2);
  }
};
var RefElement = class extends StringObject {
  constructor(e2) {
    super(Kn, "ref");
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Script = class extends StringObject {
  constructor(e2) {
    super(Kn, "script");
    this.binding = e2.binding || "";
    this.contentType = e2.contentType || "";
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.runAt = getStringOption(e2.runAt, ["client", "both", "server"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var SetProperty = class extends XFAObject {
  constructor(e2) {
    super(Kn, "setProperty");
    this.connection = e2.connection || "";
    this.ref = e2.ref || "";
    this.target = e2.target || "";
  }
};
var SignData = class extends XFAObject {
  constructor(e2) {
    super(Kn, "signData", true);
    this.id = e2.id || "";
    this.operation = getStringOption(e2.operation, ["sign", "clear", "verify"]);
    this.ref = e2.ref || "";
    this.target = e2.target || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.filter = null;
    this.manifest = null;
  }
};
var Signature = class extends XFAObject {
  constructor(e2) {
    super(Kn, "signature", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["PDF1.3", "PDF1.6"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.extras = null;
    this.filter = null;
    this.manifest = null;
    this.margin = null;
  }
};
var Signing = class extends XFAObject {
  constructor(e2) {
    super(Kn, "signing", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.certificate = new XFAObjectArray();
  }
};
var Solid = class extends XFAObject {
  constructor(e2) {
    super(Kn, "solid", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
  [In](e2) {
    return e2 ? e2[In]() : "#FFFFFF";
  }
};
var Speak = class extends StringObject {
  constructor(e2) {
    super(Kn, "speak");
    this.disable = getInteger({ data: e2.disable, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.id = e2.id || "";
    this.priority = getStringOption(e2.priority, ["custom", "caption", "name", "toolTip"]);
    this.rid = e2.rid || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Stipple = class extends XFAObject {
  constructor(e2) {
    super(Kn, "stipple", true);
    this.id = e2.id || "";
    this.rate = getInteger({ data: e2.rate, defaultValue: 50, validate: (e3) => e3 >= 0 && e3 <= 100 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [In](e2) {
    const t2 = this.rate / 100;
    return Util.makeHexColor(Math.round(e2.value.r * (1 - t2) + this.value.r * t2), Math.round(e2.value.g * (1 - t2) + this.value.g * t2), Math.round(e2.value.b * (1 - t2) + this.value.b * t2));
  }
};
var Subform = class extends XFAObject {
  constructor(e2) {
    super(Kn, "subform", true);
    this.access = getStringOption(e2.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.allowMacro = getInteger({ data: e2.allowMacro, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 });
    this.columnWidths = (e2.columnWidths || "").trim().split(/\s+/).map((e3) => "-1" === e3 ? -1 : getMeasurement(e3));
    this.h = e2.h ? getMeasurement(e2.h) : "";
    this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = e2.id || "";
    this.layout = getStringOption(e2.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
    this.locale = e2.locale || "";
    this.maxH = getMeasurement(e2.maxH, "0pt");
    this.maxW = getMeasurement(e2.maxW, "0pt");
    this.mergeMode = getStringOption(e2.mergeMode, ["consumeData", "matchTemplate"]);
    this.minH = getMeasurement(e2.minH, "0pt");
    this.minW = getMeasurement(e2.minW, "0pt");
    this.name = e2.name || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(e2.relevant);
    this.restoreState = getStringOption(e2.restoreState, ["manual", "auto"]);
    this.scope = getStringOption(e2.scope, ["name", "none"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.w = e2.w ? getMeasurement(e2.w) : "";
    this.x = getMeasurement(e2.x, "0pt");
    this.y = getMeasurement(e2.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.bookend = null;
    this.border = null;
    this.break = null;
    this.calculate = null;
    this.desc = null;
    this.extras = null;
    this.keep = null;
    this.margin = null;
    this.occur = null;
    this.overflow = null;
    this.pageSet = null;
    this.para = null;
    this.traversal = null;
    this.validate = null;
    this.variables = null;
    this.area = new XFAObjectArray();
    this.breakAfter = new XFAObjectArray();
    this.breakBefore = new XFAObjectArray();
    this.connect = new XFAObjectArray();
    this.draw = new XFAObjectArray();
    this.event = new XFAObjectArray();
    this.exObject = new XFAObjectArray();
    this.exclGroup = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.proto = new XFAObjectArray();
    this.setProperty = new XFAObjectArray();
    this.subform = new XFAObjectArray();
    this.subformSet = new XFAObjectArray();
  }
  [wr]() {
    const e2 = this[Dr]();
    return e2 instanceof SubformSet ? e2[wr]() : e2;
  }
  [xr]() {
    return true;
  }
  [Jr]() {
    return this.layout.endsWith("-tb") && 0 === this[gr].attempt && this[gr].numberInLine > 0 || this[Dr]()[Jr]();
  }
  *[mr]() {
    yield* getContainedChildren(this);
  }
  [Ir]() {
    return flushHTML(this);
  }
  [zs](e2, t2) {
    addHTML(this, e2, t2);
  }
  [hr]() {
    return getAvailableSpace(this);
  }
  [Hr]() {
    var _a4;
    const e2 = this[wr]();
    if (!e2[Hr]())
      return false;
    if (void 0 !== this[gr]._isSplittable)
      return this[gr]._isSplittable;
    if ("position" === this.layout || this.layout.includes("row")) {
      this[gr]._isSplittable = false;
      return false;
    }
    if (this.keep && "none" !== this.keep.intact) {
      this[gr]._isSplittable = false;
      return false;
    }
    if (((_a4 = e2.layout) == null ? void 0 : _a4.endsWith("-tb")) && 0 !== e2[gr].numberInLine)
      return false;
    this[gr]._isSplittable = true;
    return true;
  }
  [gn](e2) {
    var _a4;
    setTabIndex(this);
    if (this.break) {
      if ("auto" !== this.break.after || "" !== this.break.afterTarget) {
        const e3 = new BreakAfter({ targetType: this.break.after, target: this.break.afterTarget, startNew: this.break.startNew.toString() });
        e3[Fr] = this[Fr];
        this[_s2](e3);
        this.breakAfter.push(e3);
      }
      if ("auto" !== this.break.before || "" !== this.break.beforeTarget) {
        const e3 = new BreakBefore({ targetType: this.break.before, target: this.break.beforeTarget, startNew: this.break.startNew.toString() });
        e3[Fr] = this[Fr];
        this[_s2](e3);
        this.breakBefore.push(e3);
      }
      if ("" !== this.break.overflowTarget) {
        const e3 = new Overflow({ target: this.break.overflowTarget, leader: this.break.overflowLeader, trailer: this.break.overflowTrailer });
        e3[Fr] = this[Fr];
        this[_s2](e3);
        this.overflow.push(e3);
      }
      this[zr](this.break);
      this.break = null;
    }
    if ("hidden" === this.presence || "inactive" === this.presence)
      return HTMLResult.EMPTY;
    (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && warn("XFA - Several breakBefore or breakAfter in subforms: please file a bug.");
    if (this.breakBefore.children.length >= 1) {
      const e3 = this.breakBefore.children[0];
      if (handleBreak(e3))
        return HTMLResult.breakNode(e3);
    }
    if ((_a4 = this[gr]) == null ? void 0 : _a4.afterBreakAfter)
      return HTMLResult.EMPTY;
    fixDimensions(this);
    const t2 = [], i2 = { id: this[cn], class: [] };
    setAccess(this, i2.class);
    this[gr] || (this[gr] = /* @__PURE__ */ Object.create(null));
    Object.assign(this[gr], { children: t2, line: null, attributes: i2, attempt: 0, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e2.width), height: Math.min(this.h || 1 / 0, e2.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
    const a2 = this[br](), s2 = a2[gr].noLayoutFailure, r2 = this[Hr]();
    r2 || setFirstUnsplittable(this);
    if (!checkDimensions(this, e2))
      return HTMLResult.FAILURE;
    const n2 = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
    if (this.layout.includes("row")) {
      const e3 = this[wr]().columnWidths;
      if (Array.isArray(e3) && e3.length > 0) {
        this[gr].columnWidths = e3;
        this[gr].currentColumn = 0;
      }
    }
    const g2 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), o2 = ["xfaSubform"], c2 = layoutClass(this);
    c2 && o2.push(c2);
    i2.style = g2;
    i2.class = o2;
    this.name && (i2.xfaName = this.name);
    if (this.overflow) {
      const t3 = this.overflow[dr]();
      if (t3.addLeader) {
        t3.addLeader = false;
        handleOverflow(this, t3.leader, e2);
      }
    }
    this[Vr]();
    const C2 = "lr-tb" === this.layout || "rl-tb" === this.layout, h2 = C2 ? 2 : 1;
    for (; this[gr].attempt < h2; this[gr].attempt++) {
      C2 && 1 === this[gr].attempt && (this[gr].numberInLine = 0);
      const e3 = this[$s]({ filter: n2, include: true });
      if (e3.success)
        break;
      if (e3.isBreak()) {
        this[Zr]();
        return e3;
      }
      if (C2 && 0 === this[gr].attempt && 0 === this[gr].numberInLine && !a2[gr].noLayoutFailure) {
        this[gr].attempt = h2;
        break;
      }
    }
    this[Zr]();
    r2 || unsetFirstUnsplittable(this);
    a2[gr].noLayoutFailure = s2;
    if (this[gr].attempt === h2) {
      this.overflow && (this[br]()[gr].overflowNode = this.overflow);
      r2 || delete this[gr];
      return HTMLResult.FAILURE;
    }
    if (this.overflow) {
      const t3 = this.overflow[dr]();
      if (t3.addTrailer) {
        t3.addTrailer = false;
        handleOverflow(this, t3.trailer, e2);
      }
    }
    let l2 = 0, Q2 = 0;
    if (this.margin) {
      l2 = this.margin.leftInset + this.margin.rightInset;
      Q2 = this.margin.topInset + this.margin.bottomInset;
    }
    const E2 = Math.max(this[gr].width + l2, this.w || 0), u2 = Math.max(this[gr].height + Q2, this.h || 0), d2 = [this.x, this.y, E2, u2];
    "" === this.w && (g2.width = measureToString(E2));
    "" === this.h && (g2.height = measureToString(u2));
    if (("0px" === g2.width || "0px" === g2.height) && 0 === t2.length)
      return HTMLResult.EMPTY;
    const f2 = { name: "div", attributes: i2, children: t2 };
    applyAssist(this, i2);
    const p2 = HTMLResult.success(createWrapper(this, f2), d2);
    if (this.breakAfter.children.length >= 1) {
      const e3 = this.breakAfter.children[0];
      if (handleBreak(e3)) {
        this[gr].afterBreakAfter = p2;
        return HTMLResult.breakNode(e3);
      }
    }
    delete this[gr];
    return p2;
  }
};
var SubformSet = class extends XFAObject {
  constructor(e2) {
    super(Kn, "subformSet", true);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.relation = getStringOption(e2.relation, ["ordered", "choice", "unordered"]);
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.bookend = null;
    this.break = null;
    this.desc = null;
    this.extras = null;
    this.occur = null;
    this.overflow = null;
    this.breakAfter = new XFAObjectArray();
    this.breakBefore = new XFAObjectArray();
    this.subform = new XFAObjectArray();
    this.subformSet = new XFAObjectArray();
  }
  *[mr]() {
    yield* getContainedChildren(this);
  }
  [wr]() {
    let e2 = this[Dr]();
    for (; !(e2 instanceof Subform); )
      e2 = e2[Dr]();
    return e2;
  }
  [xr]() {
    return true;
  }
};
var SubjectDN = class extends ContentObject {
  constructor(e2) {
    super(Kn, "subjectDN");
    this.delimiter = e2.delimiter || ",";
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [or]() {
    this[sr] = new Map(this[sr].split(this.delimiter).map((e2) => {
      (e2 = e2.split("=", 2))[0] = e2[0].trim();
      return e2;
    }));
  }
};
var SubjectDNs = class extends XFAObject {
  constructor(e2) {
    super(Kn, "subjectDNs", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.subjectDN = new XFAObjectArray();
  }
};
var Submit = class extends XFAObject {
  constructor(e2) {
    super(Kn, "submit", true);
    this.embedPDF = getInteger({ data: e2.embedPDF, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.format = getStringOption(e2.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]);
    this.id = e2.id || "";
    this.target = e2.target || "";
    this.textEncoding = getKeyword({ data: e2.textEncoding ? e2.textEncoding.toLowerCase() : "", defaultValue: "", validate: (e3) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e3) || e3.match(/iso-8859-\d{2}/) });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.xdpContent = e2.xdpContent || "";
    this.encrypt = null;
    this.encryptData = new XFAObjectArray();
    this.signData = new XFAObjectArray();
  }
};
var Template = class extends XFAObject {
  constructor(e2) {
    super(Kn, "template", true);
    this.baseProfile = getStringOption(e2.baseProfile, ["full", "interactiveForms"]);
    this.extras = null;
    this.subform = new XFAObjectArray();
  }
  [or]() {
    0 === this.subform.children.length && warn("XFA - No subforms in template node.");
    this.subform.children.length >= 2 && warn("XFA - Several subforms in template node: please file a bug.");
    this[sn] = 5e3;
  }
  [Hr]() {
    return true;
  }
  [An](e2, t2) {
    return e2.startsWith("#") ? [this[kr].get(e2.slice(1))] : searchNode(this, t2, e2, true, true);
  }
  *[nn]() {
    var _a4, _b2, _c2;
    if (!this.subform.children.length)
      return HTMLResult.success({ name: "div", children: [] });
    this[gr] = { overflowNode: null, firstUnsplittable: null, currentContentArea: null, currentPageArea: null, noLayoutFailure: false, pageNumber: 1, pagePosition: "first", oddOrEven: "odd", blankOrNotBlank: "nonBlank", paraStack: [] };
    const e2 = this.subform.children[0];
    e2.pageSet[er]();
    const t2 = e2.pageSet.pageArea.children, i2 = { name: "div", children: [] };
    let a2 = null, s2 = null, r2 = null;
    if (e2.breakBefore.children.length >= 1) {
      s2 = e2.breakBefore.children[0];
      r2 = s2.target;
    } else if (e2.subform.children.length >= 1 && e2.subform.children[0].breakBefore.children.length >= 1) {
      s2 = e2.subform.children[0].breakBefore.children[0];
      r2 = s2.target;
    } else if ((_a4 = e2.break) == null ? void 0 : _a4.beforeTarget) {
      s2 = e2.break;
      r2 = s2.beforeTarget;
    } else if (e2.subform.children.length >= 1 && ((_b2 = e2.subform.children[0].break) == null ? void 0 : _b2.beforeTarget)) {
      s2 = e2.subform.children[0].break;
      r2 = s2.beforeTarget;
    }
    if (s2) {
      const e3 = this[An](r2, s2[Dr]());
      if (e3 instanceof PageArea) {
        a2 = e3;
        s2[gr] = {};
      }
    }
    a2 || (a2 = t2[0]);
    a2[gr] = { numberOfUse: 1 };
    const n2 = a2[Dr]();
    n2[gr] = { numberOfUse: 1, pageIndex: n2.pageArea.children.indexOf(a2), pageSetIndex: 0 };
    let g2, o2 = null, c2 = null, C2 = true, h2 = 0, l2 = 0;
    for (; ; ) {
      if (C2)
        h2 = 0;
      else {
        i2.children.pop();
        if (3 == ++h2) {
          warn("XFA - Something goes wrong: please file a bug.");
          return i2;
        }
      }
      g2 = null;
      this[gr].currentPageArea = a2;
      const t3 = a2[gn]().html;
      i2.children.push(t3);
      if (o2) {
        this[gr].noLayoutFailure = true;
        t3.children.push(o2[gn](a2[gr].space).html);
        o2 = null;
      }
      if (c2) {
        this[gr].noLayoutFailure = true;
        t3.children.push(c2[gn](a2[gr].space).html);
        c2 = null;
      }
      const s3 = a2.contentArea.children, r3 = t3.children.filter((e3) => e3.attributes.class.includes("xfaContentarea"));
      C2 = false;
      this[gr].firstUnsplittable = null;
      this[gr].noLayoutFailure = false;
      const flush = (t4) => {
        var _a5;
        const i3 = e2[Ir]();
        if (i3) {
          C2 || (C2 = ((_a5 = i3.children) == null ? void 0 : _a5.length) > 0);
          r3[t4].children.push(i3);
        }
      };
      for (let t4 = l2, a3 = s3.length; t4 < a3; t4++) {
        const a4 = this[gr].currentContentArea = s3[t4], n3 = { width: a4.w, height: a4.h };
        l2 = 0;
        if (o2) {
          r3[t4].children.push(o2[gn](n3).html);
          o2 = null;
        }
        if (c2) {
          r3[t4].children.push(c2[gn](n3).html);
          c2 = null;
        }
        const h3 = e2[gn](n3);
        if (h3.success) {
          if (h3.html) {
            C2 || (C2 = ((_c2 = h3.html.children) == null ? void 0 : _c2.length) > 0);
            r3[t4].children.push(h3.html);
          } else
            !C2 && i2.children.length > 1 && i2.children.pop();
          return i2;
        }
        if (h3.isBreak()) {
          const e3 = h3.breakNode;
          flush(t4);
          if ("auto" === e3.targetType)
            continue;
          if (e3.leader) {
            o2 = this[An](e3.leader, e3[Dr]());
            o2 = o2 ? o2[0] : null;
          }
          if (e3.trailer) {
            c2 = this[An](e3.trailer, e3[Dr]());
            c2 = c2 ? c2[0] : null;
          }
          if ("pageArea" === e3.targetType) {
            g2 = e3[gr].target;
            t4 = 1 / 0;
          } else if (e3[gr].target) {
            g2 = e3[gr].target;
            l2 = e3[gr].index + 1;
            t4 = 1 / 0;
          } else
            t4 = e3[gr].index;
        } else if (this[gr].overflowNode) {
          const e3 = this[gr].overflowNode;
          this[gr].overflowNode = null;
          const i3 = e3[dr](), a5 = i3.target;
          i3.addLeader = null !== i3.leader;
          i3.addTrailer = null !== i3.trailer;
          flush(t4);
          const r4 = t4;
          t4 = 1 / 0;
          if (a5 instanceof PageArea)
            g2 = a5;
          else if (a5 instanceof ContentArea) {
            const e4 = s3.indexOf(a5);
            if (-1 !== e4)
              e4 > r4 ? t4 = e4 - 1 : l2 = e4;
            else {
              g2 = a5[Dr]();
              l2 = g2.contentArea.children.indexOf(a5);
            }
          }
        } else
          flush(t4);
      }
      this[gr].pageNumber += 1;
      g2 && (g2[vr]() ? g2[gr].numberOfUse += 1 : g2 = null);
      a2 = g2 || a2[yr]();
      yield null;
    }
  }
};
var Text = class extends ContentObject {
  constructor(e2) {
    super(Kn, "text");
    this.id = e2.id || "";
    this.maxChars = getInteger({ data: e2.maxChars, defaultValue: 0, validate: (e3) => e3 >= 0 });
    this.name = e2.name || "";
    this.rid = e2.rid || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [Vs]() {
    return true;
  }
  [Pr](e2) {
    if (e2[Tr] === hn.xhtml.id) {
      this[sr] = e2;
      return true;
    }
    warn(`XFA - Invalid content in Text: ${e2[qr]}.`);
    return false;
  }
  [jr](e2) {
    this[sr] instanceof XFAObject || super[jr](e2);
  }
  [or]() {
    "string" == typeof this[sr] && (this[sr] = this[sr].replaceAll("\r\n", "\n"));
  }
  [dr]() {
    return "string" == typeof this[sr] ? this[sr].split(/[\u2029\u2028\n]/).reduce((e2, t2) => {
      t2 && e2.push(t2);
      return e2;
    }, []).join("\n") : this[sr][rn]();
  }
  [gn](e2) {
    if ("string" == typeof this[sr]) {
      const e3 = valueToHtml(this[sr]).html;
      if (this[sr].includes("\u2029")) {
        e3.name = "div";
        e3.children = [];
        this[sr].split("\u2029").map((e4) => e4.split(/[\u2028\n]/).reduce((e5, t2) => {
          e5.push({ name: "span", value: t2 }, { name: "br" });
          return e5;
        }, [])).forEach((t2) => {
          e3.children.push({ name: "p", children: t2 });
        });
      } else if (/[\u2028\n]/.test(this[sr])) {
        e3.name = "div";
        e3.children = [];
        this[sr].split(/[\u2028\n]/).forEach((t2) => {
          e3.children.push({ name: "span", value: t2 }, { name: "br" });
        });
      }
      return HTMLResult.success(e3);
    }
    return this[sr][gn](e2);
  }
};
var TextEdit = class extends XFAObject {
  constructor(e2) {
    super(Kn, "textEdit", true);
    this.allowRichText = getInteger({ data: e2.allowRichText, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]);
    this.id = e2.id || "";
    this.multiLine = getInteger({ data: e2.multiLine, defaultValue: "", validate: (e3) => 0 === e3 || 1 === e3 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.vScrollPolicy = getStringOption(e2.vScrollPolicy, ["auto", "off", "on"]);
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [gn](e2) {
    var _a4, _b2;
    const t2 = toStyle(this, "border", "font", "margin");
    let i2;
    const a2 = this[Dr]()[Dr]();
    "" === this.multiLine && (this.multiLine = a2 instanceof Draw ? 1 : 0);
    i2 = 1 === this.multiLine ? { name: "textarea", attributes: { dataId: ((_a4 = a2[rr]) == null ? void 0 : _a4[cn]) || a2[cn], fieldId: a2[cn], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(a2), "aria-required": false } } : { name: "input", attributes: { type: "text", dataId: ((_b2 = a2[rr]) == null ? void 0 : _b2[cn]) || a2[cn], fieldId: a2[cn], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(a2), "aria-required": false } };
    if (isRequired(a2)) {
      i2.attributes["aria-required"] = true;
      i2.attributes.required = true;
    }
    return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [i2] });
  }
};
var Time = class extends StringObject {
  constructor(e2) {
    super(Kn, "time");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [or]() {
    const e2 = this[sr].trim();
    this[sr] = e2 ? new Date(e2) : null;
  }
  [gn](e2) {
    return valueToHtml(this[sr] ? this[sr].toString() : "");
  }
};
var TimeStamp = class extends XFAObject {
  constructor(e2) {
    super(Kn, "timeStamp");
    this.id = e2.id || "";
    this.server = e2.server || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var ToolTip = class extends StringObject {
  constructor(e2) {
    super(Kn, "toolTip");
    this.id = e2.id || "";
    this.rid = e2.rid || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Traversal = class extends XFAObject {
  constructor(e2) {
    super(Kn, "traversal", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.traverse = new XFAObjectArray();
  }
};
var Traverse = class extends XFAObject {
  constructor(e2) {
    super(Kn, "traverse", true);
    this.id = e2.id || "";
    this.operation = getStringOption(e2.operation, ["next", "back", "down", "first", "left", "right", "up"]);
    this.ref = e2.ref || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.script = null;
  }
  get name() {
    return this.operation;
  }
  [Yr]() {
    return false;
  }
};
var Ui = class extends XFAObject {
  constructor(e2) {
    super(Kn, "ui", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.picture = null;
    this.barcode = null;
    this.button = null;
    this.checkButton = null;
    this.choiceList = null;
    this.dateTimeEdit = null;
    this.defaultUi = null;
    this.imageEdit = null;
    this.numericEdit = null;
    this.passwordEdit = null;
    this.signature = null;
    this.textEdit = null;
  }
  [dr]() {
    if (void 0 === this[gr]) {
      for (const e2 of Object.getOwnPropertyNames(this)) {
        if ("extras" === e2 || "picture" === e2)
          continue;
        const t2 = this[e2];
        if (t2 instanceof XFAObject) {
          this[gr] = t2;
          return t2;
        }
      }
      this[gr] = null;
    }
    return this[gr];
  }
  [gn](e2) {
    const t2 = this[dr]();
    return t2 ? t2[gn](e2) : HTMLResult.EMPTY;
  }
};
var Validate = class extends XFAObject {
  constructor(e2) {
    super(Kn, "validate", true);
    this.formatTest = getStringOption(e2.formatTest, ["warning", "disabled", "error"]);
    this.id = e2.id || "";
    this.nullTest = getStringOption(e2.nullTest, ["disabled", "error", "warning"]);
    this.scriptTest = getStringOption(e2.scriptTest, ["error", "disabled", "warning"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.message = null;
    this.picture = null;
    this.script = null;
  }
};
var Value = class extends XFAObject {
  constructor(e2) {
    super(Kn, "value", true);
    this.id = e2.id || "";
    this.override = getInteger({ data: e2.override, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.arc = null;
    this.boolean = null;
    this.date = null;
    this.dateTime = null;
    this.decimal = null;
    this.exData = null;
    this.float = null;
    this.image = null;
    this.integer = null;
    this.line = null;
    this.rectangle = null;
    this.text = null;
    this.time = null;
  }
  [an](e2) {
    var _a4;
    const t2 = this[Dr]();
    if (t2 instanceof Field && ((_a4 = t2.ui) == null ? void 0 : _a4.imageEdit)) {
      if (!this.image) {
        this.image = new Image({});
        this[_s2](this.image);
      }
      this.image[sr] = e2[sr];
      return;
    }
    const i2 = e2[qr];
    if (null === this[i2]) {
      for (const e3 of Object.getOwnPropertyNames(this)) {
        const t3 = this[e3];
        if (t3 instanceof XFAObject) {
          this[e3] = null;
          this[zr](t3);
        }
      }
      this[e2[qr]] = e2;
      this[_s2](e2);
    } else
      this[i2][sr] = e2[sr];
  }
  [rn]() {
    if (this.exData)
      return "string" == typeof this.exData[sr] ? this.exData[sr].trim() : this.exData[sr][rn]().trim();
    for (const e2 of Object.getOwnPropertyNames(this)) {
      if ("image" === e2)
        continue;
      const t2 = this[e2];
      if (t2 instanceof XFAObject)
        return (t2[sr] || "").toString().trim();
    }
    return null;
  }
  [gn](e2) {
    for (const t2 of Object.getOwnPropertyNames(this)) {
      const i2 = this[t2];
      if (i2 instanceof XFAObject)
        return i2[gn](e2);
    }
    return HTMLResult.EMPTY;
  }
};
var Variables = class extends XFAObject {
  constructor(e2) {
    super(Kn, "variables", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.manifest = new XFAObjectArray();
    this.script = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
  [Yr]() {
    return true;
  }
};
var TemplateNamespace = class _TemplateNamespace {
  static [Cn](e2, t2) {
    if (_TemplateNamespace.hasOwnProperty(e2)) {
      const i2 = _TemplateNamespace[e2](t2);
      i2[tn](t2);
      return i2;
    }
  }
  static appearanceFilter(e2) {
    return new AppearanceFilter(e2);
  }
  static arc(e2) {
    return new Arc(e2);
  }
  static area(e2) {
    return new Area(e2);
  }
  static assist(e2) {
    return new Assist(e2);
  }
  static barcode(e2) {
    return new Barcode(e2);
  }
  static bind(e2) {
    return new Bind(e2);
  }
  static bindItems(e2) {
    return new BindItems(e2);
  }
  static bookend(e2) {
    return new Bookend(e2);
  }
  static boolean(e2) {
    return new BooleanElement(e2);
  }
  static border(e2) {
    return new Border(e2);
  }
  static break(e2) {
    return new Break(e2);
  }
  static breakAfter(e2) {
    return new BreakAfter(e2);
  }
  static breakBefore(e2) {
    return new BreakBefore(e2);
  }
  static button(e2) {
    return new Button(e2);
  }
  static calculate(e2) {
    return new Calculate(e2);
  }
  static caption(e2) {
    return new Caption(e2);
  }
  static certificate(e2) {
    return new Certificate(e2);
  }
  static certificates(e2) {
    return new Certificates(e2);
  }
  static checkButton(e2) {
    return new CheckButton(e2);
  }
  static choiceList(e2) {
    return new ChoiceList(e2);
  }
  static color(e2) {
    return new Color(e2);
  }
  static comb(e2) {
    return new Comb(e2);
  }
  static connect(e2) {
    return new Connect(e2);
  }
  static contentArea(e2) {
    return new ContentArea(e2);
  }
  static corner(e2) {
    return new Corner(e2);
  }
  static date(e2) {
    return new DateElement(e2);
  }
  static dateTime(e2) {
    return new DateTime(e2);
  }
  static dateTimeEdit(e2) {
    return new DateTimeEdit(e2);
  }
  static decimal(e2) {
    return new Decimal(e2);
  }
  static defaultUi(e2) {
    return new DefaultUi(e2);
  }
  static desc(e2) {
    return new Desc(e2);
  }
  static digestMethod(e2) {
    return new DigestMethod(e2);
  }
  static digestMethods(e2) {
    return new DigestMethods(e2);
  }
  static draw(e2) {
    return new Draw(e2);
  }
  static edge(e2) {
    return new Edge(e2);
  }
  static encoding(e2) {
    return new Encoding(e2);
  }
  static encodings(e2) {
    return new Encodings(e2);
  }
  static encrypt(e2) {
    return new Encrypt(e2);
  }
  static encryptData(e2) {
    return new EncryptData(e2);
  }
  static encryption(e2) {
    return new Encryption(e2);
  }
  static encryptionMethod(e2) {
    return new EncryptionMethod(e2);
  }
  static encryptionMethods(e2) {
    return new EncryptionMethods(e2);
  }
  static event(e2) {
    return new Event(e2);
  }
  static exData(e2) {
    return new ExData(e2);
  }
  static exObject(e2) {
    return new ExObject(e2);
  }
  static exclGroup(e2) {
    return new ExclGroup(e2);
  }
  static execute(e2) {
    return new Execute(e2);
  }
  static extras(e2) {
    return new Extras(e2);
  }
  static field(e2) {
    return new Field(e2);
  }
  static fill(e2) {
    return new Fill(e2);
  }
  static filter(e2) {
    return new Filter(e2);
  }
  static float(e2) {
    return new Float(e2);
  }
  static font(e2) {
    return new template_Font(e2);
  }
  static format(e2) {
    return new Format(e2);
  }
  static handler(e2) {
    return new Handler(e2);
  }
  static hyphenation(e2) {
    return new Hyphenation(e2);
  }
  static image(e2) {
    return new Image(e2);
  }
  static imageEdit(e2) {
    return new ImageEdit(e2);
  }
  static integer(e2) {
    return new Integer(e2);
  }
  static issuers(e2) {
    return new Issuers(e2);
  }
  static items(e2) {
    return new Items(e2);
  }
  static keep(e2) {
    return new Keep(e2);
  }
  static keyUsage(e2) {
    return new KeyUsage(e2);
  }
  static line(e2) {
    return new Line(e2);
  }
  static linear(e2) {
    return new Linear(e2);
  }
  static lockDocument(e2) {
    return new LockDocument(e2);
  }
  static manifest(e2) {
    return new Manifest(e2);
  }
  static margin(e2) {
    return new Margin(e2);
  }
  static mdp(e2) {
    return new Mdp(e2);
  }
  static medium(e2) {
    return new Medium(e2);
  }
  static message(e2) {
    return new Message(e2);
  }
  static numericEdit(e2) {
    return new NumericEdit(e2);
  }
  static occur(e2) {
    return new Occur(e2);
  }
  static oid(e2) {
    return new Oid(e2);
  }
  static oids(e2) {
    return new Oids(e2);
  }
  static overflow(e2) {
    return new Overflow(e2);
  }
  static pageArea(e2) {
    return new PageArea(e2);
  }
  static pageSet(e2) {
    return new PageSet(e2);
  }
  static para(e2) {
    return new Para(e2);
  }
  static passwordEdit(e2) {
    return new PasswordEdit(e2);
  }
  static pattern(e2) {
    return new template_Pattern(e2);
  }
  static picture(e2) {
    return new Picture(e2);
  }
  static proto(e2) {
    return new Proto(e2);
  }
  static radial(e2) {
    return new Radial(e2);
  }
  static reason(e2) {
    return new Reason(e2);
  }
  static reasons(e2) {
    return new Reasons(e2);
  }
  static rectangle(e2) {
    return new Rectangle(e2);
  }
  static ref(e2) {
    return new RefElement(e2);
  }
  static script(e2) {
    return new Script(e2);
  }
  static setProperty(e2) {
    return new SetProperty(e2);
  }
  static signData(e2) {
    return new SignData(e2);
  }
  static signature(e2) {
    return new Signature(e2);
  }
  static signing(e2) {
    return new Signing(e2);
  }
  static solid(e2) {
    return new Solid(e2);
  }
  static speak(e2) {
    return new Speak(e2);
  }
  static stipple(e2) {
    return new Stipple(e2);
  }
  static subform(e2) {
    return new Subform(e2);
  }
  static subformSet(e2) {
    return new SubformSet(e2);
  }
  static subjectDN(e2) {
    return new SubjectDN(e2);
  }
  static subjectDNs(e2) {
    return new SubjectDNs(e2);
  }
  static submit(e2) {
    return new Submit(e2);
  }
  static template(e2) {
    return new Template(e2);
  }
  static text(e2) {
    return new Text(e2);
  }
  static textEdit(e2) {
    return new TextEdit(e2);
  }
  static time(e2) {
    return new Time(e2);
  }
  static timeStamp(e2) {
    return new TimeStamp(e2);
  }
  static toolTip(e2) {
    return new ToolTip(e2);
  }
  static traversal(e2) {
    return new Traversal(e2);
  }
  static traverse(e2) {
    return new Traverse(e2);
  }
  static ui(e2) {
    return new Ui(e2);
  }
  static validate(e2) {
    return new Validate(e2);
  }
  static value(e2) {
    return new Value(e2);
  }
  static variables(e2) {
    return new Variables(e2);
  }
};
var Wn = hn.datasets.id;
function createText(e2) {
  const t2 = new Text({});
  t2[sr] = e2;
  return t2;
}
var Binder = class {
  constructor(e2) {
    var _a4;
    this.root = e2;
    this.datasets = e2.datasets;
    this.data = ((_a4 = e2.datasets) == null ? void 0 : _a4.data) || new XmlObject(hn.datasets.id, "data");
    this.emptyMerge = 0 === this.data[pr]().length;
    this.root.form = this.form = e2.template[ir]();
  }
  _isConsumeData() {
    return !this.emptyMerge && this._mergeMode;
  }
  _isMatchTemplate() {
    return !this._isConsumeData();
  }
  bind() {
    this._bindElement(this.form, this.data);
    return this.form;
  }
  getData() {
    return this.data;
  }
  _bindValue(e2, t2, i2) {
    var _a4, _b2;
    e2[rr] = t2;
    if (e2[Sr]())
      if (t2[Ur]()) {
        const i3 = t2[ur]();
        e2[an](createText(i3));
      } else if (e2 instanceof Field && "multiSelect" === ((_b2 = (_a4 = e2.ui) == null ? void 0 : _a4.choiceList) == null ? void 0 : _b2.open)) {
        const i3 = t2[pr]().map((e3) => e3[sr].trim()).join("\n");
        e2[an](createText(i3));
      } else
        this._isConsumeData() && warn("XFA - Nodes haven't the same type.");
    else
      !t2[Ur]() || this._isMatchTemplate() ? this._bindElement(e2, t2) : warn("XFA - Nodes haven't the same type.");
  }
  _findDataByNameToConsume(e2, t2, i2, a2) {
    if (!e2)
      return null;
    let s2, r2;
    for (let a3 = 0; a3 < 3; a3++) {
      s2 = i2[fr](e2, false, true);
      for (; ; ) {
        r2 = s2.next().value;
        if (!r2)
          break;
        if (t2 === r2[Ur]())
          return r2;
      }
      if (i2[Tr] === hn.datasets.id && "data" === i2[qr])
        break;
      i2 = i2[Dr]();
    }
    if (!a2)
      return null;
    s2 = this.data[fr](e2, true, false);
    r2 = s2.next().value;
    if (r2)
      return r2;
    s2 = this.data[cr](e2, true);
    r2 = s2.next().value;
    return (r2 == null ? void 0 : r2[Ur]()) ? r2 : null;
  }
  _setProperties(e2, t2) {
    if (e2.hasOwnProperty("setProperty"))
      for (const { ref: i2, target: a2, connection: s2 } of e2.setProperty.children) {
        if (s2)
          continue;
        if (!i2)
          continue;
        const r2 = searchNode(this.root, t2, i2, false, false);
        if (!r2) {
          warn(`XFA - Invalid reference: ${i2}.`);
          continue;
        }
        const [n2] = r2;
        if (!n2[Mr](this.data)) {
          warn("XFA - Invalid node: must be a data node.");
          continue;
        }
        const g2 = searchNode(this.root, e2, a2, false, false);
        if (!g2) {
          warn(`XFA - Invalid target: ${a2}.`);
          continue;
        }
        const [o2] = g2;
        if (!o2[Mr](e2)) {
          warn("XFA - Invalid target: must be a property or subproperty.");
          continue;
        }
        const c2 = o2[Dr]();
        if (o2 instanceof SetProperty || c2 instanceof SetProperty) {
          warn("XFA - Invalid target: cannot be a setProperty or one of its properties.");
          continue;
        }
        if (o2 instanceof BindItems || c2 instanceof BindItems) {
          warn("XFA - Invalid target: cannot be a bindItems or one of its properties.");
          continue;
        }
        const C2 = n2[rn](), h2 = o2[qr];
        if (o2 instanceof XFAAttribute) {
          const e3 = /* @__PURE__ */ Object.create(null);
          e3[h2] = C2;
          const t3 = Reflect.construct(Object.getPrototypeOf(c2).constructor, [e3]);
          c2[h2] = t3[h2];
        } else if (o2.hasOwnProperty(sr)) {
          o2[rr] = n2;
          o2[sr] = C2;
          o2[or]();
        } else
          warn("XFA - Invalid node to use in setProperty");
      }
  }
  _bindItems(e2, t2) {
    if (!e2.hasOwnProperty("items") || !e2.hasOwnProperty("bindItems") || e2.bindItems.isEmpty())
      return;
    for (const t3 of e2.items.children)
      e2[zr](t3);
    e2.items.clear();
    const i2 = new Items({}), a2 = new Items({});
    e2[_s2](i2);
    e2.items.push(i2);
    e2[_s2](a2);
    e2.items.push(a2);
    for (const { ref: s2, labelRef: r2, valueRef: n2, connection: g2 } of e2.bindItems.children) {
      if (g2)
        continue;
      if (!s2)
        continue;
      const e3 = searchNode(this.root, t2, s2, false, false);
      if (e3)
        for (const t3 of e3) {
          if (!t3[Mr](this.datasets)) {
            warn(`XFA - Invalid ref (${s2}): must be a datasets child.`);
            continue;
          }
          const e4 = searchNode(this.root, t3, r2, true, false);
          if (!e4) {
            warn(`XFA - Invalid label: ${r2}.`);
            continue;
          }
          const [g3] = e4;
          if (!g3[Mr](this.datasets)) {
            warn("XFA - Invalid label: must be a datasets child.");
            continue;
          }
          const o2 = searchNode(this.root, t3, n2, true, false);
          if (!o2) {
            warn(`XFA - Invalid value: ${n2}.`);
            continue;
          }
          const [c2] = o2;
          if (!c2[Mr](this.datasets)) {
            warn("XFA - Invalid value: must be a datasets child.");
            continue;
          }
          const C2 = createText(g3[rn]()), h2 = createText(c2[rn]());
          i2[_s2](C2);
          i2.text.push(C2);
          a2[_s2](h2);
          a2.text.push(h2);
        }
      else
        warn(`XFA - Invalid reference: ${s2}.`);
    }
  }
  _bindOccurrences(e2, t2, i2) {
    let a2;
    if (t2.length > 1) {
      a2 = e2[ir]();
      a2[zr](a2.occur);
      a2.occur = null;
    }
    this._bindValue(e2, t2[0], i2);
    this._setProperties(e2, t2[0]);
    this._bindItems(e2, t2[0]);
    if (1 === t2.length)
      return;
    const s2 = e2[Dr](), r2 = e2[qr], n2 = s2[Rr](e2);
    for (let e3 = 1, g2 = t2.length; e3 < g2; e3++) {
      const g3 = t2[e3], o2 = a2[ir]();
      s2[r2].push(o2);
      s2[Nr](n2 + e3, o2);
      this._bindValue(o2, g3, i2);
      this._setProperties(o2, g3);
      this._bindItems(o2, g3);
    }
  }
  _createOccurrences(e2) {
    if (!this.emptyMerge)
      return;
    const { occur: t2 } = e2;
    if (!t2 || t2.initial <= 1)
      return;
    const i2 = e2[Dr](), a2 = e2[qr];
    if (!(i2[a2] instanceof XFAObjectArray))
      return;
    let s2;
    s2 = e2.name ? i2[a2].children.filter((t3) => t3.name === e2.name).length : i2[a2].children.length;
    const r2 = i2[Rr](e2) + 1, n2 = t2.initial - s2;
    if (n2) {
      const t3 = e2[ir]();
      t3[zr](t3.occur);
      t3.occur = null;
      i2[a2].push(t3);
      i2[Nr](r2, t3);
      for (let e3 = 1; e3 < n2; e3++) {
        const s3 = t3[ir]();
        i2[a2].push(s3);
        i2[Nr](r2 + e3, s3);
      }
    }
  }
  _getOccurInfo(e2) {
    const { name: t2, occur: i2 } = e2;
    if (!i2 || !t2)
      return [1, 1];
    const a2 = -1 === i2.max ? 1 / 0 : i2.max;
    return [i2.min, a2];
  }
  _setAndBind(e2, t2) {
    this._setProperties(e2, t2);
    this._bindItems(e2, t2);
    this._bindElement(e2, t2);
  }
  _bindElement(e2, t2) {
    const i2 = [];
    this._createOccurrences(e2);
    for (const a2 of e2[pr]()) {
      if (a2[rr])
        continue;
      if (void 0 === this._mergeMode && "subform" === a2[qr]) {
        this._mergeMode = "consumeData" === a2.mergeMode;
        const e4 = t2[pr]();
        if (e4.length > 0)
          this._bindOccurrences(a2, [e4[0]], null);
        else if (this.emptyMerge) {
          const e5 = t2[Tr] === Wn ? -1 : t2[Tr], i3 = a2[rr] = new XmlObject(e5, a2.name || "root");
          t2[_s2](i3);
          this._bindElement(a2, i3);
        }
        continue;
      }
      if (!a2[xr]())
        continue;
      let e3 = false, s2 = null, r2 = null, n2 = null;
      if (a2.bind) {
        switch (a2.bind.match) {
          case "none":
            this._setAndBind(a2, t2);
            continue;
          case "global":
            e3 = true;
            break;
          case "dataRef":
            if (!a2.bind.ref) {
              warn(`XFA - ref is empty in node ${a2[qr]}.`);
              this._setAndBind(a2, t2);
              continue;
            }
            r2 = a2.bind.ref;
        }
        a2.bind.picture && (s2 = a2.bind.picture[sr]);
      }
      const [g2, o2] = this._getOccurInfo(a2);
      if (r2) {
        n2 = searchNode(this.root, t2, r2, true, false);
        if (null === n2) {
          n2 = createDataNode(this.data, t2, r2);
          if (!n2)
            continue;
          this._isConsumeData() && (n2[ar] = true);
          this._setAndBind(a2, n2);
          continue;
        }
        this._isConsumeData() && (n2 = n2.filter((e4) => !e4[ar]));
        n2.length > o2 ? n2 = n2.slice(0, o2) : 0 === n2.length && (n2 = null);
        n2 && this._isConsumeData() && n2.forEach((e4) => {
          e4[ar] = true;
        });
      } else {
        if (!a2.name) {
          this._setAndBind(a2, t2);
          continue;
        }
        if (this._isConsumeData()) {
          const i3 = [];
          for (; i3.length < o2; ) {
            const s3 = this._findDataByNameToConsume(a2.name, a2[Sr](), t2, e3);
            if (!s3)
              break;
            s3[ar] = true;
            i3.push(s3);
          }
          n2 = i3.length > 0 ? i3 : null;
        } else {
          n2 = t2[fr](a2.name, false, this.emptyMerge).next().value;
          if (!n2) {
            if (0 === g2) {
              i2.push(a2);
              continue;
            }
            const e4 = t2[Tr] === Wn ? -1 : t2[Tr];
            n2 = a2[rr] = new XmlObject(e4, a2.name);
            this.emptyMerge && (n2[ar] = true);
            t2[_s2](n2);
            this._setAndBind(a2, n2);
            continue;
          }
          this.emptyMerge && (n2[ar] = true);
          n2 = [n2];
        }
      }
      n2 ? this._bindOccurrences(a2, n2, s2) : g2 > 0 ? this._setAndBind(a2, t2) : i2.push(a2);
    }
    i2.forEach((e3) => e3[Dr]()[zr](e3));
  }
};
var DataHandler = class {
  constructor(e2, t2) {
    this.data = t2;
    this.dataset = e2.datasets || null;
  }
  serialize(e2) {
    const t2 = [[-1, this.data[pr]()]];
    for (; t2.length > 0; ) {
      const i3 = t2.at(-1), [a2, s2] = i3;
      if (a2 + 1 === s2.length) {
        t2.pop();
        continue;
      }
      const r2 = s2[++i3[0]], n2 = e2.get(r2[cn]);
      if (n2)
        r2[an](n2);
      else {
        const t3 = r2[Cr]();
        for (const i4 of t3.values()) {
          const t4 = e2.get(i4[cn]);
          if (t4) {
            i4[an](t4);
            break;
          }
        }
      }
      const g2 = r2[pr]();
      g2.length > 0 && t2.push([-1, g2]);
    }
    const i2 = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
    if (this.dataset)
      for (const e3 of this.dataset[pr]())
        "data" !== e3[qr] && e3[on](i2);
    this.data[on](i2);
    i2.push("</xfa:datasets>");
    return i2.join("");
  }
};
var jn = hn.config.id;
var Acrobat = class extends XFAObject {
  constructor(e2) {
    super(jn, "acrobat", true);
    this.acrobat7 = null;
    this.autoSave = null;
    this.common = null;
    this.validate = null;
    this.validateApprovalSignatures = null;
    this.submitUrl = new XFAObjectArray();
  }
};
var Acrobat7 = class extends XFAObject {
  constructor(e2) {
    super(jn, "acrobat7", true);
    this.dynamicRender = null;
  }
};
var ADBE_JSConsole = class extends OptionObject {
  constructor(e2) {
    super(jn, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
  }
};
var ADBE_JSDebugger = class extends OptionObject {
  constructor(e2) {
    super(jn, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
  }
};
var AddSilentPrint = class extends Option01 {
  constructor(e2) {
    super(jn, "addSilentPrint");
  }
};
var AddViewerPreferences = class extends Option01 {
  constructor(e2) {
    super(jn, "addViewerPreferences");
  }
};
var AdjustData = class extends Option10 {
  constructor(e2) {
    super(jn, "adjustData");
  }
};
var AdobeExtensionLevel = class extends IntegerObject {
  constructor(e2) {
    super(jn, "adobeExtensionLevel", 0, (e3) => e3 >= 1 && e3 <= 8);
  }
};
var Agent = class extends XFAObject {
  constructor(e2) {
    super(jn, "agent", true);
    this.name = e2.name ? e2.name.trim() : "";
    this.common = new XFAObjectArray();
  }
};
var AlwaysEmbed = class extends ContentObject {
  constructor(e2) {
    super(jn, "alwaysEmbed");
  }
};
var Amd = class extends StringObject {
  constructor(e2) {
    super(jn, "amd");
  }
};
var config_Area = class extends XFAObject {
  constructor(e2) {
    super(jn, "area");
    this.level = getInteger({ data: e2.level, defaultValue: 0, validate: (e3) => e3 >= 1 && e3 <= 3 });
    this.name = getStringOption(e2.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
  }
};
var Attributes = class extends OptionObject {
  constructor(e2) {
    super(jn, "attributes", ["preserve", "delegate", "ignore"]);
  }
};
var AutoSave = class extends OptionObject {
  constructor(e2) {
    super(jn, "autoSave", ["disabled", "enabled"]);
  }
};
var Base = class extends StringObject {
  constructor(e2) {
    super(jn, "base");
  }
};
var BatchOutput = class extends XFAObject {
  constructor(e2) {
    super(jn, "batchOutput");
    this.format = getStringOption(e2.format, ["none", "concat", "zip", "zipCompress"]);
  }
};
var BehaviorOverride = class extends ContentObject {
  constructor(e2) {
    super(jn, "behaviorOverride");
  }
  [or]() {
    this[sr] = new Map(this[sr].trim().split(/\s+/).filter((e2) => e2.includes(":")).map((e2) => e2.split(":", 2)));
  }
};
var Cache = class extends XFAObject {
  constructor(e2) {
    super(jn, "cache", true);
    this.templateCache = null;
  }
};
var Change = class extends Option01 {
  constructor(e2) {
    super(jn, "change");
  }
};
var Common = class extends XFAObject {
  constructor(e2) {
    super(jn, "common", true);
    this.data = null;
    this.locale = null;
    this.localeSet = null;
    this.messaging = null;
    this.suppressBanner = null;
    this.template = null;
    this.validationMessaging = null;
    this.versionControl = null;
    this.log = new XFAObjectArray();
  }
};
var Compress = class extends XFAObject {
  constructor(e2) {
    super(jn, "compress");
    this.scope = getStringOption(e2.scope, ["imageOnly", "document"]);
  }
};
var CompressLogicalStructure = class extends Option01 {
  constructor(e2) {
    super(jn, "compressLogicalStructure");
  }
};
var CompressObjectStream = class extends Option10 {
  constructor(e2) {
    super(jn, "compressObjectStream");
  }
};
var Compression = class extends XFAObject {
  constructor(e2) {
    super(jn, "compression", true);
    this.compressLogicalStructure = null;
    this.compressObjectStream = null;
    this.level = null;
    this.type = null;
  }
};
var Config = class extends XFAObject {
  constructor(e2) {
    super(jn, "config", true);
    this.acrobat = null;
    this.present = null;
    this.trace = null;
    this.agent = new XFAObjectArray();
  }
};
var Conformance = class extends OptionObject {
  constructor(e2) {
    super(jn, "conformance", ["A", "B"]);
  }
};
var ContentCopy = class extends Option01 {
  constructor(e2) {
    super(jn, "contentCopy");
  }
};
var Copies = class extends IntegerObject {
  constructor(e2) {
    super(jn, "copies", 1, (e3) => e3 >= 1);
  }
};
var Creator = class extends StringObject {
  constructor(e2) {
    super(jn, "creator");
  }
};
var CurrentPage = class extends IntegerObject {
  constructor(e2) {
    super(jn, "currentPage", 0, (e3) => e3 >= 0);
  }
};
var Data = class extends XFAObject {
  constructor(e2) {
    super(jn, "data", true);
    this.adjustData = null;
    this.attributes = null;
    this.incrementalLoad = null;
    this.outputXSL = null;
    this.range = null;
    this.record = null;
    this.startNode = null;
    this.uri = null;
    this.window = null;
    this.xsl = null;
    this.excludeNS = new XFAObjectArray();
    this.transform = new XFAObjectArray();
  }
};
var Debug = class extends XFAObject {
  constructor(e2) {
    super(jn, "debug", true);
    this.uri = null;
  }
};
var DefaultTypeface = class extends ContentObject {
  constructor(e2) {
    super(jn, "defaultTypeface");
    this.writingScript = getStringOption(e2.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
  }
};
var Destination = class extends OptionObject {
  constructor(e2) {
    super(jn, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
  }
};
var DocumentAssembly = class extends Option01 {
  constructor(e2) {
    super(jn, "documentAssembly");
  }
};
var Driver = class extends XFAObject {
  constructor(e2) {
    super(jn, "driver", true);
    this.name = e2.name ? e2.name.trim() : "";
    this.fontInfo = null;
    this.xdc = null;
  }
};
var DuplexOption = class extends OptionObject {
  constructor(e2) {
    super(jn, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
  }
};
var DynamicRender = class extends OptionObject {
  constructor(e2) {
    super(jn, "dynamicRender", ["forbidden", "required"]);
  }
};
var Embed = class extends Option01 {
  constructor(e2) {
    super(jn, "embed");
  }
};
var config_Encrypt = class extends Option01 {
  constructor(e2) {
    super(jn, "encrypt");
  }
};
var config_Encryption = class extends XFAObject {
  constructor(e2) {
    super(jn, "encryption", true);
    this.encrypt = null;
    this.encryptionLevel = null;
    this.permissions = null;
  }
};
var EncryptionLevel = class extends OptionObject {
  constructor(e2) {
    super(jn, "encryptionLevel", ["40bit", "128bit"]);
  }
};
var Enforce = class extends StringObject {
  constructor(e2) {
    super(jn, "enforce");
  }
};
var Equate = class extends XFAObject {
  constructor(e2) {
    super(jn, "equate");
    this.force = getInteger({ data: e2.force, defaultValue: 1, validate: (e3) => 0 === e3 });
    this.from = e2.from || "";
    this.to = e2.to || "";
  }
};
var EquateRange = class extends XFAObject {
  constructor(e2) {
    super(jn, "equateRange");
    this.from = e2.from || "";
    this.to = e2.to || "";
    this._unicodeRange = e2.unicodeRange || "";
  }
  get unicodeRange() {
    const e2 = [], t2 = /U\+([0-9a-fA-F]+)/, i2 = this._unicodeRange;
    for (let a2 of i2.split(",").map((e3) => e3.trim()).filter((e3) => !!e3)) {
      a2 = a2.split("-", 2).map((e3) => {
        const i3 = e3.match(t2);
        return i3 ? parseInt(i3[1], 16) : 0;
      });
      1 === a2.length && a2.push(a2[0]);
      e2.push(a2);
    }
    return shadow(this, "unicodeRange", e2);
  }
};
var Exclude = class extends ContentObject {
  constructor(e2) {
    super(jn, "exclude");
  }
  [or]() {
    this[sr] = this[sr].trim().split(/\s+/).filter((e2) => e2 && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(e2));
  }
};
var ExcludeNS = class extends StringObject {
  constructor(e2) {
    super(jn, "excludeNS");
  }
};
var FlipLabel = class extends OptionObject {
  constructor(e2) {
    super(jn, "flipLabel", ["usePrinterSetting", "on", "off"]);
  }
};
var config_FontInfo = class extends XFAObject {
  constructor(e2) {
    super(jn, "fontInfo", true);
    this.embed = null;
    this.map = null;
    this.subsetBelow = null;
    this.alwaysEmbed = new XFAObjectArray();
    this.defaultTypeface = new XFAObjectArray();
    this.neverEmbed = new XFAObjectArray();
  }
};
var FormFieldFilling = class extends Option01 {
  constructor(e2) {
    super(jn, "formFieldFilling");
  }
};
var GroupParent = class extends StringObject {
  constructor(e2) {
    super(jn, "groupParent");
  }
};
var IfEmpty = class extends OptionObject {
  constructor(e2) {
    super(jn, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
  }
};
var IncludeXDPContent = class extends StringObject {
  constructor(e2) {
    super(jn, "includeXDPContent");
  }
};
var IncrementalLoad = class extends OptionObject {
  constructor(e2) {
    super(jn, "incrementalLoad", ["none", "forwardOnly"]);
  }
};
var IncrementalMerge = class extends Option01 {
  constructor(e2) {
    super(jn, "incrementalMerge");
  }
};
var Interactive = class extends Option01 {
  constructor(e2) {
    super(jn, "interactive");
  }
};
var Jog = class extends OptionObject {
  constructor(e2) {
    super(jn, "jog", ["usePrinterSetting", "none", "pageSet"]);
  }
};
var LabelPrinter = class extends XFAObject {
  constructor(e2) {
    super(jn, "labelPrinter", true);
    this.name = getStringOption(e2.name, ["zpl", "dpl", "ipl", "tcpl"]);
    this.batchOutput = null;
    this.flipLabel = null;
    this.fontInfo = null;
    this.xdc = null;
  }
};
var Layout = class extends OptionObject {
  constructor(e2) {
    super(jn, "layout", ["paginate", "panel"]);
  }
};
var Level = class extends IntegerObject {
  constructor(e2) {
    super(jn, "level", 0, (e3) => e3 > 0);
  }
};
var Linearized = class extends Option01 {
  constructor(e2) {
    super(jn, "linearized");
  }
};
var Locale = class extends StringObject {
  constructor(e2) {
    super(jn, "locale");
  }
};
var LocaleSet = class extends StringObject {
  constructor(e2) {
    super(jn, "localeSet");
  }
};
var Log = class extends XFAObject {
  constructor(e2) {
    super(jn, "log", true);
    this.mode = null;
    this.threshold = null;
    this.to = null;
    this.uri = null;
  }
};
var MapElement = class extends XFAObject {
  constructor(e2) {
    super(jn, "map", true);
    this.equate = new XFAObjectArray();
    this.equateRange = new XFAObjectArray();
  }
};
var MediumInfo = class extends XFAObject {
  constructor(e2) {
    super(jn, "mediumInfo", true);
    this.map = null;
  }
};
var config_Message = class extends XFAObject {
  constructor(e2) {
    super(jn, "message", true);
    this.msgId = null;
    this.severity = null;
  }
};
var Messaging = class extends XFAObject {
  constructor(e2) {
    super(jn, "messaging", true);
    this.message = new XFAObjectArray();
  }
};
var Mode = class extends OptionObject {
  constructor(e2) {
    super(jn, "mode", ["append", "overwrite"]);
  }
};
var ModifyAnnots = class extends Option01 {
  constructor(e2) {
    super(jn, "modifyAnnots");
  }
};
var MsgId = class extends IntegerObject {
  constructor(e2) {
    super(jn, "msgId", 1, (e3) => e3 >= 1);
  }
};
var NameAttr = class extends StringObject {
  constructor(e2) {
    super(jn, "nameAttr");
  }
};
var NeverEmbed = class extends ContentObject {
  constructor(e2) {
    super(jn, "neverEmbed");
  }
};
var NumberOfCopies = class extends IntegerObject {
  constructor(e2) {
    super(jn, "numberOfCopies", null, (e3) => e3 >= 2 && e3 <= 5);
  }
};
var OpenAction = class extends XFAObject {
  constructor(e2) {
    super(jn, "openAction", true);
    this.destination = null;
  }
};
var Output = class extends XFAObject {
  constructor(e2) {
    super(jn, "output", true);
    this.to = null;
    this.type = null;
    this.uri = null;
  }
};
var OutputBin = class extends StringObject {
  constructor(e2) {
    super(jn, "outputBin");
  }
};
var OutputXSL = class extends XFAObject {
  constructor(e2) {
    super(jn, "outputXSL", true);
    this.uri = null;
  }
};
var Overprint = class extends OptionObject {
  constructor(e2) {
    super(jn, "overprint", ["none", "both", "draw", "field"]);
  }
};
var Packets = class extends StringObject {
  constructor(e2) {
    super(jn, "packets");
  }
  [or]() {
    "*" !== this[sr] && (this[sr] = this[sr].trim().split(/\s+/).filter((e2) => ["config", "datasets", "template", "xfdf", "xslt"].includes(e2)));
  }
};
var PageOffset = class extends XFAObject {
  constructor(e2) {
    super(jn, "pageOffset");
    this.x = getInteger({ data: e2.x, defaultValue: "useXDCSetting", validate: (e3) => true });
    this.y = getInteger({ data: e2.y, defaultValue: "useXDCSetting", validate: (e3) => true });
  }
};
var PageRange = class extends StringObject {
  constructor(e2) {
    super(jn, "pageRange");
  }
  [or]() {
    const e2 = this[sr].trim().split(/\s+/).map((e3) => parseInt(e3, 10)), t2 = [];
    for (let i2 = 0, a2 = e2.length; i2 < a2; i2 += 2)
      t2.push(e2.slice(i2, i2 + 2));
    this[sr] = t2;
  }
};
var Pagination = class extends OptionObject {
  constructor(e2) {
    super(jn, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
  }
};
var PaginationOverride = class extends OptionObject {
  constructor(e2) {
    super(jn, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
  }
};
var Part = class extends IntegerObject {
  constructor(e2) {
    super(jn, "part", 1, (e3) => false);
  }
};
var Pcl = class extends XFAObject {
  constructor(e2) {
    super(jn, "pcl", true);
    this.name = e2.name || "";
    this.batchOutput = null;
    this.fontInfo = null;
    this.jog = null;
    this.mediumInfo = null;
    this.outputBin = null;
    this.pageOffset = null;
    this.staple = null;
    this.xdc = null;
  }
};
var Pdf = class extends XFAObject {
  constructor(e2) {
    super(jn, "pdf", true);
    this.name = e2.name || "";
    this.adobeExtensionLevel = null;
    this.batchOutput = null;
    this.compression = null;
    this.creator = null;
    this.encryption = null;
    this.fontInfo = null;
    this.interactive = null;
    this.linearized = null;
    this.openAction = null;
    this.pdfa = null;
    this.producer = null;
    this.renderPolicy = null;
    this.scriptModel = null;
    this.silentPrint = null;
    this.submitFormat = null;
    this.tagged = null;
    this.version = null;
    this.viewerPreferences = null;
    this.xdc = null;
  }
};
var Pdfa = class extends XFAObject {
  constructor(e2) {
    super(jn, "pdfa", true);
    this.amd = null;
    this.conformance = null;
    this.includeXDPContent = null;
    this.part = null;
  }
};
var Permissions = class extends XFAObject {
  constructor(e2) {
    super(jn, "permissions", true);
    this.accessibleContent = null;
    this.change = null;
    this.contentCopy = null;
    this.documentAssembly = null;
    this.formFieldFilling = null;
    this.modifyAnnots = null;
    this.plaintextMetadata = null;
    this.print = null;
    this.printHighQuality = null;
  }
};
var PickTrayByPDFSize = class extends Option01 {
  constructor(e2) {
    super(jn, "pickTrayByPDFSize");
  }
};
var config_Picture = class extends StringObject {
  constructor(e2) {
    super(jn, "picture");
  }
};
var PlaintextMetadata = class extends Option01 {
  constructor(e2) {
    super(jn, "plaintextMetadata");
  }
};
var Presence = class extends OptionObject {
  constructor(e2) {
    super(jn, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
  }
};
var Present = class extends XFAObject {
  constructor(e2) {
    super(jn, "present", true);
    this.behaviorOverride = null;
    this.cache = null;
    this.common = null;
    this.copies = null;
    this.destination = null;
    this.incrementalMerge = null;
    this.layout = null;
    this.output = null;
    this.overprint = null;
    this.pagination = null;
    this.paginationOverride = null;
    this.script = null;
    this.validate = null;
    this.xdp = null;
    this.driver = new XFAObjectArray();
    this.labelPrinter = new XFAObjectArray();
    this.pcl = new XFAObjectArray();
    this.pdf = new XFAObjectArray();
    this.ps = new XFAObjectArray();
    this.submitUrl = new XFAObjectArray();
    this.webClient = new XFAObjectArray();
    this.zpl = new XFAObjectArray();
  }
};
var Print = class extends Option01 {
  constructor(e2) {
    super(jn, "print");
  }
};
var PrintHighQuality = class extends Option01 {
  constructor(e2) {
    super(jn, "printHighQuality");
  }
};
var PrintScaling = class extends OptionObject {
  constructor(e2) {
    super(jn, "printScaling", ["appdefault", "noScaling"]);
  }
};
var PrinterName = class extends StringObject {
  constructor(e2) {
    super(jn, "printerName");
  }
};
var Producer = class extends StringObject {
  constructor(e2) {
    super(jn, "producer");
  }
};
var Ps = class extends XFAObject {
  constructor(e2) {
    super(jn, "ps", true);
    this.name = e2.name || "";
    this.batchOutput = null;
    this.fontInfo = null;
    this.jog = null;
    this.mediumInfo = null;
    this.outputBin = null;
    this.staple = null;
    this.xdc = null;
  }
};
var Range = class extends ContentObject {
  constructor(e2) {
    super(jn, "range");
  }
  [or]() {
    this[sr] = this[sr].trim().split(/\s*,\s*/, 2).map((e2) => e2.split("-").map((e3) => parseInt(e3.trim(), 10))).filter((e2) => e2.every((e3) => !isNaN(e3))).map((e2) => {
      1 === e2.length && e2.push(e2[0]);
      return e2;
    });
  }
};
var Record = class extends ContentObject {
  constructor(e2) {
    super(jn, "record");
  }
  [or]() {
    this[sr] = this[sr].trim();
    const e2 = parseInt(this[sr], 10);
    !isNaN(e2) && e2 >= 0 && (this[sr] = e2);
  }
};
var Relevant = class extends ContentObject {
  constructor(e2) {
    super(jn, "relevant");
  }
  [or]() {
    this[sr] = this[sr].trim().split(/\s+/);
  }
};
var Rename = class extends ContentObject {
  constructor(e2) {
    super(jn, "rename");
  }
  [or]() {
    this[sr] = this[sr].trim();
    (this[sr].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[sr])) && warn("XFA - Rename: invalid XFA name");
  }
};
var RenderPolicy = class extends OptionObject {
  constructor(e2) {
    super(jn, "renderPolicy", ["server", "client"]);
  }
};
var RunScripts = class extends OptionObject {
  constructor(e2) {
    super(jn, "runScripts", ["both", "client", "none", "server"]);
  }
};
var config_Script = class extends XFAObject {
  constructor(e2) {
    super(jn, "script", true);
    this.currentPage = null;
    this.exclude = null;
    this.runScripts = null;
  }
};
var ScriptModel = class extends OptionObject {
  constructor(e2) {
    super(jn, "scriptModel", ["XFA", "none"]);
  }
};
var Severity = class extends OptionObject {
  constructor(e2) {
    super(jn, "severity", ["ignore", "error", "information", "trace", "warning"]);
  }
};
var SilentPrint = class extends XFAObject {
  constructor(e2) {
    super(jn, "silentPrint", true);
    this.addSilentPrint = null;
    this.printerName = null;
  }
};
var Staple = class extends XFAObject {
  constructor(e2) {
    super(jn, "staple");
    this.mode = getStringOption(e2.mode, ["usePrinterSetting", "on", "off"]);
  }
};
var StartNode = class extends StringObject {
  constructor(e2) {
    super(jn, "startNode");
  }
};
var StartPage = class extends IntegerObject {
  constructor(e2) {
    super(jn, "startPage", 0, (e3) => true);
  }
};
var SubmitFormat = class extends OptionObject {
  constructor(e2) {
    super(jn, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
  }
};
var SubmitUrl = class extends StringObject {
  constructor(e2) {
    super(jn, "submitUrl");
  }
};
var SubsetBelow = class extends IntegerObject {
  constructor(e2) {
    super(jn, "subsetBelow", 100, (e3) => e3 >= 0 && e3 <= 100);
  }
};
var SuppressBanner = class extends Option01 {
  constructor(e2) {
    super(jn, "suppressBanner");
  }
};
var Tagged = class extends Option01 {
  constructor(e2) {
    super(jn, "tagged");
  }
};
var config_Template = class extends XFAObject {
  constructor(e2) {
    super(jn, "template", true);
    this.base = null;
    this.relevant = null;
    this.startPage = null;
    this.uri = null;
    this.xsl = null;
  }
};
var Threshold = class extends OptionObject {
  constructor(e2) {
    super(jn, "threshold", ["trace", "error", "information", "warning"]);
  }
};
var To = class extends OptionObject {
  constructor(e2) {
    super(jn, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
  }
};
var TemplateCache = class extends XFAObject {
  constructor(e2) {
    super(jn, "templateCache");
    this.maxEntries = getInteger({ data: e2.maxEntries, defaultValue: 5, validate: (e3) => e3 >= 0 });
  }
};
var Trace = class extends XFAObject {
  constructor(e2) {
    super(jn, "trace", true);
    this.area = new XFAObjectArray();
  }
};
var Transform = class extends XFAObject {
  constructor(e2) {
    super(jn, "transform", true);
    this.groupParent = null;
    this.ifEmpty = null;
    this.nameAttr = null;
    this.picture = null;
    this.presence = null;
    this.rename = null;
    this.whitespace = null;
  }
};
var Type = class extends OptionObject {
  constructor(e2) {
    super(jn, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
  }
};
var Uri = class extends StringObject {
  constructor(e2) {
    super(jn, "uri");
  }
};
var config_Validate = class extends OptionObject {
  constructor(e2) {
    super(jn, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
  }
};
var ValidateApprovalSignatures = class extends ContentObject {
  constructor(e2) {
    super(jn, "validateApprovalSignatures");
  }
  [or]() {
    this[sr] = this[sr].trim().split(/\s+/).filter((e2) => ["docReady", "postSign"].includes(e2));
  }
};
var ValidationMessaging = class extends OptionObject {
  constructor(e2) {
    super(jn, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
  }
};
var Version = class extends OptionObject {
  constructor(e2) {
    super(jn, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
  }
};
var VersionControl = class extends XFAObject {
  constructor(e2) {
    super(jn, "VersionControl");
    this.outputBelow = getStringOption(e2.outputBelow, ["warn", "error", "update"]);
    this.sourceAbove = getStringOption(e2.sourceAbove, ["warn", "error"]);
    this.sourceBelow = getStringOption(e2.sourceBelow, ["update", "maintain"]);
  }
};
var ViewerPreferences = class extends XFAObject {
  constructor(e2) {
    super(jn, "viewerPreferences", true);
    this.ADBE_JSConsole = null;
    this.ADBE_JSDebugger = null;
    this.addViewerPreferences = null;
    this.duplexOption = null;
    this.enforce = null;
    this.numberOfCopies = null;
    this.pageRange = null;
    this.pickTrayByPDFSize = null;
    this.printScaling = null;
  }
};
var WebClient = class extends XFAObject {
  constructor(e2) {
    super(jn, "webClient", true);
    this.name = e2.name ? e2.name.trim() : "";
    this.fontInfo = null;
    this.xdc = null;
  }
};
var Whitespace = class extends OptionObject {
  constructor(e2) {
    super(jn, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
  }
};
var Window = class extends ContentObject {
  constructor(e2) {
    super(jn, "window");
  }
  [or]() {
    const e2 = this[sr].trim().split(/\s*,\s*/, 2).map((e3) => parseInt(e3, 10));
    if (e2.some((e3) => isNaN(e3)))
      this[sr] = [0, 0];
    else {
      1 === e2.length && e2.push(e2[0]);
      this[sr] = e2;
    }
  }
};
var Xdc = class extends XFAObject {
  constructor(e2) {
    super(jn, "xdc", true);
    this.uri = new XFAObjectArray();
    this.xsl = new XFAObjectArray();
  }
};
var Xdp = class extends XFAObject {
  constructor(e2) {
    super(jn, "xdp", true);
    this.packets = null;
  }
};
var Xsl = class extends XFAObject {
  constructor(e2) {
    super(jn, "xsl", true);
    this.debug = null;
    this.uri = null;
  }
};
var Zpl = class extends XFAObject {
  constructor(e2) {
    super(jn, "zpl", true);
    this.name = e2.name ? e2.name.trim() : "";
    this.batchOutput = null;
    this.flipLabel = null;
    this.fontInfo = null;
    this.xdc = null;
  }
};
var ConfigNamespace = class _ConfigNamespace {
  static [Cn](e2, t2) {
    if (_ConfigNamespace.hasOwnProperty(e2))
      return _ConfigNamespace[e2](t2);
  }
  static acrobat(e2) {
    return new Acrobat(e2);
  }
  static acrobat7(e2) {
    return new Acrobat7(e2);
  }
  static ADBE_JSConsole(e2) {
    return new ADBE_JSConsole(e2);
  }
  static ADBE_JSDebugger(e2) {
    return new ADBE_JSDebugger(e2);
  }
  static addSilentPrint(e2) {
    return new AddSilentPrint(e2);
  }
  static addViewerPreferences(e2) {
    return new AddViewerPreferences(e2);
  }
  static adjustData(e2) {
    return new AdjustData(e2);
  }
  static adobeExtensionLevel(e2) {
    return new AdobeExtensionLevel(e2);
  }
  static agent(e2) {
    return new Agent(e2);
  }
  static alwaysEmbed(e2) {
    return new AlwaysEmbed(e2);
  }
  static amd(e2) {
    return new Amd(e2);
  }
  static area(e2) {
    return new config_Area(e2);
  }
  static attributes(e2) {
    return new Attributes(e2);
  }
  static autoSave(e2) {
    return new AutoSave(e2);
  }
  static base(e2) {
    return new Base(e2);
  }
  static batchOutput(e2) {
    return new BatchOutput(e2);
  }
  static behaviorOverride(e2) {
    return new BehaviorOverride(e2);
  }
  static cache(e2) {
    return new Cache(e2);
  }
  static change(e2) {
    return new Change(e2);
  }
  static common(e2) {
    return new Common(e2);
  }
  static compress(e2) {
    return new Compress(e2);
  }
  static compressLogicalStructure(e2) {
    return new CompressLogicalStructure(e2);
  }
  static compressObjectStream(e2) {
    return new CompressObjectStream(e2);
  }
  static compression(e2) {
    return new Compression(e2);
  }
  static config(e2) {
    return new Config(e2);
  }
  static conformance(e2) {
    return new Conformance(e2);
  }
  static contentCopy(e2) {
    return new ContentCopy(e2);
  }
  static copies(e2) {
    return new Copies(e2);
  }
  static creator(e2) {
    return new Creator(e2);
  }
  static currentPage(e2) {
    return new CurrentPage(e2);
  }
  static data(e2) {
    return new Data(e2);
  }
  static debug(e2) {
    return new Debug(e2);
  }
  static defaultTypeface(e2) {
    return new DefaultTypeface(e2);
  }
  static destination(e2) {
    return new Destination(e2);
  }
  static documentAssembly(e2) {
    return new DocumentAssembly(e2);
  }
  static driver(e2) {
    return new Driver(e2);
  }
  static duplexOption(e2) {
    return new DuplexOption(e2);
  }
  static dynamicRender(e2) {
    return new DynamicRender(e2);
  }
  static embed(e2) {
    return new Embed(e2);
  }
  static encrypt(e2) {
    return new config_Encrypt(e2);
  }
  static encryption(e2) {
    return new config_Encryption(e2);
  }
  static encryptionLevel(e2) {
    return new EncryptionLevel(e2);
  }
  static enforce(e2) {
    return new Enforce(e2);
  }
  static equate(e2) {
    return new Equate(e2);
  }
  static equateRange(e2) {
    return new EquateRange(e2);
  }
  static exclude(e2) {
    return new Exclude(e2);
  }
  static excludeNS(e2) {
    return new ExcludeNS(e2);
  }
  static flipLabel(e2) {
    return new FlipLabel(e2);
  }
  static fontInfo(e2) {
    return new config_FontInfo(e2);
  }
  static formFieldFilling(e2) {
    return new FormFieldFilling(e2);
  }
  static groupParent(e2) {
    return new GroupParent(e2);
  }
  static ifEmpty(e2) {
    return new IfEmpty(e2);
  }
  static includeXDPContent(e2) {
    return new IncludeXDPContent(e2);
  }
  static incrementalLoad(e2) {
    return new IncrementalLoad(e2);
  }
  static incrementalMerge(e2) {
    return new IncrementalMerge(e2);
  }
  static interactive(e2) {
    return new Interactive(e2);
  }
  static jog(e2) {
    return new Jog(e2);
  }
  static labelPrinter(e2) {
    return new LabelPrinter(e2);
  }
  static layout(e2) {
    return new Layout(e2);
  }
  static level(e2) {
    return new Level(e2);
  }
  static linearized(e2) {
    return new Linearized(e2);
  }
  static locale(e2) {
    return new Locale(e2);
  }
  static localeSet(e2) {
    return new LocaleSet(e2);
  }
  static log(e2) {
    return new Log(e2);
  }
  static map(e2) {
    return new MapElement(e2);
  }
  static mediumInfo(e2) {
    return new MediumInfo(e2);
  }
  static message(e2) {
    return new config_Message(e2);
  }
  static messaging(e2) {
    return new Messaging(e2);
  }
  static mode(e2) {
    return new Mode(e2);
  }
  static modifyAnnots(e2) {
    return new ModifyAnnots(e2);
  }
  static msgId(e2) {
    return new MsgId(e2);
  }
  static nameAttr(e2) {
    return new NameAttr(e2);
  }
  static neverEmbed(e2) {
    return new NeverEmbed(e2);
  }
  static numberOfCopies(e2) {
    return new NumberOfCopies(e2);
  }
  static openAction(e2) {
    return new OpenAction(e2);
  }
  static output(e2) {
    return new Output(e2);
  }
  static outputBin(e2) {
    return new OutputBin(e2);
  }
  static outputXSL(e2) {
    return new OutputXSL(e2);
  }
  static overprint(e2) {
    return new Overprint(e2);
  }
  static packets(e2) {
    return new Packets(e2);
  }
  static pageOffset(e2) {
    return new PageOffset(e2);
  }
  static pageRange(e2) {
    return new PageRange(e2);
  }
  static pagination(e2) {
    return new Pagination(e2);
  }
  static paginationOverride(e2) {
    return new PaginationOverride(e2);
  }
  static part(e2) {
    return new Part(e2);
  }
  static pcl(e2) {
    return new Pcl(e2);
  }
  static pdf(e2) {
    return new Pdf(e2);
  }
  static pdfa(e2) {
    return new Pdfa(e2);
  }
  static permissions(e2) {
    return new Permissions(e2);
  }
  static pickTrayByPDFSize(e2) {
    return new PickTrayByPDFSize(e2);
  }
  static picture(e2) {
    return new config_Picture(e2);
  }
  static plaintextMetadata(e2) {
    return new PlaintextMetadata(e2);
  }
  static presence(e2) {
    return new Presence(e2);
  }
  static present(e2) {
    return new Present(e2);
  }
  static print(e2) {
    return new Print(e2);
  }
  static printHighQuality(e2) {
    return new PrintHighQuality(e2);
  }
  static printScaling(e2) {
    return new PrintScaling(e2);
  }
  static printerName(e2) {
    return new PrinterName(e2);
  }
  static producer(e2) {
    return new Producer(e2);
  }
  static ps(e2) {
    return new Ps(e2);
  }
  static range(e2) {
    return new Range(e2);
  }
  static record(e2) {
    return new Record(e2);
  }
  static relevant(e2) {
    return new Relevant(e2);
  }
  static rename(e2) {
    return new Rename(e2);
  }
  static renderPolicy(e2) {
    return new RenderPolicy(e2);
  }
  static runScripts(e2) {
    return new RunScripts(e2);
  }
  static script(e2) {
    return new config_Script(e2);
  }
  static scriptModel(e2) {
    return new ScriptModel(e2);
  }
  static severity(e2) {
    return new Severity(e2);
  }
  static silentPrint(e2) {
    return new SilentPrint(e2);
  }
  static staple(e2) {
    return new Staple(e2);
  }
  static startNode(e2) {
    return new StartNode(e2);
  }
  static startPage(e2) {
    return new StartPage(e2);
  }
  static submitFormat(e2) {
    return new SubmitFormat(e2);
  }
  static submitUrl(e2) {
    return new SubmitUrl(e2);
  }
  static subsetBelow(e2) {
    return new SubsetBelow(e2);
  }
  static suppressBanner(e2) {
    return new SuppressBanner(e2);
  }
  static tagged(e2) {
    return new Tagged(e2);
  }
  static template(e2) {
    return new config_Template(e2);
  }
  static templateCache(e2) {
    return new TemplateCache(e2);
  }
  static threshold(e2) {
    return new Threshold(e2);
  }
  static to(e2) {
    return new To(e2);
  }
  static trace(e2) {
    return new Trace(e2);
  }
  static transform(e2) {
    return new Transform(e2);
  }
  static type(e2) {
    return new Type(e2);
  }
  static uri(e2) {
    return new Uri(e2);
  }
  static validate(e2) {
    return new config_Validate(e2);
  }
  static validateApprovalSignatures(e2) {
    return new ValidateApprovalSignatures(e2);
  }
  static validationMessaging(e2) {
    return new ValidationMessaging(e2);
  }
  static version(e2) {
    return new Version(e2);
  }
  static versionControl(e2) {
    return new VersionControl(e2);
  }
  static viewerPreferences(e2) {
    return new ViewerPreferences(e2);
  }
  static webClient(e2) {
    return new WebClient(e2);
  }
  static whitespace(e2) {
    return new Whitespace(e2);
  }
  static window(e2) {
    return new Window(e2);
  }
  static xdc(e2) {
    return new Xdc(e2);
  }
  static xdp(e2) {
    return new Xdp(e2);
  }
  static xsl(e2) {
    return new Xsl(e2);
  }
  static zpl(e2) {
    return new Zpl(e2);
  }
};
var Xn = hn.connectionSet.id;
var ConnectionSet = class extends XFAObject {
  constructor(e2) {
    super(Xn, "connectionSet", true);
    this.wsdlConnection = new XFAObjectArray();
    this.xmlConnection = new XFAObjectArray();
    this.xsdConnection = new XFAObjectArray();
  }
};
var EffectiveInputPolicy = class extends XFAObject {
  constructor(e2) {
    super(Xn, "effectiveInputPolicy");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var EffectiveOutputPolicy = class extends XFAObject {
  constructor(e2) {
    super(Xn, "effectiveOutputPolicy");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Operation = class extends StringObject {
  constructor(e2) {
    super(Xn, "operation");
    this.id = e2.id || "";
    this.input = e2.input || "";
    this.name = e2.name || "";
    this.output = e2.output || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var RootElement = class extends StringObject {
  constructor(e2) {
    super(Xn, "rootElement");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var SoapAction = class extends StringObject {
  constructor(e2) {
    super(Xn, "soapAction");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var SoapAddress = class extends StringObject {
  constructor(e2) {
    super(Xn, "soapAddress");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var connection_set_Uri = class extends StringObject {
  constructor(e2) {
    super(Xn, "uri");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var WsdlAddress = class extends StringObject {
  constructor(e2) {
    super(Xn, "wsdlAddress");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var WsdlConnection = class extends XFAObject {
  constructor(e2) {
    super(Xn, "wsdlConnection", true);
    this.dataDescription = e2.dataDescription || "";
    this.name = e2.name || "";
    this.effectiveInputPolicy = null;
    this.effectiveOutputPolicy = null;
    this.operation = null;
    this.soapAction = null;
    this.soapAddress = null;
    this.wsdlAddress = null;
  }
};
var XmlConnection = class extends XFAObject {
  constructor(e2) {
    super(Xn, "xmlConnection", true);
    this.dataDescription = e2.dataDescription || "";
    this.name = e2.name || "";
    this.uri = null;
  }
};
var XsdConnection = class extends XFAObject {
  constructor(e2) {
    super(Xn, "xsdConnection", true);
    this.dataDescription = e2.dataDescription || "";
    this.name = e2.name || "";
    this.rootElement = null;
    this.uri = null;
  }
};
var ConnectionSetNamespace = class _ConnectionSetNamespace {
  static [Cn](e2, t2) {
    if (_ConnectionSetNamespace.hasOwnProperty(e2))
      return _ConnectionSetNamespace[e2](t2);
  }
  static connectionSet(e2) {
    return new ConnectionSet(e2);
  }
  static effectiveInputPolicy(e2) {
    return new EffectiveInputPolicy(e2);
  }
  static effectiveOutputPolicy(e2) {
    return new EffectiveOutputPolicy(e2);
  }
  static operation(e2) {
    return new Operation(e2);
  }
  static rootElement(e2) {
    return new RootElement(e2);
  }
  static soapAction(e2) {
    return new SoapAction(e2);
  }
  static soapAddress(e2) {
    return new SoapAddress(e2);
  }
  static uri(e2) {
    return new connection_set_Uri(e2);
  }
  static wsdlAddress(e2) {
    return new WsdlAddress(e2);
  }
  static wsdlConnection(e2) {
    return new WsdlConnection(e2);
  }
  static xmlConnection(e2) {
    return new XmlConnection(e2);
  }
  static xsdConnection(e2) {
    return new XsdConnection(e2);
  }
};
var Zn = hn.datasets.id;
var datasets_Data = class extends XmlObject {
  constructor(e2) {
    super(Zn, "data", e2);
  }
  [Lr]() {
    return true;
  }
};
var Datasets = class extends XFAObject {
  constructor(e2) {
    super(Zn, "datasets", true);
    this.data = null;
    this.Signature = null;
  }
  [Pr](e2) {
    const t2 = e2[qr];
    ("data" === t2 && e2[Tr] === Zn || "Signature" === t2 && e2[Tr] === hn.signature.id) && (this[t2] = e2);
    this[_s2](e2);
  }
};
var DatasetsNamespace = class _DatasetsNamespace {
  static [Cn](e2, t2) {
    if (_DatasetsNamespace.hasOwnProperty(e2))
      return _DatasetsNamespace[e2](t2);
  }
  static datasets(e2) {
    return new Datasets(e2);
  }
  static data(e2) {
    return new datasets_Data(e2);
  }
};
var Vn = hn.localeSet.id;
var CalendarSymbols = class extends XFAObject {
  constructor(e2) {
    super(Vn, "calendarSymbols", true);
    this.name = "gregorian";
    this.dayNames = new XFAObjectArray(2);
    this.eraNames = null;
    this.meridiemNames = null;
    this.monthNames = new XFAObjectArray(2);
  }
};
var CurrencySymbol = class extends StringObject {
  constructor(e2) {
    super(Vn, "currencySymbol");
    this.name = getStringOption(e2.name, ["symbol", "isoname", "decimal"]);
  }
};
var CurrencySymbols = class extends XFAObject {
  constructor(e2) {
    super(Vn, "currencySymbols", true);
    this.currencySymbol = new XFAObjectArray(3);
  }
};
var DatePattern = class extends StringObject {
  constructor(e2) {
    super(Vn, "datePattern");
    this.name = getStringOption(e2.name, ["full", "long", "med", "short"]);
  }
};
var DatePatterns = class extends XFAObject {
  constructor(e2) {
    super(Vn, "datePatterns", true);
    this.datePattern = new XFAObjectArray(4);
  }
};
var DateTimeSymbols = class extends ContentObject {
  constructor(e2) {
    super(Vn, "dateTimeSymbols");
  }
};
var Day = class extends StringObject {
  constructor(e2) {
    super(Vn, "day");
  }
};
var DayNames = class extends XFAObject {
  constructor(e2) {
    super(Vn, "dayNames", true);
    this.abbr = getInteger({ data: e2.abbr, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.day = new XFAObjectArray(7);
  }
};
var Era = class extends StringObject {
  constructor(e2) {
    super(Vn, "era");
  }
};
var EraNames = class extends XFAObject {
  constructor(e2) {
    super(Vn, "eraNames", true);
    this.era = new XFAObjectArray(2);
  }
};
var locale_set_Locale = class extends XFAObject {
  constructor(e2) {
    super(Vn, "locale", true);
    this.desc = e2.desc || "";
    this.name = "isoname";
    this.calendarSymbols = null;
    this.currencySymbols = null;
    this.datePatterns = null;
    this.dateTimeSymbols = null;
    this.numberPatterns = null;
    this.numberSymbols = null;
    this.timePatterns = null;
    this.typeFaces = null;
  }
};
var locale_set_LocaleSet = class extends XFAObject {
  constructor(e2) {
    super(Vn, "localeSet", true);
    this.locale = new XFAObjectArray();
  }
};
var Meridiem = class extends StringObject {
  constructor(e2) {
    super(Vn, "meridiem");
  }
};
var MeridiemNames = class extends XFAObject {
  constructor(e2) {
    super(Vn, "meridiemNames", true);
    this.meridiem = new XFAObjectArray(2);
  }
};
var Month = class extends StringObject {
  constructor(e2) {
    super(Vn, "month");
  }
};
var MonthNames = class extends XFAObject {
  constructor(e2) {
    super(Vn, "monthNames", true);
    this.abbr = getInteger({ data: e2.abbr, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.month = new XFAObjectArray(12);
  }
};
var NumberPattern = class extends StringObject {
  constructor(e2) {
    super(Vn, "numberPattern");
    this.name = getStringOption(e2.name, ["full", "long", "med", "short"]);
  }
};
var NumberPatterns = class extends XFAObject {
  constructor(e2) {
    super(Vn, "numberPatterns", true);
    this.numberPattern = new XFAObjectArray(4);
  }
};
var NumberSymbol = class extends StringObject {
  constructor(e2) {
    super(Vn, "numberSymbol");
    this.name = getStringOption(e2.name, ["decimal", "grouping", "percent", "minus", "zero"]);
  }
};
var NumberSymbols = class extends XFAObject {
  constructor(e2) {
    super(Vn, "numberSymbols", true);
    this.numberSymbol = new XFAObjectArray(5);
  }
};
var TimePattern = class extends StringObject {
  constructor(e2) {
    super(Vn, "timePattern");
    this.name = getStringOption(e2.name, ["full", "long", "med", "short"]);
  }
};
var TimePatterns = class extends XFAObject {
  constructor(e2) {
    super(Vn, "timePatterns", true);
    this.timePattern = new XFAObjectArray(4);
  }
};
var TypeFace = class extends XFAObject {
  constructor(e2) {
    super(Vn, "typeFace", true);
    this.name = "" | e2.name;
  }
};
var TypeFaces = class extends XFAObject {
  constructor(e2) {
    super(Vn, "typeFaces", true);
    this.typeFace = new XFAObjectArray();
  }
};
var LocaleSetNamespace = class _LocaleSetNamespace {
  static [Cn](e2, t2) {
    if (_LocaleSetNamespace.hasOwnProperty(e2))
      return _LocaleSetNamespace[e2](t2);
  }
  static calendarSymbols(e2) {
    return new CalendarSymbols(e2);
  }
  static currencySymbol(e2) {
    return new CurrencySymbol(e2);
  }
  static currencySymbols(e2) {
    return new CurrencySymbols(e2);
  }
  static datePattern(e2) {
    return new DatePattern(e2);
  }
  static datePatterns(e2) {
    return new DatePatterns(e2);
  }
  static dateTimeSymbols(e2) {
    return new DateTimeSymbols(e2);
  }
  static day(e2) {
    return new Day(e2);
  }
  static dayNames(e2) {
    return new DayNames(e2);
  }
  static era(e2) {
    return new Era(e2);
  }
  static eraNames(e2) {
    return new EraNames(e2);
  }
  static locale(e2) {
    return new locale_set_Locale(e2);
  }
  static localeSet(e2) {
    return new locale_set_LocaleSet(e2);
  }
  static meridiem(e2) {
    return new Meridiem(e2);
  }
  static meridiemNames(e2) {
    return new MeridiemNames(e2);
  }
  static month(e2) {
    return new Month(e2);
  }
  static monthNames(e2) {
    return new MonthNames(e2);
  }
  static numberPattern(e2) {
    return new NumberPattern(e2);
  }
  static numberPatterns(e2) {
    return new NumberPatterns(e2);
  }
  static numberSymbol(e2) {
    return new NumberSymbol(e2);
  }
  static numberSymbols(e2) {
    return new NumberSymbols(e2);
  }
  static timePattern(e2) {
    return new TimePattern(e2);
  }
  static timePatterns(e2) {
    return new TimePatterns(e2);
  }
  static typeFace(e2) {
    return new TypeFace(e2);
  }
  static typeFaces(e2) {
    return new TypeFaces(e2);
  }
};
var zn = hn.signature.id;
var signature_Signature = class extends XFAObject {
  constructor(e2) {
    super(zn, "signature", true);
  }
};
var SignatureNamespace = class _SignatureNamespace {
  static [Cn](e2, t2) {
    if (_SignatureNamespace.hasOwnProperty(e2))
      return _SignatureNamespace[e2](t2);
  }
  static signature(e2) {
    return new signature_Signature(e2);
  }
};
var _n2 = hn.stylesheet.id;
var Stylesheet = class extends XFAObject {
  constructor(e2) {
    super(_n2, "stylesheet", true);
  }
};
var StylesheetNamespace = class _StylesheetNamespace {
  static [Cn](e2, t2) {
    if (_StylesheetNamespace.hasOwnProperty(e2))
      return _StylesheetNamespace[e2](t2);
  }
  static stylesheet(e2) {
    return new Stylesheet(e2);
  }
};
var $n = hn.xdp.id;
var xdp_Xdp = class extends XFAObject {
  constructor(e2) {
    super($n, "xdp", true);
    this.uuid = e2.uuid || "";
    this.timeStamp = e2.timeStamp || "";
    this.config = null;
    this.connectionSet = null;
    this.datasets = null;
    this.localeSet = null;
    this.stylesheet = new XFAObjectArray();
    this.template = null;
  }
  [Wr](e2) {
    const t2 = hn[e2[qr]];
    return t2 && e2[Tr] === t2.id;
  }
};
var XdpNamespace = class _XdpNamespace {
  static [Cn](e2, t2) {
    if (_XdpNamespace.hasOwnProperty(e2))
      return _XdpNamespace[e2](t2);
  }
  static xdp(e2) {
    return new xdp_Xdp(e2);
  }
};
var Ag = hn.xhtml.id;
var eg = Symbol();
var tg = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]);
var ig = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (e2) => "none" === e2 ? "none" : "normal"], ["xfa-font-horizontal-scale", (e2) => `scaleX(${Math.max(0, Math.min(parseInt(e2) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (e2) => `scaleY(${Math.max(0, Math.min(parseInt(e2) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (e2, t2) => measureToString(0.99 * (e2 = t2.fontSize = getMeasurement(e2)))], ["letter-spacing", (e2) => measureToString(getMeasurement(e2))], ["line-height", (e2) => measureToString(getMeasurement(e2))], ["margin", (e2) => measureToString(getMeasurement(e2))], ["margin-bottom", (e2) => measureToString(getMeasurement(e2))], ["margin-left", (e2) => measureToString(getMeasurement(e2))], ["margin-right", (e2) => measureToString(getMeasurement(e2))], ["margin-top", (e2) => measureToString(getMeasurement(e2))], ["text-indent", (e2) => measureToString(getMeasurement(e2))], ["font-family", (e2) => e2], ["vertical-align", (e2) => measureToString(getMeasurement(e2))]]);
var ag = /\s+/g;
var sg = /[\r\n]+/g;
var rg = /\r\n?/g;
function mapStyle(e2, t2, i2) {
  const a2 = /* @__PURE__ */ Object.create(null);
  if (!e2)
    return a2;
  const s2 = /* @__PURE__ */ Object.create(null);
  for (const [t3, i3] of e2.split(";").map((e3) => e3.split(":", 2))) {
    const e3 = ig.get(t3);
    if ("" === e3)
      continue;
    let r2 = i3;
    e3 && (r2 = "string" == typeof e3 ? e3 : e3(i3, s2));
    t3.endsWith("scale") ? a2.transform = a2.transform ? `${a2[t3]} ${r2}` : r2 : a2[t3.replaceAll(/-([a-zA-Z])/g, (e4, t4) => t4.toUpperCase())] = r2;
  }
  a2.fontFamily && setFontFamily({ typeface: a2.fontFamily, weight: a2.fontWeight || "normal", posture: a2.fontStyle || "normal", size: s2.fontSize || 0 }, t2, t2[Fr].fontFinder, a2);
  if (i2 && a2.verticalAlign && "0px" !== a2.verticalAlign && a2.fontSize) {
    const e3 = 0.583, t3 = 0.333, i3 = getMeasurement(a2.fontSize);
    a2.fontSize = measureToString(i3 * e3);
    a2.verticalAlign = measureToString(Math.sign(getMeasurement(a2.verticalAlign)) * i3 * t3);
  }
  i2 && a2.fontSize && (a2.fontSize = `calc(${a2.fontSize} * var(--scale-factor))`);
  fixTextIndent(a2);
  return a2;
}
var ng = /* @__PURE__ */ new Set(["body", "html"]);
var XhtmlObject = class extends XmlObject {
  constructor(e2, t2) {
    super(Ag, t2);
    this[eg] = false;
    this.style = e2.style || "";
  }
  [Ar](e2) {
    super[Ar](e2);
    this.style = function checkStyle(e3) {
      return e3.style ? e3.style.trim().split(/\s*;\s*/).filter((e4) => !!e4).map((e4) => e4.split(/\s*:\s*/, 2)).filter(([t2, i2]) => {
        "font-family" === t2 && e3[Fr].usedTypefaces.add(i2);
        return tg.has(t2);
      }).map((e4) => e4.join(":")).join(";") : "";
    }(this);
  }
  [Vs]() {
    return !ng.has(this[qr]);
  }
  [jr](e2, t2 = false) {
    if (t2)
      this[eg] = true;
    else {
      e2 = e2.replaceAll(sg, "");
      this.style.includes("xfa-spacerun:yes") || (e2 = e2.replaceAll(ag, " "));
    }
    e2 && (this[sr] += e2);
  }
  [Xr](e2, t2 = true) {
    const i2 = /* @__PURE__ */ Object.create(null), a2 = { top: NaN, bottom: NaN, left: NaN, right: NaN };
    let s2 = null;
    for (const [e3, t3] of this.style.split(";").map((e4) => e4.split(":", 2)))
      switch (e3) {
        case "font-family":
          i2.typeface = stripQuotes(t3);
          break;
        case "font-size":
          i2.size = getMeasurement(t3);
          break;
        case "font-weight":
          i2.weight = t3;
          break;
        case "font-style":
          i2.posture = t3;
          break;
        case "letter-spacing":
          i2.letterSpacing = getMeasurement(t3);
          break;
        case "margin":
          const e4 = t3.split(/ \t/).map((e5) => getMeasurement(e5));
          switch (e4.length) {
            case 1:
              a2.top = a2.bottom = a2.left = a2.right = e4[0];
              break;
            case 2:
              a2.top = a2.bottom = e4[0];
              a2.left = a2.right = e4[1];
              break;
            case 3:
              a2.top = e4[0];
              a2.bottom = e4[2];
              a2.left = a2.right = e4[1];
              break;
            case 4:
              a2.top = e4[0];
              a2.left = e4[1];
              a2.bottom = e4[2];
              a2.right = e4[3];
          }
          break;
        case "margin-top":
          a2.top = getMeasurement(t3);
          break;
        case "margin-bottom":
          a2.bottom = getMeasurement(t3);
          break;
        case "margin-left":
          a2.left = getMeasurement(t3);
          break;
        case "margin-right":
          a2.right = getMeasurement(t3);
          break;
        case "line-height":
          s2 = getMeasurement(t3);
      }
    e2.pushData(i2, a2, s2);
    if (this[sr])
      e2.addString(this[sr]);
    else
      for (const t3 of this[pr]())
        "#text" !== t3[qr] ? t3[Xr](e2) : e2.addString(t3[sr]);
    t2 && e2.popFont();
  }
  [gn](e2) {
    const t2 = [];
    this[gr] = { children: t2 };
    this[$s]({});
    if (0 === t2.length && !this[sr])
      return HTMLResult.EMPTY;
    let i2;
    i2 = this[eg] ? this[sr] ? this[sr].replaceAll(rg, "\n") : void 0 : this[sr] || void 0;
    return HTMLResult.success({ name: this[qr], attributes: { href: this.href, style: mapStyle(this.style, this, this[eg]) }, children: t2, value: i2 });
  }
};
var A = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "a");
    this.href = fixURL(e2.href) || "";
  }
};
var B = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "b");
  }
  [Xr](e2) {
    e2.pushFont({ weight: "bold" });
    super[Xr](e2);
    e2.popFont();
  }
};
var Body = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "body");
  }
  [gn](e2) {
    const t2 = super[gn](e2), { html: i2 } = t2;
    if (!i2)
      return HTMLResult.EMPTY;
    i2.name = "div";
    i2.attributes.class = ["xfaRich"];
    return t2;
  }
};
var Br = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "br");
  }
  [rn]() {
    return "\n";
  }
  [Xr](e2) {
    e2.addString("\n");
  }
  [gn](e2) {
    return HTMLResult.success({ name: "br" });
  }
};
var Html = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "html");
  }
  [gn](e2) {
    var _a4;
    const t2 = [];
    this[gr] = { children: t2 };
    this[$s]({});
    if (0 === t2.length)
      return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, value: this[sr] || "" });
    if (1 === t2.length) {
      const e3 = t2[0];
      if ((_a4 = e3.attributes) == null ? void 0 : _a4.class.includes("xfaRich"))
        return HTMLResult.success(e3);
    }
    return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, children: t2 });
  }
};
var I = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "i");
  }
  [Xr](e2) {
    e2.pushFont({ posture: "italic" });
    super[Xr](e2);
    e2.popFont();
  }
};
var Li = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "li");
  }
};
var Ol = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "ol");
  }
};
var P = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "p");
  }
  [Xr](e2) {
    super[Xr](e2, false);
    e2.addString("\n");
    e2.addPara();
    e2.popFont();
  }
  [rn]() {
    return this[Dr]()[pr]().at(-1) === this ? super[rn]() : super[rn]() + "\n";
  }
};
var Span = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "span");
  }
};
var Sub = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "sub");
  }
};
var Sup = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "sup");
  }
};
var Ul = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "ul");
  }
};
var XhtmlNamespace = class _XhtmlNamespace {
  static [Cn](e2, t2) {
    if (_XhtmlNamespace.hasOwnProperty(e2))
      return _XhtmlNamespace[e2](t2);
  }
  static a(e2) {
    return new A(e2);
  }
  static b(e2) {
    return new B(e2);
  }
  static body(e2) {
    return new Body(e2);
  }
  static br(e2) {
    return new Br(e2);
  }
  static html(e2) {
    return new Html(e2);
  }
  static i(e2) {
    return new I(e2);
  }
  static li(e2) {
    return new Li(e2);
  }
  static ol(e2) {
    return new Ol(e2);
  }
  static p(e2) {
    return new P(e2);
  }
  static span(e2) {
    return new Span(e2);
  }
  static sub(e2) {
    return new Sub(e2);
  }
  static sup(e2) {
    return new Sup(e2);
  }
  static ul(e2) {
    return new Ul(e2);
  }
};
var gg = { config: ConfigNamespace, connection: ConnectionSetNamespace, datasets: DatasetsNamespace, localeSet: LocaleSetNamespace, signature: SignatureNamespace, stylesheet: StylesheetNamespace, template: TemplateNamespace, xdp: XdpNamespace, xhtml: XhtmlNamespace };
var UnknownNamespace = class {
  constructor(e2) {
    this.namespaceId = e2;
  }
  [Cn](e2, t2) {
    return new XmlObject(this.namespaceId, e2, t2);
  }
};
var Root = class extends XFAObject {
  constructor(e2) {
    super(-1, "root", /* @__PURE__ */ Object.create(null));
    this.element = null;
    this[kr] = e2;
  }
  [Pr](e2) {
    this.element = e2;
    return true;
  }
  [or]() {
    super[or]();
    if (this.element.template instanceof Template) {
      this[kr].set(_r2, this.element);
      this.element.template[$r](this[kr]);
      this.element.template[kr] = this[kr];
    }
  }
};
var Empty = class extends XFAObject {
  constructor() {
    super(-1, "", /* @__PURE__ */ Object.create(null));
  }
  [Pr](e2) {
    return false;
  }
};
var Builder = class {
  constructor(e2 = null) {
    this._namespaceStack = [];
    this._nsAgnosticLevel = 0;
    this._namespacePrefixes = /* @__PURE__ */ new Map();
    this._namespaces = /* @__PURE__ */ new Map();
    this._nextNsId = Math.max(...Object.values(hn).map(({ id: e3 }) => e3));
    this._currentNamespace = e2 || new UnknownNamespace(++this._nextNsId);
  }
  buildRoot(e2) {
    return new Root(e2);
  }
  build({ nsPrefix: e2, name: t2, attributes: i2, namespace: a2, prefixes: s2 }) {
    const r2 = null !== a2;
    if (r2) {
      this._namespaceStack.push(this._currentNamespace);
      this._currentNamespace = this._searchNamespace(a2);
    }
    s2 && this._addNamespacePrefix(s2);
    if (i2.hasOwnProperty(Or)) {
      const e3 = gg.datasets, t3 = i2[Or];
      let a3 = null;
      for (const [i3, s3] of Object.entries(t3)) {
        if (this._getNamespaceToUse(i3) === e3) {
          a3 = { xfa: s3 };
          break;
        }
      }
      a3 ? i2[Or] = a3 : delete i2[Or];
    }
    const n2 = this._getNamespaceToUse(e2), g2 = (n2 == null ? void 0 : n2[Cn](t2, i2)) || new Empty();
    g2[Lr]() && this._nsAgnosticLevel++;
    (r2 || s2 || g2[Lr]()) && (g2[tr] = { hasNamespace: r2, prefixes: s2, nsAgnostic: g2[Lr]() });
    return g2;
  }
  isNsAgnostic() {
    return this._nsAgnosticLevel > 0;
  }
  _searchNamespace(e2) {
    let t2 = this._namespaces.get(e2);
    if (t2)
      return t2;
    for (const [i2, { check: a2 }] of Object.entries(hn))
      if (a2(e2)) {
        t2 = gg[i2];
        if (t2) {
          this._namespaces.set(e2, t2);
          return t2;
        }
        break;
      }
    t2 = new UnknownNamespace(++this._nextNsId);
    this._namespaces.set(e2, t2);
    return t2;
  }
  _addNamespacePrefix(e2) {
    for (const { prefix: t2, value: i2 } of e2) {
      const e3 = this._searchNamespace(i2);
      let a2 = this._namespacePrefixes.get(t2);
      if (!a2) {
        a2 = [];
        this._namespacePrefixes.set(t2, a2);
      }
      a2.push(e3);
    }
  }
  _getNamespaceToUse(e2) {
    if (!e2)
      return this._currentNamespace;
    const t2 = this._namespacePrefixes.get(e2);
    if ((t2 == null ? void 0 : t2.length) > 0)
      return t2.at(-1);
    warn(`Unknown namespace prefix: ${e2}.`);
    return null;
  }
  clean(e2) {
    const { hasNamespace: t2, prefixes: i2, nsAgnostic: a2 } = e2;
    t2 && (this._currentNamespace = this._namespaceStack.pop());
    i2 && i2.forEach(({ prefix: e3 }) => {
      this._namespacePrefixes.get(e3).pop();
    });
    a2 && this._nsAgnosticLevel--;
  }
};
var XFAParser = class _XFAParser extends XMLParserBase {
  constructor(e2 = null, t2 = false) {
    super();
    this._builder = new Builder(e2);
    this._stack = [];
    this._globalData = { usedTypefaces: /* @__PURE__ */ new Set() };
    this._ids = /* @__PURE__ */ new Map();
    this._current = this._builder.buildRoot(this._ids);
    this._errorCode = Us;
    this._whiteRegex = /^\s+$/;
    this._nbsps = /\xa0+/g;
    this._richText = t2;
  }
  parse(e2) {
    this.parseXml(e2);
    if (this._errorCode === Us) {
      this._current[or]();
      return this._current.element;
    }
  }
  onText(e2) {
    e2 = e2.replace(this._nbsps, (e3) => e3.slice(1) + " ");
    this._richText || this._current[Vs]() ? this._current[jr](e2, this._richText) : this._whiteRegex.test(e2) || this._current[jr](e2.trim());
  }
  onCdata(e2) {
    this._current[jr](e2);
  }
  _mkAttributes(e2, t2) {
    let i2 = null, a2 = null;
    const s2 = /* @__PURE__ */ Object.create({});
    for (const { name: r2, value: n2 } of e2)
      if ("xmlns" === r2)
        i2 ? warn(`XFA - multiple namespace definition in <${t2}>`) : i2 = n2;
      else if (r2.startsWith("xmlns:")) {
        const e3 = r2.substring(6);
        a2 || (a2 = []);
        a2.push({ prefix: e3, value: n2 });
      } else {
        const e3 = r2.indexOf(":");
        if (-1 === e3)
          s2[r2] = n2;
        else {
          let t3 = s2[Or];
          t3 || (t3 = s2[Or] = /* @__PURE__ */ Object.create(null));
          const [i3, a3] = [r2.slice(0, e3), r2.slice(e3 + 1)];
          (t3[i3] || (t3[i3] = /* @__PURE__ */ Object.create(null)))[a3] = n2;
        }
      }
    return [i2, a2, s2];
  }
  _getNameAndPrefix(e2, t2) {
    const i2 = e2.indexOf(":");
    return -1 === i2 ? [e2, null] : [e2.substring(i2 + 1), t2 ? "" : e2.substring(0, i2)];
  }
  onBeginElement(e2, t2, i2) {
    const [a2, s2, r2] = this._mkAttributes(t2, e2), [n2, g2] = this._getNameAndPrefix(e2, this._builder.isNsAgnostic()), o2 = this._builder.build({ nsPrefix: g2, name: n2, attributes: r2, namespace: a2, prefixes: s2 });
    o2[Fr] = this._globalData;
    if (i2) {
      o2[or]();
      this._current[Pr](o2) && o2[en](this._ids);
      o2[Ar](this._builder);
    } else {
      this._stack.push(this._current);
      this._current = o2;
    }
  }
  onEndElement(e2) {
    const t2 = this._current;
    if (t2[Gr]() && "string" == typeof t2[sr]) {
      const e3 = new _XFAParser();
      e3._globalData = this._globalData;
      const i2 = e3.parse(t2[sr]);
      t2[sr] = null;
      t2[Pr](i2);
    }
    t2[or]();
    this._current = this._stack.pop();
    this._current[Pr](t2) && t2[en](this._ids);
    t2[Ar](this._builder);
  }
  onError(e2) {
    this._errorCode = e2;
  }
};
var XFAFactory = class _XFAFactory {
  constructor(e2) {
    try {
      this.root = new XFAParser().parse(_XFAFactory._createDocument(e2));
      const t2 = new Binder(this.root);
      this.form = t2.bind();
      this.dataHandler = new DataHandler(this.root, t2.getData());
      this.form[Fr].template = this.form;
    } catch (e3) {
      warn(`XFA - an error occurred during parsing and binding: ${e3}`);
    }
  }
  isValid() {
    return this.root && this.form;
  }
  _createPagesHelper() {
    const e2 = this.form[nn]();
    return new Promise((t2, i2) => {
      const nextIteration = () => {
        try {
          const i3 = e2.next();
          i3.done ? t2(i3.value) : setTimeout(nextIteration, 0);
        } catch (e3) {
          i2(e3);
        }
      };
      setTimeout(nextIteration, 0);
    });
  }
  async _createPages() {
    try {
      this.pages = await this._createPagesHelper();
      this.dims = this.pages.children.map((e2) => {
        const { width: t2, height: i2 } = e2.attributes.style;
        return [0, 0, parseInt(t2), parseInt(i2)];
      });
    } catch (e2) {
      warn(`XFA - an error occurred during layout: ${e2}`);
    }
  }
  getBoundingBox(e2) {
    return this.dims[e2];
  }
  async getNumPages() {
    this.pages || await this._createPages();
    return this.dims.length;
  }
  setImages(e2) {
    this.form[Fr].images = e2;
  }
  setFonts(e2) {
    this.form[Fr].fontFinder = new FontFinder(e2);
    const t2 = [];
    for (let e3 of this.form[Fr].usedTypefaces) {
      e3 = stripQuotes(e3);
      this.form[Fr].fontFinder.find(e3) || t2.push(e3);
    }
    return t2.length > 0 ? t2 : null;
  }
  appendFonts(e2, t2) {
    this.form[Fr].fontFinder.add(e2, t2);
  }
  async getPages() {
    this.pages || await this._createPages();
    const e2 = this.pages;
    this.pages = null;
    return e2;
  }
  serializeData(e2) {
    return this.dataHandler.serialize(e2);
  }
  static _createDocument(e2) {
    return e2["/xdp:xdp"] ? Object.values(e2).join("") : e2["xdp:xdp"];
  }
  static getRichTextAsHtml(e2) {
    if (!e2 || "string" != typeof e2)
      return null;
    try {
      let t2 = new XFAParser(XhtmlNamespace, true).parse(e2);
      if (!["body", "xhtml"].includes(t2[qr])) {
        const e3 = XhtmlNamespace.body({});
        e3[_s2](t2);
        t2 = e3;
      }
      const i2 = t2[gn]();
      if (!i2.success)
        return null;
      const { html: a2 } = i2, { attributes: s2 } = a2;
      if (s2) {
        s2.class && (s2.class = s2.class.filter((e3) => !e3.startsWith("xfa")));
        s2.dir = "auto";
      }
      return { html: a2, str: t2[rn]() };
    } catch (e3) {
      warn(`XFA - an error occurred during parsing of rich text: ${e3}`);
    }
    return null;
  }
};
var AnnotationFactory = class {
  static createGlobals(e2) {
    return Promise.all([e2.ensureCatalog("acroForm"), e2.ensureDoc("xfaDatasets"), e2.ensureCatalog("structTreeRoot"), e2.ensureCatalog("baseUrl"), e2.ensureCatalog("attachments")]).then(([t2, i2, a2, s2, r2]) => ({ pdfManager: e2, acroForm: t2 instanceof Dict ? t2 : Dict.empty, xfaDatasets: i2, structTreeRoot: a2, baseUrl: s2, attachments: r2 }), (e3) => {
      warn(`createGlobals: "${e3}".`);
      return null;
    });
  }
  static async create(e2, t2, i2, a2, s2, r2) {
    const n2 = s2 ? await this._getPageIndex(e2, t2, i2.pdfManager) : null;
    return i2.pdfManager.ensure(this, "_create", [e2, t2, i2, a2, s2, n2, r2]);
  }
  static _create(e2, t2, i2, a2, s2 = false, r2 = null, n2 = null) {
    const g2 = e2.fetchIfRef(t2);
    if (!(g2 instanceof Dict))
      return;
    const { acroForm: o2, pdfManager: c2 } = i2, C2 = t2 instanceof Ref ? t2.toString() : `annot_${a2.createObjId()}`;
    let h2 = g2.get("Subtype");
    h2 = h2 instanceof Name ? h2.name : null;
    const l2 = { xref: e2, ref: t2, dict: g2, subtype: h2, id: C2, annotationGlobals: i2, collectFields: s2, needAppearances: !s2 && true === o2.get("NeedAppearances"), pageIndex: r2, evaluatorOptions: c2.evaluatorOptions, pageRef: n2 };
    switch (h2) {
      case "Link":
        return new LinkAnnotation(l2);
      case "Text":
        return new TextAnnotation(l2);
      case "Widget":
        let e3 = getInheritableProperty({ dict: g2, key: "FT" });
        e3 = e3 instanceof Name ? e3.name : null;
        switch (e3) {
          case "Tx":
            return new TextWidgetAnnotation(l2);
          case "Btn":
            return new ButtonWidgetAnnotation(l2);
          case "Ch":
            return new ChoiceWidgetAnnotation(l2);
          case "Sig":
            return new SignatureWidgetAnnotation(l2);
        }
        warn(`Unimplemented widget field type "${e3}", falling back to base field type.`);
        return new WidgetAnnotation(l2);
      case "Popup":
        return new PopupAnnotation(l2);
      case "FreeText":
        return new FreeTextAnnotation(l2);
      case "Line":
        return new LineAnnotation(l2);
      case "Square":
        return new SquareAnnotation(l2);
      case "Circle":
        return new CircleAnnotation(l2);
      case "PolyLine":
        return new PolylineAnnotation(l2);
      case "Polygon":
        return new PolygonAnnotation(l2);
      case "Caret":
        return new CaretAnnotation(l2);
      case "Ink":
        return new InkAnnotation(l2);
      case "Highlight":
        return new HighlightAnnotation(l2);
      case "Underline":
        return new UnderlineAnnotation(l2);
      case "Squiggly":
        return new SquigglyAnnotation(l2);
      case "StrikeOut":
        return new StrikeOutAnnotation(l2);
      case "Stamp":
        return new StampAnnotation(l2);
      case "FileAttachment":
        return new FileAttachmentAnnotation(l2);
      default:
        s2 || warn(h2 ? `Unimplemented annotation type "${h2}", falling back to base annotation.` : "Annotation is missing the required /Subtype.");
        return new Annotation(l2);
    }
  }
  static async _getPageIndex(e2, t2, i2) {
    try {
      const a2 = await e2.fetchIfRefAsync(t2);
      if (!(a2 instanceof Dict))
        return -1;
      const s2 = a2.getRaw("P");
      if (s2 instanceof Ref)
        try {
          return await i2.ensureCatalog("getPageIndex", [s2]);
        } catch (e3) {
          info(`_getPageIndex -- not a valid page reference: "${e3}".`);
        }
      if (a2.has("Kids"))
        return -1;
      const r2 = await i2.ensureDoc("numPages");
      for (let e3 = 0; e3 < r2; e3++) {
        const a3 = await i2.getPage(e3), s3 = await i2.ensure(a3, "annotations");
        for (const i3 of s3)
          if (i3 instanceof Ref && isRefsEqual(i3, t2))
            return e3;
      }
    } catch (e3) {
      warn(`_getPageIndex: "${e3}".`);
    }
    return -1;
  }
  static generateImages(e2, t2, i2) {
    if (!i2) {
      warn("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images.");
      return null;
    }
    let a2;
    for (const { bitmapId: i3, bitmap: s2 } of e2)
      if (s2) {
        a2 || (a2 = /* @__PURE__ */ new Map());
        a2.set(i3, StampAnnotation.createImage(s2, t2));
      }
    return a2;
  }
  static async saveNewAnnotations(e2, t2, i2, a2) {
    const s2 = e2.xref;
    let r2;
    const n2 = [], g2 = [], { isOffscreenCanvasSupported: o2 } = e2.options;
    for (const c2 of i2)
      if (!c2.deleted)
        switch (c2.annotationType) {
          case d:
            if (!r2) {
              const e3 = new Dict(s2);
              e3.set("BaseFont", Name.get("Helvetica"));
              e3.set("Type", Name.get("Font"));
              e3.set("Subtype", Name.get("Type1"));
              e3.set("Encoding", Name.get("WinAnsiEncoding"));
              const t3 = [];
              r2 = s2.getNewTemporaryRef();
              await writeObject(r2, e3, t3, s2);
              n2.push({ ref: r2, data: t3.join("") });
            }
            g2.push(FreeTextAnnotation.createNewAnnotation(s2, c2, n2, { evaluator: e2, task: t2, baseFontRef: r2 }));
            break;
          case f:
            c2.quadPoints ? g2.push(HighlightAnnotation.createNewAnnotation(s2, c2, n2)) : g2.push(InkAnnotation.createNewAnnotation(s2, c2, n2));
            break;
          case m:
            g2.push(InkAnnotation.createNewAnnotation(s2, c2, n2));
            break;
          case p:
            if (!o2)
              break;
            const i3 = await a2.get(c2.bitmapId);
            if (i3.imageStream) {
              const { imageStream: e3, smaskStream: t3 } = i3, a3 = [];
              if (t3) {
                const i4 = s2.getNewTemporaryRef();
                await writeObject(i4, t3, a3, s2);
                n2.push({ ref: i4, data: a3.join("") });
                e3.dict.set("SMask", i4);
                a3.length = 0;
              }
              const r3 = i3.imageRef = s2.getNewTemporaryRef();
              await writeObject(r3, e3, a3, s2);
              n2.push({ ref: r3, data: a3.join("") });
              i3.imageStream = i3.smaskStream = null;
            }
            g2.push(StampAnnotation.createNewAnnotation(s2, c2, n2, { image: i3 }));
        }
    return { annotations: await Promise.all(g2), dependencies: n2 };
  }
  static async printNewAnnotations(e2, t2, i2, a2, s2) {
    if (!a2)
      return null;
    const { options: r2, xref: n2 } = t2, g2 = [];
    for (const o2 of a2)
      if (!o2.deleted)
        switch (o2.annotationType) {
          case d:
            g2.push(FreeTextAnnotation.createNewPrintAnnotation(e2, n2, o2, { evaluator: t2, task: i2, evaluatorOptions: r2 }));
            break;
          case f:
            o2.quadPoints ? g2.push(HighlightAnnotation.createNewPrintAnnotation(e2, n2, o2, { evaluatorOptions: r2 })) : g2.push(InkAnnotation.createNewPrintAnnotation(e2, n2, o2, { evaluatorOptions: r2 }));
            break;
          case m:
            g2.push(InkAnnotation.createNewPrintAnnotation(e2, n2, o2, { evaluatorOptions: r2 }));
            break;
          case p:
            if (!r2.isOffscreenCanvasSupported)
              break;
            const a3 = await s2.get(o2.bitmapId);
            if (a3.imageStream) {
              const { imageStream: e3, smaskStream: t3 } = a3;
              t3 && e3.dict.set("SMask", t3);
              a3.imageRef = new JpegStream(e3, e3.length);
              a3.imageStream = a3.smaskStream = null;
            }
            g2.push(StampAnnotation.createNewPrintAnnotation(e2, n2, o2, { image: a3, evaluatorOptions: r2 }));
        }
    return Promise.all(g2);
  }
};
function getRgbColor(e2, t2 = new Uint8ClampedArray(3)) {
  if (!Array.isArray(e2))
    return t2;
  const i2 = t2 || new Uint8ClampedArray(3);
  switch (e2.length) {
    case 0:
      return null;
    case 1:
      ColorSpace.singletons.gray.getRgbItem(e2, 0, i2, 0);
      return i2;
    case 3:
      ColorSpace.singletons.rgb.getRgbItem(e2, 0, i2, 0);
      return i2;
    case 4:
      ColorSpace.singletons.cmyk.getRgbItem(e2, 0, i2, 0);
      return i2;
    default:
      return t2;
  }
}
function getPdfColorArray(e2) {
  return Array.from(e2, (e3) => e3 / 255);
}
function getQuadPoints(e2, t2) {
  const i2 = e2.getArray("QuadPoints");
  if (!isNumberArray(i2, null) || 0 === i2.length || i2.length % 8 > 0)
    return null;
  const a2 = new Float32Array(i2.length);
  for (let e3 = 0, s2 = i2.length; e3 < s2; e3 += 8) {
    const [s3, r2, n2, g2, o2, c2, C2, h2] = i2.slice(e3, e3 + 8), l2 = Math.min(s3, n2, o2, C2), Q2 = Math.max(s3, n2, o2, C2), E2 = Math.min(r2, g2, c2, h2), u2 = Math.max(r2, g2, c2, h2);
    if (null !== t2 && (l2 < t2[0] || Q2 > t2[2] || E2 < t2[1] || u2 > t2[3]))
      return null;
    a2.set([l2, u2, Q2, u2, l2, E2, Q2, E2], e3);
  }
  return a2;
}
function getTransformMatrix(e2, t2, i2) {
  const [a2, s2, r2, n2] = Util.getAxialAlignedBoundingBox(t2, i2);
  if (a2 === r2 || s2 === n2)
    return [1, 0, 0, 1, e2[0], e2[1]];
  const g2 = (e2[2] - e2[0]) / (r2 - a2), o2 = (e2[3] - e2[1]) / (n2 - s2);
  return [g2, 0, 0, o2, e2[0] - a2 * g2, e2[1] - s2 * o2];
}
var Annotation = class {
  constructor(e2) {
    const { dict: t2, xref: i2, annotationGlobals: a2 } = e2;
    this.setTitle(t2.get("T"));
    this.setContents(t2.get("Contents"));
    this.setModificationDate(t2.get("M"));
    this.setFlags(t2.get("F"));
    this.setRectangle(t2.getArray("Rect"));
    this.setColor(t2.getArray("C"));
    this.setBorderStyle(t2);
    this.setAppearance(t2);
    this.setOptionalContent(t2);
    const s2 = t2.get("MK");
    this.setBorderAndBackgroundColors(s2);
    this.setRotation(s2, t2);
    this.ref = e2.ref instanceof Ref ? e2.ref : null;
    this._streams = [];
    this.appearance && this._streams.push(this.appearance);
    const r2 = !!(this.flags & eA), n2 = !!(this.flags & tA);
    if (a2.structTreeRoot) {
      let i3 = t2.get("StructParent");
      i3 = Number.isInteger(i3) && i3 >= 0 ? i3 : -1;
      a2.structTreeRoot.addAnnotationIdToPage(e2.pageRef, i3);
    }
    this.data = { annotationFlags: this.flags, borderStyle: this.borderStyle, color: this.color, backgroundColor: this.backgroundColor, borderColor: this.borderColor, rotation: this.rotation, contentsObj: this._contents, hasAppearance: !!this.appearance, id: e2.id, modificationDate: this.modificationDate, rect: this.rectangle, subtype: e2.subtype, hasOwnCanvas: false, noRotate: !!(this.flags & $), noHTML: r2 && n2, isEditable: false };
    if (e2.collectFields) {
      const a3 = t2.get("Kids");
      if (Array.isArray(a3)) {
        const e3 = [];
        for (const t3 of a3)
          t3 instanceof Ref && e3.push(t3.toString());
        0 !== e3.length && (this.data.kidIds = e3);
      }
      this.data.actions = collectActions(i2, t2, dA);
      this.data.fieldName = this._constructFieldName(t2);
      this.data.pageIndex = e2.pageIndex;
    }
    this._isOffscreenCanvasSupported = e2.evaluatorOptions.isOffscreenCanvasSupported;
    this._fallbackFontDict = null;
    this._needAppearances = false;
  }
  _hasFlag(e2, t2) {
    return !!(e2 & t2);
  }
  _isViewable(e2) {
    return !this._hasFlag(e2, V) && !this._hasFlag(e2, AA);
  }
  _isPrintable(e2) {
    return this._hasFlag(e2, _) && !this._hasFlag(e2, z) && !this._hasFlag(e2, V);
  }
  mustBeViewed(e2, t2) {
    var _a4;
    const i2 = (_a4 = e2 == null ? void 0 : e2.get(this.data.id)) == null ? void 0 : _a4.noView;
    return void 0 !== i2 ? !i2 : this.viewable && !this._hasFlag(this.flags, z);
  }
  mustBePrinted(e2) {
    var _a4;
    const t2 = (_a4 = e2 == null ? void 0 : e2.get(this.data.id)) == null ? void 0 : _a4.noPrint;
    return void 0 !== t2 ? !t2 : this.printable;
  }
  mustBeViewedWhenEditing(e2, t2 = null) {
    return e2 ? !this.data.isEditable : !(t2 == null ? void 0 : t2.has(this.data.id));
  }
  get viewable() {
    return null !== this.data.quadPoints && (0 === this.flags || this._isViewable(this.flags));
  }
  get printable() {
    return null !== this.data.quadPoints && (0 !== this.flags && this._isPrintable(this.flags));
  }
  _parseStringHelper(e2) {
    const t2 = "string" == typeof e2 ? stringToPDFString(e2) : "";
    return { str: t2, dir: t2 && "rtl" === bidi(t2).dir ? "rtl" : "ltr" };
  }
  setDefaultAppearance(e2) {
    const { dict: t2, annotationGlobals: i2 } = e2, a2 = getInheritableProperty({ dict: t2, key: "DA" }) || i2.acroForm.get("DA");
    this._defaultAppearance = "string" == typeof a2 ? a2 : "";
    this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance);
  }
  setTitle(e2) {
    this._title = this._parseStringHelper(e2);
  }
  setContents(e2) {
    this._contents = this._parseStringHelper(e2);
  }
  setModificationDate(e2) {
    this.modificationDate = "string" == typeof e2 ? e2 : null;
  }
  setFlags(e2) {
    this.flags = Number.isInteger(e2) && e2 > 0 ? e2 : 0;
    this.flags & V && "Annotation" !== this.constructor.name && (this.flags ^= V);
  }
  hasFlag(e2) {
    return this._hasFlag(this.flags, e2);
  }
  setRectangle(e2) {
    this.rectangle = lookupNormalRect(e2, [0, 0, 0, 0]);
  }
  setColor(e2) {
    this.color = getRgbColor(e2);
  }
  setLineEndings(e2) {
    this.lineEndings = ["None", "None"];
    if (Array.isArray(e2) && 2 === e2.length)
      for (let t2 = 0; t2 < 2; t2++) {
        const i2 = e2[t2];
        if (i2 instanceof Name)
          switch (i2.name) {
            case "None":
              continue;
            case "Square":
            case "Circle":
            case "Diamond":
            case "OpenArrow":
            case "ClosedArrow":
            case "Butt":
            case "ROpenArrow":
            case "RClosedArrow":
            case "Slash":
              this.lineEndings[t2] = i2.name;
              continue;
          }
        warn(`Ignoring invalid lineEnding: ${i2}`);
      }
  }
  setRotation(e2, t2) {
    this.rotation = 0;
    let i2 = e2 instanceof Dict ? e2.get("R") || 0 : t2.get("Rotate") || 0;
    if (Number.isInteger(i2) && 0 !== i2) {
      i2 %= 360;
      i2 < 0 && (i2 += 360);
      i2 % 90 == 0 && (this.rotation = i2);
    }
  }
  setBorderAndBackgroundColors(e2) {
    if (e2 instanceof Dict) {
      this.borderColor = getRgbColor(e2.getArray("BC"), null);
      this.backgroundColor = getRgbColor(e2.getArray("BG"), null);
    } else
      this.borderColor = this.backgroundColor = null;
  }
  setBorderStyle(e2) {
    this.borderStyle = new AnnotationBorderStyle();
    if (e2 instanceof Dict)
      if (e2.has("BS")) {
        const t2 = e2.get("BS");
        if (t2 instanceof Dict) {
          const e3 = t2.get("Type");
          if (!e3 || isName(e3, "Border")) {
            this.borderStyle.setWidth(t2.get("W"), this.rectangle);
            this.borderStyle.setStyle(t2.get("S"));
            this.borderStyle.setDashArray(t2.getArray("D"));
          }
        }
      } else if (e2.has("Border")) {
        const t2 = e2.getArray("Border");
        if (Array.isArray(t2) && t2.length >= 3) {
          this.borderStyle.setHorizontalCornerRadius(t2[0]);
          this.borderStyle.setVerticalCornerRadius(t2[1]);
          this.borderStyle.setWidth(t2[2], this.rectangle);
          4 === t2.length && this.borderStyle.setDashArray(t2[3], true);
        }
      } else
        this.borderStyle.setWidth(0);
  }
  setAppearance(e2) {
    this.appearance = null;
    const t2 = e2.get("AP");
    if (!(t2 instanceof Dict))
      return;
    const i2 = t2.get("N");
    if (i2 instanceof BaseStream) {
      this.appearance = i2;
      return;
    }
    if (!(i2 instanceof Dict))
      return;
    const a2 = e2.get("AS");
    if (!(a2 instanceof Name && i2.has(a2.name)))
      return;
    const s2 = i2.get(a2.name);
    s2 instanceof BaseStream && (this.appearance = s2);
  }
  setOptionalContent(e2) {
    this.oc = null;
    const t2 = e2.get("OC");
    t2 instanceof Name ? warn("setOptionalContent: Support for /Name-entry is not implemented.") : t2 instanceof Dict && (this.oc = t2);
  }
  loadResources(e2, t2) {
    return t2.dict.getAsync("Resources").then((t3) => {
      if (!t3)
        return;
      return new ObjectLoader(t3, e2, t3.xref).load().then(function() {
        return t3;
      });
    });
  }
  async getOperatorList(e2, t2, a2, s2) {
    const { hasOwnCanvas: r2, id: n2, rect: g2 } = this.data;
    let c2 = this.appearance;
    const C2 = !!(r2 && a2 & o);
    if (C2 && (g2[0] === g2[2] || g2[1] === g2[3])) {
      this.data.hasOwnCanvas = false;
      return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
    }
    if (!c2) {
      if (!C2)
        return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
      c2 = new StringStream("");
      c2.dict = new Dict();
    }
    const h2 = c2.dict, l2 = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], c2), Q2 = lookupRect(h2.getArray("BBox"), [0, 0, 1, 1]), E2 = lookupMatrix(h2.getArray("Matrix"), i), u2 = getTransformMatrix(g2, Q2, E2), d2 = new OperatorList();
    let f2;
    this.oc && (f2 = await e2.parseMarkedContentProps(this.oc, null));
    void 0 !== f2 && d2.addOp(Ye, ["OC", f2]);
    d2.addOp(je, [n2, g2, u2, E2, C2]);
    await e2.getOperatorList({ stream: c2, task: t2, resources: l2, operatorList: d2, fallbackFontDict: this._fallbackFontDict });
    d2.addOp(Xe, []);
    void 0 !== f2 && d2.addOp(ve, []);
    this.reset();
    return { opList: d2, separateForm: false, separateCanvas: C2 };
  }
  async save(e2, t2, i2) {
    return null;
  }
  get hasTextContent() {
    return false;
  }
  async extractTextContent(e2, t2, i2) {
    if (!this.appearance)
      return;
    const a2 = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance), s2 = [], r2 = [];
    let n2 = null;
    const g2 = { desiredSize: Math.Infinity, ready: true, enqueue(e3, t3) {
      for (const t4 of e3.items)
        if (void 0 !== t4.str) {
          n2 || (n2 = t4.transform.slice(-2));
          r2.push(t4.str);
          if (t4.hasEOL) {
            s2.push(r2.join("").trimEnd());
            r2.length = 0;
          }
        }
    } };
    await e2.getTextContent({ stream: this.appearance, task: t2, resources: a2, includeMarkedContent: true, keepWhiteSpace: true, sink: g2, viewBox: i2 });
    this.reset();
    r2.length && s2.push(r2.join("").trimEnd());
    if (s2.length > 1 || s2[0]) {
      const e3 = this.appearance.dict, t3 = lookupRect(e3.getArray("BBox"), null), i3 = lookupMatrix(e3.getArray("Matrix"), null);
      this.data.textPosition = this._transformPoint(n2, t3, i3);
      this.data.textContent = s2;
    }
  }
  _transformPoint(e2, t2, i2) {
    const { rect: a2 } = this.data;
    t2 || (t2 = [0, 0, 1, 1]);
    i2 || (i2 = [1, 0, 0, 1, 0, 0]);
    const s2 = getTransformMatrix(a2, t2, i2);
    s2[4] -= a2[0];
    s2[5] -= a2[1];
    e2 = Util.applyTransform(e2, s2);
    return Util.applyTransform(e2, i2);
  }
  getFieldObject() {
    return this.data.kidIds ? { id: this.data.id, actions: this.data.actions, name: this.data.fieldName, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, type: "", kidIds: this.data.kidIds, page: this.data.pageIndex, rotation: this.rotation } : null;
  }
  reset() {
    for (const e2 of this._streams)
      e2.reset();
  }
  _constructFieldName(e2) {
    if (!e2.has("T") && !e2.has("Parent")) {
      warn("Unknown field name, falling back to empty field name.");
      return "";
    }
    if (!e2.has("Parent"))
      return stringToPDFString(e2.get("T"));
    const t2 = [];
    e2.has("T") && t2.unshift(stringToPDFString(e2.get("T")));
    let i2 = e2;
    const a2 = new RefSet();
    e2.objId && a2.put(e2.objId);
    for (; i2.has("Parent"); ) {
      i2 = i2.get("Parent");
      if (!(i2 instanceof Dict) || i2.objId && a2.has(i2.objId))
        break;
      i2.objId && a2.put(i2.objId);
      i2.has("T") && t2.unshift(stringToPDFString(i2.get("T")));
    }
    return t2.join(".");
  }
};
var AnnotationBorderStyle = class {
  constructor() {
    this.width = 1;
    this.style = BA;
    this.dashArray = [3];
    this.horizontalCornerRadius = 0;
    this.verticalCornerRadius = 0;
  }
  setWidth(e2, t2 = [0, 0, 0, 0]) {
    if (e2 instanceof Name)
      this.width = 0;
    else if ("number" == typeof e2) {
      if (e2 > 0) {
        const i2 = (t2[2] - t2[0]) / 2, a2 = (t2[3] - t2[1]) / 2;
        if (i2 > 0 && a2 > 0 && (e2 > i2 || e2 > a2)) {
          warn(`AnnotationBorderStyle.setWidth - ignoring width: ${e2}`);
          e2 = 1;
        }
      }
      this.width = e2;
    }
  }
  setStyle(e2) {
    if (e2 instanceof Name)
      switch (e2.name) {
        case "S":
          this.style = BA;
          break;
        case "D":
          this.style = lA;
          break;
        case "B":
          this.style = QA;
          break;
        case "I":
          this.style = EA;
          break;
        case "U":
          this.style = uA;
      }
  }
  setDashArray(e2, t2 = false) {
    if (Array.isArray(e2)) {
      let i2 = true, a2 = true;
      for (const t3 of e2) {
        if (!(+t3 >= 0)) {
          i2 = false;
          break;
        }
        t3 > 0 && (a2 = false);
      }
      if (0 === e2.length || i2 && !a2) {
        this.dashArray = e2;
        t2 && this.setStyle(Name.get("D"));
      } else
        this.width = 0;
    } else
      e2 && (this.width = 0);
  }
  setHorizontalCornerRadius(e2) {
    Number.isInteger(e2) && (this.horizontalCornerRadius = e2);
  }
  setVerticalCornerRadius(e2) {
    Number.isInteger(e2) && (this.verticalCornerRadius = e2);
  }
};
var MarkupAnnotation = class extends Annotation {
  constructor(e2) {
    super(e2);
    const { dict: t2 } = e2;
    if (t2.has("IRT")) {
      const e3 = t2.getRaw("IRT");
      this.data.inReplyTo = e3 instanceof Ref ? e3.toString() : null;
      const i3 = t2.get("RT");
      this.data.replyType = i3 instanceof Name ? i3.name : Z;
    }
    let i2 = null;
    if (this.data.replyType === X) {
      const e3 = t2.get("IRT");
      this.setTitle(e3.get("T"));
      this.data.titleObj = this._title;
      this.setContents(e3.get("Contents"));
      this.data.contentsObj = this._contents;
      if (e3.has("CreationDate")) {
        this.setCreationDate(e3.get("CreationDate"));
        this.data.creationDate = this.creationDate;
      } else
        this.data.creationDate = null;
      if (e3.has("M")) {
        this.setModificationDate(e3.get("M"));
        this.data.modificationDate = this.modificationDate;
      } else
        this.data.modificationDate = null;
      i2 = e3.getRaw("Popup");
      if (e3.has("C")) {
        this.setColor(e3.getArray("C"));
        this.data.color = this.color;
      } else
        this.data.color = null;
    } else {
      this.data.titleObj = this._title;
      this.setCreationDate(t2.get("CreationDate"));
      this.data.creationDate = this.creationDate;
      i2 = t2.getRaw("Popup");
      t2.has("C") || (this.data.color = null);
    }
    this.data.popupRef = i2 instanceof Ref ? i2.toString() : null;
    t2.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(t2.get("RC")));
  }
  setCreationDate(e2) {
    this.creationDate = "string" == typeof e2 ? e2 : null;
  }
  _setDefaultAppearance({ xref: e2, extra: t2, strokeColor: i2, fillColor: a2, blendMode: s2, strokeAlpha: r2, fillAlpha: n2, pointsCallback: g2 }) {
    let o2 = Number.MAX_VALUE, c2 = Number.MAX_VALUE, C2 = Number.MIN_VALUE, h2 = Number.MIN_VALUE;
    const l2 = ["q"];
    t2 && l2.push(t2);
    i2 && l2.push(`${i2[0]} ${i2[1]} ${i2[2]} RG`);
    a2 && l2.push(`${a2[0]} ${a2[1]} ${a2[2]} rg`);
    let Q2 = this.data.quadPoints;
    Q2 || (Q2 = Float32Array.from([this.rectangle[0], this.rectangle[3], this.rectangle[2], this.rectangle[3], this.rectangle[0], this.rectangle[1], this.rectangle[2], this.rectangle[1]]));
    for (let e3 = 0, t3 = Q2.length; e3 < t3; e3 += 8) {
      const [t4, i3, a3, s3] = g2(l2, Q2.subarray(e3, e3 + 8));
      o2 = Math.min(o2, t4);
      C2 = Math.max(C2, i3);
      c2 = Math.min(c2, a3);
      h2 = Math.max(h2, s3);
    }
    l2.push("Q");
    const E2 = new Dict(e2), u2 = new Dict(e2);
    u2.set("Subtype", Name.get("Form"));
    const d2 = new StringStream(l2.join(" "));
    d2.dict = u2;
    E2.set("Fm0", d2);
    const f2 = new Dict(e2);
    s2 && f2.set("BM", Name.get(s2));
    "number" == typeof r2 && f2.set("CA", r2);
    "number" == typeof n2 && f2.set("ca", n2);
    const p2 = new Dict(e2);
    p2.set("GS0", f2);
    const m2 = new Dict(e2);
    m2.set("ExtGState", p2);
    m2.set("XObject", E2);
    const y2 = new Dict(e2);
    y2.set("Resources", m2);
    const w2 = this.data.rect = [o2, c2, C2, h2];
    y2.set("BBox", w2);
    this.appearance = new StringStream("/GS0 gs /Fm0 Do");
    this.appearance.dict = y2;
    this._streams.push(this.appearance, d2);
  }
  static async createNewAnnotation(e2, t2, i2, a2) {
    let s2;
    t2.ref ? s2 = (await e2.fetchIfRefAsync(t2.ref)).clone() : t2.ref = e2.getNewTemporaryRef();
    const r2 = t2.ref, n2 = await this.createNewAppearanceStream(t2, e2, a2), g2 = [];
    let o2;
    if (n2) {
      const a3 = e2.getNewTemporaryRef();
      o2 = this.createNewDict(t2, e2, { apRef: a3, oldAnnotation: s2 });
      await writeObject(a3, n2, g2, e2);
      i2.push({ ref: a3, data: g2.join("") });
    } else
      o2 = this.createNewDict(t2, e2, { oldAnnotation: s2 });
    Number.isInteger(t2.parentTreeId) && o2.set("StructParent", t2.parentTreeId);
    g2.length = 0;
    await writeObject(r2, o2, g2, e2);
    return { ref: r2, data: g2.join("") };
  }
  static async createNewPrintAnnotation(e2, t2, i2, a2) {
    const s2 = await this.createNewAppearanceStream(i2, t2, a2), r2 = this.createNewDict(i2, t2, { ap: s2 }), n2 = new this.prototype.constructor({ dict: r2, xref: t2, annotationGlobals: e2, evaluatorOptions: a2.evaluatorOptions });
    i2.ref && (n2.ref = n2.refToReplace = i2.ref);
    return n2;
  }
};
var WidgetAnnotation = class _WidgetAnnotation extends Annotation {
  constructor(e2) {
    var _a4;
    super(e2);
    const { dict: t2, xref: i2, annotationGlobals: a2 } = e2, s2 = this.data;
    this._needAppearances = e2.needAppearances;
    s2.annotationType = j;
    void 0 === s2.fieldName && (s2.fieldName = this._constructFieldName(t2));
    void 0 === s2.actions && (s2.actions = collectActions(i2, t2, dA));
    let r2 = getInheritableProperty({ dict: t2, key: "V", getArray: true });
    s2.fieldValue = this._decodeFormValue(r2);
    const n2 = getInheritableProperty({ dict: t2, key: "DV", getArray: true });
    s2.defaultFieldValue = this._decodeFormValue(n2);
    if (void 0 === r2 && a2.xfaDatasets) {
      const e3 = this._title.str;
      if (e3) {
        this._hasValueFromXFA = true;
        s2.fieldValue = r2 = a2.xfaDatasets.getValue(e3);
      }
    }
    void 0 === r2 && null !== s2.defaultFieldValue && (s2.fieldValue = s2.defaultFieldValue);
    s2.alternativeText = stringToPDFString(t2.get("TU") || "");
    this.setDefaultAppearance(e2);
    s2.hasAppearance || (s2.hasAppearance = this._needAppearances && void 0 !== s2.fieldValue && null !== s2.fieldValue);
    const g2 = getInheritableProperty({ dict: t2, key: "FT" });
    s2.fieldType = g2 instanceof Name ? g2.name : null;
    const o2 = getInheritableProperty({ dict: t2, key: "DR" }), c2 = a2.acroForm.get("DR"), C2 = (_a4 = this.appearance) == null ? void 0 : _a4.dict.get("Resources");
    this._fieldResources = { localResources: o2, acroFormResources: c2, appearanceResources: C2, mergedResources: Dict.merge({ xref: i2, dictArray: [o2, C2, c2], mergeSubDicts: true }) };
    s2.fieldFlags = getInheritableProperty({ dict: t2, key: "Ff" });
    (!Number.isInteger(s2.fieldFlags) || s2.fieldFlags < 0) && (s2.fieldFlags = 0);
    s2.readOnly = this.hasFieldFlag(iA);
    s2.required = this.hasFieldFlag(aA);
    s2.hidden = this._hasFlag(s2.annotationFlags, z) || this._hasFlag(s2.annotationFlags, AA);
  }
  _decodeFormValue(e2) {
    return Array.isArray(e2) ? e2.filter((e3) => "string" == typeof e3).map((e3) => stringToPDFString(e3)) : e2 instanceof Name ? stringToPDFString(e2.name) : "string" == typeof e2 ? stringToPDFString(e2) : null;
  }
  hasFieldFlag(e2) {
    return !!(this.data.fieldFlags & e2);
  }
  _isViewable(e2) {
    return true;
  }
  mustBeViewed(e2, t2) {
    return t2 ? this.viewable : super.mustBeViewed(e2, t2) && !this._hasFlag(this.flags, AA);
  }
  getRotationMatrix(e2) {
    var _a4;
    let t2 = (_a4 = e2 == null ? void 0 : e2.get(this.data.id)) == null ? void 0 : _a4.rotation;
    void 0 === t2 && (t2 = this.rotation);
    if (0 === t2)
      return i;
    return getRotationMatrix(t2, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]);
  }
  getBorderAndBackgroundAppearances(e2) {
    var _a4;
    let t2 = (_a4 = e2 == null ? void 0 : e2.get(this.data.id)) == null ? void 0 : _a4.rotation;
    void 0 === t2 && (t2 = this.rotation);
    if (!this.backgroundColor && !this.borderColor)
      return "";
    const i2 = this.data.rect[2] - this.data.rect[0], a2 = this.data.rect[3] - this.data.rect[1], s2 = 0 === t2 || 180 === t2 ? `0 0 ${i2} ${a2} re` : `0 0 ${a2} ${i2} re`;
    let r2 = "";
    this.backgroundColor && (r2 = `${getPdfColor(this.backgroundColor, true)} ${s2} f `);
    if (this.borderColor) {
      r2 += `${this.borderStyle.width || 1} w ${getPdfColor(this.borderColor, false)} ${s2} S `;
    }
    return r2;
  }
  async getOperatorList(e2, t2, i2, a2) {
    if (i2 & h && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas)
      return { opList: new OperatorList(), separateForm: true, separateCanvas: false };
    if (!this._hasText)
      return super.getOperatorList(e2, t2, i2, a2);
    const s2 = await this._getAppearance(e2, t2, i2, a2);
    if (this.appearance && null === s2)
      return super.getOperatorList(e2, t2, i2, a2);
    const r2 = new OperatorList();
    if (!this._defaultAppearance || null === s2)
      return { opList: r2, separateForm: false, separateCanvas: false };
    const n2 = !!(this.data.hasOwnCanvas && i2 & o), g2 = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], c2 = getTransformMatrix(this.data.rect, g2, [1, 0, 0, 1, 0, 0]);
    let C2;
    this.oc && (C2 = await e2.parseMarkedContentProps(this.oc, null));
    void 0 !== C2 && r2.addOp(Ye, ["OC", C2]);
    r2.addOp(je, [this.data.id, this.data.rect, c2, this.getRotationMatrix(a2), n2]);
    const l2 = new StringStream(s2);
    await e2.getOperatorList({ stream: l2, task: t2, resources: this._fieldResources.mergedResources, operatorList: r2 });
    r2.addOp(Xe, []);
    void 0 !== C2 && r2.addOp(ve, []);
    return { opList: r2, separateForm: false, separateCanvas: n2 };
  }
  _getMKDict(e2) {
    const t2 = new Dict(null);
    e2 && t2.set("R", e2);
    this.borderColor && t2.set("BC", getPdfColorArray(this.borderColor));
    this.backgroundColor && t2.set("BG", getPdfColorArray(this.backgroundColor));
    return t2.size > 0 ? t2 : null;
  }
  amendSavedDict(e2, t2) {
  }
  async save(e2, t2, a2) {
    const s2 = a2 == null ? void 0 : a2.get(this.data.id);
    let r2 = s2 == null ? void 0 : s2.value, n2 = s2 == null ? void 0 : s2.rotation;
    if (r2 === this.data.fieldValue || void 0 === r2) {
      if (!this._hasValueFromXFA && void 0 === n2)
        return null;
      r2 || (r2 = this.data.fieldValue);
    }
    if (void 0 === n2 && !this._hasValueFromXFA && Array.isArray(r2) && Array.isArray(this.data.fieldValue) && r2.length === this.data.fieldValue.length && r2.every((e3, t3) => e3 === this.data.fieldValue[t3]))
      return null;
    void 0 === n2 && (n2 = this.rotation);
    let g2 = null;
    if (!this._needAppearances) {
      g2 = await this._getAppearance(e2, t2, C, a2);
      if (null === g2)
        return null;
    }
    let o2 = false;
    if (g2 == null ? void 0 : g2.needAppearances) {
      o2 = true;
      g2 = null;
    }
    const { xref: c2 } = e2, h2 = c2.fetchIfRef(this.ref);
    if (!(h2 instanceof Dict))
      return null;
    const l2 = new Dict(c2);
    for (const e3 of h2.getKeys())
      "AP" !== e3 && l2.set(e3, h2.getRaw(e3));
    const Q2 = { path: this.data.fieldName, value: r2 };
    l2.set("V", Array.isArray(r2) ? r2.map(stringToAsciiOrUTF16BE) : stringToAsciiOrUTF16BE(r2));
    this.amendSavedDict(a2, l2);
    const E2 = this._getMKDict(n2);
    E2 && l2.set("MK", E2);
    const u2 = [], d2 = [{ ref: this.ref, data: "", xfa: Q2, needAppearances: o2 }];
    if (null !== g2) {
      const e3 = c2.getNewTemporaryRef(), t3 = new Dict(c2);
      l2.set("AP", t3);
      t3.set("N", e3);
      const s3 = this._getSaveFieldResources(c2), r3 = new StringStream(g2), n3 = r3.dict = new Dict(c2);
      n3.set("Subtype", Name.get("Form"));
      n3.set("Resources", s3);
      n3.set("BBox", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);
      const o3 = this.getRotationMatrix(a2);
      o3 !== i && n3.set("Matrix", o3);
      await writeObject(e3, r3, u2, c2);
      d2.push({ ref: e3, data: u2.join(""), xfa: null, needAppearances: false });
      u2.length = 0;
    }
    l2.set("M", `D:${getModificationDate()}`);
    await writeObject(this.ref, l2, u2, c2);
    d2[0].data = u2.join("");
    return d2;
  }
  async _getAppearance(e2, t2, i2, a2) {
    if (this.hasFieldFlag(rA))
      return null;
    const s2 = a2 == null ? void 0 : a2.get(this.data.id);
    let r2, g2;
    if (s2) {
      r2 = s2.formattedValue || s2.value;
      g2 = s2.rotation;
    }
    if (void 0 === g2 && void 0 === r2 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance))
      return null;
    const o2 = this.getBorderAndBackgroundAppearances(a2);
    if (void 0 === r2) {
      r2 = this.data.fieldValue;
      if (!r2)
        return `/Tx BMC q ${o2}Q EMC`;
    }
    Array.isArray(r2) && 1 === r2.length && (r2 = r2[0]);
    assert("string" == typeof r2, "Expected `value` to be a string.");
    r2 = r2.trim();
    if (this.data.combo) {
      const e3 = this.data.options.find(({ exportValue: e4 }) => r2 === e4);
      r2 = (e3 == null ? void 0 : e3.displayValue) || r2;
    }
    if ("" === r2)
      return `/Tx BMC q ${o2}Q EMC`;
    void 0 === g2 && (g2 = this.rotation);
    let c2, h2 = -1;
    if (this.data.multiLine) {
      c2 = r2.split(/\r\n?|\n/).map((e3) => e3.normalize("NFC"));
      h2 = c2.length;
    } else
      c2 = [r2.replace(/\r\n?|\n/, "").normalize("NFC")];
    let l2 = this.data.rect[3] - this.data.rect[1], Q2 = this.data.rect[2] - this.data.rect[0];
    90 !== g2 && 270 !== g2 || ([Q2, l2] = [l2, Q2]);
    this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    let E2, u2, d2, f2 = await _WidgetAnnotation._getFontData(e2, t2, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    const p2 = [];
    let m2 = false;
    for (const e3 of c2) {
      const t3 = f2.encodeString(e3);
      t3.length > 1 && (m2 = true);
      p2.push(t3.join(""));
    }
    if (m2 && i2 & C)
      return { needAppearances: true };
    if (m2 && this._isOffscreenCanvasSupported) {
      const i3 = this.data.comb ? "monospace" : "sans-serif", a3 = new FakeUnicodeFont(e2.xref, i3), s3 = a3.createFontResources(c2.join("")), n2 = s3.getRaw("Font");
      if (this._fieldResources.mergedResources.has("Font")) {
        const e3 = this._fieldResources.mergedResources.get("Font");
        for (const t3 of n2.getKeys())
          e3.set(t3, n2.getRaw(t3));
      } else
        this._fieldResources.mergedResources.set("Font", n2);
      const g3 = a3.fontName.name;
      f2 = await _WidgetAnnotation._getFontData(e2, t2, { fontName: g3, fontSize: 0 }, s3);
      for (let e3 = 0, t3 = p2.length; e3 < t3; e3++)
        p2[e3] = stringToUTF16String(c2[e3]);
      const o3 = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
      this.data.defaultAppearanceData.fontSize = 0;
      this.data.defaultAppearanceData.fontName = g3;
      [E2, u2, d2] = this._computeFontSize(l2 - 2, Q2 - 4, r2, f2, h2);
      this.data.defaultAppearanceData = o3;
    } else {
      this._isOffscreenCanvasSupported || warn("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly.");
      [E2, u2, d2] = this._computeFontSize(l2 - 2, Q2 - 4, r2, f2, h2);
    }
    let y2 = f2.descent;
    y2 = isNaN(y2) ? n * d2 : Math.max(n * d2, Math.abs(y2) * u2);
    const w2 = Math.min(Math.floor((l2 - u2) / 2), 1), D2 = this.data.textAlignment;
    if (this.data.multiLine)
      return this._getMultilineAppearance(E2, p2, f2, u2, Q2, l2, D2, 2, w2, y2, d2, a2);
    if (this.data.comb)
      return this._getCombAppearance(E2, f2, p2[0], u2, Q2, l2, 2, w2, y2, d2, a2);
    const b2 = w2 + y2;
    if (0 === D2 || D2 > 2)
      return `/Tx BMC q ${o2}BT ` + E2 + ` 1 0 0 1 ${numberToString(2)} ${numberToString(b2)} Tm (${escapeString(p2[0])}) Tj ET Q EMC`;
    return `/Tx BMC q ${o2}BT ` + E2 + ` 1 0 0 1 0 0 Tm ${this._renderText(p2[0], f2, u2, Q2, D2, { shift: 0 }, 2, b2)} ET Q EMC`;
  }
  static async _getFontData(e2, t2, i2, a2) {
    const s2 = new OperatorList(), r2 = { font: null, clone() {
      return this;
    } }, { fontName: n2, fontSize: g2 } = i2;
    await e2.handleSetFont(a2, [n2 && Name.get(n2), g2], null, s2, t2, r2, null);
    return r2.font;
  }
  _getTextWidth(e2, t2) {
    return t2.charsToGlyphs(e2).reduce((e3, t3) => e3 + t3.width, 0) / 1e3;
  }
  _computeFontSize(e2, t2, i2, a2, r2) {
    let { fontSize: n2 } = this.data.defaultAppearanceData, g2 = (n2 || 12) * s, o2 = Math.round(e2 / g2);
    if (!n2) {
      const roundWithTwoDigits = (e3) => Math.floor(100 * e3) / 100;
      if (-1 === r2) {
        const r3 = this._getTextWidth(i2, a2);
        n2 = roundWithTwoDigits(Math.min(e2 / s, r3 > t2 ? t2 / r3 : 1 / 0));
        o2 = 1;
      } else {
        const c3 = i2.split(/\r\n?|\n/), C3 = [];
        for (const e3 of c3) {
          const t3 = a2.encodeString(e3).join(""), i3 = a2.charsToGlyphs(t3), s2 = a2.getCharPositions(t3);
          C3.push({ line: t3, glyphs: i3, positions: s2 });
        }
        const isTooBig = (i3) => {
          let s2 = 0;
          for (const r3 of C3) {
            s2 += this._splitLine(null, a2, i3, t2, r3).length * i3;
            if (s2 > e2)
              return true;
          }
          return false;
        };
        o2 = Math.max(o2, r2);
        for (; ; ) {
          g2 = e2 / o2;
          n2 = roundWithTwoDigits(g2 / s);
          if (!isTooBig(n2))
            break;
          o2++;
        }
      }
      const { fontName: c2, fontColor: C2 } = this.data.defaultAppearanceData;
      this._defaultAppearance = function createDefaultAppearance({ fontSize: e3, fontName: t3, fontColor: i3 }) {
        return `/${escapePDFName(t3)} ${e3} Tf ${getPdfColor(i3, true)}`;
      }({ fontSize: n2, fontName: c2, fontColor: C2 });
    }
    return [this._defaultAppearance, n2, e2 / o2];
  }
  _renderText(e2, t2, i2, a2, s2, r2, n2, g2) {
    let o2;
    if (1 === s2) {
      o2 = (a2 - this._getTextWidth(e2, t2) * i2) / 2;
    } else if (2 === s2) {
      o2 = a2 - this._getTextWidth(e2, t2) * i2 - n2;
    } else
      o2 = n2;
    const c2 = numberToString(o2 - r2.shift);
    r2.shift = o2;
    return `${c2} ${g2 = numberToString(g2)} Td (${escapeString(e2)}) Tj`;
  }
  _getSaveFieldResources(e2) {
    var _a4;
    const { localResources: t2, appearanceResources: i2, acroFormResources: a2 } = this._fieldResources, s2 = (_a4 = this.data.defaultAppearanceData) == null ? void 0 : _a4.fontName;
    if (!s2)
      return t2 || Dict.empty;
    for (const e3 of [t2, i2])
      if (e3 instanceof Dict) {
        const t3 = e3.get("Font");
        if (t3 instanceof Dict && t3.has(s2))
          return e3;
      }
    if (a2 instanceof Dict) {
      const i3 = a2.get("Font");
      if (i3 instanceof Dict && i3.has(s2)) {
        const a3 = new Dict(e2);
        a3.set(s2, i3.getRaw(s2));
        const r2 = new Dict(e2);
        r2.set("Font", a3);
        return Dict.merge({ xref: e2, dictArray: [r2, t2], mergeSubDicts: true });
      }
    }
    return t2 || Dict.empty;
  }
  getFieldObject() {
    return null;
  }
};
var TextWidgetAnnotation = class extends WidgetAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2 } = e2;
    if (t2.has("PMD")) {
      this.flags |= z;
      this.data.hidden = true;
      warn("Barcodes are not supported");
    }
    this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
    this._hasText = true;
    "string" != typeof this.data.fieldValue && (this.data.fieldValue = "");
    let i2 = getInheritableProperty({ dict: t2, key: "Q" });
    (!Number.isInteger(i2) || i2 < 0 || i2 > 2) && (i2 = null);
    this.data.textAlignment = i2;
    let a2 = getInheritableProperty({ dict: t2, key: "MaxLen" });
    (!Number.isInteger(a2) || a2 < 0) && (a2 = 0);
    this.data.maxLen = a2;
    this.data.multiLine = this.hasFieldFlag(sA);
    this.data.comb = this.hasFieldFlag(hA) && !this.hasFieldFlag(sA) && !this.hasFieldFlag(rA) && !this.hasFieldFlag(IA) && 0 !== this.data.maxLen;
    this.data.doNotScroll = this.hasFieldFlag(CA);
  }
  get hasTextContent() {
    return !!this.appearance && !this._needAppearances;
  }
  _getCombAppearance(e2, t2, i2, a2, s2, r2, n2, g2, o2, c2, C2) {
    const h2 = s2 / this.data.maxLen, l2 = this.getBorderAndBackgroundAppearances(C2), Q2 = [], E2 = t2.getCharPositions(i2);
    for (const [e3, t3] of E2)
      Q2.push(`(${escapeString(i2.substring(e3, t3))}) Tj`);
    const u2 = Q2.join(` ${numberToString(h2)} 0 Td `);
    return `/Tx BMC q ${l2}BT ` + e2 + ` 1 0 0 1 ${numberToString(n2)} ${numberToString(g2 + o2)} Tm ${u2} ET Q EMC`;
  }
  _getMultilineAppearance(e2, t2, i2, a2, s2, r2, n2, g2, o2, c2, C2, h2) {
    const l2 = [], Q2 = s2 - 2 * g2, E2 = { shift: 0 };
    for (let e3 = 0, r3 = t2.length; e3 < r3; e3++) {
      const r4 = t2[e3], h3 = this._splitLine(r4, i2, a2, Q2);
      for (let t3 = 0, r5 = h3.length; t3 < r5; t3++) {
        const r6 = h3[t3], Q3 = 0 === e3 && 0 === t3 ? -o2 - (C2 - c2) : -C2;
        l2.push(this._renderText(r6, i2, a2, s2, n2, E2, g2, Q3));
      }
    }
    const u2 = this.getBorderAndBackgroundAppearances(h2), d2 = l2.join("\n");
    return `/Tx BMC q ${u2}BT ` + e2 + ` 1 0 0 1 0 ${numberToString(r2)} Tm ${d2} ET Q EMC`;
  }
  _splitLine(e2, t2, i2, a2, s2 = {}) {
    e2 = s2.line || e2;
    const r2 = s2.glyphs || t2.charsToGlyphs(e2);
    if (r2.length <= 1)
      return [e2];
    const n2 = s2.positions || t2.getCharPositions(e2), g2 = i2 / 1e3, o2 = [];
    let c2 = -1, C2 = -1, h2 = -1, l2 = 0, Q2 = 0;
    for (let t3 = 0, i3 = r2.length; t3 < i3; t3++) {
      const [i4, s3] = n2[t3], E2 = r2[t3], u2 = E2.width * g2;
      if (" " === E2.unicode)
        if (Q2 + u2 > a2) {
          o2.push(e2.substring(l2, i4));
          l2 = i4;
          Q2 = u2;
          c2 = -1;
          h2 = -1;
        } else {
          Q2 += u2;
          c2 = i4;
          C2 = s3;
          h2 = t3;
        }
      else if (Q2 + u2 > a2)
        if (-1 !== c2) {
          o2.push(e2.substring(l2, C2));
          l2 = C2;
          t3 = h2 + 1;
          c2 = -1;
          Q2 = 0;
        } else {
          o2.push(e2.substring(l2, i4));
          l2 = i4;
          Q2 = u2;
        }
      else
        Q2 += u2;
    }
    l2 < e2.length && o2.push(e2.substring(l2, e2.length));
    return o2;
  }
  getFieldObject() {
    return { id: this.data.id, value: this.data.fieldValue, defaultValue: this.data.defaultFieldValue || "", multiline: this.data.multiLine, password: this.hasFieldFlag(rA), charLimit: this.data.maxLen, comb: this.data.comb, editable: !this.data.readOnly, hidden: this.data.hidden, name: this.data.fieldName, rect: this.data.rect, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: "text" };
  }
};
var ButtonWidgetAnnotation = class extends WidgetAnnotation {
  constructor(e2) {
    super(e2);
    this.checkedAppearance = null;
    this.uncheckedAppearance = null;
    this.data.checkBox = !this.hasFieldFlag(nA) && !this.hasFieldFlag(gA);
    this.data.radioButton = this.hasFieldFlag(nA) && !this.hasFieldFlag(gA);
    this.data.pushButton = this.hasFieldFlag(gA);
    this.data.isTooltipOnly = false;
    if (this.data.checkBox)
      this._processCheckBox(e2);
    else if (this.data.radioButton)
      this._processRadioButton(e2);
    else if (this.data.pushButton) {
      this.data.hasOwnCanvas = true;
      this.data.noHTML = false;
      this._processPushButton(e2);
    } else
      warn("Invalid field flags for button widget annotation");
  }
  async getOperatorList(e2, t2, a2, s2) {
    if (this.data.pushButton)
      return super.getOperatorList(e2, t2, a2, false, s2);
    let r2 = null, n2 = null;
    if (s2) {
      const e3 = s2.get(this.data.id);
      r2 = e3 ? e3.value : null;
      n2 = e3 ? e3.rotation : null;
    }
    if (null === r2 && this.appearance)
      return super.getOperatorList(e2, t2, a2, s2);
    null == r2 && (r2 = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
    const g2 = r2 ? this.checkedAppearance : this.uncheckedAppearance;
    if (g2) {
      const r3 = this.appearance, o2 = lookupMatrix(g2.dict.getArray("Matrix"), i);
      n2 && g2.dict.set("Matrix", this.getRotationMatrix(s2));
      this.appearance = g2;
      const c2 = super.getOperatorList(e2, t2, a2, s2);
      this.appearance = r3;
      g2.dict.set("Matrix", o2);
      return c2;
    }
    return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
  }
  async save(e2, t2, i2) {
    return this.data.checkBox ? this._saveCheckbox(e2, t2, i2) : this.data.radioButton ? this._saveRadioButton(e2, t2, i2) : null;
  }
  async _saveCheckbox(e2, t2, i2) {
    if (!i2)
      return null;
    const a2 = i2.get(this.data.id);
    let s2 = a2 == null ? void 0 : a2.rotation, r2 = a2 == null ? void 0 : a2.value;
    if (void 0 === s2) {
      if (void 0 === r2)
        return null;
      if (this.data.fieldValue === this.data.exportValue === r2)
        return null;
    }
    const n2 = e2.xref.fetchIfRef(this.ref);
    if (!(n2 instanceof Dict))
      return null;
    void 0 === s2 && (s2 = this.rotation);
    void 0 === r2 && (r2 = this.data.fieldValue === this.data.exportValue);
    const g2 = { path: this.data.fieldName, value: r2 ? this.data.exportValue : "" }, o2 = Name.get(r2 ? this.data.exportValue : "Off");
    n2.set("V", o2);
    n2.set("AS", o2);
    n2.set("M", `D:${getModificationDate()}`);
    const c2 = this._getMKDict(s2);
    c2 && n2.set("MK", c2);
    const C2 = [];
    await writeObject(this.ref, n2, C2, e2.xref);
    return [{ ref: this.ref, data: C2.join(""), xfa: g2 }];
  }
  async _saveRadioButton(e2, t2, i2) {
    if (!i2)
      return null;
    const a2 = i2.get(this.data.id);
    let s2 = a2 == null ? void 0 : a2.rotation, r2 = a2 == null ? void 0 : a2.value;
    if (void 0 === s2) {
      if (void 0 === r2)
        return null;
      if (this.data.fieldValue === this.data.buttonValue === r2)
        return null;
    }
    const n2 = e2.xref.fetchIfRef(this.ref);
    if (!(n2 instanceof Dict))
      return null;
    void 0 === r2 && (r2 = this.data.fieldValue === this.data.buttonValue);
    void 0 === s2 && (s2 = this.rotation);
    const g2 = { path: this.data.fieldName, value: r2 ? this.data.buttonValue : "" }, o2 = Name.get(r2 ? this.data.buttonValue : "Off"), c2 = [];
    let C2 = null;
    if (r2)
      if (this.parent instanceof Ref) {
        const t3 = e2.xref.fetch(this.parent);
        t3.set("V", o2);
        await writeObject(this.parent, t3, c2, e2.xref);
        C2 = c2.join("");
        c2.length = 0;
      } else
        this.parent instanceof Dict && this.parent.set("V", o2);
    n2.set("AS", o2);
    n2.set("M", `D:${getModificationDate()}`);
    const h2 = this._getMKDict(s2);
    h2 && n2.set("MK", h2);
    await writeObject(this.ref, n2, c2, e2.xref);
    const l2 = [{ ref: this.ref, data: c2.join(""), xfa: g2 }];
    C2 && l2.push({ ref: this.parent, data: C2, xfa: null });
    return l2;
  }
  _getDefaultCheckedAppearance(e2, t2) {
    const i2 = this.data.rect[2] - this.data.rect[0], a2 = this.data.rect[3] - this.data.rect[1], s2 = [0, 0, i2, a2], r2 = 0.8 * Math.min(i2, a2);
    let n2, g2;
    if ("check" === t2) {
      n2 = { width: 0.755 * r2, height: 0.705 * r2 };
      g2 = "3";
    } else if ("disc" === t2) {
      n2 = { width: 0.791 * r2, height: 0.705 * r2 };
      g2 = "l";
    } else
      unreachable(`_getDefaultCheckedAppearance - unsupported type: ${t2}`);
    const o2 = `q BT /PdfJsZaDb ${r2} Tf 0 g ${numberToString((i2 - n2.width) / 2)} ${numberToString((a2 - n2.height) / 2)} Td (${g2}) Tj ET Q`, c2 = new Dict(e2.xref);
    c2.set("FormType", 1);
    c2.set("Subtype", Name.get("Form"));
    c2.set("Type", Name.get("XObject"));
    c2.set("BBox", s2);
    c2.set("Matrix", [1, 0, 0, 1, 0, 0]);
    c2.set("Length", o2.length);
    const C2 = new Dict(e2.xref), h2 = new Dict(e2.xref);
    h2.set("PdfJsZaDb", this.fallbackFontDict);
    C2.set("Font", h2);
    c2.set("Resources", C2);
    this.checkedAppearance = new StringStream(o2);
    this.checkedAppearance.dict = c2;
    this._streams.push(this.checkedAppearance);
  }
  _processCheckBox(e2) {
    const t2 = e2.dict.get("AP");
    if (!(t2 instanceof Dict))
      return;
    const i2 = t2.get("N");
    if (!(i2 instanceof Dict))
      return;
    const a2 = this._decodeFormValue(e2.dict.get("AS"));
    "string" == typeof a2 && (this.data.fieldValue = a2);
    const s2 = null !== this.data.fieldValue && "Off" !== this.data.fieldValue ? this.data.fieldValue : "Yes", r2 = i2.getKeys();
    if (0 === r2.length)
      r2.push("Off", s2);
    else if (1 === r2.length)
      "Off" === r2[0] ? r2.push(s2) : r2.unshift("Off");
    else if (r2.includes(s2)) {
      r2.length = 0;
      r2.push("Off", s2);
    } else {
      const e3 = r2.find((e4) => "Off" !== e4);
      r2.length = 0;
      r2.push("Off", e3);
    }
    r2.includes(this.data.fieldValue) || (this.data.fieldValue = "Off");
    this.data.exportValue = r2[1];
    const n2 = i2.get(this.data.exportValue);
    this.checkedAppearance = n2 instanceof BaseStream ? n2 : null;
    const g2 = i2.get("Off");
    this.uncheckedAppearance = g2 instanceof BaseStream ? g2 : null;
    this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e2, "check");
    this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
    this._fallbackFontDict = this.fallbackFontDict;
    null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
  }
  _processRadioButton(e2) {
    this.data.buttonValue = null;
    const t2 = e2.dict.get("Parent");
    if (t2 instanceof Dict) {
      this.parent = e2.dict.getRaw("Parent");
      const i3 = t2.get("V");
      i3 instanceof Name && (this.data.fieldValue = this._decodeFormValue(i3));
    }
    const i2 = e2.dict.get("AP");
    if (!(i2 instanceof Dict))
      return;
    const a2 = i2.get("N");
    if (!(a2 instanceof Dict))
      return;
    for (const e3 of a2.getKeys())
      if ("Off" !== e3) {
        this.data.buttonValue = this._decodeFormValue(e3);
        break;
      }
    const s2 = a2.get(this.data.buttonValue);
    this.checkedAppearance = s2 instanceof BaseStream ? s2 : null;
    const r2 = a2.get("Off");
    this.uncheckedAppearance = r2 instanceof BaseStream ? r2 : null;
    this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e2, "disc");
    this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
    this._fallbackFontDict = this.fallbackFontDict;
    null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
  }
  _processPushButton(e2) {
    const { dict: t2, annotationGlobals: i2 } = e2;
    if (t2.has("A") || t2.has("AA") || this.data.alternativeText) {
      this.data.isTooltipOnly = !t2.has("A") && !t2.has("AA");
      Catalog.parseDestDictionary({ destDict: t2, resultObj: this.data, docBaseUrl: i2.baseUrl, docAttachments: i2.attachments });
    } else
      warn("Push buttons without action dictionaries are not supported");
  }
  getFieldObject() {
    let e2, t2 = "button";
    if (this.data.checkBox) {
      t2 = "checkbox";
      e2 = this.data.exportValue;
    } else if (this.data.radioButton) {
      t2 = "radiobutton";
      e2 = this.data.buttonValue;
    }
    return { id: this.data.id, value: this.data.fieldValue || "Off", defaultValue: this.data.defaultFieldValue, exportValues: e2, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, hidden: this.data.hidden, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: t2 };
  }
  get fallbackFontDict() {
    const e2 = new Dict();
    e2.set("BaseFont", Name.get("ZapfDingbats"));
    e2.set("Type", Name.get("FallbackType"));
    e2.set("Subtype", Name.get("FallbackType"));
    e2.set("Encoding", Name.get("ZapfDingbatsEncoding"));
    return shadow(this, "fallbackFontDict", e2);
  }
};
var ChoiceWidgetAnnotation = class extends WidgetAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.indices = t2.getArray("I");
    this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
    this.data.options = [];
    const a2 = getInheritableProperty({ dict: t2, key: "Opt" });
    if (Array.isArray(a2))
      for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) {
        const t4 = i2.fetchIfRef(a2[e3]), s2 = Array.isArray(t4);
        this.data.options[e3] = { exportValue: this._decodeFormValue(s2 ? i2.fetchIfRef(t4[0]) : t4), displayValue: this._decodeFormValue(s2 ? i2.fetchIfRef(t4[1]) : t4) };
      }
    if (this.hasIndices) {
      this.data.fieldValue = [];
      const e3 = this.data.options.length;
      for (const t3 of this.indices)
        Number.isInteger(t3) && t3 >= 0 && t3 < e3 && this.data.fieldValue.push(this.data.options[t3].exportValue);
    } else
      "string" == typeof this.data.fieldValue ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []);
    this.data.combo = this.hasFieldFlag(oA);
    this.data.multiSelect = this.hasFieldFlag(cA);
    this._hasText = true;
  }
  getFieldObject() {
    const e2 = this.data.combo ? "combobox" : "listbox", t2 = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
    return { id: this.data.id, value: t2, defaultValue: this.data.defaultFieldValue, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, numItems: this.data.fieldValue.length, multipleSelection: this.data.multiSelect, hidden: this.data.hidden, actions: this.data.actions, items: this.data.options, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: e2 };
  }
  amendSavedDict(e2, t2) {
    var _a4;
    if (!this.hasIndices)
      return;
    let i2 = (_a4 = e2 == null ? void 0 : e2.get(this.data.id)) == null ? void 0 : _a4.value;
    Array.isArray(i2) || (i2 = [i2]);
    const a2 = [], { options: s2 } = this.data;
    for (let e3 = 0, t3 = 0, r2 = s2.length; e3 < r2; e3++)
      if (s2[e3].exportValue === i2[t3]) {
        a2.push(e3);
        t3 += 1;
      }
    t2.set("I", a2);
  }
  async _getAppearance(e2, t2, i2, a2) {
    if (this.data.combo)
      return super._getAppearance(e2, t2, i2, a2);
    let r2, n2;
    const g2 = a2 == null ? void 0 : a2.get(this.data.id);
    if (g2) {
      n2 = g2.rotation;
      r2 = g2.value;
    }
    if (void 0 === n2 && void 0 === r2 && !this._needAppearances)
      return null;
    void 0 === r2 ? r2 = this.data.fieldValue : Array.isArray(r2) || (r2 = [r2]);
    let o2 = this.data.rect[3] - this.data.rect[1], c2 = this.data.rect[2] - this.data.rect[0];
    90 !== n2 && 270 !== n2 || ([c2, o2] = [o2, c2]);
    const C2 = this.data.options.length, h2 = [];
    for (let e3 = 0; e3 < C2; e3++) {
      const { exportValue: t3 } = this.data.options[e3];
      r2.includes(t3) && h2.push(e3);
    }
    this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    const l2 = await WidgetAnnotation._getFontData(e2, t2, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    let Q2, { fontSize: E2 } = this.data.defaultAppearanceData;
    if (E2)
      Q2 = this._defaultAppearance;
    else {
      const e3 = (o2 - 1) / C2;
      let t3, i3 = -1;
      for (const { displayValue: e4 } of this.data.options) {
        const a3 = this._getTextWidth(e4, l2);
        if (a3 > i3) {
          i3 = a3;
          t3 = e4;
        }
      }
      [Q2, E2] = this._computeFontSize(e3, c2 - 4, t3, l2, -1);
    }
    const u2 = E2 * s, d2 = (u2 - E2) / 2, f2 = Math.floor(o2 / u2);
    let p2 = 0;
    if (h2.length > 0) {
      const e3 = Math.min(...h2), t3 = Math.max(...h2);
      p2 = Math.max(0, t3 - f2 + 1);
      p2 > e3 && (p2 = e3);
    }
    const m2 = Math.min(p2 + f2 + 1, C2), y2 = ["/Tx BMC q", `1 1 ${c2} ${o2} re W n`];
    if (h2.length) {
      y2.push("0.600006 0.756866 0.854904 rg");
      for (const e3 of h2)
        p2 <= e3 && e3 < m2 && y2.push(`1 ${o2 - (e3 - p2 + 1) * u2} ${c2} ${u2} re f`);
    }
    y2.push("BT", Q2, `1 0 0 1 0 ${o2} Tm`);
    const w2 = { shift: 0 };
    for (let e3 = p2; e3 < m2; e3++) {
      const { displayValue: t3 } = this.data.options[e3], i3 = e3 === p2 ? d2 : 0;
      y2.push(this._renderText(t3, l2, E2, c2, 0, w2, 2, -u2 + i3));
    }
    y2.push("ET Q EMC");
    return y2.join("\n");
  }
};
var SignatureWidgetAnnotation = class extends WidgetAnnotation {
  constructor(e2) {
    super(e2);
    this.data.fieldValue = null;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = !this.data.hasOwnCanvas;
  }
  getFieldObject() {
    return { id: this.data.id, value: null, page: this.data.pageIndex, type: "signature" };
  }
};
var TextAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    this.data.noRotate = true;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = false;
    const { dict: t2 } = e2;
    this.data.annotationType = k;
    if (this.data.hasAppearance)
      this.data.name = "NoIcon";
    else {
      this.data.rect[1] = this.data.rect[3] - 22;
      this.data.rect[2] = this.data.rect[0] + 22;
      this.data.name = t2.has("Name") ? t2.get("Name").name : "Note";
    }
    if (t2.has("State")) {
      this.data.state = t2.get("State") || null;
      this.data.stateModel = t2.get("StateModel") || null;
    } else {
      this.data.state = null;
      this.data.stateModel = null;
    }
  }
};
var LinkAnnotation = class extends Annotation {
  constructor(e2) {
    var _a4;
    super(e2);
    const { dict: t2, annotationGlobals: i2 } = e2;
    this.data.annotationType = R;
    this.data.noHTML = false;
    const a2 = getQuadPoints(t2, this.rectangle);
    a2 && (this.data.quadPoints = a2);
    (_a4 = this.data).borderColor || (_a4.borderColor = this.data.color);
    Catalog.parseDestDictionary({ destDict: t2, resultObj: this.data, docBaseUrl: i2.baseUrl, docAttachments: i2.attachments });
  }
};
var PopupAnnotation = class extends Annotation {
  constructor(e2) {
    super(e2);
    const { dict: t2 } = e2;
    this.data.annotationType = O;
    this.data.noHTML = false;
    this.data.rect[0] !== this.data.rect[2] && this.data.rect[1] !== this.data.rect[3] || (this.data.rect = null);
    let i2 = t2.get("Parent");
    if (!i2) {
      warn("Popup annotation has a missing or invalid parent annotation.");
      return;
    }
    this.data.parentRect = lookupNormalRect(i2.getArray("Rect"), null);
    isName(i2.get("RT"), X) && (i2 = i2.get("IRT"));
    if (i2.has("M")) {
      this.setModificationDate(i2.get("M"));
      this.data.modificationDate = this.modificationDate;
    } else
      this.data.modificationDate = null;
    if (i2.has("C")) {
      this.setColor(i2.getArray("C"));
      this.data.color = this.color;
    } else
      this.data.color = null;
    if (!this.viewable) {
      const e3 = i2.get("F");
      this._isViewable(e3) && this.setFlags(e3);
    }
    this.setTitle(i2.get("T"));
    this.data.titleObj = this._title;
    this.setContents(i2.get("Contents"));
    this.data.contentsObj = this._contents;
    i2.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(i2.get("RC")));
    this.data.open = !!t2.get("Open");
  }
};
var FreeTextAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    var _a4;
    super(e2);
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.isEditable = !this.data.noHTML;
    this.data.noHTML = false;
    const { evaluatorOptions: t2, xref: i2 } = e2;
    this.data.annotationType = N;
    this.setDefaultAppearance(e2);
    this._hasAppearance = !!this.appearance;
    if (this._hasAppearance) {
      const { fontColor: e3, fontSize: a2 } = function parseAppearanceStream(e4, t3, i3) {
        return new AppearanceStreamEvaluator(e4, t3, i3).parse();
      }(this.appearance, t2, i2);
      this.data.defaultAppearanceData.fontColor = e3;
      this.data.defaultAppearanceData.fontSize = a2 || 10;
    } else {
      (_a4 = this.data.defaultAppearanceData).fontSize || (_a4.fontSize = 10);
      const { fontColor: t3, fontSize: a2 } = this.data.defaultAppearanceData;
      if (this._contents.str) {
        this.data.textContent = this._contents.str.split(/\r\n?|\n/).map((e4) => e4.trimEnd());
        const { coords: e3, bbox: t4, matrix: i3 } = FakeUnicodeFont.getFirstPositionInfo(this.rectangle, this.rotation, a2);
        this.data.textPosition = this._transformPoint(e3, t4, i3);
      }
      if (this._isOffscreenCanvasSupported) {
        const s2 = e2.dict.get("CA"), r2 = new FakeUnicodeFont(i2, "sans-serif");
        this.appearance = r2.createAppearance(this._contents.str, this.rectangle, this.rotation, a2, t3, s2);
        this._streams.push(this.appearance);
      } else
        warn("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
    }
  }
  get hasTextContent() {
    return this._hasAppearance;
  }
  static createNewDict(e2, t2, { apRef: i2, ap: a2, oldAnnotation: s2 }) {
    const { color: r2, fontSize: n2, rect: g2, rotation: o2, user: c2, value: C2 } = e2, h2 = s2 || new Dict(t2);
    h2.set("Type", Name.get("Annot"));
    h2.set("Subtype", Name.get("FreeText"));
    if (s2) {
      h2.set("M", `D:${getModificationDate()}`);
      h2.delete("RC");
    } else
      h2.set("CreationDate", `D:${getModificationDate()}`);
    h2.set("Rect", g2);
    const l2 = `/Helv ${n2} Tf ${getPdfColor(r2, true)}`;
    h2.set("DA", l2);
    h2.set("Contents", stringToAsciiOrUTF16BE(C2));
    h2.set("F", 4);
    h2.set("Border", [0, 0, 0]);
    h2.set("Rotate", o2);
    c2 && h2.set("T", stringToAsciiOrUTF16BE(c2));
    if (i2 || a2) {
      const e3 = new Dict(t2);
      h2.set("AP", e3);
      i2 ? e3.set("N", i2) : e3.set("N", a2);
    }
    return h2;
  }
  static async createNewAppearanceStream(e2, t2, i2) {
    const { baseFontRef: a2, evaluator: r2, task: n2 } = i2, { color: g2, fontSize: o2, rect: c2, rotation: C2, value: h2 } = e2, l2 = new Dict(t2), Q2 = new Dict(t2);
    if (a2)
      Q2.set("Helv", a2);
    else {
      const e3 = new Dict(t2);
      e3.set("BaseFont", Name.get("Helvetica"));
      e3.set("Type", Name.get("Font"));
      e3.set("Subtype", Name.get("Type1"));
      e3.set("Encoding", Name.get("WinAnsiEncoding"));
      Q2.set("Helv", e3);
    }
    l2.set("Font", Q2);
    const E2 = await WidgetAnnotation._getFontData(r2, n2, { fontName: "Helv", fontSize: o2 }, l2), [u2, d2, f2, p2] = c2;
    let m2 = f2 - u2, y2 = p2 - d2;
    C2 % 180 != 0 && ([m2, y2] = [y2, m2]);
    const w2 = h2.split("\n"), D2 = o2 / 1e3;
    let b2 = -1 / 0;
    const F2 = [];
    for (let e3 of w2) {
      const t3 = E2.encodeString(e3);
      if (t3.length > 1)
        return null;
      e3 = t3.join("");
      F2.push(e3);
      let i3 = 0;
      const a3 = E2.charsToGlyphs(e3);
      for (const e4 of a3)
        i3 += e4.width * D2;
      b2 = Math.max(b2, i3);
    }
    let S2 = 1;
    b2 > m2 && (S2 = m2 / b2);
    let k2 = 1;
    const R2 = s * o2, N2 = 1 * o2, G2 = R2 * w2.length;
    G2 > y2 && (k2 = y2 / G2);
    const x2 = o2 * Math.min(S2, k2);
    let U2, M2, L2;
    switch (C2) {
      case 0:
        L2 = [1, 0, 0, 1];
        M2 = [c2[0], c2[1], m2, y2];
        U2 = [c2[0], c2[3] - N2];
        break;
      case 90:
        L2 = [0, 1, -1, 0];
        M2 = [c2[1], -c2[2], m2, y2];
        U2 = [c2[1], -c2[0] - N2];
        break;
      case 180:
        L2 = [-1, 0, 0, -1];
        M2 = [-c2[2], -c2[3], m2, y2];
        U2 = [-c2[2], -c2[1] - N2];
        break;
      case 270:
        L2 = [0, -1, 1, 0];
        M2 = [-c2[3], c2[0], m2, y2];
        U2 = [-c2[3], c2[2] - N2];
    }
    const H2 = ["q", `${L2.join(" ")} 0 0 cm`, `${M2.join(" ")} re W n`, "BT", `${getPdfColor(g2, true)}`, `0 Tc /Helv ${numberToString(x2)} Tf`];
    H2.push(`${U2.join(" ")} Td (${escapeString(F2[0])}) Tj`);
    const J2 = numberToString(R2);
    for (let e3 = 1, t3 = F2.length; e3 < t3; e3++) {
      const t4 = F2[e3];
      H2.push(`0 -${J2} Td (${escapeString(t4)}) Tj`);
    }
    H2.push("ET", "Q");
    const Y2 = H2.join("\n"), v2 = new Dict(t2);
    v2.set("FormType", 1);
    v2.set("Subtype", Name.get("Form"));
    v2.set("Type", Name.get("XObject"));
    v2.set("BBox", c2);
    v2.set("Resources", l2);
    v2.set("Matrix", [1, 0, 0, 1, -c2[0], -c2[1]]);
    const K2 = new StringStream(Y2);
    K2.dict = v2;
    return K2;
  }
};
var LineAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = G;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = false;
    const a2 = lookupRect(t2.getArray("L"), [0, 0, 0, 0]);
    this.data.lineCoordinates = Util.normalizeRect(a2);
    this.setLineEndings(t2.getArray("LE"));
    this.data.lineEndings = this.lineEndings;
    if (!this.appearance) {
      const e3 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], s2 = t2.get("CA"), r2 = getRgbColor(t2.getArray("IC"), null), n2 = r2 ? getPdfColorArray(r2) : null, g2 = n2 ? s2 : null, o2 = this.borderStyle.width || 1, c2 = 2 * o2, C2 = [this.data.lineCoordinates[0] - c2, this.data.lineCoordinates[1] - c2, this.data.lineCoordinates[2] + c2, this.data.lineCoordinates[3] + c2];
      Util.intersect(this.rectangle, C2) || (this.rectangle = C2);
      this._setDefaultAppearance({ xref: i2, extra: `${o2} w`, strokeColor: e3, fillColor: n2, strokeAlpha: s2, fillAlpha: g2, pointsCallback: (e4, t3) => {
        e4.push(`${a2[0]} ${a2[1]} m`, `${a2[2]} ${a2[3]} l`, "S");
        return [t3[0] - o2, t3[2] + o2, t3[7] - o2, t3[3] + o2];
      } });
    }
  }
};
var SquareAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = x;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = false;
    if (!this.appearance) {
      const e3 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a2 = t2.get("CA"), s2 = getRgbColor(t2.getArray("IC"), null), r2 = s2 ? getPdfColorArray(s2) : null, n2 = r2 ? a2 : null;
      if (0 === this.borderStyle.width && !r2)
        return;
      this._setDefaultAppearance({ xref: i2, extra: `${this.borderStyle.width} w`, strokeColor: e3, fillColor: r2, strokeAlpha: a2, fillAlpha: n2, pointsCallback: (e4, t3) => {
        const i3 = t3[4] + this.borderStyle.width / 2, a3 = t3[5] + this.borderStyle.width / 2, s3 = t3[6] - t3[4] - this.borderStyle.width, n3 = t3[3] - t3[7] - this.borderStyle.width;
        e4.push(`${i3} ${a3} ${s3} ${n3} re`);
        r2 ? e4.push("B") : e4.push("S");
        return [t3[0], t3[2], t3[7], t3[3]];
      } });
    }
  }
};
var CircleAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = U;
    if (!this.appearance) {
      const e3 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a2 = t2.get("CA"), s2 = getRgbColor(t2.getArray("IC"), null), r2 = s2 ? getPdfColorArray(s2) : null, n2 = r2 ? a2 : null;
      if (0 === this.borderStyle.width && !r2)
        return;
      const g2 = 4 / 3 * Math.tan(Math.PI / 8);
      this._setDefaultAppearance({ xref: i2, extra: `${this.borderStyle.width} w`, strokeColor: e3, fillColor: r2, strokeAlpha: a2, fillAlpha: n2, pointsCallback: (e4, t3) => {
        const i3 = t3[0] + this.borderStyle.width / 2, a3 = t3[1] - this.borderStyle.width / 2, s3 = t3[6] - this.borderStyle.width / 2, n3 = t3[7] + this.borderStyle.width / 2, o2 = i3 + (s3 - i3) / 2, c2 = a3 + (n3 - a3) / 2, C2 = (s3 - i3) / 2 * g2, h2 = (n3 - a3) / 2 * g2;
        e4.push(`${o2} ${n3} m`, `${o2 + C2} ${n3} ${s3} ${c2 + h2} ${s3} ${c2} c`, `${s3} ${c2 - h2} ${o2 + C2} ${a3} ${o2} ${a3} c`, `${o2 - C2} ${a3} ${i3} ${c2 - h2} ${i3} ${c2} c`, `${i3} ${c2 + h2} ${o2 - C2} ${n3} ${o2} ${n3} c`, "h");
        r2 ? e4.push("B") : e4.push("S");
        return [t3[0], t3[2], t3[7], t3[3]];
      } });
    }
  }
};
var PolylineAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = L;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = false;
    this.data.vertices = null;
    if (!(this instanceof PolygonAnnotation)) {
      this.setLineEndings(t2.getArray("LE"));
      this.data.lineEndings = this.lineEndings;
    }
    const a2 = t2.getArray("Vertices");
    if (!isNumberArray(a2, null))
      return;
    const s2 = this.data.vertices = Float32Array.from(a2);
    if (!this.appearance) {
      const e3 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a3 = t2.get("CA"), r2 = this.borderStyle.width || 1, n2 = 2 * r2, g2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let e4 = 0, t3 = s2.length; e4 < t3; e4 += 2) {
        g2[0] = Math.min(g2[0], s2[e4] - n2);
        g2[1] = Math.min(g2[1], s2[e4 + 1] - n2);
        g2[2] = Math.max(g2[2], s2[e4] + n2);
        g2[3] = Math.max(g2[3], s2[e4 + 1] + n2);
      }
      Util.intersect(this.rectangle, g2) || (this.rectangle = g2);
      this._setDefaultAppearance({ xref: i2, extra: `${r2} w`, strokeColor: e3, strokeAlpha: a3, pointsCallback: (e4, t3) => {
        for (let t4 = 0, i3 = s2.length; t4 < i3; t4 += 2)
          e4.push(`${s2[t4]} ${s2[t4 + 1]} ${0 === t4 ? "m" : "l"}`);
        e4.push("S");
        return [t3[0], t3[2], t3[7], t3[3]];
      } });
    }
  }
};
var PolygonAnnotation = class extends PolylineAnnotation {
  constructor(e2) {
    super(e2);
    this.data.annotationType = M;
  }
};
var CaretAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    this.data.annotationType = T;
  }
};
var InkAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = false;
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = q;
    this.data.inkLists = [];
    const a2 = t2.getArray("InkList");
    if (Array.isArray(a2)) {
      for (let e3 = 0, t3 = a2.length; e3 < t3; ++e3) {
        if (!Array.isArray(a2[e3]))
          continue;
        const t4 = new Float32Array(a2[e3].length);
        this.data.inkLists.push(t4);
        for (let s2 = 0, r2 = a2[e3].length; s2 < r2; s2 += 2) {
          const r3 = i2.fetchIfRef(a2[e3][s2]), n2 = i2.fetchIfRef(a2[e3][s2 + 1]);
          if ("number" == typeof r3 && "number" == typeof n2) {
            t4[s2] = r3;
            t4[s2 + 1] = n2;
          }
        }
      }
      if (!this.appearance) {
        const e3 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a3 = t2.get("CA"), s2 = this.borderStyle.width || 1, r2 = 2 * s2, n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const e4 of this.data.inkLists)
          for (let t3 = 0, i3 = e4.length; t3 < i3; t3 += 2) {
            n2[0] = Math.min(n2[0], e4[t3] - r2);
            n2[1] = Math.min(n2[1], e4[t3 + 1] - r2);
            n2[2] = Math.max(n2[2], e4[t3] + r2);
            n2[3] = Math.max(n2[3], e4[t3 + 1] + r2);
          }
        Util.intersect(this.rectangle, n2) || (this.rectangle = n2);
        this._setDefaultAppearance({ xref: i2, extra: `${s2} w`, strokeColor: e3, strokeAlpha: a3, pointsCallback: (e4, t3) => {
          for (const t4 of this.data.inkLists) {
            for (let i3 = 0, a4 = t4.length; i3 < a4; i3 += 2)
              e4.push(`${t4[i3]} ${t4[i3 + 1]} ${0 === i3 ? "m" : "l"}`);
            e4.push("S");
          }
          return [t3[0], t3[2], t3[7], t3[3]];
        } });
      }
    }
  }
  static createNewDict(e2, t2, { apRef: i2, ap: a2 }) {
    const { color: s2, opacity: r2, paths: n2, outlines: g2, rect: o2, rotation: c2, thickness: C2 } = e2, h2 = new Dict(t2);
    h2.set("Type", Name.get("Annot"));
    h2.set("Subtype", Name.get("Ink"));
    h2.set("CreationDate", `D:${getModificationDate()}`);
    h2.set("Rect", o2);
    h2.set("InkList", (g2 == null ? void 0 : g2.points) || n2.map((e3) => e3.points));
    h2.set("F", 4);
    h2.set("Rotate", c2);
    g2 && h2.set("IT", Name.get("InkHighlight"));
    const l2 = new Dict(t2);
    h2.set("BS", l2);
    l2.set("W", C2);
    h2.set("C", Array.from(s2, (e3) => e3 / 255));
    h2.set("CA", r2);
    const Q2 = new Dict(t2);
    h2.set("AP", Q2);
    i2 ? Q2.set("N", i2) : Q2.set("N", a2);
    return h2;
  }
  static async createNewAppearanceStream(e2, t2, i2) {
    if (e2.outlines)
      return this.createNewAppearanceStreamForHighlight(e2, t2, i2);
    const { color: a2, rect: s2, paths: r2, thickness: n2, opacity: g2 } = e2, o2 = [`${n2} w 1 J 1 j`, `${getPdfColor(a2, false)}`];
    1 !== g2 && o2.push("/R0 gs");
    const c2 = [];
    for (const { bezier: e3 } of r2) {
      c2.length = 0;
      c2.push(`${numberToString(e3[0])} ${numberToString(e3[1])} m`);
      if (2 === e3.length)
        c2.push(`${numberToString(e3[0])} ${numberToString(e3[1])} l S`);
      else {
        for (let t3 = 2, i3 = e3.length; t3 < i3; t3 += 6) {
          const i4 = e3.slice(t3, t3 + 6).map(numberToString).join(" ");
          c2.push(`${i4} c`);
        }
        c2.push("S");
      }
      o2.push(c2.join("\n"));
    }
    const C2 = o2.join("\n"), h2 = new Dict(t2);
    h2.set("FormType", 1);
    h2.set("Subtype", Name.get("Form"));
    h2.set("Type", Name.get("XObject"));
    h2.set("BBox", s2);
    h2.set("Length", C2.length);
    if (1 !== g2) {
      const e3 = new Dict(t2), i3 = new Dict(t2), a3 = new Dict(t2);
      a3.set("CA", g2);
      a3.set("Type", Name.get("ExtGState"));
      i3.set("R0", a3);
      e3.set("ExtGState", i3);
      h2.set("Resources", e3);
    }
    const l2 = new StringStream(C2);
    l2.dict = h2;
    return l2;
  }
  static async createNewAppearanceStreamForHighlight(e2, t2, i2) {
    const { color: a2, rect: s2, outlines: { outline: r2 }, opacity: n2 } = e2, g2 = [`${getPdfColor(a2, true)}`, "/R0 gs"];
    g2.push(`${numberToString(r2[4])} ${numberToString(r2[5])} m`);
    for (let e3 = 6, t3 = r2.length; e3 < t3; e3 += 6)
      if (isNaN(r2[e3]) || null === r2[e3])
        g2.push(`${numberToString(r2[e3 + 4])} ${numberToString(r2[e3 + 5])} l`);
      else {
        const t4 = r2.slice(e3, e3 + 6).map(numberToString).join(" ");
        g2.push(`${t4} c`);
      }
    g2.push("h f");
    const o2 = g2.join("\n"), c2 = new Dict(t2);
    c2.set("FormType", 1);
    c2.set("Subtype", Name.get("Form"));
    c2.set("Type", Name.get("XObject"));
    c2.set("BBox", s2);
    c2.set("Length", o2.length);
    const C2 = new Dict(t2), h2 = new Dict(t2);
    C2.set("ExtGState", h2);
    c2.set("Resources", C2);
    const l2 = new Dict(t2);
    h2.set("R0", l2);
    l2.set("BM", Name.get("Multiply"));
    if (1 !== n2) {
      l2.set("ca", n2);
      l2.set("Type", Name.get("ExtGState"));
    }
    const Q2 = new StringStream(o2);
    Q2.dict = c2;
    return Q2;
  }
};
var HighlightAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    var _a4;
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = H;
    if (this.data.quadPoints = getQuadPoints(t2, null)) {
      const e3 = (_a4 = this.appearance) == null ? void 0 : _a4.dict.get("Resources");
      if (!this.appearance || !(e3 == null ? void 0 : e3.has("ExtGState"))) {
        this.appearance && warn("HighlightAnnotation - ignoring built-in appearance stream.");
        const e4 = this.color ? getPdfColorArray(this.color) : [1, 1, 0], a2 = t2.get("CA");
        this._setDefaultAppearance({ xref: i2, fillColor: e4, blendMode: "Multiply", fillAlpha: a2, pointsCallback: (e5, t3) => {
          e5.push(`${t3[0]} ${t3[1]} m`, `${t3[2]} ${t3[3]} l`, `${t3[6]} ${t3[7]} l`, `${t3[4]} ${t3[5]} l`, "f");
          return [t3[0], t3[2], t3[7], t3[3]];
        } });
      }
    } else
      this.data.popupRef = null;
  }
  static createNewDict(e2, t2, { apRef: i2, ap: a2 }) {
    const { color: s2, opacity: r2, rect: n2, rotation: g2, user: o2, quadPoints: c2 } = e2, C2 = new Dict(t2);
    C2.set("Type", Name.get("Annot"));
    C2.set("Subtype", Name.get("Highlight"));
    C2.set("CreationDate", `D:${getModificationDate()}`);
    C2.set("Rect", n2);
    C2.set("F", 4);
    C2.set("Border", [0, 0, 0]);
    C2.set("Rotate", g2);
    C2.set("QuadPoints", c2);
    C2.set("C", Array.from(s2, (e3) => e3 / 255));
    C2.set("CA", r2);
    o2 && C2.set("T", stringToAsciiOrUTF16BE(o2));
    if (i2 || a2) {
      const e3 = new Dict(t2);
      C2.set("AP", e3);
      e3.set("N", i2 || a2);
    }
    return C2;
  }
  static async createNewAppearanceStream(e2, t2, i2) {
    const { color: a2, rect: s2, outlines: r2, opacity: n2 } = e2, g2 = [`${getPdfColor(a2, true)}`, "/R0 gs"], o2 = [];
    for (const e3 of r2) {
      o2.length = 0;
      o2.push(`${numberToString(e3[0])} ${numberToString(e3[1])} m`);
      for (let t3 = 2, i3 = e3.length; t3 < i3; t3 += 2)
        o2.push(`${numberToString(e3[t3])} ${numberToString(e3[t3 + 1])} l`);
      o2.push("h");
      g2.push(o2.join("\n"));
    }
    g2.push("f*");
    const c2 = g2.join("\n"), C2 = new Dict(t2);
    C2.set("FormType", 1);
    C2.set("Subtype", Name.get("Form"));
    C2.set("Type", Name.get("XObject"));
    C2.set("BBox", s2);
    C2.set("Length", c2.length);
    const h2 = new Dict(t2), l2 = new Dict(t2);
    h2.set("ExtGState", l2);
    C2.set("Resources", h2);
    const Q2 = new Dict(t2);
    l2.set("R0", Q2);
    Q2.set("BM", Name.get("Multiply"));
    if (1 !== n2) {
      Q2.set("ca", n2);
      Q2.set("Type", Name.get("ExtGState"));
    }
    const E2 = new StringStream(c2);
    E2.dict = C2;
    return E2;
  }
};
var UnderlineAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = J;
    if (this.data.quadPoints = getQuadPoints(t2, null)) {
      if (!this.appearance) {
        const e3 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a2 = t2.get("CA");
        this._setDefaultAppearance({ xref: i2, extra: "[] 0 d 0.571 w", strokeColor: e3, strokeAlpha: a2, pointsCallback: (e4, t3) => {
          e4.push(`${t3[4]} ${t3[5] + 1.3} m`, `${t3[6]} ${t3[7] + 1.3} l`, "S");
          return [t3[0], t3[2], t3[7], t3[3]];
        } });
      }
    } else
      this.data.popupRef = null;
  }
};
var SquigglyAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = Y;
    if (this.data.quadPoints = getQuadPoints(t2, null)) {
      if (!this.appearance) {
        const e3 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a2 = t2.get("CA");
        this._setDefaultAppearance({ xref: i2, extra: "[] 0 d 1 w", strokeColor: e3, strokeAlpha: a2, pointsCallback: (e4, t3) => {
          const i3 = (t3[1] - t3[5]) / 6;
          let a3 = i3, s2 = t3[4];
          const r2 = t3[5], n2 = t3[6];
          e4.push(`${s2} ${r2 + a3} m`);
          do {
            s2 += 2;
            a3 = 0 === a3 ? i3 : 0;
            e4.push(`${s2} ${r2 + a3} l`);
          } while (s2 < n2);
          e4.push("S");
          return [t3[4], n2, r2 - 2 * i3, r2 + 2 * i3];
        } });
      }
    } else
      this.data.popupRef = null;
  }
};
var StrikeOutAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = v;
    if (this.data.quadPoints = getQuadPoints(t2, null)) {
      if (!this.appearance) {
        const e3 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a2 = t2.get("CA");
        this._setDefaultAppearance({ xref: i2, extra: "[] 0 d 1 w", strokeColor: e3, strokeAlpha: a2, pointsCallback: (e4, t3) => {
          e4.push((t3[0] + t3[4]) / 2 + " " + (t3[1] + t3[5]) / 2 + " m", (t3[2] + t3[6]) / 2 + " " + (t3[3] + t3[7]) / 2 + " l", "S");
          return [t3[0], t3[2], t3[7], t3[3]];
        } });
      }
    } else
      this.data.popupRef = null;
  }
};
var StampAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    this.data.annotationType = K;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = false;
  }
  static async createImage(e2, t2) {
    const { width: i2, height: a2 } = e2, s2 = new OffscreenCanvas(i2, a2), r2 = s2.getContext("2d", { alpha: true });
    r2.drawImage(e2, 0, 0);
    const n2 = r2.getImageData(0, 0, i2, a2).data, g2 = new Uint32Array(n2.buffer), o2 = g2.some(FeatureTest.isLittleEndian ? (e3) => e3 >>> 24 != 255 : (e3) => 255 != (255 & e3));
    if (o2) {
      r2.fillStyle = "white";
      r2.fillRect(0, 0, i2, a2);
      r2.drawImage(e2, 0, 0);
    }
    const c2 = s2.convertToBlob({ type: "image/jpeg", quality: 1 }).then((e3) => e3.arrayBuffer()), C2 = Name.get("XObject"), h2 = Name.get("Image"), l2 = new Dict(t2);
    l2.set("Type", C2);
    l2.set("Subtype", h2);
    l2.set("BitsPerComponent", 8);
    l2.set("ColorSpace", Name.get("DeviceRGB"));
    l2.set("Filter", Name.get("DCTDecode"));
    l2.set("BBox", [0, 0, i2, a2]);
    l2.set("Width", i2);
    l2.set("Height", a2);
    let Q2 = null;
    if (o2) {
      const e3 = new Uint8Array(g2.length);
      if (FeatureTest.isLittleEndian)
        for (let t3 = 0, i3 = g2.length; t3 < i3; t3++)
          e3[t3] = g2[t3] >>> 24;
      else
        for (let t3 = 0, i3 = g2.length; t3 < i3; t3++)
          e3[t3] = 255 & g2[t3];
      const s3 = new Dict(t2);
      s3.set("Type", C2);
      s3.set("Subtype", h2);
      s3.set("BitsPerComponent", 8);
      s3.set("ColorSpace", Name.get("DeviceGray"));
      s3.set("Width", i2);
      s3.set("Height", a2);
      Q2 = new Stream(e3, 0, 0, s3);
    }
    return { imageStream: new Stream(await c2, 0, 0, l2), smaskStream: Q2, width: i2, height: a2 };
  }
  static createNewDict(e2, t2, { apRef: i2, ap: a2 }) {
    const { rect: s2, rotation: r2, user: n2 } = e2, g2 = new Dict(t2);
    g2.set("Type", Name.get("Annot"));
    g2.set("Subtype", Name.get("Stamp"));
    g2.set("CreationDate", `D:${getModificationDate()}`);
    g2.set("Rect", s2);
    g2.set("F", 4);
    g2.set("Border", [0, 0, 0]);
    g2.set("Rotate", r2);
    n2 && g2.set("T", stringToAsciiOrUTF16BE(n2));
    if (i2 || a2) {
      const e3 = new Dict(t2);
      g2.set("AP", e3);
      i2 ? e3.set("N", i2) : e3.set("N", a2);
    }
    return g2;
  }
  static async createNewAppearanceStream(e2, t2, i2) {
    const { rotation: a2 } = e2, { imageRef: s2, width: r2, height: n2 } = i2.image, g2 = new Dict(t2), o2 = new Dict(t2);
    g2.set("XObject", o2);
    o2.set("Im0", s2);
    const c2 = `q ${r2} 0 0 ${n2} 0 0 cm /Im0 Do Q`, C2 = new Dict(t2);
    C2.set("FormType", 1);
    C2.set("Subtype", Name.get("Form"));
    C2.set("Type", Name.get("XObject"));
    C2.set("BBox", [0, 0, r2, n2]);
    C2.set("Resources", g2);
    if (a2) {
      const e3 = getRotationMatrix(a2, r2, n2);
      C2.set("Matrix", e3);
    }
    const h2 = new StringStream(c2);
    h2.dict = C2;
    return h2;
  }
};
var FileAttachmentAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2, a2 = new FileSpec(t2.get("FS"), i2);
    this.data.annotationType = W;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = false;
    this.data.file = a2.serializable;
    const s2 = t2.get("Name");
    this.data.name = s2 instanceof Name ? stringToPDFString(s2.name) : "PushPin";
    const r2 = t2.get("ca");
    this.data.fillAlpha = "number" == typeof r2 && r2 >= 0 && r2 <= 1 ? r2 : null;
  }
};
function decodeString(e2) {
  try {
    return stringToUTF8String(e2);
  } catch (t2) {
    warn(`UTF-8 decoding failed: "${t2}".`);
    return e2;
  }
}
var DatasetXMLParser = class extends SimpleXMLParser {
  constructor(e2) {
    super(e2);
    this.node = null;
  }
  onEndElement(e2) {
    const t2 = super.onEndElement(e2);
    if (t2 && "xfa:datasets" === e2) {
      this.node = t2;
      throw new Error("Aborting DatasetXMLParser.");
    }
  }
};
var DatasetReader = class {
  constructor(e2) {
    if (e2.datasets)
      this.node = new SimpleXMLParser({ hasAttributes: true }).parseFromString(e2.datasets).documentElement;
    else {
      const t2 = new DatasetXMLParser({ hasAttributes: true });
      try {
        t2.parseFromString(e2["xdp:xdp"]);
      } catch {
      }
      this.node = t2.node;
    }
  }
  getValue(e2) {
    if (!this.node || !e2)
      return "";
    const t2 = this.node.searchNode(parseXFAPath(e2), 0);
    if (!t2)
      return "";
    const i2 = t2.firstChild;
    return "value" === (i2 == null ? void 0 : i2.nodeName) ? t2.children.map((e3) => decodeString(e3.textContent)) : decodeString(t2.textContent);
  }
};
var _K;
var XRef = class {
  constructor(e2, t2) {
    __privateAdd(this, _K, null);
    this.stream = e2;
    this.pdfManager = t2;
    this.entries = [];
    this._xrefStms = /* @__PURE__ */ new Set();
    this._cacheMap = /* @__PURE__ */ new Map();
    this._pendingRefs = new RefSet();
    this._newPersistentRefNum = null;
    this._newTemporaryRefNum = null;
    this._persistentRefsCache = null;
  }
  getNewPersistentRef(e2) {
    null === this._newPersistentRefNum && (this._newPersistentRefNum = this.entries.length || 1);
    const t2 = this._newPersistentRefNum++;
    this._cacheMap.set(t2, e2);
    return Ref.get(t2, 0);
  }
  getNewTemporaryRef() {
    if (null === this._newTemporaryRefNum) {
      this._newTemporaryRefNum = this.entries.length || 1;
      if (this._newPersistentRefNum) {
        this._persistentRefsCache = /* @__PURE__ */ new Map();
        for (let e2 = this._newTemporaryRefNum; e2 < this._newPersistentRefNum; e2++) {
          this._persistentRefsCache.set(e2, this._cacheMap.get(e2));
          this._cacheMap.delete(e2);
        }
      }
    }
    return Ref.get(this._newTemporaryRefNum++, 0);
  }
  resetNewTemporaryRef() {
    this._newTemporaryRefNum = null;
    if (this._persistentRefsCache)
      for (const [e2, t2] of this._persistentRefsCache)
        this._cacheMap.set(e2, t2);
    this._persistentRefsCache = null;
  }
  setStartXRef(e2) {
    this.startXRefQueue = [e2];
  }
  parse(e2 = false) {
    let t2, i2, a2;
    if (e2) {
      warn("Indexing all PDF objects");
      t2 = this.indexObjects();
    } else
      t2 = this.readXRef();
    t2.assignXref(this);
    this.trailer = t2;
    try {
      i2 = t2.get("Encrypt");
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      warn(`XRef.parse - Invalid "Encrypt" reference: "${e3}".`);
    }
    if (i2 instanceof Dict) {
      const e3 = t2.get("ID"), a3 = (e3 == null ? void 0 : e3.length) ? e3[0] : "";
      i2.suppressEncryption = true;
      this.encrypt = new CipherTransformFactory(i2, a3, this.pdfManager.password);
    }
    try {
      a2 = t2.get("Root");
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      warn(`XRef.parse - Invalid "Root" reference: "${e3}".`);
    }
    if (a2 instanceof Dict)
      try {
        if (a2.get("Pages") instanceof Dict) {
          this.root = a2;
          return;
        }
      } catch (e3) {
        if (e3 instanceof MissingDataException)
          throw e3;
        warn(`XRef.parse - Invalid "Pages" reference: "${e3}".`);
      }
    if (!e2)
      throw new XRefParseException();
    throw new InvalidPDFException("Invalid Root reference.");
  }
  processXRefTable(e2) {
    "tableState" in this || (this.tableState = { entryNum: 0, streamPos: e2.lexer.stream.pos, parserBuf1: e2.buf1, parserBuf2: e2.buf2 });
    if (!isCmd(this.readXRefTable(e2), "trailer"))
      throw new FormatError("Invalid XRef table: could not find trailer dictionary");
    let t2 = e2.getObj();
    t2 instanceof Dict || !t2.dict || (t2 = t2.dict);
    if (!(t2 instanceof Dict))
      throw new FormatError("Invalid XRef table: could not parse trailer dictionary");
    delete this.tableState;
    return t2;
  }
  readXRefTable(e2) {
    const t2 = e2.lexer.stream, i2 = this.tableState;
    t2.pos = i2.streamPos;
    e2.buf1 = i2.parserBuf1;
    e2.buf2 = i2.parserBuf2;
    let a2;
    for (; ; ) {
      if (!("firstEntryNum" in i2) || !("entryCount" in i2)) {
        if (isCmd(a2 = e2.getObj(), "trailer"))
          break;
        i2.firstEntryNum = a2;
        i2.entryCount = e2.getObj();
      }
      let s2 = i2.firstEntryNum;
      const r2 = i2.entryCount;
      if (!Number.isInteger(s2) || !Number.isInteger(r2))
        throw new FormatError("Invalid XRef table: wrong types in subsection header");
      for (let a3 = i2.entryNum; a3 < r2; a3++) {
        i2.streamPos = t2.pos;
        i2.entryNum = a3;
        i2.parserBuf1 = e2.buf1;
        i2.parserBuf2 = e2.buf2;
        const n2 = {};
        n2.offset = e2.getObj();
        n2.gen = e2.getObj();
        const g2 = e2.getObj();
        if (g2 instanceof Cmd)
          switch (g2.cmd) {
            case "f":
              n2.free = true;
              break;
            case "n":
              n2.uncompressed = true;
          }
        if (!Number.isInteger(n2.offset) || !Number.isInteger(n2.gen) || !n2.free && !n2.uncompressed)
          throw new FormatError(`Invalid entry in XRef subsection: ${s2}, ${r2}`);
        0 === a3 && n2.free && 1 === s2 && (s2 = 0);
        this.entries[a3 + s2] || (this.entries[a3 + s2] = n2);
      }
      i2.entryNum = 0;
      i2.streamPos = t2.pos;
      i2.parserBuf1 = e2.buf1;
      i2.parserBuf2 = e2.buf2;
      delete i2.firstEntryNum;
      delete i2.entryCount;
    }
    if (this.entries[0] && !this.entries[0].free)
      throw new FormatError("Invalid XRef table: unexpected first object");
    return a2;
  }
  processXRefStream(e2) {
    if (!("streamState" in this)) {
      const t2 = e2.dict, i2 = t2.get("W");
      let a2 = t2.get("Index");
      a2 || (a2 = [0, t2.get("Size")]);
      this.streamState = { entryRanges: a2, byteWidths: i2, entryNum: 0, streamPos: e2.pos };
    }
    this.readXRefStream(e2);
    delete this.streamState;
    return e2.dict;
  }
  readXRefStream(e2) {
    const t2 = this.streamState;
    e2.pos = t2.streamPos;
    const [i2, a2, s2] = t2.byteWidths, r2 = t2.entryRanges;
    for (; r2.length > 0; ) {
      const [n2, g2] = r2;
      if (!Number.isInteger(n2) || !Number.isInteger(g2))
        throw new FormatError(`Invalid XRef range fields: ${n2}, ${g2}`);
      if (!Number.isInteger(i2) || !Number.isInteger(a2) || !Number.isInteger(s2))
        throw new FormatError(`Invalid XRef entry fields length: ${n2}, ${g2}`);
      for (let r3 = t2.entryNum; r3 < g2; ++r3) {
        t2.entryNum = r3;
        t2.streamPos = e2.pos;
        let g3 = 0, o2 = 0, c2 = 0;
        for (let t3 = 0; t3 < i2; ++t3) {
          const t4 = e2.getByte();
          if (-1 === t4)
            throw new FormatError("Invalid XRef byteWidths 'type'.");
          g3 = g3 << 8 | t4;
        }
        0 === i2 && (g3 = 1);
        for (let t3 = 0; t3 < a2; ++t3) {
          const t4 = e2.getByte();
          if (-1 === t4)
            throw new FormatError("Invalid XRef byteWidths 'offset'.");
          o2 = o2 << 8 | t4;
        }
        for (let t3 = 0; t3 < s2; ++t3) {
          const t4 = e2.getByte();
          if (-1 === t4)
            throw new FormatError("Invalid XRef byteWidths 'generation'.");
          c2 = c2 << 8 | t4;
        }
        const C2 = {};
        C2.offset = o2;
        C2.gen = c2;
        switch (g3) {
          case 0:
            C2.free = true;
            break;
          case 1:
            C2.uncompressed = true;
            break;
          case 2:
            break;
          default:
            throw new FormatError(`Invalid XRef entry type: ${g3}`);
        }
        this.entries[n2 + r3] || (this.entries[n2 + r3] = C2);
      }
      t2.entryNum = 0;
      t2.streamPos = e2.pos;
      r2.splice(0, 2);
    }
  }
  indexObjects() {
    function readToken(e3, t3) {
      let i3 = "", a3 = e3[t3];
      for (; 10 !== a3 && 13 !== a3 && 60 !== a3 && !(++t3 >= e3.length); ) {
        i3 += String.fromCharCode(a3);
        a3 = e3[t3];
      }
      return i3;
    }
    function skipUntil(e3, t3, i3) {
      const a3 = i3.length, s3 = e3.length;
      let r3 = 0;
      for (; t3 < s3; ) {
        let s4 = 0;
        for (; s4 < a3 && e3[t3 + s4] === i3[s4]; )
          ++s4;
        if (s4 >= a3)
          break;
        t3++;
        r3++;
      }
      return r3;
    }
    const e2 = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, t2 = /\b(startxref|\d+\s+\d+\s+obj)\b/g, i2 = /^(\d+)\s+(\d+)\s+obj\b/, a2 = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), s2 = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), r2 = new Uint8Array([47, 88, 82, 101, 102]);
    this.entries.length = 0;
    this._cacheMap.clear();
    const n2 = this.stream;
    n2.pos = 0;
    const g2 = n2.getBytes(), o2 = bytesToString(g2), c2 = g2.length;
    let C2 = n2.start;
    const h2 = [], l2 = [];
    for (; C2 < c2; ) {
      let Q3 = g2[C2];
      if (9 === Q3 || 10 === Q3 || 13 === Q3 || 32 === Q3) {
        ++C2;
        continue;
      }
      if (37 === Q3) {
        do {
          ++C2;
          if (C2 >= c2)
            break;
          Q3 = g2[C2];
        } while (10 !== Q3 && 13 !== Q3);
        continue;
      }
      const E3 = readToken(g2, C2);
      let u3;
      if (E3.startsWith("xref") && (4 === E3.length || /\s/.test(E3[4]))) {
        C2 += skipUntil(g2, C2, a2);
        h2.push(C2);
        C2 += skipUntil(g2, C2, s2);
      } else if (u3 = i2.exec(E3)) {
        const t3 = 0 | u3[1], i3 = 0 | u3[2], a3 = C2 + E3.length;
        let s3, h3 = false;
        if (this.entries[t3]) {
          if (this.entries[t3].gen === i3)
            try {
              new Parser({ lexer: new Lexer(n2.makeSubStream(a3)) }).getObj();
              h3 = true;
            } catch (e3) {
              e3 instanceof ParserEOFException ? warn(`indexObjects -- checking object (${E3}): "${e3}".`) : h3 = true;
            }
        } else
          h3 = true;
        h3 && (this.entries[t3] = { offset: C2 - n2.start, gen: i3, uncompressed: true });
        e2.lastIndex = a3;
        const Q4 = e2.exec(o2);
        if (Q4) {
          s3 = e2.lastIndex + 1 - C2;
          if ("endobj" !== Q4[1]) {
            warn(`indexObjects: Found "${Q4[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`);
            s3 -= Q4[1].length + 1;
          }
        } else
          s3 = c2 - C2;
        const d3 = g2.subarray(C2, C2 + s3), f2 = skipUntil(d3, 0, r2);
        if (f2 < s3 && d3[f2 + 5] < 64) {
          l2.push(C2 - n2.start);
          this._xrefStms.add(C2 - n2.start);
        }
        C2 += s3;
      } else if (E3.startsWith("trailer") && (7 === E3.length || /\s/.test(E3[7]))) {
        h2.push(C2);
        const e3 = C2 + E3.length;
        let i3;
        t2.lastIndex = e3;
        const a3 = t2.exec(o2);
        if (a3) {
          i3 = t2.lastIndex + 1 - C2;
          if ("startxref" !== a3[1]) {
            warn(`indexObjects: Found "${a3[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`);
            i3 -= a3[1].length + 1;
          }
        } else
          i3 = c2 - C2;
        C2 += i3;
      } else
        C2 += E3.length + 1;
    }
    for (const e3 of l2) {
      this.startXRefQueue.push(e3);
      this.readXRef(true);
    }
    const Q2 = [];
    let E2, u2, d2 = false;
    for (const e3 of h2) {
      n2.pos = e3;
      const t3 = new Parser({ lexer: new Lexer(n2), xref: this, allowStreams: true, recoveryMode: true });
      if (!isCmd(t3.getObj(), "trailer"))
        continue;
      const i3 = t3.getObj();
      if (i3 instanceof Dict) {
        Q2.push(i3);
        i3.has("Encrypt") && (d2 = true);
      }
    }
    for (const e3 of [...Q2, "genFallback", ...Q2]) {
      if ("genFallback" === e3) {
        if (!u2)
          break;
        this._generationFallback = true;
        continue;
      }
      let t3 = false;
      try {
        const i3 = e3.get("Root");
        if (!(i3 instanceof Dict))
          continue;
        const a3 = i3.get("Pages");
        if (!(a3 instanceof Dict))
          continue;
        const s3 = a3.get("Count");
        Number.isInteger(s3) && (t3 = true);
      } catch (e4) {
        u2 = e4;
        continue;
      }
      if (t3 && (!d2 || e3.has("Encrypt")) && e3.has("ID"))
        return e3;
      E2 = e3;
    }
    if (E2)
      return E2;
    if (this.topDict)
      return this.topDict;
    throw new InvalidPDFException("Invalid PDF structure.");
  }
  readXRef(e2 = false) {
    const t2 = this.stream, i2 = /* @__PURE__ */ new Set();
    for (; this.startXRefQueue.length; ) {
      try {
        const e3 = this.startXRefQueue[0];
        if (i2.has(e3)) {
          warn("readXRef - skipping XRef table since it was already parsed.");
          this.startXRefQueue.shift();
          continue;
        }
        i2.add(e3);
        t2.pos = e3 + t2.start;
        const a2 = new Parser({ lexer: new Lexer(t2), xref: this, allowStreams: true });
        let s2, r2 = a2.getObj();
        if (isCmd(r2, "xref")) {
          s2 = this.processXRefTable(a2);
          this.topDict || (this.topDict = s2);
          r2 = s2.get("XRefStm");
          if (Number.isInteger(r2) && !this._xrefStms.has(r2)) {
            this._xrefStms.add(r2);
            this.startXRefQueue.push(r2);
            __privateGet(this, _K) ?? __privateSet(this, _K, r2);
          }
        } else {
          if (!Number.isInteger(r2))
            throw new FormatError("Invalid XRef stream header");
          if (!(Number.isInteger(a2.getObj()) && isCmd(a2.getObj(), "obj") && (r2 = a2.getObj()) instanceof BaseStream))
            throw new FormatError("Invalid XRef stream");
          s2 = this.processXRefStream(r2);
          this.topDict || (this.topDict = s2);
          if (!s2)
            throw new FormatError("Failed to read XRef stream");
        }
        r2 = s2.get("Prev");
        Number.isInteger(r2) ? this.startXRefQueue.push(r2) : r2 instanceof Ref && this.startXRefQueue.push(r2.num);
      } catch (e3) {
        if (e3 instanceof MissingDataException)
          throw e3;
        info("(while reading XRef): " + e3);
      }
      this.startXRefQueue.shift();
    }
    if (this.topDict)
      return this.topDict;
    if (!e2)
      throw new XRefParseException();
  }
  get lastXRefStreamPos() {
    return __privateGet(this, _K) ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
  }
  getEntry(e2) {
    const t2 = this.entries[e2];
    return t2 && !t2.free && t2.offset ? t2 : null;
  }
  fetchIfRef(e2, t2 = false) {
    return e2 instanceof Ref ? this.fetch(e2, t2) : e2;
  }
  fetch(e2, t2 = false) {
    if (!(e2 instanceof Ref))
      throw new Error("ref object is not a reference");
    const i2 = e2.num, a2 = this._cacheMap.get(i2);
    if (void 0 !== a2) {
      a2 instanceof Dict && !a2.objId && (a2.objId = e2.toString());
      return a2;
    }
    let s2 = this.getEntry(i2);
    if (null === s2) {
      this._cacheMap.set(i2, s2);
      return s2;
    }
    if (this._pendingRefs.has(e2)) {
      this._pendingRefs.remove(e2);
      warn(`Ignoring circular reference: ${e2}.`);
      return yt;
    }
    this._pendingRefs.put(e2);
    try {
      s2 = s2.uncompressed ? this.fetchUncompressed(e2, s2, t2) : this.fetchCompressed(e2, s2, t2);
      this._pendingRefs.remove(e2);
    } catch (t3) {
      this._pendingRefs.remove(e2);
      throw t3;
    }
    s2 instanceof Dict ? s2.objId = e2.toString() : s2 instanceof BaseStream && (s2.dict.objId = e2.toString());
    return s2;
  }
  fetchUncompressed(e2, t2, i2 = false) {
    const a2 = e2.gen;
    let s2 = e2.num;
    if (t2.gen !== a2) {
      const r3 = `Inconsistent generation in XRef: ${e2}`;
      if (this._generationFallback && t2.gen < a2) {
        warn(r3);
        return this.fetchUncompressed(Ref.get(s2, t2.gen), t2, i2);
      }
      throw new XRefEntryException(r3);
    }
    const r2 = this.stream.makeSubStream(t2.offset + this.stream.start), n2 = new Parser({ lexer: new Lexer(r2), xref: this, allowStreams: true }), g2 = n2.getObj(), o2 = n2.getObj(), c2 = n2.getObj();
    if (g2 !== s2 || o2 !== a2 || !(c2 instanceof Cmd))
      throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e2}`);
    if ("obj" !== c2.cmd) {
      if (c2.cmd.startsWith("obj")) {
        s2 = parseInt(c2.cmd.substring(3), 10);
        if (!Number.isNaN(s2))
          return s2;
      }
      throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e2}`);
    }
    (t2 = this.encrypt && !i2 ? n2.getObj(this.encrypt.createCipherTransform(s2, a2)) : n2.getObj()) instanceof BaseStream || this._cacheMap.set(s2, t2);
    return t2;
  }
  fetchCompressed(e2, t2, i2 = false) {
    const a2 = t2.offset, s2 = this.fetch(Ref.get(a2, 0));
    if (!(s2 instanceof BaseStream))
      throw new FormatError("bad ObjStm stream");
    const r2 = s2.dict.get("First"), n2 = s2.dict.get("N");
    if (!Number.isInteger(r2) || !Number.isInteger(n2))
      throw new FormatError("invalid first and n parameters for ObjStm stream");
    let g2 = new Parser({ lexer: new Lexer(s2), xref: this, allowStreams: true });
    const o2 = new Array(n2), c2 = new Array(n2);
    for (let e3 = 0; e3 < n2; ++e3) {
      const t3 = g2.getObj();
      if (!Number.isInteger(t3))
        throw new FormatError(`invalid object number in the ObjStm stream: ${t3}`);
      const i3 = g2.getObj();
      if (!Number.isInteger(i3))
        throw new FormatError(`invalid object offset in the ObjStm stream: ${i3}`);
      o2[e3] = t3;
      c2[e3] = i3;
    }
    const C2 = (s2.start || 0) + r2, h2 = new Array(n2);
    for (let e3 = 0; e3 < n2; ++e3) {
      const t3 = e3 < n2 - 1 ? c2[e3 + 1] - c2[e3] : void 0;
      if (t3 < 0)
        throw new FormatError("Invalid offset in the ObjStm stream.");
      g2 = new Parser({ lexer: new Lexer(s2.makeSubStream(C2 + c2[e3], t3, s2.dict)), xref: this, allowStreams: true });
      const i3 = g2.getObj();
      h2[e3] = i3;
      if (i3 instanceof BaseStream)
        continue;
      const r3 = o2[e3], l2 = this.entries[r3];
      l2 && l2.offset === a2 && l2.gen === e3 && this._cacheMap.set(r3, i3);
    }
    if (void 0 === (t2 = h2[t2.gen]))
      throw new XRefEntryException(`Bad (compressed) XRef entry: ${e2}`);
    return t2;
  }
  async fetchIfRefAsync(e2, t2) {
    return e2 instanceof Ref ? this.fetchAsync(e2, t2) : e2;
  }
  async fetchAsync(e2, t2) {
    try {
      return this.fetch(e2, t2);
    } catch (i2) {
      if (!(i2 instanceof MissingDataException))
        throw i2;
      await this.pdfManager.requestRange(i2.begin, i2.end);
      return this.fetchAsync(e2, t2);
    }
  }
  getCatalogObj() {
    return this.root;
  }
};
_K = new WeakMap();
var og = [0, 0, 612, 792];
var _T, T_fn;
var Page = class {
  constructor({ pdfManager: e2, xref: t2, pageIndex: i2, pageDict: a2, ref: s2, globalIdFactory: r2, fontCache: n2, builtInCMapCache: g2, standardFontDataCache: o2, globalImageCache: c2, systemFontCache: C2, nonBlendModesSet: h2, xfaFactory: l2 }) {
    __privateAdd(this, _T);
    this.pdfManager = e2;
    this.pageIndex = i2;
    this.pageDict = a2;
    this.xref = t2;
    this.ref = s2;
    this.fontCache = n2;
    this.builtInCMapCache = g2;
    this.standardFontDataCache = o2;
    this.globalImageCache = c2;
    this.systemFontCache = C2;
    this.nonBlendModesSet = h2;
    this.evaluatorOptions = e2.evaluatorOptions;
    this.resourcesPromise = null;
    this.xfaFactory = l2;
    const Q2 = { obj: 0 };
    this._localIdFactory = class extends r2 {
      static createObjId() {
        return `p${i2}_${++Q2.obj}`;
      }
      static getPageObjId() {
        return `p${s2.toString()}`;
      }
    };
  }
  _getInheritableProperty(e2, t2 = false) {
    const i2 = getInheritableProperty({ dict: this.pageDict, key: e2, getArray: t2, stopWhenFound: false });
    return Array.isArray(i2) ? 1 !== i2.length && i2[0] instanceof Dict ? Dict.merge({ xref: this.xref, dictArray: i2 }) : i2[0] : i2;
  }
  get content() {
    return this.pageDict.getArray("Contents");
  }
  get resources() {
    const e2 = this._getInheritableProperty("Resources");
    return shadow(this, "resources", e2 instanceof Dict ? e2 : Dict.empty);
  }
  _getBoundingBox(e2) {
    if (this.xfaData)
      return this.xfaData.bbox;
    const t2 = lookupNormalRect(this._getInheritableProperty(e2, true), null);
    if (t2) {
      if (t2[2] - t2[0] > 0 && t2[3] - t2[1] > 0)
        return t2;
      warn(`Empty, or invalid, /${e2} entry.`);
    }
    return null;
  }
  get mediaBox() {
    return shadow(this, "mediaBox", this._getBoundingBox("MediaBox") || og);
  }
  get cropBox() {
    return shadow(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
  }
  get userUnit() {
    let e2 = this.pageDict.get("UserUnit");
    ("number" != typeof e2 || e2 <= 0) && (e2 = 1);
    return shadow(this, "userUnit", e2);
  }
  get view() {
    const { cropBox: e2, mediaBox: t2 } = this;
    if (e2 !== t2 && !isArrayEqual(e2, t2)) {
      const i2 = Util.intersect(e2, t2);
      if (i2 && i2[2] - i2[0] > 0 && i2[3] - i2[1] > 0)
        return shadow(this, "view", i2);
      warn("Empty /CropBox and /MediaBox intersection.");
    }
    return shadow(this, "view", t2);
  }
  get rotate() {
    let e2 = this._getInheritableProperty("Rotate") || 0;
    e2 % 90 != 0 ? e2 = 0 : e2 >= 360 ? e2 %= 360 : e2 < 0 && (e2 = (e2 % 360 + 360) % 360);
    return shadow(this, "rotate", e2);
  }
  _onSubStreamError(e2, t2) {
    if (!this.evaluatorOptions.ignoreErrors)
      throw e2;
    warn(`getContentStream - ignoring sub-stream (${t2}): "${e2}".`);
  }
  getContentStream() {
    return this.pdfManager.ensure(this, "content").then((e2) => e2 instanceof BaseStream ? e2 : Array.isArray(e2) ? new StreamsSequenceStream(e2, this._onSubStreamError.bind(this)) : new NullStream());
  }
  get xfaData() {
    return shadow(this, "xfaData", this.xfaFactory ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) } : null);
  }
  async saveNewAnnotations(e2, t2, i2, a2) {
    if (this.xfaFactory)
      throw new Error("XFA: Cannot save new annotations.");
    const s2 = new PartialEvaluator({ xref: this.xref, handler: e2, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }), r2 = new RefSetCache(), n2 = new RefSet();
    __privateMethod(this, _T, T_fn).call(this, i2, r2, n2);
    const g2 = this.pageDict, o2 = this.annotations.filter((e3) => !(e3 instanceof Ref && r2.has(e3))), c2 = await AnnotationFactory.saveNewAnnotations(s2, t2, i2, a2);
    for (const { ref: e3 } of c2.annotations)
      e3 instanceof Ref && !n2.has(e3) && o2.push(e3);
    const C2 = g2.get("Annots");
    g2.set("Annots", o2);
    const h2 = [];
    await writeObject(this.ref, g2, h2, this.xref);
    C2 && g2.set("Annots", C2);
    const l2 = c2.dependencies;
    l2.push({ ref: this.ref, data: h2.join("") }, ...c2.annotations);
    for (const e3 of r2)
      l2.push({ ref: e3, data: null });
    return l2;
  }
  save(e2, t2, i2) {
    const a2 = new PartialEvaluator({ xref: this.xref, handler: e2, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions });
    return this._parsedAnnotations.then(function(e3) {
      const s2 = [];
      for (const r2 of e3)
        r2.mustBePrinted(i2) && s2.push(r2.save(a2, t2, i2).catch(function(e4) {
          warn(`save - ignoring annotation data during "${t2.name}" task: "${e4}".`);
          return null;
        }));
      return Promise.all(s2).then(function(e4) {
        return e4.filter((e5) => !!e5);
      });
    });
  }
  loadResources(e2) {
    this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources"));
    return this.resourcesPromise.then(() => new ObjectLoader(this.resources, e2, this.xref).load());
  }
  getOperatorList({ handler: e2, sink: t2, task: i2, intent: a2, cacheKey: s2, annotationStorage: r2 = null, modifiedIds: n2 = null }) {
    const C2 = this.getContentStream(), E2 = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]), d2 = new PartialEvaluator({ xref: this.xref, handler: e2, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }), f2 = this.xfaFactory ? null : getNewAnnotationsMap(r2), p2 = f2 == null ? void 0 : f2.get(this.pageIndex);
    let m2 = Promise.resolve(null), y2 = null;
    if (p2) {
      const e3 = this.pdfManager.ensureDoc("annotationGlobals");
      let t3;
      const a3 = /* @__PURE__ */ new Set();
      for (const { bitmapId: e4, bitmap: t4 } of p2)
        !e4 || t4 || a3.has(e4) || a3.add(e4);
      const { isOffscreenCanvasSupported: s3 } = this.evaluatorOptions;
      if (a3.size > 0) {
        const e4 = p2.slice();
        for (const [t4, i3] of r2)
          t4.startsWith(u) && i3.bitmap && a3.has(i3.bitmapId) && e4.push(i3);
        t3 = AnnotationFactory.generateImages(e4, this.xref, s3);
      } else
        t3 = AnnotationFactory.generateImages(p2, this.xref, s3);
      y2 = new RefSet();
      __privateMethod(this, _T, T_fn).call(this, p2, y2, null);
      m2 = e3.then((e4) => e4 ? AnnotationFactory.printNewAnnotations(e4, d2, i2, p2, t3) : null);
    }
    const w2 = Promise.all([C2, E2]).then(([r3]) => {
      const n3 = new OperatorList(a2, t2);
      e2.send("StartRenderPage", { transparency: d2.hasBlendModes(this.resources, this.nonBlendModesSet), pageIndex: this.pageIndex, cacheKey: s2 });
      return d2.getOperatorList({ stream: r3, task: i2, resources: this.resources, operatorList: n3 }).then(function() {
        return n3;
      });
    });
    return Promise.all([w2, this._parsedAnnotations, m2]).then(function([e3, t3, s3]) {
      if (s3) {
        t3 = t3.filter((e4) => !(e4.ref && y2.has(e4.ref)));
        for (let e4 = 0, i3 = s3.length; e4 < i3; e4++) {
          const a3 = s3[e4];
          if (a3.refToReplace) {
            const r3 = t3.findIndex((e5) => e5.ref && isRefsEqual(e5.ref, a3.refToReplace));
            if (r3 >= 0) {
              t3.splice(r3, 1, a3);
              s3.splice(e4--, 1);
              i3--;
            }
          }
        }
        t3 = t3.concat(s3);
      }
      if (0 === t3.length || a2 & l) {
        e3.flush(true);
        return { length: e3.totalLength };
      }
      const C3 = !!(a2 & h), E3 = !!(a2 & Q), u2 = !!(a2 & g), f3 = !!(a2 & o), p3 = !!(a2 & c), m3 = [];
      for (const e4 of t3)
        (u2 || f3 && e4.mustBeViewed(r2, C3) && e4.mustBeViewedWhenEditing(E3, n2) || p3 && e4.mustBePrinted(r2)) && m3.push(e4.getOperatorList(d2, i2, a2, r2).catch(function(e5) {
          warn(`getOperatorList - ignoring annotation data during "${i2.name}" task: "${e5}".`);
          return { opList: null, separateForm: false, separateCanvas: false };
        }));
      return Promise.all(m3).then(function(t4) {
        let i3 = false, a3 = false;
        for (const { opList: s4, separateForm: r3, separateCanvas: n3 } of t4) {
          e3.addOpList(s4);
          i3 || (i3 = r3);
          a3 || (a3 = n3);
        }
        e3.flush(true, { form: i3, canvas: a3 });
        return { length: e3.totalLength };
      });
    });
  }
  async extractTextContent({ handler: e2, task: t2, includeMarkedContent: i2, disableNormalization: a2, sink: s2 }) {
    const r2 = this.getContentStream(), n2 = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]), g2 = this.pdfManager.ensureCatalog("lang"), [o2, , c2] = await Promise.all([r2, n2, g2]);
    return new PartialEvaluator({ xref: this.xref, handler: e2, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }).getTextContent({ stream: o2, task: t2, resources: this.resources, includeMarkedContent: i2, disableNormalization: a2, sink: s2, viewBox: this.view, lang: c2 });
  }
  async getStructTree() {
    const e2 = await this.pdfManager.ensureCatalog("structTreeRoot");
    if (!e2)
      return null;
    await this._parsedAnnotations;
    return (await this.pdfManager.ensure(this, "_parseStructTree", [e2])).serializable;
  }
  _parseStructTree(e2) {
    const t2 = new StructTreePage(e2, this.pageDict);
    t2.parse(this.ref);
    return t2;
  }
  async getAnnotationsData(e2, t2, i2) {
    const a2 = await this._parsedAnnotations;
    if (0 === a2.length)
      return a2;
    const s2 = [], r2 = [];
    let n2;
    const C2 = !!(i2 & g), h2 = !!(i2 & o), l2 = !!(i2 & c);
    for (const i3 of a2) {
      const a3 = C2 || h2 && i3.viewable;
      (a3 || l2 && i3.printable) && s2.push(i3.data);
      if (i3.hasTextContent && a3) {
        n2 || (n2 = new PartialEvaluator({ xref: this.xref, handler: e2, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }));
        r2.push(i3.extractTextContent(n2, t2, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch(function(e3) {
          warn(`getAnnotationsData - ignoring textContent during "${t2.name}" task: "${e3}".`);
        }));
      }
    }
    await Promise.all(r2);
    return s2;
  }
  get annotations() {
    const e2 = this._getInheritableProperty("Annots");
    return shadow(this, "annotations", Array.isArray(e2) ? e2 : []);
  }
  get _parsedAnnotations() {
    return shadow(this, "_parsedAnnotations", this.pdfManager.ensure(this, "annotations").then(async (e2) => {
      if (0 === e2.length)
        return e2;
      const t2 = await this.pdfManager.ensureDoc("annotationGlobals");
      if (!t2)
        return [];
      const i2 = [];
      for (const a3 of e2)
        i2.push(AnnotationFactory.create(this.xref, a3, t2, this._localIdFactory, false, this.ref).catch(function(e3) {
          warn(`_parsedAnnotations: "${e3}".`);
          return null;
        }));
      const a2 = [];
      let s2, r2;
      for (const e3 of await Promise.all(i2))
        e3 && (e3 instanceof WidgetAnnotation ? (r2 || (r2 = [])).push(e3) : e3 instanceof PopupAnnotation ? (s2 || (s2 = [])).push(e3) : a2.push(e3));
      r2 && a2.push(...r2);
      s2 && a2.push(...s2);
      return a2;
    }));
  }
  get jsActions() {
    return shadow(this, "jsActions", collectActions(this.xref, this.pageDict, pA));
  }
};
_T = new WeakSet();
T_fn = function(e2, t2, i2) {
  for (const a2 of e2)
    if (a2.id) {
      const e3 = Ref.fromString(a2.id);
      if (!e3) {
        warn(`A non-linked annotation cannot be modified: ${a2.id}`);
        continue;
      }
      if (a2.deleted) {
        t2.put(e3, e3);
        continue;
      }
      i2 == null ? void 0 : i2.put(e3);
      a2.ref = e3;
      delete a2.id;
    }
};
var Ig = new Uint8Array([37, 80, 68, 70, 45]);
var cg = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
var Cg = new Uint8Array([101, 110, 100, 111, 98, 106]);
function find(e2, t2, i2 = 1024, a2 = false) {
  const s2 = t2.length, r2 = e2.peekBytes(i2), n2 = r2.length - s2;
  if (n2 <= 0)
    return false;
  if (a2) {
    const i3 = s2 - 1;
    let a3 = r2.length - 1;
    for (; a3 >= i3; ) {
      let n3 = 0;
      for (; n3 < s2 && r2[a3 - n3] === t2[i3 - n3]; )
        n3++;
      if (n3 >= s2) {
        e2.pos += a3 - i3;
        return true;
      }
      a3--;
    }
  } else {
    let i3 = 0;
    for (; i3 <= n2; ) {
      let a3 = 0;
      for (; a3 < s2 && r2[i3 + a3] === t2[a3]; )
        a3++;
      if (a3 >= s2) {
        e2.pos += i3;
        return true;
      }
      i3++;
    }
  }
  return false;
}
var _q, q_fn;
var PDFDocument = class {
  constructor(e2, t2) {
    __privateAdd(this, _q);
    if (t2.length <= 0)
      throw new InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
    this.pdfManager = e2;
    this.stream = t2;
    this.xref = new XRef(t2, e2);
    this._pagePromises = /* @__PURE__ */ new Map();
    this._version = null;
    const i2 = { font: 0 };
    this._globalIdFactory = class {
      static getDocId() {
        return `g_${e2.docId}`;
      }
      static createFontId() {
        return "f" + ++i2.font;
      }
      static createObjId() {
        unreachable("Abstract method `createObjId` called.");
      }
      static getPageObjId() {
        unreachable("Abstract method `getPageObjId` called.");
      }
    };
  }
  parse(e2) {
    this.xref.parse(e2);
    this.catalog = new Catalog(this.pdfManager, this.xref);
  }
  get linearization() {
    let e2 = null;
    try {
      e2 = Linearization.create(this.stream);
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      info(e3);
    }
    return shadow(this, "linearization", e2);
  }
  get startXRef() {
    const e2 = this.stream;
    let t2 = 0;
    if (this.linearization) {
      e2.reset();
      if (find(e2, Cg)) {
        e2.skip(6);
        let i2 = e2.peekByte();
        for (; isWhiteSpace(i2); ) {
          e2.pos++;
          i2 = e2.peekByte();
        }
        t2 = e2.pos - e2.start;
      }
    } else {
      const i2 = 1024, a2 = cg.length;
      let s2 = false, r2 = e2.end;
      for (; !s2 && r2 > 0; ) {
        r2 -= i2 - a2;
        r2 < 0 && (r2 = 0);
        e2.pos = r2;
        s2 = find(e2, cg, i2, true);
      }
      if (s2) {
        e2.skip(9);
        let i3;
        do {
          i3 = e2.getByte();
        } while (isWhiteSpace(i3));
        let a3 = "";
        for (; i3 >= 32 && i3 <= 57; ) {
          a3 += String.fromCharCode(i3);
          i3 = e2.getByte();
        }
        t2 = parseInt(a3, 10);
        isNaN(t2) && (t2 = 0);
      }
    }
    return shadow(this, "startXRef", t2);
  }
  checkHeader() {
    const e2 = this.stream;
    e2.reset();
    if (!find(e2, Ig))
      return;
    e2.moveStart();
    e2.skip(Ig.length);
    let t2, i2 = "";
    for (; (t2 = e2.getByte()) > 32 && i2.length < 7; )
      i2 += String.fromCharCode(t2);
    kt.test(i2) ? this._version = i2 : warn(`Invalid PDF header version: ${i2}`);
  }
  parseStartXRef() {
    this.xref.setStartXRef(this.startXRef);
  }
  get numPages() {
    let e2 = 0;
    e2 = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages;
    return shadow(this, "numPages", e2);
  }
  _hasOnlyDocumentSignatures(e2, t2 = 0) {
    return !!Array.isArray(e2) && e2.every((e3) => {
      if (!((e3 = this.xref.fetchIfRef(e3)) instanceof Dict))
        return false;
      if (e3.has("Kids")) {
        if (++t2 > 10) {
          warn("_hasOnlyDocumentSignatures: maximum recursion depth reached");
          return false;
        }
        return this._hasOnlyDocumentSignatures(e3.get("Kids"), t2);
      }
      const i2 = isName(e3.get("FT"), "Sig"), a2 = e3.get("Rect"), s2 = Array.isArray(a2) && a2.every((e4) => 0 === e4);
      return i2 && s2;
    });
  }
  get _xfaStreams() {
    const e2 = this.catalog.acroForm;
    if (!e2)
      return null;
    const t2 = e2.get("XFA"), i2 = { "xdp:xdp": "", template: "", datasets: "", config: "", connectionSet: "", localeSet: "", stylesheet: "", "/xdp:xdp": "" };
    if (t2 instanceof BaseStream && !t2.isEmpty) {
      i2["xdp:xdp"] = t2;
      return i2;
    }
    if (!Array.isArray(t2) || 0 === t2.length)
      return null;
    for (let e3 = 0, a2 = t2.length; e3 < a2; e3 += 2) {
      let s2;
      s2 = 0 === e3 ? "xdp:xdp" : e3 === a2 - 2 ? "/xdp:xdp" : t2[e3];
      if (!i2.hasOwnProperty(s2))
        continue;
      const r2 = this.xref.fetchIfRef(t2[e3 + 1]);
      r2 instanceof BaseStream && !r2.isEmpty && (i2[s2] = r2);
    }
    return i2;
  }
  get xfaDatasets() {
    const e2 = this._xfaStreams;
    if (!e2)
      return shadow(this, "xfaDatasets", null);
    for (const t2 of ["datasets", "xdp:xdp"]) {
      const i2 = e2[t2];
      if (i2)
        try {
          const e3 = stringToUTF8String(i2.getString());
          return shadow(this, "xfaDatasets", new DatasetReader({ [t2]: e3 }));
        } catch {
          warn("XFA - Invalid utf-8 string.");
          break;
        }
    }
    return shadow(this, "xfaDatasets", null);
  }
  get xfaData() {
    const e2 = this._xfaStreams;
    if (!e2)
      return null;
    const t2 = /* @__PURE__ */ Object.create(null);
    for (const [i2, a2] of Object.entries(e2))
      if (a2)
        try {
          t2[i2] = stringToUTF8String(a2.getString());
        } catch {
          warn("XFA - Invalid utf-8 string.");
          return null;
        }
    return t2;
  }
  get xfaFactory() {
    let e2;
    this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e2 = this.xfaData);
    return shadow(this, "xfaFactory", e2 ? new XFAFactory(e2) : null);
  }
  get isPureXfa() {
    return !!this.xfaFactory && this.xfaFactory.isValid();
  }
  get htmlForXfa() {
    return this.xfaFactory ? this.xfaFactory.getPages() : null;
  }
  async loadXfaImages() {
    const e2 = await this.pdfManager.ensureCatalog("xfaImages");
    if (!e2)
      return;
    const t2 = e2.getKeys(), i2 = new ObjectLoader(e2, t2, this.xref);
    await i2.load();
    const a2 = /* @__PURE__ */ new Map();
    for (const i3 of t2) {
      const t3 = e2.get(i3);
      t3 instanceof BaseStream && a2.set(i3, t3.getBytes());
    }
    this.xfaFactory.setImages(a2);
  }
  async loadXfaFonts(e2, t2) {
    const i2 = await this.pdfManager.ensureCatalog("acroForm");
    if (!i2)
      return;
    const a2 = await i2.getAsync("DR");
    if (!(a2 instanceof Dict))
      return;
    const s2 = new ObjectLoader(a2, ["Font"], this.xref);
    await s2.load();
    const r2 = a2.get("Font");
    if (!(r2 instanceof Dict))
      return;
    const n2 = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
    n2.useSystemFonts = false;
    const g2 = new PartialEvaluator({ xref: this.xref, handler: e2, pageIndex: -1, idFactory: this._globalIdFactory, fontCache: this.catalog.fontCache, builtInCMapCache: this.catalog.builtInCMapCache, standardFontDataCache: this.catalog.standardFontDataCache, options: n2 }), o2 = new OperatorList(), c2 = [], C2 = { get font() {
      return c2.at(-1);
    }, set font(e3) {
      c2.push(e3);
    }, clone() {
      return this;
    } }, h2 = /* @__PURE__ */ new Map();
    r2.forEach((e3, t3) => {
      h2.set(e3, t3);
    });
    const l2 = [];
    for (const [e3, i3] of h2) {
      const s3 = i3.get("FontDescriptor");
      if (!(s3 instanceof Dict))
        continue;
      let r3 = s3.get("FontFamily");
      r3 = r3.replaceAll(/[ ]+(\d)/g, "$1");
      const n3 = { fontFamily: r3, fontWeight: s3.get("FontWeight"), italicAngle: -s3.get("ItalicAngle") };
      validateCSSFont(n3) && l2.push(g2.handleSetFont(a2, [Name.get(e3), 1], null, o2, t2, C2, null, n3).catch(function(e4) {
        warn(`loadXfaFonts: "${e4}".`);
        return null;
      }));
    }
    await Promise.all(l2);
    const Q2 = this.xfaFactory.setFonts(c2);
    if (!Q2)
      return;
    n2.ignoreErrors = true;
    l2.length = 0;
    c2.length = 0;
    const E2 = /* @__PURE__ */ new Set();
    for (const e3 of Q2)
      getXfaFontName(`${e3}-Regular`) || E2.add(e3);
    E2.size && Q2.push("PdfJS-Fallback");
    for (const e3 of Q2)
      if (!E2.has(e3))
        for (const i3 of [{ name: "Regular", fontWeight: 400, italicAngle: 0 }, { name: "Bold", fontWeight: 700, italicAngle: 0 }, { name: "Italic", fontWeight: 400, italicAngle: 12 }, { name: "BoldItalic", fontWeight: 700, italicAngle: 12 }]) {
          const s3 = `${e3}-${i3.name}`, r3 = getXfaFontDict(s3);
          l2.push(g2.handleSetFont(a2, [Name.get(s3), 1], null, o2, t2, C2, r3, { fontFamily: e3, fontWeight: i3.fontWeight, italicAngle: i3.italicAngle }).catch(function(e4) {
            warn(`loadXfaFonts: "${e4}".`);
            return null;
          }));
        }
    await Promise.all(l2);
    this.xfaFactory.appendFonts(c2, E2);
  }
  async serializeXfaData(e2) {
    return this.xfaFactory ? this.xfaFactory.serializeData(e2) : null;
  }
  get version() {
    return this.catalog.version || this._version;
  }
  get formInfo() {
    const e2 = { hasFields: false, hasAcroForm: false, hasXfa: false, hasSignatures: false }, t2 = this.catalog.acroForm;
    if (!t2)
      return shadow(this, "formInfo", e2);
    try {
      const i2 = t2.get("Fields"), a2 = Array.isArray(i2) && i2.length > 0;
      e2.hasFields = a2;
      const s2 = t2.get("XFA");
      e2.hasXfa = Array.isArray(s2) && s2.length > 0 || s2 instanceof BaseStream && !s2.isEmpty;
      const r2 = !!(1 & t2.get("SigFlags")), n2 = r2 && this._hasOnlyDocumentSignatures(i2);
      e2.hasAcroForm = a2 && !n2;
      e2.hasSignatures = r2;
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      warn(`Cannot fetch form information: "${e3}".`);
    }
    return shadow(this, "formInfo", e2);
  }
  get documentInfo() {
    const e2 = { PDFFormatVersion: this.version, Language: this.catalog.lang, EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null, IsLinearized: !!this.linearization, IsAcroFormPresent: this.formInfo.hasAcroForm, IsXFAPresent: this.formInfo.hasXfa, IsCollectionPresent: !!this.catalog.collection, IsSignaturesPresent: this.formInfo.hasSignatures };
    let t2;
    try {
      t2 = this.xref.trailer.get("Info");
    } catch (e3) {
      if (e3 instanceof MissingDataException)
        throw e3;
      info("The document information dictionary is invalid.");
    }
    if (!(t2 instanceof Dict))
      return shadow(this, "documentInfo", e2);
    for (const i2 of t2.getKeys()) {
      const a2 = t2.get(i2);
      switch (i2) {
        case "Title":
        case "Author":
        case "Subject":
        case "Keywords":
        case "Creator":
        case "Producer":
        case "CreationDate":
        case "ModDate":
          if ("string" == typeof a2) {
            e2[i2] = stringToPDFString(a2);
            continue;
          }
          break;
        case "Trapped":
          if (a2 instanceof Name) {
            e2[i2] = a2;
            continue;
          }
          break;
        default:
          let t3;
          switch (typeof a2) {
            case "string":
              t3 = stringToPDFString(a2);
              break;
            case "number":
            case "boolean":
              t3 = a2;
              break;
            default:
              a2 instanceof Name && (t3 = a2);
          }
          if (void 0 === t3) {
            warn(`Bad value, for custom key "${i2}", in Info: ${a2}.`);
            continue;
          }
          e2.Custom || (e2.Custom = /* @__PURE__ */ Object.create(null));
          e2.Custom[i2] = t3;
          continue;
      }
      warn(`Bad value, for key "${i2}", in Info: ${a2}.`);
    }
    return shadow(this, "documentInfo", e2);
  }
  get fingerprints() {
    function validate(e3) {
      return "string" == typeof e3 && e3.length > 0 && "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0" !== e3;
    }
    function hexString(e3) {
      const t3 = [];
      for (const i3 of e3) {
        const e4 = i3.toString(16);
        t3.push(e4.padStart(2, "0"));
      }
      return t3.join("");
    }
    const e2 = this.xref.trailer.get("ID");
    let t2, i2;
    if (Array.isArray(e2) && validate(e2[0])) {
      t2 = stringToBytes(e2[0]);
      e2[1] !== e2[0] && validate(e2[1]) && (i2 = stringToBytes(e2[1]));
    } else
      t2 = Ks(this.stream.getByteRange(0, 1024), 0, 1024);
    return shadow(this, "fingerprints", [hexString(t2), i2 ? hexString(i2) : null]);
  }
  async _getLinearizationPage(e2) {
    const { catalog: t2, linearization: i2, xref: a2 } = this, s2 = Ref.get(i2.objectNumberFirst, 0);
    try {
      const e3 = await a2.fetchAsync(s2);
      if (e3 instanceof Dict) {
        let i3 = e3.getRaw("Type");
        i3 instanceof Ref && (i3 = await a2.fetchAsync(i3));
        if (isName(i3, "Page") || !e3.has("Type") && !e3.has("Kids") && e3.has("Contents")) {
          t2.pageKidsCountCache.has(s2) || t2.pageKidsCountCache.put(s2, 1);
          t2.pageIndexCache.has(s2) || t2.pageIndexCache.put(s2, 0);
          return [e3, s2];
        }
      }
      throw new FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
    } catch (i3) {
      warn(`_getLinearizationPage: "${i3.message}".`);
      return t2.getPageDict(e2);
    }
  }
  getPage(e2) {
    const t2 = this._pagePromises.get(e2);
    if (t2)
      return t2;
    const { catalog: i2, linearization: a2, xfaFactory: s2 } = this;
    let r2;
    r2 = s2 ? Promise.resolve([Dict.empty, null]) : (a2 == null ? void 0 : a2.pageFirst) === e2 ? this._getLinearizationPage(e2) : i2.getPageDict(e2);
    r2 = r2.then(([t3, a3]) => new Page({ pdfManager: this.pdfManager, xref: this.xref, pageIndex: e2, pageDict: t3, ref: a3, globalIdFactory: this._globalIdFactory, fontCache: i2.fontCache, builtInCMapCache: i2.builtInCMapCache, standardFontDataCache: i2.standardFontDataCache, globalImageCache: i2.globalImageCache, systemFontCache: i2.systemFontCache, nonBlendModesSet: i2.nonBlendModesSet, xfaFactory: s2 }));
    this._pagePromises.set(e2, r2);
    return r2;
  }
  async checkFirstPage(e2 = false) {
    if (!e2)
      try {
        await this.getPage(0);
      } catch (e3) {
        if (e3 instanceof XRefEntryException) {
          this._pagePromises.delete(0);
          await this.cleanup();
          throw new XRefParseException();
        }
      }
  }
  async checkLastPage(e2 = false) {
    const { catalog: t2, pdfManager: i2 } = this;
    t2.setActualNumPages();
    let a2;
    try {
      await Promise.all([i2.ensureDoc("xfaFactory"), i2.ensureDoc("linearization"), i2.ensureCatalog("numPages")]);
      if (this.xfaFactory)
        return;
      a2 = this.linearization ? this.linearization.numPages : t2.numPages;
      if (!Number.isInteger(a2))
        throw new FormatError("Page count is not an integer.");
      if (a2 <= 1)
        return;
      await this.getPage(a2 - 1);
    } catch (s2) {
      this._pagePromises.delete(a2 - 1);
      await this.cleanup();
      if (s2 instanceof XRefEntryException && !e2)
        throw new XRefParseException();
      warn(`checkLastPage - invalid /Pages tree /Count: ${a2}.`);
      let r2;
      try {
        r2 = await t2.getAllPageDicts(e2);
      } catch (i3) {
        if (i3 instanceof XRefEntryException && !e2)
          throw new XRefParseException();
        t2.setActualNumPages(1);
        return;
      }
      for (const [e3, [a3, s3]] of r2) {
        let r3;
        if (a3 instanceof Error) {
          r3 = Promise.reject(a3);
          r3.catch(() => {
          });
        } else
          r3 = Promise.resolve(new Page({ pdfManager: i2, xref: this.xref, pageIndex: e3, pageDict: a3, ref: s3, globalIdFactory: this._globalIdFactory, fontCache: t2.fontCache, builtInCMapCache: t2.builtInCMapCache, standardFontDataCache: t2.standardFontDataCache, globalImageCache: t2.globalImageCache, systemFontCache: t2.systemFontCache, nonBlendModesSet: t2.nonBlendModesSet, xfaFactory: null }));
        this._pagePromises.set(e3, r3);
      }
      t2.setActualNumPages(r2.size);
    }
  }
  fontFallback(e2, t2) {
    return this.catalog.fontFallback(e2, t2);
  }
  async cleanup(e2 = false) {
    return this.catalog ? this.catalog.cleanup(e2) : clearGlobalCaches();
  }
  get fieldObjects() {
    if (!this.formInfo.hasFields)
      return shadow(this, "fieldObjects", Promise.resolve(null));
    return shadow(this, "fieldObjects", Promise.all([this.pdfManager.ensureDoc("annotationGlobals"), this.pdfManager.ensureCatalog("acroForm")]).then(async ([e2, t2]) => {
      if (!e2)
        return null;
      const i2 = new RefSet(), a2 = /* @__PURE__ */ Object.create(null), s2 = /* @__PURE__ */ new Map();
      for (const a3 of await t2.getAsync("Fields"))
        await __privateMethod(this, _q, q_fn).call(this, "", a3, s2, e2, i2);
      const r2 = [];
      for (const [e3, t3] of s2)
        r2.push(Promise.all(t3).then((t4) => {
          (t4 = t4.filter((e4) => !!e4)).length > 0 && (a2[e3] = t4);
        }));
      await Promise.all(r2);
      return a2;
    }));
  }
  get hasJSActions() {
    return shadow(this, "hasJSActions", this.pdfManager.ensureDoc("_parseHasJSActions"));
  }
  async _parseHasJSActions() {
    const [e2, t2] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
    return !!e2 || !!t2 && Object.values(t2).some((e3) => e3.some((e4) => null !== e4.actions));
  }
  get calculationOrderIds() {
    const e2 = this.catalog.acroForm;
    if (!(e2 == null ? void 0 : e2.has("CO")))
      return shadow(this, "calculationOrderIds", null);
    const t2 = e2.get("CO");
    if (!Array.isArray(t2) || 0 === t2.length)
      return shadow(this, "calculationOrderIds", null);
    const i2 = [];
    for (const e3 of t2)
      e3 instanceof Ref && i2.push(e3.toString());
    return 0 === i2.length ? shadow(this, "calculationOrderIds", null) : shadow(this, "calculationOrderIds", i2);
  }
  get annotationGlobals() {
    return shadow(this, "annotationGlobals", AnnotationFactory.createGlobals(this.pdfManager));
  }
};
_q = new WeakSet();
q_fn = async function(e2, t2, i2, a2, s2) {
  const { xref: r2 } = this;
  if (!(t2 instanceof Ref) || s2.has(t2))
    return;
  s2.put(t2);
  const n2 = await r2.fetchAsync(t2);
  if (!(n2 instanceof Dict))
    return;
  if (n2.has("T")) {
    const t3 = stringToPDFString(await n2.getAsync("T"));
    e2 = "" === e2 ? t3 : `${e2}.${t3}`;
  } else {
    let t3 = n2;
    for (; ; ) {
      t3 = t3.getRaw("Parent");
      if (t3 instanceof Ref) {
        if (s2.has(t3))
          break;
        t3 = await r2.fetchAsync(t3);
      }
      if (!(t3 instanceof Dict))
        break;
      if (t3.has("T")) {
        const i3 = stringToPDFString(await t3.getAsync("T"));
        e2 = "" === e2 ? i3 : `${e2}.${i3}`;
        break;
      }
    }
  }
  i2.has(e2) || i2.set(e2, []);
  i2.get(e2).push(AnnotationFactory.create(r2, t2, a2, null, true, null).then((e3) => e3 == null ? void 0 : e3.getFieldObject()).catch(function(e3) {
    warn(`#collectFieldObjects: "${e3}".`);
    return null;
  }));
  if (!n2.has("Kids"))
    return;
  const g2 = await n2.getAsync("Kids");
  if (Array.isArray(g2))
    for (const t3 of g2)
      await __privateMethod(this, _q, q_fn).call(this, e2, t3, i2, a2, s2);
};
var BasePdfManager = class _BasePdfManager {
  constructor(e2) {
    var _a4;
    this.constructor === _BasePdfManager && unreachable("Cannot initialize BasePdfManager.");
    this._docBaseUrl = function parseDocBaseUrl(e3) {
      if (e3) {
        const t2 = createValidAbsoluteUrl(e3);
        if (t2)
          return t2.href;
        warn(`Invalid absolute docBaseUrl: "${e3}".`);
      }
      return null;
    }(e2.docBaseUrl);
    this._docId = e2.docId;
    this._password = e2.password;
    this.enableXfa = e2.enableXfa;
    (_a4 = e2.evaluatorOptions).isOffscreenCanvasSupported && (_a4.isOffscreenCanvasSupported = FeatureTest.isOffscreenCanvasSupported);
    this.evaluatorOptions = Object.freeze(e2.evaluatorOptions);
  }
  get docId() {
    return this._docId;
  }
  get password() {
    return this._password;
  }
  get docBaseUrl() {
    return this._docBaseUrl;
  }
  get catalog() {
    return this.pdfDocument.catalog;
  }
  ensureDoc(e2, t2) {
    return this.ensure(this.pdfDocument, e2, t2);
  }
  ensureXRef(e2, t2) {
    return this.ensure(this.pdfDocument.xref, e2, t2);
  }
  ensureCatalog(e2, t2) {
    return this.ensure(this.pdfDocument.catalog, e2, t2);
  }
  getPage(e2) {
    return this.pdfDocument.getPage(e2);
  }
  fontFallback(e2, t2) {
    return this.pdfDocument.fontFallback(e2, t2);
  }
  loadXfaFonts(e2, t2) {
    return this.pdfDocument.loadXfaFonts(e2, t2);
  }
  loadXfaImages() {
    return this.pdfDocument.loadXfaImages();
  }
  serializeXfaData(e2) {
    return this.pdfDocument.serializeXfaData(e2);
  }
  cleanup(e2 = false) {
    return this.pdfDocument.cleanup(e2);
  }
  async ensure(e2, t2, i2) {
    unreachable("Abstract method `ensure` called");
  }
  requestRange(e2, t2) {
    unreachable("Abstract method `requestRange` called");
  }
  requestLoadedStream(e2 = false) {
    unreachable("Abstract method `requestLoadedStream` called");
  }
  sendProgressiveData(e2) {
    unreachable("Abstract method `sendProgressiveData` called");
  }
  updatePassword(e2) {
    this._password = e2;
  }
  terminate(e2) {
    unreachable("Abstract method `terminate` called");
  }
};
var LocalPdfManager = class extends BasePdfManager {
  constructor(e2) {
    super(e2);
    const t2 = new Stream(e2.source);
    this.pdfDocument = new PDFDocument(this, t2);
    this._loadedStreamPromise = Promise.resolve(t2);
  }
  async ensure(e2, t2, i2) {
    const a2 = e2[t2];
    return "function" == typeof a2 ? a2.apply(e2, i2) : a2;
  }
  requestRange(e2, t2) {
    return Promise.resolve();
  }
  requestLoadedStream(e2 = false) {
    return this._loadedStreamPromise;
  }
  terminate(e2) {
  }
};
var NetworkPdfManager = class extends BasePdfManager {
  constructor(e2) {
    super(e2);
    this.streamManager = new ChunkedStreamManager(e2.source, { msgHandler: e2.handler, length: e2.length, disableAutoFetch: e2.disableAutoFetch, rangeChunkSize: e2.rangeChunkSize });
    this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());
  }
  async ensure(e2, t2, i2) {
    try {
      const a2 = e2[t2];
      return "function" == typeof a2 ? a2.apply(e2, i2) : a2;
    } catch (a2) {
      if (!(a2 instanceof MissingDataException))
        throw a2;
      await this.requestRange(a2.begin, a2.end);
      return this.ensure(e2, t2, i2);
    }
  }
  requestRange(e2, t2) {
    return this.streamManager.requestRange(e2, t2);
  }
  requestLoadedStream(e2 = false) {
    return this.streamManager.requestAllChunks(e2);
  }
  sendProgressiveData(e2) {
    this.streamManager.onReceiveData({ chunk: e2 });
  }
  terminate(e2) {
    this.streamManager.abort(e2);
  }
};
var hg = 1;
var Bg = 2;
var lg = 1;
var Qg = 2;
var Eg = 3;
var ug = 4;
var dg = 5;
var fg = 6;
var pg = 7;
var mg = 8;
function wrapReason(e2) {
  e2 instanceof Error || "object" == typeof e2 && null !== e2 || unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  switch (e2.name) {
    case "AbortException":
      return new AbortException(e2.message);
    case "MissingPDFException":
      return new MissingPDFException(e2.message);
    case "PasswordException":
      return new PasswordException(e2.message, e2.code);
    case "UnexpectedResponseException":
      return new UnexpectedResponseException(e2.message, e2.status);
    case "UnknownErrorException":
      return new UnknownErrorException(e2.message, e2.details);
    default:
      return new UnknownErrorException(e2.message, e2.toString());
  }
}
var _P, P_fn, _O, O_fn, _W, W_fn;
var MessageHandler = class {
  constructor(e2, t2, i2) {
    __privateAdd(this, _P);
    __privateAdd(this, _O);
    __privateAdd(this, _W);
    this.sourceName = e2;
    this.targetName = t2;
    this.comObj = i2;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = /* @__PURE__ */ Object.create(null);
    this.streamControllers = /* @__PURE__ */ Object.create(null);
    this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
    this.actionHandler = /* @__PURE__ */ Object.create(null);
    this._onComObjOnMessage = (e3) => {
      const t3 = e3.data;
      if (t3.targetName !== this.sourceName)
        return;
      if (t3.stream) {
        __privateMethod(this, _O, O_fn).call(this, t3);
        return;
      }
      if (t3.callback) {
        const e4 = t3.callbackId, i3 = this.callbackCapabilities[e4];
        if (!i3)
          throw new Error(`Cannot resolve callback ${e4}`);
        delete this.callbackCapabilities[e4];
        if (t3.callback === hg)
          i3.resolve(t3.data);
        else {
          if (t3.callback !== Bg)
            throw new Error("Unexpected callback case");
          i3.reject(wrapReason(t3.reason));
        }
        return;
      }
      const a2 = this.actionHandler[t3.action];
      if (!a2)
        throw new Error(`Unknown action from worker: ${t3.action}`);
      if (t3.callbackId) {
        const e4 = this.sourceName, s2 = t3.sourceName;
        new Promise(function(e5) {
          e5(a2(t3.data));
        }).then(function(a3) {
          i2.postMessage({ sourceName: e4, targetName: s2, callback: hg, callbackId: t3.callbackId, data: a3 });
        }, function(a3) {
          i2.postMessage({ sourceName: e4, targetName: s2, callback: Bg, callbackId: t3.callbackId, reason: wrapReason(a3) });
        });
      } else
        t3.streamId ? __privateMethod(this, _P, P_fn).call(this, t3) : a2(t3.data);
    };
    i2.addEventListener("message", this._onComObjOnMessage);
  }
  on(e2, t2) {
    const i2 = this.actionHandler;
    if (i2[e2])
      throw new Error(`There is already an actionName called "${e2}"`);
    i2[e2] = t2;
  }
  send(e2, t2, i2) {
    this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e2, data: t2 }, i2);
  }
  sendWithPromise(e2, t2, i2) {
    const a2 = this.callbackId++, s2 = Promise.withResolvers();
    this.callbackCapabilities[a2] = s2;
    try {
      this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e2, callbackId: a2, data: t2 }, i2);
    } catch (e3) {
      s2.reject(e3);
    }
    return s2.promise;
  }
  sendWithStream(e2, t2, i2, a2) {
    const s2 = this.streamId++, r2 = this.sourceName, n2 = this.targetName, g2 = this.comObj;
    return new ReadableStream({ start: (i3) => {
      const o2 = Promise.withResolvers();
      this.streamControllers[s2] = { controller: i3, startCall: o2, pullCall: null, cancelCall: null, isClosed: false };
      g2.postMessage({ sourceName: r2, targetName: n2, action: e2, streamId: s2, data: t2, desiredSize: i3.desiredSize }, a2);
      return o2.promise;
    }, pull: (e3) => {
      const t3 = Promise.withResolvers();
      this.streamControllers[s2].pullCall = t3;
      g2.postMessage({ sourceName: r2, targetName: n2, stream: fg, streamId: s2, desiredSize: e3.desiredSize });
      return t3.promise;
    }, cancel: (e3) => {
      assert(e3 instanceof Error, "cancel must have a valid reason");
      const t3 = Promise.withResolvers();
      this.streamControllers[s2].cancelCall = t3;
      this.streamControllers[s2].isClosed = true;
      g2.postMessage({ sourceName: r2, targetName: n2, stream: lg, streamId: s2, reason: wrapReason(e3) });
      return t3.promise;
    } }, i2);
  }
  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }
};
_P = new WeakSet();
P_fn = function(e2) {
  const t2 = e2.streamId, i2 = this.sourceName, a2 = e2.sourceName, s2 = this.comObj, r2 = this, n2 = this.actionHandler[e2.action], g2 = { enqueue(e3, r3 = 1, n3) {
    if (this.isCancelled)
      return;
    const g3 = this.desiredSize;
    this.desiredSize -= r3;
    if (g3 > 0 && this.desiredSize <= 0) {
      this.sinkCapability = Promise.withResolvers();
      this.ready = this.sinkCapability.promise;
    }
    s2.postMessage({ sourceName: i2, targetName: a2, stream: ug, streamId: t2, chunk: e3 }, n3);
  }, close() {
    if (!this.isCancelled) {
      this.isCancelled = true;
      s2.postMessage({ sourceName: i2, targetName: a2, stream: Eg, streamId: t2 });
      delete r2.streamSinks[t2];
    }
  }, error(e3) {
    assert(e3 instanceof Error, "error must have a valid reason");
    if (!this.isCancelled) {
      this.isCancelled = true;
      s2.postMessage({ sourceName: i2, targetName: a2, stream: dg, streamId: t2, reason: wrapReason(e3) });
    }
  }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: false, desiredSize: e2.desiredSize, ready: null };
  g2.sinkCapability.resolve();
  g2.ready = g2.sinkCapability.promise;
  this.streamSinks[t2] = g2;
  new Promise(function(t3) {
    t3(n2(e2.data, g2));
  }).then(function() {
    s2.postMessage({ sourceName: i2, targetName: a2, stream: mg, streamId: t2, success: true });
  }, function(e3) {
    s2.postMessage({ sourceName: i2, targetName: a2, stream: mg, streamId: t2, reason: wrapReason(e3) });
  });
};
_O = new WeakSet();
O_fn = function(e2) {
  const t2 = e2.streamId, i2 = this.sourceName, a2 = e2.sourceName, s2 = this.comObj, r2 = this.streamControllers[t2], n2 = this.streamSinks[t2];
  switch (e2.stream) {
    case mg:
      e2.success ? r2.startCall.resolve() : r2.startCall.reject(wrapReason(e2.reason));
      break;
    case pg:
      e2.success ? r2.pullCall.resolve() : r2.pullCall.reject(wrapReason(e2.reason));
      break;
    case fg:
      if (!n2) {
        s2.postMessage({ sourceName: i2, targetName: a2, stream: pg, streamId: t2, success: true });
        break;
      }
      n2.desiredSize <= 0 && e2.desiredSize > 0 && n2.sinkCapability.resolve();
      n2.desiredSize = e2.desiredSize;
      new Promise(function(e3) {
        var _a4;
        e3((_a4 = n2.onPull) == null ? void 0 : _a4.call(n2));
      }).then(function() {
        s2.postMessage({ sourceName: i2, targetName: a2, stream: pg, streamId: t2, success: true });
      }, function(e3) {
        s2.postMessage({ sourceName: i2, targetName: a2, stream: pg, streamId: t2, reason: wrapReason(e3) });
      });
      break;
    case ug:
      assert(r2, "enqueue should have stream controller");
      if (r2.isClosed)
        break;
      r2.controller.enqueue(e2.chunk);
      break;
    case Eg:
      assert(r2, "close should have stream controller");
      if (r2.isClosed)
        break;
      r2.isClosed = true;
      r2.controller.close();
      __privateMethod(this, _W, W_fn).call(this, r2, t2);
      break;
    case dg:
      assert(r2, "error should have stream controller");
      r2.controller.error(wrapReason(e2.reason));
      __privateMethod(this, _W, W_fn).call(this, r2, t2);
      break;
    case Qg:
      e2.success ? r2.cancelCall.resolve() : r2.cancelCall.reject(wrapReason(e2.reason));
      __privateMethod(this, _W, W_fn).call(this, r2, t2);
      break;
    case lg:
      if (!n2)
        break;
      new Promise(function(t3) {
        var _a4;
        t3((_a4 = n2.onCancel) == null ? void 0 : _a4.call(n2, wrapReason(e2.reason)));
      }).then(function() {
        s2.postMessage({ sourceName: i2, targetName: a2, stream: Qg, streamId: t2, success: true });
      }, function(e3) {
        s2.postMessage({ sourceName: i2, targetName: a2, stream: Qg, streamId: t2, reason: wrapReason(e3) });
      });
      n2.sinkCapability.reject(wrapReason(e2.reason));
      n2.isCancelled = true;
      delete this.streamSinks[t2];
      break;
    default:
      throw new Error("Unexpected stream case");
  }
};
_W = new WeakSet();
W_fn = async function(e2, t2) {
  var _a4, _b2, _c2;
  await Promise.allSettled([(_a4 = e2.startCall) == null ? void 0 : _a4.promise, (_b2 = e2.pullCall) == null ? void 0 : _b2.promise, (_c2 = e2.cancelCall) == null ? void 0 : _c2.promise]);
  delete this.streamControllers[t2];
};
var PDFWorkerStream = class {
  constructor(e2) {
    this._msgHandler = e2;
    this._contentLength = null;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
    return this._fullRequestReader;
  }
  getRangeReader(e2, t2) {
    const i2 = new PDFWorkerStreamRangeReader(e2, t2, this._msgHandler);
    this._rangeRequestReaders.push(i2);
    return i2;
  }
  cancelAllRequests(e2) {
    var _a4;
    (_a4 = this._fullRequestReader) == null ? void 0 : _a4.cancel(e2);
    for (const t2 of this._rangeRequestReaders.slice(0))
      t2.cancel(e2);
  }
};
var PDFWorkerStreamReader = class {
  constructor(e2) {
    this._msgHandler = e2;
    this.onProgress = null;
    this._contentLength = null;
    this._isRangeSupported = false;
    this._isStreamingSupported = false;
    const t2 = this._msgHandler.sendWithStream("GetReader");
    this._reader = t2.getReader();
    this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((e3) => {
      this._isStreamingSupported = e3.isStreamingSupported;
      this._isRangeSupported = e3.isRangeSupported;
      this._contentLength = e3.contentLength;
    });
  }
  get headersReady() {
    return this._headersReady;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  async read() {
    const { value: e2, done: t2 } = await this._reader.read();
    return t2 ? { value: void 0, done: true } : { value: e2.buffer, done: false };
  }
  cancel(e2) {
    this._reader.cancel(e2);
  }
};
var PDFWorkerStreamRangeReader = class {
  constructor(e2, t2, i2) {
    this._msgHandler = i2;
    this.onProgress = null;
    const a2 = this._msgHandler.sendWithStream("GetRangeReader", { begin: e2, end: t2 });
    this._reader = a2.getReader();
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    const { value: e2, done: t2 } = await this._reader.read();
    return t2 ? { value: void 0, done: true } : { value: e2.buffer, done: false };
  }
  cancel(e2) {
    this._reader.cancel(e2);
  }
};
var WorkerTask = class {
  constructor(e2) {
    this.name = e2;
    this.terminated = false;
    this._capability = Promise.withResolvers();
  }
  get finished() {
    return this._capability.promise;
  }
  finish() {
    this._capability.resolve();
  }
  terminate() {
    this.terminated = true;
  }
  ensureNotTerminated() {
    if (this.terminated)
      throw new Error("Worker task was terminated");
  }
};
var WorkerMessageHandler = class _WorkerMessageHandler {
  static setup(e2, t2) {
    let i2 = false;
    e2.on("test", function(t3) {
      if (!i2) {
        i2 = true;
        e2.send("test", t3 instanceof Uint8Array);
      }
    });
    e2.on("configure", function(e3) {
      !function setVerbosityLevel(e4) {
        Number.isInteger(e4) && (gt = e4);
      }(e3.verbosity);
    });
    e2.on("GetDocRequest", function(e3) {
      return _WorkerMessageHandler.createDocumentHandler(e3, t2);
    });
  }
  static createDocumentHandler(e2, t2) {
    let i2, a2 = false, s2 = null;
    const r2 = /* @__PURE__ */ new Set(), n2 = getVerbosityLevel(), { docId: g2, apiVersion: o2 } = e2, c2 = "4.5.136";
    if (o2 !== c2)
      throw new Error(`The API version "${o2}" does not match the Worker version "${c2}".`);
    const C2 = [];
    for (const e3 in [])
      C2.push(e3);
    if (C2.length)
      throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + C2.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
    const h2 = g2 + "_worker";
    let l2 = new MessageHandler(h2, g2, t2);
    function ensureNotTerminated() {
      if (a2)
        throw new Error("Worker was terminated");
    }
    function startWorkerTask(e3) {
      r2.add(e3);
    }
    function finishWorkerTask(e3) {
      e3.finish();
      r2.delete(e3);
    }
    async function loadDocument(e3) {
      await i2.ensureDoc("checkHeader");
      await i2.ensureDoc("parseStartXRef");
      await i2.ensureDoc("parse", [e3]);
      await i2.ensureDoc("checkFirstPage", [e3]);
      await i2.ensureDoc("checkLastPage", [e3]);
      const t3 = await i2.ensureDoc("isPureXfa");
      if (t3) {
        const e4 = new WorkerTask("loadXfaFonts");
        startWorkerTask(e4);
        await Promise.all([i2.loadXfaFonts(l2, e4).catch((e5) => {
        }).then(() => finishWorkerTask(e4)), i2.loadXfaImages()]);
      }
      const [a3, s3] = await Promise.all([i2.ensureDoc("numPages"), i2.ensureDoc("fingerprints")]);
      return { numPages: a3, fingerprints: s3, htmlForXfa: t3 ? await i2.ensureDoc("htmlForXfa") : null };
    }
    function getPdfManager({ data: e3, password: t3, disableAutoFetch: i3, rangeChunkSize: a3, length: r3, docBaseUrl: n3, enableXfa: o3, evaluatorOptions: c3 }) {
      const C3 = { source: null, disableAutoFetch: i3, docBaseUrl: n3, docId: g2, enableXfa: o3, evaluatorOptions: c3, handler: l2, length: r3, password: t3, rangeChunkSize: a3 }, h3 = Promise.withResolvers();
      let Q2;
      if (e3) {
        try {
          C3.source = e3;
          Q2 = new LocalPdfManager(C3);
          h3.resolve(Q2);
        } catch (e4) {
          h3.reject(e4);
        }
        return h3.promise;
      }
      let E2, u2 = [];
      try {
        E2 = new PDFWorkerStream(l2);
      } catch (e4) {
        h3.reject(e4);
        return h3.promise;
      }
      const d2 = E2.getFullReader();
      d2.headersReady.then(function() {
        if (d2.isRangeSupported) {
          C3.source = E2;
          C3.length = d2.contentLength;
          C3.disableAutoFetch || (C3.disableAutoFetch = d2.isStreamingSupported);
          Q2 = new NetworkPdfManager(C3);
          for (const e4 of u2)
            Q2.sendProgressiveData(e4);
          u2 = [];
          h3.resolve(Q2);
          s2 = null;
        }
      }).catch(function(e4) {
        h3.reject(e4);
        s2 = null;
      });
      let f2 = 0;
      new Promise(function(e4, t4) {
        const readChunk = function({ value: e5, done: i4 }) {
          try {
            ensureNotTerminated();
            if (i4) {
              Q2 || function() {
                const e6 = arrayBuffersToBytes(u2);
                r3 && e6.length !== r3 && warn("reported HTTP length is different from actual");
                try {
                  C3.source = e6;
                  Q2 = new LocalPdfManager(C3);
                  h3.resolve(Q2);
                } catch (e7) {
                  h3.reject(e7);
                }
                u2 = [];
              }();
              s2 = null;
              return;
            }
            f2 += e5.byteLength;
            d2.isStreamingSupported || l2.send("DocProgress", { loaded: f2, total: Math.max(f2, d2.contentLength || 0) });
            Q2 ? Q2.sendProgressiveData(e5) : u2.push(e5);
            d2.read().then(readChunk, t4);
          } catch (e6) {
            t4(e6);
          }
        };
        d2.read().then(readChunk, t4);
      }).catch(function(e4) {
        h3.reject(e4);
        s2 = null;
      });
      s2 = function(e4) {
        E2.cancelAllRequests(e4);
      };
      return h3.promise;
    }
    l2.on("GetPage", function(e3) {
      return i2.getPage(e3.pageIndex).then(function(e4) {
        return Promise.all([i2.ensure(e4, "rotate"), i2.ensure(e4, "ref"), i2.ensure(e4, "userUnit"), i2.ensure(e4, "view")]).then(function([e5, t3, i3, a3]) {
          return { rotate: e5, ref: t3, refStr: (t3 == null ? void 0 : t3.toString()) ?? null, userUnit: i3, view: a3 };
        });
      });
    });
    l2.on("GetPageIndex", function(e3) {
      const t3 = Ref.get(e3.num, e3.gen);
      return i2.ensureCatalog("getPageIndex", [t3]);
    });
    l2.on("GetDestinations", function(e3) {
      return i2.ensureCatalog("destinations");
    });
    l2.on("GetDestination", function(e3) {
      return i2.ensureCatalog("getDestination", [e3.id]);
    });
    l2.on("GetPageLabels", function(e3) {
      return i2.ensureCatalog("pageLabels");
    });
    l2.on("GetPageLayout", function(e3) {
      return i2.ensureCatalog("pageLayout");
    });
    l2.on("GetPageMode", function(e3) {
      return i2.ensureCatalog("pageMode");
    });
    l2.on("GetViewerPreferences", function(e3) {
      return i2.ensureCatalog("viewerPreferences");
    });
    l2.on("GetOpenAction", function(e3) {
      return i2.ensureCatalog("openAction");
    });
    l2.on("GetAttachments", function(e3) {
      return i2.ensureCatalog("attachments");
    });
    l2.on("GetDocJSActions", function(e3) {
      return i2.ensureCatalog("jsActions");
    });
    l2.on("GetPageJSActions", function({ pageIndex: e3 }) {
      return i2.getPage(e3).then(function(e4) {
        return i2.ensure(e4, "jsActions");
      });
    });
    l2.on("GetOutline", function(e3) {
      return i2.ensureCatalog("documentOutline");
    });
    l2.on("GetOptionalContentConfig", function(e3) {
      return i2.ensureCatalog("optionalContentConfig");
    });
    l2.on("GetPermissions", function(e3) {
      return i2.ensureCatalog("permissions");
    });
    l2.on("GetMetadata", function(e3) {
      return Promise.all([i2.ensureDoc("documentInfo"), i2.ensureCatalog("metadata")]);
    });
    l2.on("GetMarkInfo", function(e3) {
      return i2.ensureCatalog("markInfo");
    });
    l2.on("GetData", function(e3) {
      return i2.requestLoadedStream().then(function(e4) {
        return e4.bytes;
      });
    });
    l2.on("GetAnnotations", function({ pageIndex: e3, intent: t3 }) {
      return i2.getPage(e3).then(function(i3) {
        const a3 = new WorkerTask(`GetAnnotations: page ${e3}`);
        startWorkerTask(a3);
        return i3.getAnnotationsData(l2, a3, t3).then((e4) => {
          finishWorkerTask(a3);
          return e4;
        }, (e4) => {
          finishWorkerTask(a3);
          throw e4;
        });
      });
    });
    l2.on("GetFieldObjects", function(e3) {
      return i2.ensureDoc("fieldObjects");
    });
    l2.on("HasJSActions", function(e3) {
      return i2.ensureDoc("hasJSActions");
    });
    l2.on("GetCalculationOrderIds", function(e3) {
      return i2.ensureDoc("calculationOrderIds");
    });
    l2.on("SaveDocument", async function({ isPureXfa: e3, numPages: t3, annotationStorage: a3, filename: s3 }) {
      const r3 = [i2.requestLoadedStream(), i2.ensureCatalog("acroForm"), i2.ensureCatalog("acroFormRef"), i2.ensureDoc("startXRef"), i2.ensureDoc("xref"), i2.ensureDoc("linearization"), i2.ensureCatalog("structTreeRoot")], n3 = [], g3 = e3 ? null : getNewAnnotationsMap(a3), [o3, c3, C3, h3, Q2, E2, u2] = await Promise.all(r3), d2 = Q2.trailer.getRaw("Root") || null;
      let f2;
      if (g3) {
        u2 ? await u2.canUpdateStructTree({ pdfManager: i2, xref: Q2, newAnnotationsByPage: g3 }) && (f2 = u2) : await StructTreeRoot.canCreateStructureTree({ catalogRef: d2, pdfManager: i2, newAnnotationsByPage: g3 }) && (f2 = null);
        const e4 = AnnotationFactory.generateImages(a3.values(), Q2, i2.evaluatorOptions.isOffscreenCanvasSupported), t4 = void 0 === f2 ? n3 : [];
        for (const [a4, s4] of g3)
          t4.push(i2.getPage(a4).then((t5) => {
            const i3 = new WorkerTask(`Save (editor): page ${a4}`);
            return t5.saveNewAnnotations(l2, i3, s4, e4).finally(function() {
              finishWorkerTask(i3);
            });
          }));
        null === f2 ? n3.push(Promise.all(t4).then(async (e5) => {
          await StructTreeRoot.createStructureTree({ newAnnotationsByPage: g3, xref: Q2, catalogRef: d2, pdfManager: i2, newRefs: e5 });
          return e5;
        })) : f2 && n3.push(Promise.all(t4).then(async (e5) => {
          await f2.updateStructureTree({ newAnnotationsByPage: g3, pdfManager: i2, newRefs: e5 });
          return e5;
        }));
      }
      if (e3)
        n3.push(i2.serializeXfaData(a3));
      else
        for (let e4 = 0; e4 < t3; e4++)
          n3.push(i2.getPage(e4).then(function(t4) {
            const i3 = new WorkerTask(`Save: page ${e4}`);
            return t4.save(l2, i3, a3).finally(function() {
              finishWorkerTask(i3);
            });
          }));
      const p2 = await Promise.all(n3);
      let m2 = [], y2 = null;
      if (e3) {
        y2 = p2[0];
        if (!y2)
          return o3.bytes;
      } else {
        m2 = p2.flat(2);
        if (0 === m2.length)
          return o3.bytes;
      }
      const w2 = C3 && c3 instanceof Dict && m2.some((e4) => e4.needAppearances), D2 = c3 instanceof Dict && c3.get("XFA") || null;
      let b2 = null, F2 = false;
      if (Array.isArray(D2)) {
        for (let e4 = 0, t4 = D2.length; e4 < t4; e4 += 2)
          if ("datasets" === D2[e4]) {
            b2 = D2[e4 + 1];
            F2 = true;
          }
        null === b2 && (b2 = Q2.getNewTemporaryRef());
      } else
        D2 && warn("Unsupported XFA type.");
      let S2 = /* @__PURE__ */ Object.create(null);
      if (Q2.trailer) {
        const e4 = /* @__PURE__ */ Object.create(null), t4 = Q2.trailer.get("Info") || null;
        t4 instanceof Dict && t4.forEach((t5, i3) => {
          "string" == typeof i3 && (e4[t5] = stringToPDFString(i3));
        });
        S2 = { rootRef: d2, encryptRef: Q2.trailer.getRaw("Encrypt") || null, newRef: Q2.getNewTemporaryRef(), infoRef: Q2.trailer.getRaw("Info") || null, info: e4, fileIds: Q2.trailer.get("ID") || null, startXRef: E2 ? h3 : Q2.lastXRefStreamPos ?? h3, filename: s3 };
      }
      return incrementalUpdate({ originalData: o3.bytes, xrefInfo: S2, newRefs: m2, xref: Q2, hasXfa: !!D2, xfaDatasetsRef: b2, hasXfaDatasetsEntry: F2, needAppearances: w2, acroFormRef: C3, acroForm: c3, xfaData: y2, useXrefStream: isDict(Q2.topDict, "XRef") }).finally(() => {
        Q2.resetNewTemporaryRef();
      });
    });
    l2.on("GetOperatorList", function(e3, t3) {
      const a3 = e3.pageIndex;
      i2.getPage(a3).then(function(i3) {
        const s3 = new WorkerTask(`GetOperatorList: page ${a3}`);
        startWorkerTask(s3);
        const r3 = n2 >= mA.INFOS ? Date.now() : 0;
        i3.getOperatorList({ handler: l2, sink: t3, task: s3, intent: e3.intent, cacheKey: e3.cacheKey, annotationStorage: e3.annotationStorage, modifiedIds: e3.modifiedIds }).then(function(e4) {
          finishWorkerTask(s3);
          r3 && info(`page=${a3 + 1} - getOperatorList: time=${Date.now() - r3}ms, len=${e4.length}`);
          t3.close();
        }, function(e4) {
          finishWorkerTask(s3);
          s3.terminated || t3.error(e4);
        });
      });
    });
    l2.on("GetTextContent", function(e3, t3) {
      const { pageIndex: a3, includeMarkedContent: s3, disableNormalization: r3 } = e3;
      i2.getPage(a3).then(function(e4) {
        const i3 = new WorkerTask("GetTextContent: page " + a3);
        startWorkerTask(i3);
        const g3 = n2 >= mA.INFOS ? Date.now() : 0;
        e4.extractTextContent({ handler: l2, task: i3, sink: t3, includeMarkedContent: s3, disableNormalization: r3 }).then(function() {
          finishWorkerTask(i3);
          g3 && info(`page=${a3 + 1} - getTextContent: time=` + (Date.now() - g3) + "ms");
          t3.close();
        }, function(e5) {
          finishWorkerTask(i3);
          i3.terminated || t3.error(e5);
        });
      });
    });
    l2.on("GetStructTree", function(e3) {
      return i2.getPage(e3.pageIndex).then(function(e4) {
        return i2.ensure(e4, "getStructTree");
      });
    });
    l2.on("FontFallback", function(e3) {
      return i2.fontFallback(e3.id, l2);
    });
    l2.on("Cleanup", function(e3) {
      return i2.cleanup(true);
    });
    l2.on("Terminate", function(e3) {
      a2 = true;
      const t3 = [];
      if (i2) {
        i2.terminate(new AbortException("Worker was terminated."));
        const e4 = i2.cleanup();
        t3.push(e4);
        i2 = null;
      } else
        clearGlobalCaches();
      s2 && s2(new AbortException("Worker was terminated."));
      for (const e4 of r2) {
        t3.push(e4.finished);
        e4.terminate();
      }
      return Promise.all(t3).then(function() {
        l2.destroy();
        l2 = null;
      });
    });
    l2.on("Ready", function(t3) {
      !function setupDoc(e3) {
        function onSuccess(e4) {
          ensureNotTerminated();
          l2.send("GetDoc", { pdfInfo: e4 });
        }
        function onFailure(e4) {
          ensureNotTerminated();
          if (e4 instanceof PasswordException) {
            const t4 = new WorkerTask(`PasswordException: response ${e4.code}`);
            startWorkerTask(t4);
            l2.sendWithPromise("PasswordRequest", e4).then(function({ password: e5 }) {
              finishWorkerTask(t4);
              i2.updatePassword(e5);
              pdfManagerReady();
            }).catch(function() {
              finishWorkerTask(t4);
              l2.send("DocException", e4);
            });
          } else
            e4 instanceof InvalidPDFException || e4 instanceof MissingPDFException || e4 instanceof UnexpectedResponseException || e4 instanceof UnknownErrorException ? l2.send("DocException", e4) : l2.send("DocException", new UnknownErrorException(e4.message, e4.toString()));
        }
        function pdfManagerReady() {
          ensureNotTerminated();
          loadDocument(false).then(onSuccess, function(e4) {
            ensureNotTerminated();
            e4 instanceof XRefParseException ? i2.requestLoadedStream().then(function() {
              ensureNotTerminated();
              loadDocument(true).then(onSuccess, onFailure);
            }) : onFailure(e4);
          });
        }
        ensureNotTerminated();
        getPdfManager(e3).then(function(e4) {
          if (a2) {
            e4.terminate(new AbortException("Worker was terminated."));
            throw new Error("Worker was terminated");
          }
          i2 = e4;
          i2.requestLoadedStream(true).then((e5) => {
            l2.send("DataLoaded", { length: e5.bytes.byteLength });
          });
        }).then(pdfManagerReady, onFailure);
      }(e2);
      e2 = null;
    });
    return h2;
  }
  static initializeFromPort(e2) {
    const t2 = new MessageHandler("worker", "main", e2);
    _WorkerMessageHandler.setup(t2, e2);
    t2.send("ready", null);
  }
};
"undefined" == typeof window && !t && "undefined" != typeof self && function isMessagePort(e2) {
  return "function" == typeof e2.postMessage && "onmessage" in e2;
}(self) && WorkerMessageHandler.initializeFromPort(self);
var yg = __webpack_exports__.WorkerMessageHandler;
export {
  yg as WorkerMessageHandler
};
//# sourceMappingURL=pdfjs-dist_build_pdf__worker__min__mjs.js.map
